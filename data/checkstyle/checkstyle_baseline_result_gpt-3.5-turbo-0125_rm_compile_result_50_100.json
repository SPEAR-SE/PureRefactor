[{"type": "Extract Method", "description": "Extract Method\tprivate isInlineTagWithName(javadocInlineTag DetailNode, name String) : boolean extracted from private isSummaryTag(javadocInlineTag DetailNode) : boolean in class com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java", "startLine": 388, "endLine": 402, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java", "startLine": 399, "endLine": 407, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java", "startLine": 419, "endLine": 435, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks if the javadoc inline tag is {@code {@summary}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if inline tag is summary tag.\n     */\n    private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n        final DetailNode[] child = javadocInlineTag.getChildren();\n\n        // Checking size of ast is not required, since ast contains\n        // children of Inline Tag, as at least 2 children will be present which are\n        // RCURLY and LCURLY.\n        return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n                && SUMMARY_TEXT.equals(child[1].getText());\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java", "isPureRefactoring": true, "commitId": "cc90b04b02f963571ae4697857db838ac27efb84", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.javadoc", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#isSummaryTag", "classSignatureBefore": "public class SummaryJavadocCheck extends AbstractJavadocCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#isSummaryTag"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck"], "classSignatureBeforeSet": ["public class SummaryJavadocCheck extends AbstractJavadocCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All the mappings are matched! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.javadoc;\n\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailNode;\nimport com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n\n/**\n * <p>\n * Checks that\n * <a href=\"https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#firstsentence\">\n * Javadoc summary sentence</a> does not contain phrases that are not recommended to use.\n * Summaries that contain only the {@code {@inheritDoc}} tag are skipped.\n * Check also violate Javadoc that does not contain first sentence.\n * </p>\n * <ul>\n * <li>\n * Property {@code violateExecutionOnNonTightHtml} - Control when to print violations\n * if the Javadoc being examined by this check violates the tight html rules defined at\n * <a href=\"https://checkstyle.org/writingjavadocchecks.html#Tight-HTML_rules\">Tight-HTML Rules</a>.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code forbiddenSummaryFragments} - Specify the regexp for forbidden summary fragments.\n * Type is {@code java.util.regex.Pattern}.\n * Default value is {@code \"^$\"}.\n * </li>\n * <li>\n * Property {@code period} - Specify the period symbol at the end of first javadoc sentence.\n * Type is {@code java.lang.String}.\n * Default value is {@code \".\"}.\n * </li>\n * </ul>\n * <p>\n * To configure the default check to validate that first sentence is not empty and first\n * sentence is not missing:\n * </p>\n * <pre>\n * &lt;module name=&quot;SummaryJavadocCheck&quot;/&gt;\n * </pre>\n * <p>\n * Example of {@code {@inheritDoc}} without summary.\n * </p>\n * <pre>\n * public class Test extends Exception {\n * //Valid\n *   &#47;**\n *    * {&#64;inheritDoc}\n *    *&#47;\n *   public String ValidFunction(){\n *     return \"\";\n *   }\n *   //Violation\n *   &#47;**\n *    *\n *    *&#47;\n *   public String InvalidFunction(){\n *     return \"\";\n *   }\n * }\n * </pre>\n * <p>\n * Example of non permitted empty javadoc for Inline Summary Javadoc.\n * </p>\n * <pre>\n * public class Test extends Exception {\n *   &#47;**\n *    * {&#64;summary  }\n *    *&#47;\n *   public String InvalidFunctionOne(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt; &lt;p/&gt;}\n *    *&#47;\n *   public String InvalidFunctionTwo(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt;This is summary for validFunctionThree.&lt;p/&gt;}\n *    *&#47;\n *   public void validFunctionThree(){} // ok\n * }\n * </pre>\n * <p>\n * To ensure that summary do not contain phrase like \"This method returns\",\n * use following config:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"forbiddenSummaryFragments\"\n *     value=\"^This method returns.*\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * To specify period symbol at the end of first javadoc sentence:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"period\" value=\"\u3002\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Example of period property.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * This is invalid java doc.\n *   *&#47;\n *   void invalidJavaDocMethod() {\n *   }\n *  &#47;**\n *   * This is valid java doc\u3002\n *   *&#47;\n *   void validJavaDocMethod() {\n *   }\n * }\n * </pre>\n * <p>\n * Example of period property for inline summary javadoc.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * {&#64;summary This is invalid java doc.}\n *   *&#47;\n *   public void invalidJavaDocMethod() { // violation\n *   }\n *  &#47;**\n *   * {&#64;summary This is valid java doc\u3002}\n *   *&#47;\n *   public void validJavaDocMethod() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Example of inline summary javadoc with HTML tags.\n * </p>\n * <pre>\n * public class Test {\n *  &#47;**\n *   * {&#64;summary First sentence is normally the summary.\n *   * Use of html tags:\n *   * &lt;ul&gt;\n *   * &lt;li&gt;Item one.&lt;/li&gt;\n *   * &lt;li&gt;Item two.&lt;/li&gt;\n *   * &lt;/ul&gt;}\n *   *&#47;\n *   public void validInlineJavadoc() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code javadoc.missed.html.close}\n * </li>\n * <li>\n * {@code javadoc.parse.rule.error}\n * </li>\n * <li>\n * {@code javadoc.wrong.singleton.html.tag}\n * </li>\n * <li>\n * {@code summary.first.sentence}\n * </li>\n * <li>\n * {@code summary.javaDoc}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing.period}\n * </li>\n * </ul>\n *\n * @since 6.0\n */\n@StatelessCheck\npublic class SummaryJavadocCheck extends AbstractJavadocCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_FIRST_SENTENCE = \"summary.first.sentence\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC = \"summary.javaDoc\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC_MISSING = \"summary.javaDoc.missing\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\" file.\n     */\n    public static final String MSG_SUMMARY_MISSING_PERIOD = \"summary.javaDoc.missing.period\";\n\n    /**\n     * This regexp is used to convert multiline javadoc to single line without stars.\n     */\n    private static final Pattern JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN =\n            Pattern.compile(\"\\n[ ]+(\\\\*)|^[ ]+(\\\\*)\");\n\n    /**\n     * This regexp is used to remove html tags, whitespace, and asterisks from a string.\n     */\n    private static final Pattern HTML_ELEMENTS =\n            Pattern.compile(\"<[^>]*>\");\n\n    /** Period literal. */\n    private static final String PERIOD = \".\";\n\n    /** Summary tag text. */\n    private static final String SUMMARY_TEXT = \"@summary\";\n\n    /** Set of allowed Tokens tags in summary java doc. */\n    private static final Set<Integer> ALLOWED_TYPES = Set.of(\n                    JavadocTokenTypes.WS,\n                    JavadocTokenTypes.DESCRIPTION,\n                    JavadocTokenTypes.TEXT);\n\n    /**\n     * Specify the regexp for forbidden summary fragments.\n     */\n    private Pattern forbiddenSummaryFragments = CommonUtil.createPattern(\"^$\");\n\n    /**\n     * Specify the period symbol at the end of first javadoc sentence.\n     */\n    private String period = PERIOD;\n\n    /**\n     * Setter to specify the regexp for forbidden summary fragments.\n     *\n     * @param pattern a pattern.\n     */\n    public void setForbiddenSummaryFragments(Pattern pattern) {\n        forbiddenSummaryFragments = pattern;\n    }\n\n    /**\n     * Setter to specify the period symbol at the end of first javadoc sentence.\n     *\n     * @param period period's value.\n     */\n    public void setPeriod(String period) {\n        this.period = period;\n    }\n\n    @Override\n    public int[] getDefaultJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.JAVADOC,\n        };\n    }\n\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return getAcceptableJavadocTokens();\n    }\n\n    @Override\n    public void visitJavadocToken(DetailNode ast) {\n        final Optional<DetailNode> inlineSummaryTag = getInlineSummaryTag(ast);\n        if (inlineSummaryTag.isPresent()) {\n            validateSummaryTag(inlineSummaryTag.get());\n        }\n        else if (!startsWithInheritDoc(ast)) {\n            final String summaryDoc = getSummarySentence(ast);\n            if (summaryDoc.isEmpty()) {\n                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n            }\n            else if (!period.isEmpty()) {\n                final String firstSentence = getFirstSentence(ast);\n                final int endOfSentence = firstSentence.lastIndexOf(period);\n                if (!summaryDoc.contains(period)) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n                }\n                if (endOfSentence != -1\n                        && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the inline summary tag.\n     *\n     * @param javadoc javadoc root node.\n     * @return an optional of inline summary tag node, empty optional if inline tag is not\n     *         a summary tag.\n     */\n    private static Optional<DetailNode> getInlineSummaryTag(DetailNode javadoc) {\n        Optional<DetailNode> node = Arrays.stream(javadoc.getChildren())\n                .filter(SummaryJavadocCheck::isInlineTagPresent)\n                .findFirst()\n                .map(SummaryJavadocCheck::getInlineTagNodeWithinHtmlElement);\n\n        if (node.isPresent() && !isSummaryTag(node.get())) {\n            node = Optional.empty();\n        }\n        return node;\n    }\n\n    /**\n     * Checks if the inline tag node is present.\n     *\n     * @param ast ast node to check.\n     * @return true, if the inline tag node is present.\n     */\n    private static boolean isInlineTagPresent(DetailNode ast) {\n        return ast.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                || ast.getType() == JavadocTokenTypes.HTML_ELEMENT\n                && getInlineTagNodeWithinHtmlElement(ast) != null;\n    }\n\n    /**\n     * Returns an inline javadoc tag node that is within a html tag.\n     *\n     * @param ast html tag node.\n     * @return inline summary javadoc tag node or null if no node is found.\n     */\n    private static DetailNode getInlineTagNodeWithinHtmlElement(DetailNode ast) {\n        DetailNode node = ast;\n        DetailNode result = null;\n        // node can never be null as this method is called when there is a HTML_ELEMENT\n        if (node.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG) {\n            result = node;\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_TAG) {\n            // HTML_TAG always has more than 2 children.\n            node = node.getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_ELEMENT\n                // Condition for SINGLETON html element which cannot contain summary node\n                && node.getChildren()[0].getChildren().length > 1) {\n            // Html elements have one tested tag before actual content inside it\n            node = node.getChildren()[0].getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if the javadoc inline tag is {@code {@summary}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if inline tag is summary tag.\n     */\n    private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n        final DetailNode[] child = javadocInlineTag.getChildren();\n\n        // Checking size of ast is not required, since ast contains\n        // children of Inline Tag, as at least 2 children will be present which are\n        // RCURLY and LCURLY.\n        return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n                && SUMMARY_TEXT.equals(child[1].getText());\n    }\n\n    /**\n     * Checks the inline summary (if present) for {@code period} at end and forbidden fragments.\n     *\n     * @param inlineSummaryTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     */\n    private void validateSummaryTag(DetailNode inlineSummaryTag) {\n        final String inlineSummary = getContentOfInlineCustomTag(inlineSummaryTag);\n        final String summaryVisible = getVisibleContent(inlineSummary);\n        if (summaryVisible.isEmpty()) {\n            log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (!period.isEmpty()) {\n            if (isPeriodNotAtEnd(summaryVisible, period)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_MISSING_PERIOD);\n            }\n            else if (containsForbiddenFragment(inlineSummary)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC);\n            }\n        }\n    }\n\n    /**\n     * Gets the content of inline custom tag.\n     *\n     * @param inlineTag inline tag node.\n     * @return String consisting of the content of inline custom tag.\n     */\n    public static String getContentOfInlineCustomTag(DetailNode inlineTag) {\n        final DetailNode[] childrenOfInlineTag = inlineTag.getChildren();\n        final StringBuilder customTagContent = new StringBuilder(256);\n        final int indexOfContentOfSummaryTag = 3;\n        if (childrenOfInlineTag.length != indexOfContentOfSummaryTag) {\n            DetailNode currentNode = childrenOfInlineTag[indexOfContentOfSummaryTag];\n            while (currentNode.getType() != JavadocTokenTypes.JAVADOC_INLINE_TAG_END) {\n                extractInlineTagContent(currentNode, customTagContent);\n                currentNode = JavadocUtil.getNextSibling(currentNode);\n            }\n        }\n        return customTagContent.toString();\n    }\n\n    /**\n     * Extracts the content of inline custom tag recursively.\n     *\n     * @param node DetailNode\n     * @param customTagContent content of custom tag\n     */\n    private static void extractInlineTagContent(DetailNode node,\n        StringBuilder customTagContent) {\n        final DetailNode[] children = node.getChildren();\n        if (children.length == 0) {\n            customTagContent.append(node.getText());\n        }\n        else {\n            for (DetailNode child : children) {\n                if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                    extractInlineTagContent(child, customTagContent);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the string that is visible to user in javadoc.\n     *\n     * @param summary entire content of summary javadoc.\n     * @return string that is visible to user in javadoc.\n     */\n    private static String getVisibleContent(String summary) {\n        final String visibleSummary = HTML_ELEMENTS.matcher(summary).replaceAll(\"\");\n        return visibleSummary.trim();\n    }\n\n    /**\n     * Checks if the string does not end with period.\n     *\n     * @param sentence string to check for period at end.\n     * @param period string to check within sentence.\n     * @return {@code true} if sentence does not end with period.\n     */\n    private static boolean isPeriodNotAtEnd(String sentence, String period) {\n        final String summarySentence = sentence.trim();\n        return summarySentence.lastIndexOf(period) != summarySentence.length() - 1;\n    }\n\n    /**\n     * Tests if first sentence contains forbidden summary fragment.\n     *\n     * @param firstSentence string with first sentence.\n     * @return {@code true} if first sentence contains forbidden summary fragment.\n     */\n    private boolean containsForbiddenFragment(String firstSentence) {\n        final String javadocText = JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN\n                .matcher(firstSentence).replaceAll(\" \").trim();\n        return forbiddenSummaryFragments.matcher(trimExcessWhitespaces(javadocText)).find();\n    }\n\n    /**\n     * Trims the given {@code text} of duplicate whitespaces.\n     *\n     * @param text the text to transform.\n     * @return the finalized form of the text.\n     */\n    private static String trimExcessWhitespaces(String text) {\n        final StringBuilder result = new StringBuilder(256);\n        boolean previousWhitespace = true;\n\n        for (char letter : text.toCharArray()) {\n            final char print;\n            if (Character.isWhitespace(letter)) {\n                if (previousWhitespace) {\n                    continue;\n                }\n\n                previousWhitespace = true;\n                print = ' ';\n            }\n            else {\n                previousWhitespace = false;\n                print = letter;\n            }\n\n            result.append(print);\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Checks if the node starts with an {&#64;inheritDoc}.\n     *\n     * @param root the root node to examine.\n     * @return {@code true} if the javadoc starts with an {&#64;inheritDoc}.\n     */\n    private static boolean startsWithInheritDoc(DetailNode root) {\n        boolean found = false;\n        final DetailNode[] children = root.getChildren();\n\n        for (int i = 0; !found; i++) {\n            final DetailNode child = children[i];\n            if (child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                    && child.getChildren()[1].getType() == JavadocTokenTypes.INHERIT_DOC_LITERAL) {\n                found = true;\n            }\n            else if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK\n                    && !CommonUtil.isBlank(child.getText())) {\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    /**\n     * Finds and returns summary sentence.\n     *\n     * @param ast javadoc root node.\n     * @return violation string.\n     */\n    private static String getSummarySentence(DetailNode ast) {\n        boolean flag = true;\n        final StringBuilder result = new StringBuilder(256);\n        for (DetailNode child : ast.getChildren()) {\n            if (ALLOWED_TYPES.contains(child.getType())) {\n                result.append(child.getText());\n            }\n            else if (child.getType() == JavadocTokenTypes.HTML_ELEMENT\n                    && CommonUtil.isBlank(result.toString().trim())) {\n                result.append(getStringInsideTag(result.toString(),\n                        child.getChildren()[0].getChildren()[0]));\n            }\n            else if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n                flag = false;\n            }\n            if (!flag) {\n                break;\n            }\n        }\n        return result.toString().trim();\n    }\n\n    /**\n     * Get concatenated string within text of html tags.\n     *\n     * @param result javadoc string\n     * @param detailNode javadoc tag node\n     * @return java doc tag content appended in result\n     */\n    private static String getStringInsideTag(String result, DetailNode detailNode) {\n        final StringBuilder contents = new StringBuilder(result);\n        DetailNode tempNode = detailNode;\n        while (tempNode != null) {\n            if (tempNode.getType() == JavadocTokenTypes.TEXT) {\n                contents.append(tempNode.getText());\n            }\n            tempNode = JavadocUtil.getNextSibling(tempNode);\n        }\n        return contents.toString();\n    }\n\n    /**\n     * Finds and returns first sentence.\n     *\n     * @param ast Javadoc root node.\n     * @return first sentence.\n     */\n    private static String getFirstSentence(DetailNode ast) {\n        final StringBuilder result = new StringBuilder(256);\n        final String periodSuffix = PERIOD + ' ';\n        for (DetailNode child : ast.getChildren()) {\n            final String text;\n            if (child.getChildren().length == 0) {\n                text = child.getText();\n            }\n            else {\n                text = getFirstSentence(child);\n            }\n\n            if (text.contains(periodSuffix)) {\n                result.append(text, 0, text.indexOf(periodSuffix) + 1);\n                break;\n            }\n\n            result.append(text);\n        }\n        return result.toString();\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.javadoc;\n\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailNode;\nimport com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n\n/**\n * <p>\n * Checks that\n * <a href=\"https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#firstsentence\">\n * Javadoc summary sentence</a> does not contain phrases that are not recommended to use.\n * Summaries that contain only the {@code {@inheritDoc}} tag are skipped.\n * Summaries that contain a non-empty {@code {@return}} are allowed.\n * Check also violate Javadoc that does not contain first sentence, though with {@code {@return}} a\n * period is not required as the Javadoc tool adds it.\n * </p>\n * <ul>\n * <li>\n * Property {@code violateExecutionOnNonTightHtml} - Control when to print violations\n * if the Javadoc being examined by this check violates the tight html rules defined at\n * <a href=\"https://checkstyle.org/writingjavadocchecks.html#Tight-HTML_rules\">Tight-HTML Rules</a>.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code forbiddenSummaryFragments} - Specify the regexp for forbidden summary fragments.\n * Type is {@code java.util.regex.Pattern}.\n * Default value is {@code \"^$\"}.\n * </li>\n * <li>\n * Property {@code period} - Specify the period symbol at the end of first javadoc sentence.\n * Type is {@code java.lang.String}.\n * Default value is {@code \".\"}.\n * </li>\n * </ul>\n * <p>\n * To configure the default check to validate that first sentence is not empty and first\n * sentence is not missing:\n * </p>\n * <pre>\n * &lt;module name=&quot;SummaryJavadocCheck&quot;/&gt;\n * </pre>\n * <p>\n * Example of {@code {@inheritDoc}} without summary.\n * </p>\n * <pre>\n * public class Test extends Exception {\n * //Valid\n *   &#47;**\n *    * {&#64;inheritDoc}\n *    *&#47;\n *   public String ValidFunction(){\n *     return \"\";\n *   }\n *   //Violation\n *   &#47;**\n *    *\n *    *&#47;\n *   public String InvalidFunction(){\n *     return \"\";\n *   }\n * }\n * </pre>\n * <p>\n * Example of non permitted empty javadoc for Inline Summary Javadoc.\n * </p>\n * <pre>\n * public class Test extends Exception {\n *   &#47;**\n *    * {&#64;summary  }\n *    *&#47;\n *   public String InvalidFunctionOne(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt; &lt;p/&gt;}\n *    *&#47;\n *   public String InvalidFunctionTwo(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt;This is summary for validFunctionThree.&lt;p/&gt;}\n *    *&#47;\n *   public void validFunctionThree(){} // ok\n * }\n * </pre>\n * <p>\n * To ensure that summary do not contain phrase like \"This method returns\",\n * use following config:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"forbiddenSummaryFragments\"\n *     value=\"^This method returns.*\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * To specify period symbol at the end of first javadoc sentence:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"period\" value=\"\u3002\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Example of period property.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * This is invalid java doc.\n *   *&#47;\n *   void invalidJavaDocMethod() {\n *   }\n *  &#47;**\n *   * This is valid java doc\u3002\n *   *&#47;\n *   void validJavaDocMethod() {\n *   }\n * }\n * </pre>\n * <p>\n * Example of period property for inline summary javadoc.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * {&#64;summary This is invalid java doc.}\n *   *&#47;\n *   public void invalidJavaDocMethod() { // violation\n *   }\n *  &#47;**\n *   * {&#64;summary This is valid java doc\u3002}\n *   *&#47;\n *   public void validJavaDocMethod() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Example of inline summary javadoc with HTML tags.\n * </p>\n * <pre>\n * public class Test {\n *  &#47;**\n *   * {&#64;summary First sentence is normally the summary.\n *   * Use of html tags:\n *   * &lt;ul&gt;\n *   * &lt;li&gt;Item one.&lt;/li&gt;\n *   * &lt;li&gt;Item two.&lt;/li&gt;\n *   * &lt;/ul&gt;}\n *   *&#47;\n *   public void validInlineJavadoc() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code javadoc.missed.html.close}\n * </li>\n * <li>\n * {@code javadoc.parse.rule.error}\n * </li>\n * <li>\n * {@code javadoc.wrong.singleton.html.tag}\n * </li>\n * <li>\n * {@code summary.first.sentence}\n * </li>\n * <li>\n * {@code summary.javaDoc}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing.period}\n * </li>\n * </ul>\n *\n * @since 6.0\n */\n@StatelessCheck\npublic class SummaryJavadocCheck extends AbstractJavadocCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_FIRST_SENTENCE = \"summary.first.sentence\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC = \"summary.javaDoc\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC_MISSING = \"summary.javaDoc.missing\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\" file.\n     */\n    public static final String MSG_SUMMARY_MISSING_PERIOD = \"summary.javaDoc.missing.period\";\n\n    /**\n     * This regexp is used to convert multiline javadoc to single line without stars.\n     */\n    private static final Pattern JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN =\n            Pattern.compile(\"\\n[ ]+(\\\\*)|^[ ]+(\\\\*)\");\n\n    /**\n     * This regexp is used to remove html tags, whitespace, and asterisks from a string.\n     */\n    private static final Pattern HTML_ELEMENTS =\n            Pattern.compile(\"<[^>]*>\");\n\n    /** Period literal. */\n    private static final String PERIOD = \".\";\n\n    /** Summary tag text. */\n    private static final String SUMMARY_TEXT = \"@summary\";\n\n    /** Return tag text. */\n    private static final String RETURN_TEXT = \"@return\";\n\n    /** Set of allowed Tokens tags in summary java doc. */\n    private static final Set<Integer> ALLOWED_TYPES = Set.of(\n                    JavadocTokenTypes.WS,\n                    JavadocTokenTypes.DESCRIPTION,\n                    JavadocTokenTypes.TEXT);\n\n    /**\n     * Specify the regexp for forbidden summary fragments.\n     */\n    private Pattern forbiddenSummaryFragments = CommonUtil.createPattern(\"^$\");\n\n    /**\n     * Specify the period symbol at the end of first javadoc sentence.\n     */\n    private String period = PERIOD;\n\n    /**\n     * Setter to specify the regexp for forbidden summary fragments.\n     *\n     * @param pattern a pattern.\n     */\n    public void setForbiddenSummaryFragments(Pattern pattern) {\n        forbiddenSummaryFragments = pattern;\n    }\n\n    /**\n     * Setter to specify the period symbol at the end of first javadoc sentence.\n     *\n     * @param period period's value.\n     */\n    public void setPeriod(String period) {\n        this.period = period;\n    }\n\n    @Override\n    public int[] getDefaultJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.JAVADOC,\n        };\n    }\n\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return getAcceptableJavadocTokens();\n    }\n\n    @Override\n    public void visitJavadocToken(DetailNode ast) {\n        final Optional<DetailNode> inlineTag = getInlineTagNode(ast);\n        if (inlineTag.isPresent() && isSummaryTag(inlineTag.get())) {\n            validateSummaryTag(inlineTag.get());\n        }\n        else if (inlineTag.isPresent() && isInlineReturnTag(inlineTag.get())) {\n            validateInlineReturnTag(inlineTag.get());\n        }\n        else if (!startsWithInheritDoc(ast)) {\n            validateUntaggedSummary(ast);\n        }\n    }\n\n    /**\n     * Checks the javadoc text for {@code period} at end and forbidden fragments.\n     *\n     * @param ast the javadoc text node\n     */\n    private void validateUntaggedSummary(DetailNode ast) {\n        final String summaryDoc = getSummarySentence(ast);\n        if (summaryDoc.isEmpty()) {\n            log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (!period.isEmpty()) {\n            final String firstSentence = getFirstSentence(ast);\n            final int endOfSentence = firstSentence.lastIndexOf(period);\n            if (!summaryDoc.contains(period)) {\n                log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n            }\n            if (endOfSentence != -1\n                    && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n            }\n        }\n    }\n\n    /**\n     * Gets the node for the inline tag if present.\n     *\n     * @param javadoc javadoc root node.\n     * @return the node for the inline tag if present.\n     */\n    private static Optional<DetailNode> getInlineTagNode(DetailNode javadoc) {\n        return Arrays.stream(javadoc.getChildren())\n            .filter(SummaryJavadocCheck::isInlineTagPresent)\n            .findFirst()\n            .map(SummaryJavadocCheck::getInlineTagNodeWithinHtmlElement);\n    }\n\n    /**\n     * Checks if the inline tag node is present.\n     *\n     * @param ast ast node to check.\n     * @return true, if the inline tag node is present.\n     */\n    private static boolean isInlineTagPresent(DetailNode ast) {\n        return ast.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                || ast.getType() == JavadocTokenTypes.HTML_ELEMENT\n                && getInlineTagNodeWithinHtmlElement(ast) != null;\n    }\n\n    /**\n     * Returns an inline javadoc tag node that is within a html tag.\n     *\n     * @param ast html tag node.\n     * @return inline summary javadoc tag node or null if no node is found.\n     */\n    private static DetailNode getInlineTagNodeWithinHtmlElement(DetailNode ast) {\n        DetailNode node = ast;\n        DetailNode result = null;\n        // node can never be null as this method is called when there is a HTML_ELEMENT\n        if (node.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG) {\n            result = node;\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_TAG) {\n            // HTML_TAG always has more than 2 children.\n            node = node.getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_ELEMENT\n                // Condition for SINGLETON html element which cannot contain summary node\n                && node.getChildren()[0].getChildren().length > 1) {\n            // Html elements have one tested tag before actual content inside it\n            node = node.getChildren()[0].getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if the javadoc inline tag is {@code {@summary}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if inline tag is summary tag.\n     */\n    private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n        return isInlineTagWithName(javadocInlineTag, SUMMARY_TEXT);\n    }\n\n    /**\n     * Checks if the first tag inside ast is {@code {@return}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if first tag is return tag.\n     */\n    private static boolean isInlineReturnTag(DetailNode javadocInlineTag) {\n        return isInlineTagWithName(javadocInlineTag, RETURN_TEXT);\n    }\n\n    /**\n     * Checks if the first tag inside ast is a tag with the given name.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @param name name of inline tag.\n     *\n     * @return {@code true} if first tag is a tag with the given name.\n     */\n    private static boolean isInlineTagWithName(DetailNode javadocInlineTag, String name) {\n        final DetailNode[] child = javadocInlineTag.getChildren();\n\n        // Checking size of ast is not required, since ast contains\n        // children of Inline Tag, as at least 2 children will be present which are\n        // RCURLY and LCURLY.\n        return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n            && name.equals(child[1].getText());\n    }\n\n    /**\n     * Checks the inline summary (if present) for {@code period} at end and forbidden fragments.\n     *\n     * @param inlineSummaryTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     */\n    private void validateSummaryTag(DetailNode inlineSummaryTag) {\n        final String inlineSummary = getContentOfInlineCustomTag(inlineSummaryTag);\n        final String summaryVisible = getVisibleContent(inlineSummary);\n        if (summaryVisible.isEmpty()) {\n            log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (!period.isEmpty()) {\n            if (isPeriodNotAtEnd(summaryVisible, period)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_MISSING_PERIOD);\n            }\n            else if (containsForbiddenFragment(inlineSummary)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC);\n            }\n        }\n    }\n\n    /**\n     * Checks the inline return for forbidden fragments.\n     *\n     * @param inlineReturnTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     */\n    private void validateInlineReturnTag(DetailNode inlineReturnTag) {\n        final String inlineReturn = getContentOfInlineCustomTag(inlineReturnTag);\n        final String returnVisible = getVisibleContent(inlineReturn);\n        if (returnVisible.isEmpty()) {\n            log(inlineReturnTag.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (containsForbiddenFragment(inlineReturn)) {\n            log(inlineReturnTag.getLineNumber(), MSG_SUMMARY_JAVADOC);\n        }\n    }\n\n    /**\n     * Gets the content of inline custom tag.\n     *\n     * @param inlineTag inline tag node.\n     * @return String consisting of the content of inline custom tag.\n     */\n    public static String getContentOfInlineCustomTag(DetailNode inlineTag) {\n        final DetailNode[] childrenOfInlineTag = inlineTag.getChildren();\n        final StringBuilder customTagContent = new StringBuilder(256);\n        final int indexOfContentOfSummaryTag = 3;\n        if (childrenOfInlineTag.length != indexOfContentOfSummaryTag) {\n            DetailNode currentNode = childrenOfInlineTag[indexOfContentOfSummaryTag];\n            while (currentNode.getType() != JavadocTokenTypes.JAVADOC_INLINE_TAG_END) {\n                extractInlineTagContent(currentNode, customTagContent);\n                currentNode = JavadocUtil.getNextSibling(currentNode);\n            }\n        }\n        return customTagContent.toString();\n    }\n\n    /**\n     * Extracts the content of inline custom tag recursively.\n     *\n     * @param node DetailNode\n     * @param customTagContent content of custom tag\n     */\n    private static void extractInlineTagContent(DetailNode node,\n        StringBuilder customTagContent) {\n        final DetailNode[] children = node.getChildren();\n        if (children.length == 0) {\n            customTagContent.append(node.getText());\n        }\n        else {\n            for (DetailNode child : children) {\n                if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                    extractInlineTagContent(child, customTagContent);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the string that is visible to user in javadoc.\n     *\n     * @param summary entire content of summary javadoc.\n     * @return string that is visible to user in javadoc.\n     */\n    private static String getVisibleContent(String summary) {\n        final String visibleSummary = HTML_ELEMENTS.matcher(summary).replaceAll(\"\");\n        return visibleSummary.trim();\n    }\n\n    /**\n     * Checks if the string does not end with period.\n     *\n     * @param sentence string to check for period at end.\n     * @param period string to check within sentence.\n     * @return {@code true} if sentence does not end with period.\n     */\n    private static boolean isPeriodNotAtEnd(String sentence, String period) {\n        final String summarySentence = sentence.trim();\n        return summarySentence.lastIndexOf(period) != summarySentence.length() - 1;\n    }\n\n    /**\n     * Tests if first sentence contains forbidden summary fragment.\n     *\n     * @param firstSentence string with first sentence.\n     * @return {@code true} if first sentence contains forbidden summary fragment.\n     */\n    private boolean containsForbiddenFragment(String firstSentence) {\n        final String javadocText = JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN\n                .matcher(firstSentence).replaceAll(\" \").trim();\n        return forbiddenSummaryFragments.matcher(trimExcessWhitespaces(javadocText)).find();\n    }\n\n    /**\n     * Trims the given {@code text} of duplicate whitespaces.\n     *\n     * @param text the text to transform.\n     * @return the finalized form of the text.\n     */\n    private static String trimExcessWhitespaces(String text) {\n        final StringBuilder result = new StringBuilder(256);\n        boolean previousWhitespace = true;\n\n        for (char letter : text.toCharArray()) {\n            final char print;\n            if (Character.isWhitespace(letter)) {\n                if (previousWhitespace) {\n                    continue;\n                }\n\n                previousWhitespace = true;\n                print = ' ';\n            }\n            else {\n                previousWhitespace = false;\n                print = letter;\n            }\n\n            result.append(print);\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Checks if the node starts with an {&#64;inheritDoc}.\n     *\n     * @param root the root node to examine.\n     * @return {@code true} if the javadoc starts with an {&#64;inheritDoc}.\n     */\n    private static boolean startsWithInheritDoc(DetailNode root) {\n        boolean found = false;\n        final DetailNode[] children = root.getChildren();\n\n        for (int i = 0; !found; i++) {\n            final DetailNode child = children[i];\n            if (child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                    && child.getChildren()[1].getType() == JavadocTokenTypes.INHERIT_DOC_LITERAL) {\n                found = true;\n            }\n            else if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK\n                    && !CommonUtil.isBlank(child.getText())) {\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    /**\n     * Finds and returns summary sentence.\n     *\n     * @param ast javadoc root node.\n     * @return violation string.\n     */\n    private static String getSummarySentence(DetailNode ast) {\n        boolean flag = true;\n        final StringBuilder result = new StringBuilder(256);\n        for (DetailNode child : ast.getChildren()) {\n            if (ALLOWED_TYPES.contains(child.getType())) {\n                result.append(child.getText());\n            }\n            else if (child.getType() == JavadocTokenTypes.HTML_ELEMENT\n                    && CommonUtil.isBlank(result.toString().trim())) {\n                result.append(getStringInsideTag(result.toString(),\n                        child.getChildren()[0].getChildren()[0]));\n            }\n            else if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n                flag = false;\n            }\n            if (!flag) {\n                break;\n            }\n        }\n        return result.toString().trim();\n    }\n\n    /**\n     * Get concatenated string within text of html tags.\n     *\n     * @param result javadoc string\n     * @param detailNode javadoc tag node\n     * @return java doc tag content appended in result\n     */\n    private static String getStringInsideTag(String result, DetailNode detailNode) {\n        final StringBuilder contents = new StringBuilder(result);\n        DetailNode tempNode = detailNode;\n        while (tempNode != null) {\n            if (tempNode.getType() == JavadocTokenTypes.TEXT) {\n                contents.append(tempNode.getText());\n            }\n            tempNode = JavadocUtil.getNextSibling(tempNode);\n        }\n        return contents.toString();\n    }\n\n    /**\n     * Finds and returns first sentence.\n     *\n     * @param ast Javadoc root node.\n     * @return first sentence.\n     */\n    private static String getFirstSentence(DetailNode ast) {\n        final StringBuilder result = new StringBuilder(256);\n        final String periodSuffix = PERIOD + ' ';\n        for (DetailNode child : ast.getChildren()) {\n            final String text;\n            if (child.getChildren().length == 0) {\n                text = child.getText();\n            }\n            else {\n                text = getFirstSentence(child);\n            }\n\n            if (text.contains(periodSuffix)) {\n                result.append(text, 0, text.indexOf(periodSuffix) + 1);\n                break;\n            }\n\n            result.append(text);\n        }\n        return result.toString();\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Checks if the first tag inside ast is a tag with the given name.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @param name name of inline tag.\n     *\n     * @return {@code true} if first tag is a tag with the given name.\n     */\n    private static boolean isInlineTagWithName(DetailNode javadocInlineTag, String name) {\n        final DetailNode[] child = javadocInlineTag.getChildren();\n\n        // Checking size of ast is not required, since ast contains\n        // children of Inline Tag, as at least 2 children will be present which are\n        // RCURLY and LCURLY.\n        return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n            && name.equals(child[1].getText());\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Checks if the javadoc inline tag is {@code {@summary}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if inline tag is summary tag.\n     */\n    private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n        return isInlineTagWithName(javadocInlineTag, SUMMARY_TEXT);\n    }\n/**\n     * Checks if the first tag inside ast is a tag with the given name.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @param name name of inline tag.\n     *\n     * @return {@code true} if first tag is a tag with the given name.\n     */\n    private static boolean isInlineTagWithName(DetailNode javadocInlineTag, String name) {\n        final DetailNode[] child = javadocInlineTag.getChildren();\n\n        // Checking size of ast is not required, since ast contains\n        // children of Inline Tag, as at least 2 children will be present which are\n        // RCURLY and LCURLY.\n        return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n            && name.equals(child[1].getText());\n    }", "diffSourceCode": "-  388:     /**\n-  389:      * Checks if the javadoc inline tag is {@code {@summary}} tag.\n-  390:      *\n-  391:      * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n-  392:      * @return {@code true} if inline tag is summary tag.\n-  393:      */\n-  394:     private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n-  395:         final DetailNode[] child = javadocInlineTag.getChildren();\n-  396: \n-  397:         // Checking size of ast is not required, since ast contains\n-  398:         // children of Inline Tag, as at least 2 children will be present which are\n-  399:         // RCURLY and LCURLY.\n-  400:         return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n-  401:                 && SUMMARY_TEXT.equals(child[1].getText());\n-  402:     }\n-  403: \n-  404:     /**\n-  405:      * Checks the inline summary (if present) for {@code period} at end and forbidden fragments.\n-  406:      *\n-  407:      * @param inlineSummaryTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n-  419:             else if (containsForbiddenFragment(inlineSummary)) {\n-  420:                 log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC);\n-  421:             }\n-  422:         }\n-  423:     }\n-  424: \n-  425:     /**\n-  426:      * Gets the content of inline custom tag.\n-  427:      *\n-  428:      * @param inlineTag inline tag node.\n-  429:      * @return String consisting of the content of inline custom tag.\n-  430:      */\n-  431:     public static String getContentOfInlineCustomTag(DetailNode inlineTag) {\n-  432:         final DetailNode[] childrenOfInlineTag = inlineTag.getChildren();\n-  433:         final StringBuilder customTagContent = new StringBuilder(256);\n-  434:         final int indexOfContentOfSummaryTag = 3;\n-  435:         if (childrenOfInlineTag.length != indexOfContentOfSummaryTag) {\n+  388:         }\n+  389:         else if (node.getType() == JavadocTokenTypes.HTML_ELEMENT\n+  390:                 // Condition for SINGLETON html element which cannot contain summary node\n+  391:                 && node.getChildren()[0].getChildren().length > 1) {\n+  392:             // Html elements have one tested tag before actual content inside it\n+  393:             node = node.getChildren()[0].getChildren()[1];\n+  394:             result = getInlineTagNodeWithinHtmlElement(node);\n+  395:         }\n+  396:         return result;\n+  397:     }\n+  398: \n+  399:     /**\n+  400:      * Checks if the javadoc inline tag is {@code {@summary}} tag.\n+  401:      *\n+  402:      * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n+  403:      * @return {@code true} if inline tag is summary tag.\n+  404:      */\n+  405:     private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n+  406:         return isInlineTagWithName(javadocInlineTag, SUMMARY_TEXT);\n+  407:     }\n+  419:     /**\n+  420:      * Checks if the first tag inside ast is a tag with the given name.\n+  421:      *\n+  422:      * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n+  423:      * @param name name of inline tag.\n+  424:      *\n+  425:      * @return {@code true} if first tag is a tag with the given name.\n+  426:      */\n+  427:     private static boolean isInlineTagWithName(DetailNode javadocInlineTag, String name) {\n+  428:         final DetailNode[] child = javadocInlineTag.getChildren();\n+  429: \n+  430:         // Checking size of ast is not required, since ast contains\n+  431:         // children of Inline Tag, as at least 2 children will be present which are\n+  432:         // RCURLY and LCURLY.\n+  433:         return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n+  434:             && name.equals(child[1].getText());\n+  435:     }\n", "uniqueId": "cc90b04b02f963571ae4697857db838ac27efb84_388_402_419_435_399_407", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 20}, "BRANCH": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 3}, "COMPLEXITY": {"missed": 0, "covered": 3}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\n/**\n * Extracts the content of inline custom tag.\n *\n * @param inlineTag inline tag node.\n * @return String consisting of the content of inline custom tag.\n */\npublic static String getContentOfInlineCustomTag(DetailNode inlineTag) {\n    final DetailNode[] childrenOfInlineTag = inlineTag.getChildren();\n    final StringBuilder customTagContent = new StringBuilder(256);\n    final int indexOfContentOfSummaryTag = 3;\n    if (childrenOfInlineTag.length != indexOfContentOfSummaryTag) {\n        DetailNode currentNode = childrenOfInlineTag[indexOfContentOfSummaryTag];\n        while (currentNode.getType() != JavadocTokenTypes.JAVADOC_INLINE_TAG_END) {\n            extractInlineTagContent(currentNode, customTagContent);\n            currentNode = JavadocUtil.getNextSibling(currentNode);\n        }\n    }\n    return customTagContent.toString();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Checks if the javadoc inline tag is {@code {@summary}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if inline tag is summary tag.\n     */\n    private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n        final DetailNode[] child = javadocInlineTag.getChildren();\n\n        // Checking size of ast is not required, since ast contains\n        // children of Inline Tag, as at least 2 children will be present which are\n        // RCURLY and LCURLY.\n        return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n                && SUMMARY_TEXT.equals(child[1].getText());\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.javadoc;\n\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailNode;\nimport com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n\n/**\n * <p>\n * Checks that\n * <a href=\"https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#firstsentence\">\n * Javadoc summary sentence</a> does not contain phrases that are not recommended to use.\n * Summaries that contain only the {@code {@inheritDoc}} tag are skipped.\n * Check also violate Javadoc that does not contain first sentence.\n * </p>\n * <ul>\n * <li>\n * Property {@code violateExecutionOnNonTightHtml} - Control when to print violations\n * if the Javadoc being examined by this check violates the tight html rules defined at\n * <a href=\"https://checkstyle.org/writingjavadocchecks.html#Tight-HTML_rules\">Tight-HTML Rules</a>.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code forbiddenSummaryFragments} - Specify the regexp for forbidden summary fragments.\n * Type is {@code java.util.regex.Pattern}.\n * Default value is {@code \"^$\"}.\n * </li>\n * <li>\n * Property {@code period} - Specify the period symbol at the end of first javadoc sentence.\n * Type is {@code java.lang.String}.\n * Default value is {@code \".\"}.\n * </li>\n * </ul>\n * <p>\n * To configure the default check to validate that first sentence is not empty and first\n * sentence is not missing:\n * </p>\n * <pre>\n * &lt;module name=&quot;SummaryJavadocCheck&quot;/&gt;\n * </pre>\n * <p>\n * Example of {@code {@inheritDoc}} without summary.\n * </p>\n * <pre>\n * public class Test extends Exception {\n * //Valid\n *   &#47;**\n *    * {&#64;inheritDoc}\n *    *&#47;\n *   public String ValidFunction(){\n *     return \"\";\n *   }\n *   //Violation\n *   &#47;**\n *    *\n *    *&#47;\n *   public String InvalidFunction(){\n *     return \"\";\n *   }\n * }\n * </pre>\n * <p>\n * Example of non permitted empty javadoc for Inline Summary Javadoc.\n * </p>\n * <pre>\n * public class Test extends Exception {\n *   &#47;**\n *    * {&#64;summary  }\n *    *&#47;\n *   public String InvalidFunctionOne(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt; &lt;p/&gt;}\n *    *&#47;\n *   public String InvalidFunctionTwo(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt;This is summary for validFunctionThree.&lt;p/&gt;}\n *    *&#47;\n *   public void validFunctionThree(){} // ok\n * }\n * </pre>\n * <p>\n * To ensure that summary do not contain phrase like \"This method returns\",\n * use following config:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"forbiddenSummaryFragments\"\n *     value=\"^This method returns.*\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * To specify period symbol at the end of first javadoc sentence:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"period\" value=\"\u3002\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Example of period property.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * This is invalid java doc.\n *   *&#47;\n *   void invalidJavaDocMethod() {\n *   }\n *  &#47;**\n *   * This is valid java doc\u3002\n *   *&#47;\n *   void validJavaDocMethod() {\n *   }\n * }\n * </pre>\n * <p>\n * Example of period property for inline summary javadoc.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * {&#64;summary This is invalid java doc.}\n *   *&#47;\n *   public void invalidJavaDocMethod() { // violation\n *   }\n *  &#47;**\n *   * {&#64;summary This is valid java doc\u3002}\n *   *&#47;\n *   public void validJavaDocMethod() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Example of inline summary javadoc with HTML tags.\n * </p>\n * <pre>\n * public class Test {\n *  &#47;**\n *   * {&#64;summary First sentence is normally the summary.\n *   * Use of html tags:\n *   * &lt;ul&gt;\n *   * &lt;li&gt;Item one.&lt;/li&gt;\n *   * &lt;li&gt;Item two.&lt;/li&gt;\n *   * &lt;/ul&gt;}\n *   *&#47;\n *   public void validInlineJavadoc() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code javadoc.missed.html.close}\n * </li>\n * <li>\n * {@code javadoc.parse.rule.error}\n * </li>\n * <li>\n * {@code javadoc.wrong.singleton.html.tag}\n * </li>\n * <li>\n * {@code summary.first.sentence}\n * </li>\n * <li>\n * {@code summary.javaDoc}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing.period}\n * </li>\n * </ul>\n *\n * @since 6.0\n */\n@StatelessCheck\npublic class SummaryJavadocCheck extends AbstractJavadocCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_FIRST_SENTENCE = \"summary.first.sentence\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC = \"summary.javaDoc\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC_MISSING = \"summary.javaDoc.missing\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\" file.\n     */\n    public static final String MSG_SUMMARY_MISSING_PERIOD = \"summary.javaDoc.missing.period\";\n\n    /**\n     * This regexp is used to convert multiline javadoc to single line without stars.\n     */\n    private static final Pattern JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN =\n            Pattern.compile(\"\\n[ ]+(\\\\*)|^[ ]+(\\\\*)\");\n\n    /**\n     * This regexp is used to remove html tags, whitespace, and asterisks from a string.\n     */\n    private static final Pattern HTML_ELEMENTS =\n            Pattern.compile(\"<[^>]*>\");\n\n    /** Period literal. */\n    private static final String PERIOD = \".\";\n\n    /** Summary tag text. */\n    private static final String SUMMARY_TEXT = \"@summary\";\n\n    /** Set of allowed Tokens tags in summary java doc. */\n    private static final Set<Integer> ALLOWED_TYPES = Set.of(\n                    JavadocTokenTypes.WS,\n                    JavadocTokenTypes.DESCRIPTION,\n                    JavadocTokenTypes.TEXT);\n\n    /**\n     * Specify the regexp for forbidden summary fragments.\n     */\n    private Pattern forbiddenSummaryFragments = CommonUtil.createPattern(\"^$\");\n\n    /**\n     * Specify the period symbol at the end of first javadoc sentence.\n     */\n    private String period = PERIOD;\n\n    /**\n     * Setter to specify the regexp for forbidden summary fragments.\n     *\n     * @param pattern a pattern.\n     */\n    public void setForbiddenSummaryFragments(Pattern pattern) {\n        forbiddenSummaryFragments = pattern;\n    }\n\n    /**\n     * Setter to specify the period symbol at the end of first javadoc sentence.\n     *\n     * @param period period's value.\n     */\n    public void setPeriod(String period) {\n        this.period = period;\n    }\n\n    @Override\n    public int[] getDefaultJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.JAVADOC,\n        };\n    }\n\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return getAcceptableJavadocTokens();\n    }\n\n    @Override\n    public void visitJavadocToken(DetailNode ast) {\n        final Optional<DetailNode> inlineSummaryTag = getInlineSummaryTag(ast);\n        if (inlineSummaryTag.isPresent()) {\n            validateSummaryTag(inlineSummaryTag.get());\n        }\n        else if (!startsWithInheritDoc(ast)) {\n            final String summaryDoc = getSummarySentence(ast);\n            if (summaryDoc.isEmpty()) {\n                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n            }\n            else if (!period.isEmpty()) {\n                final String firstSentence = getFirstSentence(ast);\n                final int endOfSentence = firstSentence.lastIndexOf(period);\n                if (!summaryDoc.contains(period)) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n                }\n                if (endOfSentence != -1\n                        && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the inline summary tag.\n     *\n     * @param javadoc javadoc root node.\n     * @return an optional of inline summary tag node, empty optional if inline tag is not\n     *         a summary tag.\n     */\n    private static Optional<DetailNode> getInlineSummaryTag(DetailNode javadoc) {\n        Optional<DetailNode> node = Arrays.stream(javadoc.getChildren())\n                .filter(SummaryJavadocCheck::isInlineTagPresent)\n                .findFirst()\n                .map(SummaryJavadocCheck::getInlineTagNodeWithinHtmlElement);\n\n        if (node.isPresent() && !isSummaryTag(node.get())) {\n            node = Optional.empty();\n        }\n        return node;\n    }\n\n    /**\n     * Checks if the inline tag node is present.\n     *\n     * @param ast ast node to check.\n     * @return true, if the inline tag node is present.\n     */\n    private static boolean isInlineTagPresent(DetailNode ast) {\n        return ast.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                || ast.getType() == JavadocTokenTypes.HTML_ELEMENT\n                && getInlineTagNodeWithinHtmlElement(ast) != null;\n    }\n\n    /**\n     * Returns an inline javadoc tag node that is within a html tag.\n     *\n     * @param ast html tag node.\n     * @return inline summary javadoc tag node or null if no node is found.\n     */\n    private static DetailNode getInlineTagNodeWithinHtmlElement(DetailNode ast) {\n        DetailNode node = ast;\n        DetailNode result = null;\n        // node can never be null as this method is called when there is a HTML_ELEMENT\n        if (node.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG) {\n            result = node;\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_TAG) {\n            // HTML_TAG always has more than 2 children.\n            node = node.getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_ELEMENT\n                // Condition for SINGLETON html element which cannot contain summary node\n                && node.getChildren()[0].getChildren().length > 1) {\n            // Html elements have one tested tag before actual content inside it\n            node = node.getChildren()[0].getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if the javadoc inline tag is {@code {@summary}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if inline tag is summary tag.\n     */\n    private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n        final DetailNode[] child = javadocInlineTag.getChildren();\n\n        // Checking size of ast is not required, since ast contains\n        // children of Inline Tag, as at least 2 children will be present which are\n        // RCURLY and LCURLY.\n        return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n                && SUMMARY_TEXT.equals(child[1].getText());\n    }\n\n    /**\n     * Checks the inline summary (if present) for {@code period} at end and forbidden fragments.\n     *\n     * @param inlineSummaryTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     */\n    private void validateSummaryTag(DetailNode inlineSummaryTag) {\n        final String inlineSummary = getContentOfInlineCustomTag(inlineSummaryTag);\n        final String summaryVisible = getVisibleContent(inlineSummary);\n        if (summaryVisible.isEmpty()) {\n            log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (!period.isEmpty()) {\n            if (isPeriodNotAtEnd(summaryVisible, period)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_MISSING_PERIOD);\n            }\n            else if (containsForbiddenFragment(inlineSummary)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC);\n            }\n        }\n    }\n\n    /**\n     * Gets the content of inline custom tag.\n     *\n     * @param inlineTag inline tag node.\n     * @return String consisting of the content of inline custom tag.\n     */\n    public static String getContentOfInlineCustomTag(DetailNode inlineTag) {\n        final DetailNode[] childrenOfInlineTag = inlineTag.getChildren();\n        final StringBuilder customTagContent = new StringBuilder(256);\n        final int indexOfContentOfSummaryTag = 3;\n        if (childrenOfInlineTag.length != indexOfContentOfSummaryTag) {\n            DetailNode currentNode = childrenOfInlineTag[indexOfContentOfSummaryTag];\n            while (currentNode.getType() != JavadocTokenTypes.JAVADOC_INLINE_TAG_END) {\n                extractInlineTagContent(currentNode, customTagContent);\n                currentNode = JavadocUtil.getNextSibling(currentNode);\n            }\n        }\n        return customTagContent.toString();\n    }\n\n    /**\n     * Extracts the content of inline custom tag recursively.\n     *\n     * @param node DetailNode\n     * @param customTagContent content of custom tag\n     */\n    private static void extractInlineTagContent(DetailNode node,\n        StringBuilder customTagContent) {\n        final DetailNode[] children = node.getChildren();\n        if (children.length == 0) {\n            customTagContent.append(node.getText());\n        }\n        else {\n            for (DetailNode child : children) {\n                if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                    extractInlineTagContent(child, customTagContent);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the string that is visible to user in javadoc.\n     *\n     * @param summary entire content of summary javadoc.\n     * @return string that is visible to user in javadoc.\n     */\n    private static String getVisibleContent(String summary) {\n        final String visibleSummary = HTML_ELEMENTS.matcher(summary).replaceAll(\"\");\n        return visibleSummary.trim();\n    }\n\n    /**\n     * Checks if the string does not end with period.\n     *\n     * @param sentence string to check for period at end.\n     * @param period string to check within sentence.\n     * @return {@code true} if sentence does not end with period.\n     */\n    private static boolean isPeriodNotAtEnd(String sentence, String period) {\n        final String summarySentence = sentence.trim();\n        return summarySentence.lastIndexOf(period) != summarySentence.length() - 1;\n    }\n\n    /**\n     * Tests if first sentence contains forbidden summary fragment.\n     *\n     * @param firstSentence string with first sentence.\n     * @return {@code true} if first sentence contains forbidden summary fragment.\n     */\n    private boolean containsForbiddenFragment(String firstSentence) {\n        final String javadocText = JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN\n                .matcher(firstSentence).replaceAll(\" \").trim();\n        return forbiddenSummaryFragments.matcher(trimExcessWhitespaces(javadocText)).find();\n    }\n\n    /**\n     * Trims the given {@code text} of duplicate whitespaces.\n     *\n     * @param text the text to transform.\n     * @return the finalized form of the text.\n     */\n    private static String trimExcessWhitespaces(String text) {\n        final StringBuilder result = new StringBuilder(256);\n        boolean previousWhitespace = true;\n\n        for (char letter : text.toCharArray()) {\n            final char print;\n            if (Character.isWhitespace(letter)) {\n                if (previousWhitespace) {\n                    continue;\n                }\n\n                previousWhitespace = true;\n                print = ' ';\n            }\n            else {\n                previousWhitespace = false;\n                print = letter;\n            }\n\n            result.append(print);\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Checks if the node starts with an {&#64;inheritDoc}.\n     *\n     * @param root the root node to examine.\n     * @return {@code true} if the javadoc starts with an {&#64;inheritDoc}.\n     */\n    private static boolean startsWithInheritDoc(DetailNode root) {\n        boolean found = false;\n        final DetailNode[] children = root.getChildren();\n\n        for (int i = 0; !found; i++) {\n            final DetailNode child = children[i];\n            if (child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                    && child.getChildren()[1].getType() == JavadocTokenTypes.INHERIT_DOC_LITERAL) {\n                found = true;\n            }\n            else if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK\n                    && !CommonUtil.isBlank(child.getText())) {\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    /**\n     * Finds and returns summary sentence.\n     *\n     * @param ast javadoc root node.\n     * @return violation string.\n     */\n    private static String getSummarySentence(DetailNode ast) {\n        boolean flag = true;\n        final StringBuilder result = new StringBuilder(256);\n        for (DetailNode child : ast.getChildren()) {\n            if (ALLOWED_TYPES.contains(child.getType())) {\n                result.append(child.getText());\n            }\n            else if (child.getType() == JavadocTokenTypes.HTML_ELEMENT\n                    && CommonUtil.isBlank(result.toString().trim())) {\n                result.append(getStringInsideTag(result.toString(),\n                        child.getChildren()[0].getChildren()[0]));\n            }\n            else if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n                flag = false;\n            }\n            if (!flag) {\n                break;\n            }\n        }\n        return result.toString().trim();\n    }\n\n    /**\n     * Get concatenated string within text of html tags.\n     *\n     * @param result javadoc string\n     * @param detailNode javadoc tag node\n     * @return java doc tag content appended in result\n     */\n    private static String getStringInsideTag(String result, DetailNode detailNode) {\n        final StringBuilder contents = new StringBuilder(result);\n        DetailNode tempNode = detailNode;\n        while (tempNode != null) {\n            if (tempNode.getType() == JavadocTokenTypes.TEXT) {\n                contents.append(tempNode.getText());\n            }\n            tempNode = JavadocUtil.getNextSibling(tempNode);\n        }\n        return contents.toString();\n    }\n\n    /**\n     * Finds and returns first sentence.\n     *\n     * @param ast Javadoc root node.\n     * @return first sentence.\n     */\n    private static String getFirstSentence(DetailNode ast) {\n        final StringBuilder result = new StringBuilder(256);\n        final String periodSuffix = PERIOD + ' ';\n        for (DetailNode child : ast.getChildren()) {\n            final String text;\n            if (child.getChildren().length == 0) {\n                text = child.getText();\n            }\n            else {\n                text = getFirstSentence(child);\n            }\n\n            if (text.contains(periodSuffix)) {\n                result.append(text, 0, text.indexOf(periodSuffix) + 1);\n                break;\n            }\n\n            result.append(text);\n        }\n        return result.toString();\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate validateUntaggedSummary(ast DetailNode) : void extracted from public visitJavadocToken(ast DetailNode) : void in class com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java", "startLine": 304, "endLine": 327, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java", "startLine": 309, "endLine": 321, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java", "startLine": 323, "endLine": 344, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public void visitJavadocToken(DetailNode ast) {\n        final Optional<DetailNode> inlineSummaryTag = getInlineSummaryTag(ast);\n        if (inlineSummaryTag.isPresent()) {\n            validateSummaryTag(inlineSummaryTag.get());\n        }\n        else if (!startsWithInheritDoc(ast)) {\n            final String summaryDoc = getSummarySentence(ast);\n            if (summaryDoc.isEmpty()) {\n                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n            }\n            else if (!period.isEmpty()) {\n                final String firstSentence = getFirstSentence(ast);\n                final int endOfSentence = firstSentence.lastIndexOf(period);\n                if (!summaryDoc.contains(period)) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n                }\n                if (endOfSentence != -1\n                        && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n                }\n            }\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java", "isPureRefactoring": true, "commitId": "cc90b04b02f963571ae4697857db838ac27efb84", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.javadoc", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#visitJavadocToken", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#getFirstSentence\n methodBody: private static String getFirstSentence(DetailNode ast) {\nfinal StringBuilder result=new StringBuilder(256);\nfinal String periodSuffix=PERIOD + ' ';\nfor(DetailNode child: ast.getChildren()){final String text;\nif(child.getChildren().length == 0){text=child.getText();\n}{text=getFirstSentence(child);\n}if(text.contains(periodSuffix)){result.append(text,0,text.indexOf(periodSuffix) + 1);\nbreak;\n}result.append(text);\n}return result.toString();\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#validateSummaryTag\n methodBody: private void validateSummaryTag(DetailNode inlineSummaryTag) {\nfinal String inlineSummary=getContentOfInlineCustomTag(inlineSummaryTag);\nfinal String summaryVisible=getVisibleContent(inlineSummary);\nif(summaryVisible.isEmpty()){log(inlineSummaryTag.getLineNumber(),MSG_SUMMARY_JAVADOC_MISSING);\n}if(!period.isEmpty()){if(isPeriodNotAtEnd(summaryVisible,period)){log(inlineSummaryTag.getLineNumber(),MSG_SUMMARY_MISSING_PERIOD);\n}if(containsForbiddenFragment(inlineSummary)){log(inlineSummaryTag.getLineNumber(),MSG_SUMMARY_JAVADOC);\n}}}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#startsWithInheritDoc\n methodBody: private static boolean startsWithInheritDoc(DetailNode root) {\nboolean found=false;\nfinal DetailNode[] children=root.getChildren();\nfor(int i=0; !found; i++){final DetailNode child=children[i];\nif(child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG && child.getChildren()[1].getType() == JavadocTokenTypes.INHERIT_DOC_LITERAL){found=true;\n}if(child.getType() != JavadocTokenTypes.LEADING_ASTERISK && !CommonUtil.isBlank(child.getText())){break;\n}}return found;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#containsForbiddenFragment\n methodBody: private boolean containsForbiddenFragment(String firstSentence) {\nfinal String javadocText=JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN.matcher(firstSentence).replaceAll(\" \").trim();\nreturn forbiddenSummaryFragments.matcher(trimExcessWhitespaces(javadocText)).find();\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#getSummarySentence\n methodBody: private static String getSummarySentence(DetailNode ast) {\nboolean flag=true;\nfinal StringBuilder result=new StringBuilder(256);\nfor(DetailNode child: ast.getChildren()){if(ALLOWED_TYPES.contains(child.getType())){result.append(child.getText());\n}if(child.getType() == JavadocTokenTypes.HTML_ELEMENT && CommonUtil.isBlank(result.toString().trim())){result.append(getStringInsideTag(result.toString(),child.getChildren()[0].getChildren()[0]));\n}if(child.getType() == JavadocTokenTypes.JAVADOC_TAG){flag=false;\n}if(!flag){break;\n}}return result.toString().trim();\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#getInlineSummaryTag\n methodBody: private static Optional<DetailNode> getInlineSummaryTag(DetailNode javadoc) {\nOptional<DetailNode> node=Arrays.stream(javadoc.getChildren()).filter(SummaryJavadocCheck::isInlineTagPresent).findFirst().map(SummaryJavadocCheck::getInlineTagNodeWithinHtmlElement);\nif(node.isPresent() && !isSummaryTag(node.get())){node=Optional.empty();\n}return node;\n}", "classSignatureBefore": "public class SummaryJavadocCheck extends AbstractJavadocCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#visitJavadocToken"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck"], "classSignatureBeforeSet": ["public class SummaryJavadocCheck extends AbstractJavadocCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.javadoc;\n\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailNode;\nimport com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n\n/**\n * <p>\n * Checks that\n * <a href=\"https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#firstsentence\">\n * Javadoc summary sentence</a> does not contain phrases that are not recommended to use.\n * Summaries that contain only the {@code {@inheritDoc}} tag are skipped.\n * Check also violate Javadoc that does not contain first sentence.\n * </p>\n * <ul>\n * <li>\n * Property {@code violateExecutionOnNonTightHtml} - Control when to print violations\n * if the Javadoc being examined by this check violates the tight html rules defined at\n * <a href=\"https://checkstyle.org/writingjavadocchecks.html#Tight-HTML_rules\">Tight-HTML Rules</a>.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code forbiddenSummaryFragments} - Specify the regexp for forbidden summary fragments.\n * Type is {@code java.util.regex.Pattern}.\n * Default value is {@code \"^$\"}.\n * </li>\n * <li>\n * Property {@code period} - Specify the period symbol at the end of first javadoc sentence.\n * Type is {@code java.lang.String}.\n * Default value is {@code \".\"}.\n * </li>\n * </ul>\n * <p>\n * To configure the default check to validate that first sentence is not empty and first\n * sentence is not missing:\n * </p>\n * <pre>\n * &lt;module name=&quot;SummaryJavadocCheck&quot;/&gt;\n * </pre>\n * <p>\n * Example of {@code {@inheritDoc}} without summary.\n * </p>\n * <pre>\n * public class Test extends Exception {\n * //Valid\n *   &#47;**\n *    * {&#64;inheritDoc}\n *    *&#47;\n *   public String ValidFunction(){\n *     return \"\";\n *   }\n *   //Violation\n *   &#47;**\n *    *\n *    *&#47;\n *   public String InvalidFunction(){\n *     return \"\";\n *   }\n * }\n * </pre>\n * <p>\n * Example of non permitted empty javadoc for Inline Summary Javadoc.\n * </p>\n * <pre>\n * public class Test extends Exception {\n *   &#47;**\n *    * {&#64;summary  }\n *    *&#47;\n *   public String InvalidFunctionOne(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt; &lt;p/&gt;}\n *    *&#47;\n *   public String InvalidFunctionTwo(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt;This is summary for validFunctionThree.&lt;p/&gt;}\n *    *&#47;\n *   public void validFunctionThree(){} // ok\n * }\n * </pre>\n * <p>\n * To ensure that summary do not contain phrase like \"This method returns\",\n * use following config:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"forbiddenSummaryFragments\"\n *     value=\"^This method returns.*\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * To specify period symbol at the end of first javadoc sentence:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"period\" value=\"\u3002\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Example of period property.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * This is invalid java doc.\n *   *&#47;\n *   void invalidJavaDocMethod() {\n *   }\n *  &#47;**\n *   * This is valid java doc\u3002\n *   *&#47;\n *   void validJavaDocMethod() {\n *   }\n * }\n * </pre>\n * <p>\n * Example of period property for inline summary javadoc.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * {&#64;summary This is invalid java doc.}\n *   *&#47;\n *   public void invalidJavaDocMethod() { // violation\n *   }\n *  &#47;**\n *   * {&#64;summary This is valid java doc\u3002}\n *   *&#47;\n *   public void validJavaDocMethod() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Example of inline summary javadoc with HTML tags.\n * </p>\n * <pre>\n * public class Test {\n *  &#47;**\n *   * {&#64;summary First sentence is normally the summary.\n *   * Use of html tags:\n *   * &lt;ul&gt;\n *   * &lt;li&gt;Item one.&lt;/li&gt;\n *   * &lt;li&gt;Item two.&lt;/li&gt;\n *   * &lt;/ul&gt;}\n *   *&#47;\n *   public void validInlineJavadoc() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code javadoc.missed.html.close}\n * </li>\n * <li>\n * {@code javadoc.parse.rule.error}\n * </li>\n * <li>\n * {@code javadoc.wrong.singleton.html.tag}\n * </li>\n * <li>\n * {@code summary.first.sentence}\n * </li>\n * <li>\n * {@code summary.javaDoc}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing.period}\n * </li>\n * </ul>\n *\n * @since 6.0\n */\n@StatelessCheck\npublic class SummaryJavadocCheck extends AbstractJavadocCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_FIRST_SENTENCE = \"summary.first.sentence\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC = \"summary.javaDoc\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC_MISSING = \"summary.javaDoc.missing\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\" file.\n     */\n    public static final String MSG_SUMMARY_MISSING_PERIOD = \"summary.javaDoc.missing.period\";\n\n    /**\n     * This regexp is used to convert multiline javadoc to single line without stars.\n     */\n    private static final Pattern JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN =\n            Pattern.compile(\"\\n[ ]+(\\\\*)|^[ ]+(\\\\*)\");\n\n    /**\n     * This regexp is used to remove html tags, whitespace, and asterisks from a string.\n     */\n    private static final Pattern HTML_ELEMENTS =\n            Pattern.compile(\"<[^>]*>\");\n\n    /** Period literal. */\n    private static final String PERIOD = \".\";\n\n    /** Summary tag text. */\n    private static final String SUMMARY_TEXT = \"@summary\";\n\n    /** Set of allowed Tokens tags in summary java doc. */\n    private static final Set<Integer> ALLOWED_TYPES = Set.of(\n                    JavadocTokenTypes.WS,\n                    JavadocTokenTypes.DESCRIPTION,\n                    JavadocTokenTypes.TEXT);\n\n    /**\n     * Specify the regexp for forbidden summary fragments.\n     */\n    private Pattern forbiddenSummaryFragments = CommonUtil.createPattern(\"^$\");\n\n    /**\n     * Specify the period symbol at the end of first javadoc sentence.\n     */\n    private String period = PERIOD;\n\n    /**\n     * Setter to specify the regexp for forbidden summary fragments.\n     *\n     * @param pattern a pattern.\n     */\n    public void setForbiddenSummaryFragments(Pattern pattern) {\n        forbiddenSummaryFragments = pattern;\n    }\n\n    /**\n     * Setter to specify the period symbol at the end of first javadoc sentence.\n     *\n     * @param period period's value.\n     */\n    public void setPeriod(String period) {\n        this.period = period;\n    }\n\n    @Override\n    public int[] getDefaultJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.JAVADOC,\n        };\n    }\n\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return getAcceptableJavadocTokens();\n    }\n\n    @Override\n    public void visitJavadocToken(DetailNode ast) {\n        final Optional<DetailNode> inlineSummaryTag = getInlineSummaryTag(ast);\n        if (inlineSummaryTag.isPresent()) {\n            validateSummaryTag(inlineSummaryTag.get());\n        }\n        else if (!startsWithInheritDoc(ast)) {\n            final String summaryDoc = getSummarySentence(ast);\n            if (summaryDoc.isEmpty()) {\n                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n            }\n            else if (!period.isEmpty()) {\n                final String firstSentence = getFirstSentence(ast);\n                final int endOfSentence = firstSentence.lastIndexOf(period);\n                if (!summaryDoc.contains(period)) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n                }\n                if (endOfSentence != -1\n                        && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the inline summary tag.\n     *\n     * @param javadoc javadoc root node.\n     * @return an optional of inline summary tag node, empty optional if inline tag is not\n     *         a summary tag.\n     */\n    private static Optional<DetailNode> getInlineSummaryTag(DetailNode javadoc) {\n        Optional<DetailNode> node = Arrays.stream(javadoc.getChildren())\n                .filter(SummaryJavadocCheck::isInlineTagPresent)\n                .findFirst()\n                .map(SummaryJavadocCheck::getInlineTagNodeWithinHtmlElement);\n\n        if (node.isPresent() && !isSummaryTag(node.get())) {\n            node = Optional.empty();\n        }\n        return node;\n    }\n\n    /**\n     * Checks if the inline tag node is present.\n     *\n     * @param ast ast node to check.\n     * @return true, if the inline tag node is present.\n     */\n    private static boolean isInlineTagPresent(DetailNode ast) {\n        return ast.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                || ast.getType() == JavadocTokenTypes.HTML_ELEMENT\n                && getInlineTagNodeWithinHtmlElement(ast) != null;\n    }\n\n    /**\n     * Returns an inline javadoc tag node that is within a html tag.\n     *\n     * @param ast html tag node.\n     * @return inline summary javadoc tag node or null if no node is found.\n     */\n    private static DetailNode getInlineTagNodeWithinHtmlElement(DetailNode ast) {\n        DetailNode node = ast;\n        DetailNode result = null;\n        // node can never be null as this method is called when there is a HTML_ELEMENT\n        if (node.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG) {\n            result = node;\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_TAG) {\n            // HTML_TAG always has more than 2 children.\n            node = node.getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_ELEMENT\n                // Condition for SINGLETON html element which cannot contain summary node\n                && node.getChildren()[0].getChildren().length > 1) {\n            // Html elements have one tested tag before actual content inside it\n            node = node.getChildren()[0].getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if the javadoc inline tag is {@code {@summary}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if inline tag is summary tag.\n     */\n    private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n        final DetailNode[] child = javadocInlineTag.getChildren();\n\n        // Checking size of ast is not required, since ast contains\n        // children of Inline Tag, as at least 2 children will be present which are\n        // RCURLY and LCURLY.\n        return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n                && SUMMARY_TEXT.equals(child[1].getText());\n    }\n\n    /**\n     * Checks the inline summary (if present) for {@code period} at end and forbidden fragments.\n     *\n     * @param inlineSummaryTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     */\n    private void validateSummaryTag(DetailNode inlineSummaryTag) {\n        final String inlineSummary = getContentOfInlineCustomTag(inlineSummaryTag);\n        final String summaryVisible = getVisibleContent(inlineSummary);\n        if (summaryVisible.isEmpty()) {\n            log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (!period.isEmpty()) {\n            if (isPeriodNotAtEnd(summaryVisible, period)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_MISSING_PERIOD);\n            }\n            else if (containsForbiddenFragment(inlineSummary)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC);\n            }\n        }\n    }\n\n    /**\n     * Gets the content of inline custom tag.\n     *\n     * @param inlineTag inline tag node.\n     * @return String consisting of the content of inline custom tag.\n     */\n    public static String getContentOfInlineCustomTag(DetailNode inlineTag) {\n        final DetailNode[] childrenOfInlineTag = inlineTag.getChildren();\n        final StringBuilder customTagContent = new StringBuilder(256);\n        final int indexOfContentOfSummaryTag = 3;\n        if (childrenOfInlineTag.length != indexOfContentOfSummaryTag) {\n            DetailNode currentNode = childrenOfInlineTag[indexOfContentOfSummaryTag];\n            while (currentNode.getType() != JavadocTokenTypes.JAVADOC_INLINE_TAG_END) {\n                extractInlineTagContent(currentNode, customTagContent);\n                currentNode = JavadocUtil.getNextSibling(currentNode);\n            }\n        }\n        return customTagContent.toString();\n    }\n\n    /**\n     * Extracts the content of inline custom tag recursively.\n     *\n     * @param node DetailNode\n     * @param customTagContent content of custom tag\n     */\n    private static void extractInlineTagContent(DetailNode node,\n        StringBuilder customTagContent) {\n        final DetailNode[] children = node.getChildren();\n        if (children.length == 0) {\n            customTagContent.append(node.getText());\n        }\n        else {\n            for (DetailNode child : children) {\n                if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                    extractInlineTagContent(child, customTagContent);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the string that is visible to user in javadoc.\n     *\n     * @param summary entire content of summary javadoc.\n     * @return string that is visible to user in javadoc.\n     */\n    private static String getVisibleContent(String summary) {\n        final String visibleSummary = HTML_ELEMENTS.matcher(summary).replaceAll(\"\");\n        return visibleSummary.trim();\n    }\n\n    /**\n     * Checks if the string does not end with period.\n     *\n     * @param sentence string to check for period at end.\n     * @param period string to check within sentence.\n     * @return {@code true} if sentence does not end with period.\n     */\n    private static boolean isPeriodNotAtEnd(String sentence, String period) {\n        final String summarySentence = sentence.trim();\n        return summarySentence.lastIndexOf(period) != summarySentence.length() - 1;\n    }\n\n    /**\n     * Tests if first sentence contains forbidden summary fragment.\n     *\n     * @param firstSentence string with first sentence.\n     * @return {@code true} if first sentence contains forbidden summary fragment.\n     */\n    private boolean containsForbiddenFragment(String firstSentence) {\n        final String javadocText = JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN\n                .matcher(firstSentence).replaceAll(\" \").trim();\n        return forbiddenSummaryFragments.matcher(trimExcessWhitespaces(javadocText)).find();\n    }\n\n    /**\n     * Trims the given {@code text} of duplicate whitespaces.\n     *\n     * @param text the text to transform.\n     * @return the finalized form of the text.\n     */\n    private static String trimExcessWhitespaces(String text) {\n        final StringBuilder result = new StringBuilder(256);\n        boolean previousWhitespace = true;\n\n        for (char letter : text.toCharArray()) {\n            final char print;\n            if (Character.isWhitespace(letter)) {\n                if (previousWhitespace) {\n                    continue;\n                }\n\n                previousWhitespace = true;\n                print = ' ';\n            }\n            else {\n                previousWhitespace = false;\n                print = letter;\n            }\n\n            result.append(print);\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Checks if the node starts with an {&#64;inheritDoc}.\n     *\n     * @param root the root node to examine.\n     * @return {@code true} if the javadoc starts with an {&#64;inheritDoc}.\n     */\n    private static boolean startsWithInheritDoc(DetailNode root) {\n        boolean found = false;\n        final DetailNode[] children = root.getChildren();\n\n        for (int i = 0; !found; i++) {\n            final DetailNode child = children[i];\n            if (child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                    && child.getChildren()[1].getType() == JavadocTokenTypes.INHERIT_DOC_LITERAL) {\n                found = true;\n            }\n            else if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK\n                    && !CommonUtil.isBlank(child.getText())) {\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    /**\n     * Finds and returns summary sentence.\n     *\n     * @param ast javadoc root node.\n     * @return violation string.\n     */\n    private static String getSummarySentence(DetailNode ast) {\n        boolean flag = true;\n        final StringBuilder result = new StringBuilder(256);\n        for (DetailNode child : ast.getChildren()) {\n            if (ALLOWED_TYPES.contains(child.getType())) {\n                result.append(child.getText());\n            }\n            else if (child.getType() == JavadocTokenTypes.HTML_ELEMENT\n                    && CommonUtil.isBlank(result.toString().trim())) {\n                result.append(getStringInsideTag(result.toString(),\n                        child.getChildren()[0].getChildren()[0]));\n            }\n            else if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n                flag = false;\n            }\n            if (!flag) {\n                break;\n            }\n        }\n        return result.toString().trim();\n    }\n\n    /**\n     * Get concatenated string within text of html tags.\n     *\n     * @param result javadoc string\n     * @param detailNode javadoc tag node\n     * @return java doc tag content appended in result\n     */\n    private static String getStringInsideTag(String result, DetailNode detailNode) {\n        final StringBuilder contents = new StringBuilder(result);\n        DetailNode tempNode = detailNode;\n        while (tempNode != null) {\n            if (tempNode.getType() == JavadocTokenTypes.TEXT) {\n                contents.append(tempNode.getText());\n            }\n            tempNode = JavadocUtil.getNextSibling(tempNode);\n        }\n        return contents.toString();\n    }\n\n    /**\n     * Finds and returns first sentence.\n     *\n     * @param ast Javadoc root node.\n     * @return first sentence.\n     */\n    private static String getFirstSentence(DetailNode ast) {\n        final StringBuilder result = new StringBuilder(256);\n        final String periodSuffix = PERIOD + ' ';\n        for (DetailNode child : ast.getChildren()) {\n            final String text;\n            if (child.getChildren().length == 0) {\n                text = child.getText();\n            }\n            else {\n                text = getFirstSentence(child);\n            }\n\n            if (text.contains(periodSuffix)) {\n                result.append(text, 0, text.indexOf(periodSuffix) + 1);\n                break;\n            }\n\n            result.append(text);\n        }\n        return result.toString();\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.javadoc;\n\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailNode;\nimport com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n\n/**\n * <p>\n * Checks that\n * <a href=\"https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#firstsentence\">\n * Javadoc summary sentence</a> does not contain phrases that are not recommended to use.\n * Summaries that contain only the {@code {@inheritDoc}} tag are skipped.\n * Summaries that contain a non-empty {@code {@return}} are allowed.\n * Check also violate Javadoc that does not contain first sentence, though with {@code {@return}} a\n * period is not required as the Javadoc tool adds it.\n * </p>\n * <ul>\n * <li>\n * Property {@code violateExecutionOnNonTightHtml} - Control when to print violations\n * if the Javadoc being examined by this check violates the tight html rules defined at\n * <a href=\"https://checkstyle.org/writingjavadocchecks.html#Tight-HTML_rules\">Tight-HTML Rules</a>.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code forbiddenSummaryFragments} - Specify the regexp for forbidden summary fragments.\n * Type is {@code java.util.regex.Pattern}.\n * Default value is {@code \"^$\"}.\n * </li>\n * <li>\n * Property {@code period} - Specify the period symbol at the end of first javadoc sentence.\n * Type is {@code java.lang.String}.\n * Default value is {@code \".\"}.\n * </li>\n * </ul>\n * <p>\n * To configure the default check to validate that first sentence is not empty and first\n * sentence is not missing:\n * </p>\n * <pre>\n * &lt;module name=&quot;SummaryJavadocCheck&quot;/&gt;\n * </pre>\n * <p>\n * Example of {@code {@inheritDoc}} without summary.\n * </p>\n * <pre>\n * public class Test extends Exception {\n * //Valid\n *   &#47;**\n *    * {&#64;inheritDoc}\n *    *&#47;\n *   public String ValidFunction(){\n *     return \"\";\n *   }\n *   //Violation\n *   &#47;**\n *    *\n *    *&#47;\n *   public String InvalidFunction(){\n *     return \"\";\n *   }\n * }\n * </pre>\n * <p>\n * Example of non permitted empty javadoc for Inline Summary Javadoc.\n * </p>\n * <pre>\n * public class Test extends Exception {\n *   &#47;**\n *    * {&#64;summary  }\n *    *&#47;\n *   public String InvalidFunctionOne(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt; &lt;p/&gt;}\n *    *&#47;\n *   public String InvalidFunctionTwo(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt;This is summary for validFunctionThree.&lt;p/&gt;}\n *    *&#47;\n *   public void validFunctionThree(){} // ok\n * }\n * </pre>\n * <p>\n * To ensure that summary do not contain phrase like \"This method returns\",\n * use following config:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"forbiddenSummaryFragments\"\n *     value=\"^This method returns.*\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * To specify period symbol at the end of first javadoc sentence:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"period\" value=\"\u3002\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Example of period property.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * This is invalid java doc.\n *   *&#47;\n *   void invalidJavaDocMethod() {\n *   }\n *  &#47;**\n *   * This is valid java doc\u3002\n *   *&#47;\n *   void validJavaDocMethod() {\n *   }\n * }\n * </pre>\n * <p>\n * Example of period property for inline summary javadoc.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * {&#64;summary This is invalid java doc.}\n *   *&#47;\n *   public void invalidJavaDocMethod() { // violation\n *   }\n *  &#47;**\n *   * {&#64;summary This is valid java doc\u3002}\n *   *&#47;\n *   public void validJavaDocMethod() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Example of inline summary javadoc with HTML tags.\n * </p>\n * <pre>\n * public class Test {\n *  &#47;**\n *   * {&#64;summary First sentence is normally the summary.\n *   * Use of html tags:\n *   * &lt;ul&gt;\n *   * &lt;li&gt;Item one.&lt;/li&gt;\n *   * &lt;li&gt;Item two.&lt;/li&gt;\n *   * &lt;/ul&gt;}\n *   *&#47;\n *   public void validInlineJavadoc() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code javadoc.missed.html.close}\n * </li>\n * <li>\n * {@code javadoc.parse.rule.error}\n * </li>\n * <li>\n * {@code javadoc.wrong.singleton.html.tag}\n * </li>\n * <li>\n * {@code summary.first.sentence}\n * </li>\n * <li>\n * {@code summary.javaDoc}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing.period}\n * </li>\n * </ul>\n *\n * @since 6.0\n */\n@StatelessCheck\npublic class SummaryJavadocCheck extends AbstractJavadocCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_FIRST_SENTENCE = \"summary.first.sentence\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC = \"summary.javaDoc\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC_MISSING = \"summary.javaDoc.missing\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\" file.\n     */\n    public static final String MSG_SUMMARY_MISSING_PERIOD = \"summary.javaDoc.missing.period\";\n\n    /**\n     * This regexp is used to convert multiline javadoc to single line without stars.\n     */\n    private static final Pattern JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN =\n            Pattern.compile(\"\\n[ ]+(\\\\*)|^[ ]+(\\\\*)\");\n\n    /**\n     * This regexp is used to remove html tags, whitespace, and asterisks from a string.\n     */\n    private static final Pattern HTML_ELEMENTS =\n            Pattern.compile(\"<[^>]*>\");\n\n    /** Period literal. */\n    private static final String PERIOD = \".\";\n\n    /** Summary tag text. */\n    private static final String SUMMARY_TEXT = \"@summary\";\n\n    /** Return tag text. */\n    private static final String RETURN_TEXT = \"@return\";\n\n    /** Set of allowed Tokens tags in summary java doc. */\n    private static final Set<Integer> ALLOWED_TYPES = Set.of(\n                    JavadocTokenTypes.WS,\n                    JavadocTokenTypes.DESCRIPTION,\n                    JavadocTokenTypes.TEXT);\n\n    /**\n     * Specify the regexp for forbidden summary fragments.\n     */\n    private Pattern forbiddenSummaryFragments = CommonUtil.createPattern(\"^$\");\n\n    /**\n     * Specify the period symbol at the end of first javadoc sentence.\n     */\n    private String period = PERIOD;\n\n    /**\n     * Setter to specify the regexp for forbidden summary fragments.\n     *\n     * @param pattern a pattern.\n     */\n    public void setForbiddenSummaryFragments(Pattern pattern) {\n        forbiddenSummaryFragments = pattern;\n    }\n\n    /**\n     * Setter to specify the period symbol at the end of first javadoc sentence.\n     *\n     * @param period period's value.\n     */\n    public void setPeriod(String period) {\n        this.period = period;\n    }\n\n    @Override\n    public int[] getDefaultJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.JAVADOC,\n        };\n    }\n\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return getAcceptableJavadocTokens();\n    }\n\n    @Override\n    public void visitJavadocToken(DetailNode ast) {\n        final Optional<DetailNode> inlineTag = getInlineTagNode(ast);\n        if (inlineTag.isPresent() && isSummaryTag(inlineTag.get())) {\n            validateSummaryTag(inlineTag.get());\n        }\n        else if (inlineTag.isPresent() && isInlineReturnTag(inlineTag.get())) {\n            validateInlineReturnTag(inlineTag.get());\n        }\n        else if (!startsWithInheritDoc(ast)) {\n            validateUntaggedSummary(ast);\n        }\n    }\n\n    /**\n     * Checks the javadoc text for {@code period} at end and forbidden fragments.\n     *\n     * @param ast the javadoc text node\n     */\n    private void validateUntaggedSummary(DetailNode ast) {\n        final String summaryDoc = getSummarySentence(ast);\n        if (summaryDoc.isEmpty()) {\n            log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (!period.isEmpty()) {\n            final String firstSentence = getFirstSentence(ast);\n            final int endOfSentence = firstSentence.lastIndexOf(period);\n            if (!summaryDoc.contains(period)) {\n                log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n            }\n            if (endOfSentence != -1\n                    && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n            }\n        }\n    }\n\n    /**\n     * Gets the node for the inline tag if present.\n     *\n     * @param javadoc javadoc root node.\n     * @return the node for the inline tag if present.\n     */\n    private static Optional<DetailNode> getInlineTagNode(DetailNode javadoc) {\n        return Arrays.stream(javadoc.getChildren())\n            .filter(SummaryJavadocCheck::isInlineTagPresent)\n            .findFirst()\n            .map(SummaryJavadocCheck::getInlineTagNodeWithinHtmlElement);\n    }\n\n    /**\n     * Checks if the inline tag node is present.\n     *\n     * @param ast ast node to check.\n     * @return true, if the inline tag node is present.\n     */\n    private static boolean isInlineTagPresent(DetailNode ast) {\n        return ast.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                || ast.getType() == JavadocTokenTypes.HTML_ELEMENT\n                && getInlineTagNodeWithinHtmlElement(ast) != null;\n    }\n\n    /**\n     * Returns an inline javadoc tag node that is within a html tag.\n     *\n     * @param ast html tag node.\n     * @return inline summary javadoc tag node or null if no node is found.\n     */\n    private static DetailNode getInlineTagNodeWithinHtmlElement(DetailNode ast) {\n        DetailNode node = ast;\n        DetailNode result = null;\n        // node can never be null as this method is called when there is a HTML_ELEMENT\n        if (node.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG) {\n            result = node;\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_TAG) {\n            // HTML_TAG always has more than 2 children.\n            node = node.getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_ELEMENT\n                // Condition for SINGLETON html element which cannot contain summary node\n                && node.getChildren()[0].getChildren().length > 1) {\n            // Html elements have one tested tag before actual content inside it\n            node = node.getChildren()[0].getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if the javadoc inline tag is {@code {@summary}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if inline tag is summary tag.\n     */\n    private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n        return isInlineTagWithName(javadocInlineTag, SUMMARY_TEXT);\n    }\n\n    /**\n     * Checks if the first tag inside ast is {@code {@return}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if first tag is return tag.\n     */\n    private static boolean isInlineReturnTag(DetailNode javadocInlineTag) {\n        return isInlineTagWithName(javadocInlineTag, RETURN_TEXT);\n    }\n\n    /**\n     * Checks if the first tag inside ast is a tag with the given name.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @param name name of inline tag.\n     *\n     * @return {@code true} if first tag is a tag with the given name.\n     */\n    private static boolean isInlineTagWithName(DetailNode javadocInlineTag, String name) {\n        final DetailNode[] child = javadocInlineTag.getChildren();\n\n        // Checking size of ast is not required, since ast contains\n        // children of Inline Tag, as at least 2 children will be present which are\n        // RCURLY and LCURLY.\n        return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n            && name.equals(child[1].getText());\n    }\n\n    /**\n     * Checks the inline summary (if present) for {@code period} at end and forbidden fragments.\n     *\n     * @param inlineSummaryTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     */\n    private void validateSummaryTag(DetailNode inlineSummaryTag) {\n        final String inlineSummary = getContentOfInlineCustomTag(inlineSummaryTag);\n        final String summaryVisible = getVisibleContent(inlineSummary);\n        if (summaryVisible.isEmpty()) {\n            log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (!period.isEmpty()) {\n            if (isPeriodNotAtEnd(summaryVisible, period)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_MISSING_PERIOD);\n            }\n            else if (containsForbiddenFragment(inlineSummary)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC);\n            }\n        }\n    }\n\n    /**\n     * Checks the inline return for forbidden fragments.\n     *\n     * @param inlineReturnTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     */\n    private void validateInlineReturnTag(DetailNode inlineReturnTag) {\n        final String inlineReturn = getContentOfInlineCustomTag(inlineReturnTag);\n        final String returnVisible = getVisibleContent(inlineReturn);\n        if (returnVisible.isEmpty()) {\n            log(inlineReturnTag.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (containsForbiddenFragment(inlineReturn)) {\n            log(inlineReturnTag.getLineNumber(), MSG_SUMMARY_JAVADOC);\n        }\n    }\n\n    /**\n     * Gets the content of inline custom tag.\n     *\n     * @param inlineTag inline tag node.\n     * @return String consisting of the content of inline custom tag.\n     */\n    public static String getContentOfInlineCustomTag(DetailNode inlineTag) {\n        final DetailNode[] childrenOfInlineTag = inlineTag.getChildren();\n        final StringBuilder customTagContent = new StringBuilder(256);\n        final int indexOfContentOfSummaryTag = 3;\n        if (childrenOfInlineTag.length != indexOfContentOfSummaryTag) {\n            DetailNode currentNode = childrenOfInlineTag[indexOfContentOfSummaryTag];\n            while (currentNode.getType() != JavadocTokenTypes.JAVADOC_INLINE_TAG_END) {\n                extractInlineTagContent(currentNode, customTagContent);\n                currentNode = JavadocUtil.getNextSibling(currentNode);\n            }\n        }\n        return customTagContent.toString();\n    }\n\n    /**\n     * Extracts the content of inline custom tag recursively.\n     *\n     * @param node DetailNode\n     * @param customTagContent content of custom tag\n     */\n    private static void extractInlineTagContent(DetailNode node,\n        StringBuilder customTagContent) {\n        final DetailNode[] children = node.getChildren();\n        if (children.length == 0) {\n            customTagContent.append(node.getText());\n        }\n        else {\n            for (DetailNode child : children) {\n                if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                    extractInlineTagContent(child, customTagContent);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the string that is visible to user in javadoc.\n     *\n     * @param summary entire content of summary javadoc.\n     * @return string that is visible to user in javadoc.\n     */\n    private static String getVisibleContent(String summary) {\n        final String visibleSummary = HTML_ELEMENTS.matcher(summary).replaceAll(\"\");\n        return visibleSummary.trim();\n    }\n\n    /**\n     * Checks if the string does not end with period.\n     *\n     * @param sentence string to check for period at end.\n     * @param period string to check within sentence.\n     * @return {@code true} if sentence does not end with period.\n     */\n    private static boolean isPeriodNotAtEnd(String sentence, String period) {\n        final String summarySentence = sentence.trim();\n        return summarySentence.lastIndexOf(period) != summarySentence.length() - 1;\n    }\n\n    /**\n     * Tests if first sentence contains forbidden summary fragment.\n     *\n     * @param firstSentence string with first sentence.\n     * @return {@code true} if first sentence contains forbidden summary fragment.\n     */\n    private boolean containsForbiddenFragment(String firstSentence) {\n        final String javadocText = JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN\n                .matcher(firstSentence).replaceAll(\" \").trim();\n        return forbiddenSummaryFragments.matcher(trimExcessWhitespaces(javadocText)).find();\n    }\n\n    /**\n     * Trims the given {@code text} of duplicate whitespaces.\n     *\n     * @param text the text to transform.\n     * @return the finalized form of the text.\n     */\n    private static String trimExcessWhitespaces(String text) {\n        final StringBuilder result = new StringBuilder(256);\n        boolean previousWhitespace = true;\n\n        for (char letter : text.toCharArray()) {\n            final char print;\n            if (Character.isWhitespace(letter)) {\n                if (previousWhitespace) {\n                    continue;\n                }\n\n                previousWhitespace = true;\n                print = ' ';\n            }\n            else {\n                previousWhitespace = false;\n                print = letter;\n            }\n\n            result.append(print);\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Checks if the node starts with an {&#64;inheritDoc}.\n     *\n     * @param root the root node to examine.\n     * @return {@code true} if the javadoc starts with an {&#64;inheritDoc}.\n     */\n    private static boolean startsWithInheritDoc(DetailNode root) {\n        boolean found = false;\n        final DetailNode[] children = root.getChildren();\n\n        for (int i = 0; !found; i++) {\n            final DetailNode child = children[i];\n            if (child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                    && child.getChildren()[1].getType() == JavadocTokenTypes.INHERIT_DOC_LITERAL) {\n                found = true;\n            }\n            else if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK\n                    && !CommonUtil.isBlank(child.getText())) {\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    /**\n     * Finds and returns summary sentence.\n     *\n     * @param ast javadoc root node.\n     * @return violation string.\n     */\n    private static String getSummarySentence(DetailNode ast) {\n        boolean flag = true;\n        final StringBuilder result = new StringBuilder(256);\n        for (DetailNode child : ast.getChildren()) {\n            if (ALLOWED_TYPES.contains(child.getType())) {\n                result.append(child.getText());\n            }\n            else if (child.getType() == JavadocTokenTypes.HTML_ELEMENT\n                    && CommonUtil.isBlank(result.toString().trim())) {\n                result.append(getStringInsideTag(result.toString(),\n                        child.getChildren()[0].getChildren()[0]));\n            }\n            else if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n                flag = false;\n            }\n            if (!flag) {\n                break;\n            }\n        }\n        return result.toString().trim();\n    }\n\n    /**\n     * Get concatenated string within text of html tags.\n     *\n     * @param result javadoc string\n     * @param detailNode javadoc tag node\n     * @return java doc tag content appended in result\n     */\n    private static String getStringInsideTag(String result, DetailNode detailNode) {\n        final StringBuilder contents = new StringBuilder(result);\n        DetailNode tempNode = detailNode;\n        while (tempNode != null) {\n            if (tempNode.getType() == JavadocTokenTypes.TEXT) {\n                contents.append(tempNode.getText());\n            }\n            tempNode = JavadocUtil.getNextSibling(tempNode);\n        }\n        return contents.toString();\n    }\n\n    /**\n     * Finds and returns first sentence.\n     *\n     * @param ast Javadoc root node.\n     * @return first sentence.\n     */\n    private static String getFirstSentence(DetailNode ast) {\n        final StringBuilder result = new StringBuilder(256);\n        final String periodSuffix = PERIOD + ' ';\n        for (DetailNode child : ast.getChildren()) {\n            final String text;\n            if (child.getChildren().length == 0) {\n                text = child.getText();\n            }\n            else {\n                text = getFirstSentence(child);\n            }\n\n            if (text.contains(periodSuffix)) {\n                result.append(text, 0, text.indexOf(periodSuffix) + 1);\n                break;\n            }\n\n            result.append(text);\n        }\n        return result.toString();\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Checks the javadoc text for {@code period} at end and forbidden fragments.\n     *\n     * @param ast the javadoc text node\n     */\n    private void validateUntaggedSummary(DetailNode ast) {\n        final String summaryDoc = getSummarySentence(ast);\n        if (summaryDoc.isEmpty()) {\n            log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (!period.isEmpty()) {\n            final String firstSentence = getFirstSentence(ast);\n            final int endOfSentence = firstSentence.lastIndexOf(period);\n            if (!summaryDoc.contains(period)) {\n                log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n            }\n            if (endOfSentence != -1\n                    && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n            }\n        }\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#getFirstSentence\n methodBody: private static String getFirstSentence(DetailNode ast) {\nfinal StringBuilder result=new StringBuilder(256);\nfinal String periodSuffix=PERIOD + ' ';\nfor(DetailNode child: ast.getChildren()){final String text;\nif(child.getChildren().length == 0){text=child.getText();\n}{text=getFirstSentence(child);\n}if(text.contains(periodSuffix)){result.append(text,0,text.indexOf(periodSuffix) + 1);\nbreak;\n}result.append(text);\n}return result.toString();\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#validateSummaryTag\n methodBody: private void validateSummaryTag(DetailNode inlineSummaryTag) {\nfinal String inlineSummary=getContentOfInlineCustomTag(inlineSummaryTag);\nfinal String summaryVisible=getVisibleContent(inlineSummary);\nif(summaryVisible.isEmpty()){log(inlineSummaryTag.getLineNumber(),MSG_SUMMARY_JAVADOC_MISSING);\n}if(!period.isEmpty()){if(isPeriodNotAtEnd(summaryVisible,period)){log(inlineSummaryTag.getLineNumber(),MSG_SUMMARY_MISSING_PERIOD);\n}if(containsForbiddenFragment(inlineSummary)){log(inlineSummaryTag.getLineNumber(),MSG_SUMMARY_JAVADOC);\n}}}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#startsWithInheritDoc\n methodBody: private static boolean startsWithInheritDoc(DetailNode root) {\nboolean found=false;\nfinal DetailNode[] children=root.getChildren();\nfor(int i=0; !found; i++){final DetailNode child=children[i];\nif(child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG && child.getChildren()[1].getType() == JavadocTokenTypes.INHERIT_DOC_LITERAL){found=true;\n}if(child.getType() != JavadocTokenTypes.LEADING_ASTERISK && !CommonUtil.isBlank(child.getText())){break;\n}}return found;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#containsForbiddenFragment\n methodBody: private boolean containsForbiddenFragment(String firstSentence) {\nfinal String javadocText=JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN.matcher(firstSentence).replaceAll(\" \").trim();\nreturn forbiddenSummaryFragments.matcher(trimExcessWhitespaces(javadocText)).find();\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#getSummarySentence\n methodBody: private static String getSummarySentence(DetailNode ast) {\nboolean flag=true;\nfinal StringBuilder result=new StringBuilder(256);\nfor(DetailNode child: ast.getChildren()){if(ALLOWED_TYPES.contains(child.getType())){result.append(child.getText());\n}if(child.getType() == JavadocTokenTypes.HTML_ELEMENT && CommonUtil.isBlank(result.toString().trim())){result.append(getStringInsideTag(result.toString(),child.getChildren()[0].getChildren()[0]));\n}if(child.getType() == JavadocTokenTypes.JAVADOC_TAG){flag=false;\n}if(!flag){break;\n}}return result.toString().trim();\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.javadoc.SummaryJavadocCheck#getInlineSummaryTag\n methodBody: private static Optional<DetailNode> getInlineSummaryTag(DetailNode javadoc) {\nOptional<DetailNode> node=Arrays.stream(javadoc.getChildren()).filter(SummaryJavadocCheck::isInlineTagPresent).findFirst().map(SummaryJavadocCheck::getInlineTagNodeWithinHtmlElement);\nif(node.isPresent() && !isSummaryTag(node.get())){node=Optional.empty();\n}return node;\n}"], "sourceCodeAfterRefactoring": "@Override\n    public void visitJavadocToken(DetailNode ast) {\n        final Optional<DetailNode> inlineTag = getInlineTagNode(ast);\n        if (inlineTag.isPresent() && isSummaryTag(inlineTag.get())) {\n            validateSummaryTag(inlineTag.get());\n        }\n        else if (inlineTag.isPresent() && isInlineReturnTag(inlineTag.get())) {\n            validateInlineReturnTag(inlineTag.get());\n        }\n        else if (!startsWithInheritDoc(ast)) {\n            validateUntaggedSummary(ast);\n        }\n    }\n/**\n     * Checks the javadoc text for {@code period} at end and forbidden fragments.\n     *\n     * @param ast the javadoc text node\n     */\n    private void validateUntaggedSummary(DetailNode ast) {\n        final String summaryDoc = getSummarySentence(ast);\n        if (summaryDoc.isEmpty()) {\n            log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (!period.isEmpty()) {\n            final String firstSentence = getFirstSentence(ast);\n            final int endOfSentence = firstSentence.lastIndexOf(period);\n            if (!summaryDoc.contains(period)) {\n                log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n            }\n            if (endOfSentence != -1\n                    && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n            }\n        }\n    }", "diffSourceCode": "   304:     @Override\n-  305:     public void visitJavadocToken(DetailNode ast) {\n-  306:         final Optional<DetailNode> inlineSummaryTag = getInlineSummaryTag(ast);\n-  307:         if (inlineSummaryTag.isPresent()) {\n-  308:             validateSummaryTag(inlineSummaryTag.get());\n-  309:         }\n-  310:         else if (!startsWithInheritDoc(ast)) {\n-  311:             final String summaryDoc = getSummarySentence(ast);\n-  312:             if (summaryDoc.isEmpty()) {\n-  313:                 log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n-  314:             }\n-  315:             else if (!period.isEmpty()) {\n-  316:                 final String firstSentence = getFirstSentence(ast);\n-  317:                 final int endOfSentence = firstSentence.lastIndexOf(period);\n-  318:                 if (!summaryDoc.contains(period)) {\n-  319:                     log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n-  320:                 }\n-  321:                 if (endOfSentence != -1\n-  322:                         && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n-  323:                     log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n-  324:                 }\n-  325:             }\n-  326:         }\n-  327:     }\n-  328: \n-  329:     /**\n-  330:      * Gets the inline summary tag.\n-  331:      *\n-  332:      * @param javadoc javadoc root node.\n-  333:      * @return an optional of inline summary tag node, empty optional if inline tag is not\n-  334:      *         a summary tag.\n-  335:      */\n-  336:     private static Optional<DetailNode> getInlineSummaryTag(DetailNode javadoc) {\n-  337:         Optional<DetailNode> node = Arrays.stream(javadoc.getChildren())\n-  338:                 .filter(SummaryJavadocCheck::isInlineTagPresent)\n-  339:                 .findFirst()\n-  340:                 .map(SummaryJavadocCheck::getInlineTagNodeWithinHtmlElement);\n-  341: \n-  342:         if (node.isPresent() && !isSummaryTag(node.get())) {\n-  343:             node = Optional.empty();\n-  344:         }\n+  305:     public int[] getRequiredJavadocTokens() {\n+  306:         return getAcceptableJavadocTokens();\n+  307:     }\n+  308: \n+  309:     @Override\n+  310:     public void visitJavadocToken(DetailNode ast) {\n+  311:         final Optional<DetailNode> inlineTag = getInlineTagNode(ast);\n+  312:         if (inlineTag.isPresent() && isSummaryTag(inlineTag.get())) {\n+  313:             validateSummaryTag(inlineTag.get());\n+  314:         }\n+  315:         else if (inlineTag.isPresent() && isInlineReturnTag(inlineTag.get())) {\n+  316:             validateInlineReturnTag(inlineTag.get());\n+  317:         }\n+  318:         else if (!startsWithInheritDoc(ast)) {\n+  319:             validateUntaggedSummary(ast);\n+  320:         }\n+  321:     }\n+  322: \n+  323:     /**\n+  324:      * Checks the javadoc text for {@code period} at end and forbidden fragments.\n+  325:      *\n+  326:      * @param ast the javadoc text node\n+  327:      */\n+  328:     private void validateUntaggedSummary(DetailNode ast) {\n+  329:         final String summaryDoc = getSummarySentence(ast);\n+  330:         if (summaryDoc.isEmpty()) {\n+  331:             log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n+  332:         }\n+  333:         else if (!period.isEmpty()) {\n+  334:             final String firstSentence = getFirstSentence(ast);\n+  335:             final int endOfSentence = firstSentence.lastIndexOf(period);\n+  336:             if (!summaryDoc.contains(period)) {\n+  337:                 log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n+  338:             }\n+  339:             if (endOfSentence != -1\n+  340:                     && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n+  341:                 log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n+  342:             }\n+  343:         }\n+  344:     }\n", "uniqueId": "cc90b04b02f963571ae4697857db838ac27efb84_304_327_323_344_309_321", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 71}, "BRANCH": {"missed": 0, "covered": 14}, "LINE": {"missed": 0, "covered": 16}, "COMPLEXITY": {"missed": 0, "covered": 8}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nprivate Optional<DetailNode> getInlineSummaryTag(DetailNode ast) {\n    Optional<DetailNode> node = Arrays.stream(ast.getChildren())\n            .filter(this::isInlineTagPresent)\n            .findFirst()\n            .map(this::getInlineTagNodeWithinHtmlElement);\n\n    if (node.isPresent() && !isSummaryTag(node.get())) {\n        node = Optional.empty();\n    }\n    return node;\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public void visitJavadocToken(DetailNode ast) {\n        final Optional<DetailNode> inlineSummaryTag = getInlineSummaryTag(ast);\n        if (inlineSummaryTag.isPresent()) {\n            validateSummaryTag(inlineSummaryTag.get());\n        }\n        else if (!startsWithInheritDoc(ast)) {\n            final String summaryDoc = getSummarySentence(ast);\n            if (summaryDoc.isEmpty()) {\n                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n            }\n            else if (!period.isEmpty()) {\n                final String firstSentence = getFirstSentence(ast);\n                final int endOfSentence = firstSentence.lastIndexOf(period);\n                if (!summaryDoc.contains(period)) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n                }\n                if (endOfSentence != -1\n                        && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n                }\n            }\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.javadoc;\n\nimport java.util.Arrays;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailNode;\nimport com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n\n/**\n * <p>\n * Checks that\n * <a href=\"https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#firstsentence\">\n * Javadoc summary sentence</a> does not contain phrases that are not recommended to use.\n * Summaries that contain only the {@code {@inheritDoc}} tag are skipped.\n * Check also violate Javadoc that does not contain first sentence.\n * </p>\n * <ul>\n * <li>\n * Property {@code violateExecutionOnNonTightHtml} - Control when to print violations\n * if the Javadoc being examined by this check violates the tight html rules defined at\n * <a href=\"https://checkstyle.org/writingjavadocchecks.html#Tight-HTML_rules\">Tight-HTML Rules</a>.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code forbiddenSummaryFragments} - Specify the regexp for forbidden summary fragments.\n * Type is {@code java.util.regex.Pattern}.\n * Default value is {@code \"^$\"}.\n * </li>\n * <li>\n * Property {@code period} - Specify the period symbol at the end of first javadoc sentence.\n * Type is {@code java.lang.String}.\n * Default value is {@code \".\"}.\n * </li>\n * </ul>\n * <p>\n * To configure the default check to validate that first sentence is not empty and first\n * sentence is not missing:\n * </p>\n * <pre>\n * &lt;module name=&quot;SummaryJavadocCheck&quot;/&gt;\n * </pre>\n * <p>\n * Example of {@code {@inheritDoc}} without summary.\n * </p>\n * <pre>\n * public class Test extends Exception {\n * //Valid\n *   &#47;**\n *    * {&#64;inheritDoc}\n *    *&#47;\n *   public String ValidFunction(){\n *     return \"\";\n *   }\n *   //Violation\n *   &#47;**\n *    *\n *    *&#47;\n *   public String InvalidFunction(){\n *     return \"\";\n *   }\n * }\n * </pre>\n * <p>\n * Example of non permitted empty javadoc for Inline Summary Javadoc.\n * </p>\n * <pre>\n * public class Test extends Exception {\n *   &#47;**\n *    * {&#64;summary  }\n *    *&#47;\n *   public String InvalidFunctionOne(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt; &lt;p/&gt;}\n *    *&#47;\n *   public String InvalidFunctionTwo(){ // violation\n *     return \"\";\n *   }\n *\n *   &#47;**\n *    * {&#64;summary &lt;p&gt;This is summary for validFunctionThree.&lt;p/&gt;}\n *    *&#47;\n *   public void validFunctionThree(){} // ok\n * }\n * </pre>\n * <p>\n * To ensure that summary do not contain phrase like \"This method returns\",\n * use following config:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"forbiddenSummaryFragments\"\n *     value=\"^This method returns.*\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * To specify period symbol at the end of first javadoc sentence:\n * </p>\n * <pre>\n * &lt;module name=\"SummaryJavadocCheck\"&gt;\n *   &lt;property name=\"period\" value=\"\u3002\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Example of period property.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * This is invalid java doc.\n *   *&#47;\n *   void invalidJavaDocMethod() {\n *   }\n *  &#47;**\n *   * This is valid java doc\u3002\n *   *&#47;\n *   void validJavaDocMethod() {\n *   }\n * }\n * </pre>\n * <p>\n * Example of period property for inline summary javadoc.\n * </p>\n * <pre>\n * public class TestClass {\n *  &#47;**\n *   * {&#64;summary This is invalid java doc.}\n *   *&#47;\n *   public void invalidJavaDocMethod() { // violation\n *   }\n *  &#47;**\n *   * {&#64;summary This is valid java doc\u3002}\n *   *&#47;\n *   public void validJavaDocMethod() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Example of inline summary javadoc with HTML tags.\n * </p>\n * <pre>\n * public class Test {\n *  &#47;**\n *   * {&#64;summary First sentence is normally the summary.\n *   * Use of html tags:\n *   * &lt;ul&gt;\n *   * &lt;li&gt;Item one.&lt;/li&gt;\n *   * &lt;li&gt;Item two.&lt;/li&gt;\n *   * &lt;/ul&gt;}\n *   *&#47;\n *   public void validInlineJavadoc() { // ok\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code javadoc.missed.html.close}\n * </li>\n * <li>\n * {@code javadoc.parse.rule.error}\n * </li>\n * <li>\n * {@code javadoc.wrong.singleton.html.tag}\n * </li>\n * <li>\n * {@code summary.first.sentence}\n * </li>\n * <li>\n * {@code summary.javaDoc}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing}\n * </li>\n * <li>\n * {@code summary.javaDoc.missing.period}\n * </li>\n * </ul>\n *\n * @since 6.0\n */\n@StatelessCheck\npublic class SummaryJavadocCheck extends AbstractJavadocCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_FIRST_SENTENCE = \"summary.first.sentence\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC = \"summary.javaDoc\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_SUMMARY_JAVADOC_MISSING = \"summary.javaDoc.missing\";\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\" file.\n     */\n    public static final String MSG_SUMMARY_MISSING_PERIOD = \"summary.javaDoc.missing.period\";\n\n    /**\n     * This regexp is used to convert multiline javadoc to single line without stars.\n     */\n    private static final Pattern JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN =\n            Pattern.compile(\"\\n[ ]+(\\\\*)|^[ ]+(\\\\*)\");\n\n    /**\n     * This regexp is used to remove html tags, whitespace, and asterisks from a string.\n     */\n    private static final Pattern HTML_ELEMENTS =\n            Pattern.compile(\"<[^>]*>\");\n\n    /** Period literal. */\n    private static final String PERIOD = \".\";\n\n    /** Summary tag text. */\n    private static final String SUMMARY_TEXT = \"@summary\";\n\n    /** Set of allowed Tokens tags in summary java doc. */\n    private static final Set<Integer> ALLOWED_TYPES = Set.of(\n                    JavadocTokenTypes.WS,\n                    JavadocTokenTypes.DESCRIPTION,\n                    JavadocTokenTypes.TEXT);\n\n    /**\n     * Specify the regexp for forbidden summary fragments.\n     */\n    private Pattern forbiddenSummaryFragments = CommonUtil.createPattern(\"^$\");\n\n    /**\n     * Specify the period symbol at the end of first javadoc sentence.\n     */\n    private String period = PERIOD;\n\n    /**\n     * Setter to specify the regexp for forbidden summary fragments.\n     *\n     * @param pattern a pattern.\n     */\n    public void setForbiddenSummaryFragments(Pattern pattern) {\n        forbiddenSummaryFragments = pattern;\n    }\n\n    /**\n     * Setter to specify the period symbol at the end of first javadoc sentence.\n     *\n     * @param period period's value.\n     */\n    public void setPeriod(String period) {\n        this.period = period;\n    }\n\n    @Override\n    public int[] getDefaultJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.JAVADOC,\n        };\n    }\n\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return getAcceptableJavadocTokens();\n    }\n\n    @Override\n    public void visitJavadocToken(DetailNode ast) {\n        final Optional<DetailNode> inlineSummaryTag = getInlineSummaryTag(ast);\n        if (inlineSummaryTag.isPresent()) {\n            validateSummaryTag(inlineSummaryTag.get());\n        }\n        else if (!startsWithInheritDoc(ast)) {\n            final String summaryDoc = getSummarySentence(ast);\n            if (summaryDoc.isEmpty()) {\n                log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n            }\n            else if (!period.isEmpty()) {\n                final String firstSentence = getFirstSentence(ast);\n                final int endOfSentence = firstSentence.lastIndexOf(period);\n                if (!summaryDoc.contains(period)) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_FIRST_SENTENCE);\n                }\n                if (endOfSentence != -1\n                        && containsForbiddenFragment(firstSentence.substring(0, endOfSentence))) {\n                    log(ast.getLineNumber(), MSG_SUMMARY_JAVADOC);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the inline summary tag.\n     *\n     * @param javadoc javadoc root node.\n     * @return an optional of inline summary tag node, empty optional if inline tag is not\n     *         a summary tag.\n     */\n    private static Optional<DetailNode> getInlineSummaryTag(DetailNode javadoc) {\n        Optional<DetailNode> node = Arrays.stream(javadoc.getChildren())\n                .filter(SummaryJavadocCheck::isInlineTagPresent)\n                .findFirst()\n                .map(SummaryJavadocCheck::getInlineTagNodeWithinHtmlElement);\n\n        if (node.isPresent() && !isSummaryTag(node.get())) {\n            node = Optional.empty();\n        }\n        return node;\n    }\n\n    /**\n     * Checks if the inline tag node is present.\n     *\n     * @param ast ast node to check.\n     * @return true, if the inline tag node is present.\n     */\n    private static boolean isInlineTagPresent(DetailNode ast) {\n        return ast.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                || ast.getType() == JavadocTokenTypes.HTML_ELEMENT\n                && getInlineTagNodeWithinHtmlElement(ast) != null;\n    }\n\n    /**\n     * Returns an inline javadoc tag node that is within a html tag.\n     *\n     * @param ast html tag node.\n     * @return inline summary javadoc tag node or null if no node is found.\n     */\n    private static DetailNode getInlineTagNodeWithinHtmlElement(DetailNode ast) {\n        DetailNode node = ast;\n        DetailNode result = null;\n        // node can never be null as this method is called when there is a HTML_ELEMENT\n        if (node.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG) {\n            result = node;\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_TAG) {\n            // HTML_TAG always has more than 2 children.\n            node = node.getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        else if (node.getType() == JavadocTokenTypes.HTML_ELEMENT\n                // Condition for SINGLETON html element which cannot contain summary node\n                && node.getChildren()[0].getChildren().length > 1) {\n            // Html elements have one tested tag before actual content inside it\n            node = node.getChildren()[0].getChildren()[1];\n            result = getInlineTagNodeWithinHtmlElement(node);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if the javadoc inline tag is {@code {@summary}} tag.\n     *\n     * @param javadocInlineTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     * @return {@code true} if inline tag is summary tag.\n     */\n    private static boolean isSummaryTag(DetailNode javadocInlineTag) {\n        final DetailNode[] child = javadocInlineTag.getChildren();\n\n        // Checking size of ast is not required, since ast contains\n        // children of Inline Tag, as at least 2 children will be present which are\n        // RCURLY and LCURLY.\n        return child[1].getType() == JavadocTokenTypes.CUSTOM_NAME\n                && SUMMARY_TEXT.equals(child[1].getText());\n    }\n\n    /**\n     * Checks the inline summary (if present) for {@code period} at end and forbidden fragments.\n     *\n     * @param inlineSummaryTag node of type {@link JavadocTokenTypes#JAVADOC_INLINE_TAG}\n     */\n    private void validateSummaryTag(DetailNode inlineSummaryTag) {\n        final String inlineSummary = getContentOfInlineCustomTag(inlineSummaryTag);\n        final String summaryVisible = getVisibleContent(inlineSummary);\n        if (summaryVisible.isEmpty()) {\n            log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC_MISSING);\n        }\n        else if (!period.isEmpty()) {\n            if (isPeriodNotAtEnd(summaryVisible, period)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_MISSING_PERIOD);\n            }\n            else if (containsForbiddenFragment(inlineSummary)) {\n                log(inlineSummaryTag.getLineNumber(), MSG_SUMMARY_JAVADOC);\n            }\n        }\n    }\n\n    /**\n     * Gets the content of inline custom tag.\n     *\n     * @param inlineTag inline tag node.\n     * @return String consisting of the content of inline custom tag.\n     */\n    public static String getContentOfInlineCustomTag(DetailNode inlineTag) {\n        final DetailNode[] childrenOfInlineTag = inlineTag.getChildren();\n        final StringBuilder customTagContent = new StringBuilder(256);\n        final int indexOfContentOfSummaryTag = 3;\n        if (childrenOfInlineTag.length != indexOfContentOfSummaryTag) {\n            DetailNode currentNode = childrenOfInlineTag[indexOfContentOfSummaryTag];\n            while (currentNode.getType() != JavadocTokenTypes.JAVADOC_INLINE_TAG_END) {\n                extractInlineTagContent(currentNode, customTagContent);\n                currentNode = JavadocUtil.getNextSibling(currentNode);\n            }\n        }\n        return customTagContent.toString();\n    }\n\n    /**\n     * Extracts the content of inline custom tag recursively.\n     *\n     * @param node DetailNode\n     * @param customTagContent content of custom tag\n     */\n    private static void extractInlineTagContent(DetailNode node,\n        StringBuilder customTagContent) {\n        final DetailNode[] children = node.getChildren();\n        if (children.length == 0) {\n            customTagContent.append(node.getText());\n        }\n        else {\n            for (DetailNode child : children) {\n                if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK) {\n                    extractInlineTagContent(child, customTagContent);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets the string that is visible to user in javadoc.\n     *\n     * @param summary entire content of summary javadoc.\n     * @return string that is visible to user in javadoc.\n     */\n    private static String getVisibleContent(String summary) {\n        final String visibleSummary = HTML_ELEMENTS.matcher(summary).replaceAll(\"\");\n        return visibleSummary.trim();\n    }\n\n    /**\n     * Checks if the string does not end with period.\n     *\n     * @param sentence string to check for period at end.\n     * @param period string to check within sentence.\n     * @return {@code true} if sentence does not end with period.\n     */\n    private static boolean isPeriodNotAtEnd(String sentence, String period) {\n        final String summarySentence = sentence.trim();\n        return summarySentence.lastIndexOf(period) != summarySentence.length() - 1;\n    }\n\n    /**\n     * Tests if first sentence contains forbidden summary fragment.\n     *\n     * @param firstSentence string with first sentence.\n     * @return {@code true} if first sentence contains forbidden summary fragment.\n     */\n    private boolean containsForbiddenFragment(String firstSentence) {\n        final String javadocText = JAVADOC_MULTILINE_TO_SINGLELINE_PATTERN\n                .matcher(firstSentence).replaceAll(\" \").trim();\n        return forbiddenSummaryFragments.matcher(trimExcessWhitespaces(javadocText)).find();\n    }\n\n    /**\n     * Trims the given {@code text} of duplicate whitespaces.\n     *\n     * @param text the text to transform.\n     * @return the finalized form of the text.\n     */\n    private static String trimExcessWhitespaces(String text) {\n        final StringBuilder result = new StringBuilder(256);\n        boolean previousWhitespace = true;\n\n        for (char letter : text.toCharArray()) {\n            final char print;\n            if (Character.isWhitespace(letter)) {\n                if (previousWhitespace) {\n                    continue;\n                }\n\n                previousWhitespace = true;\n                print = ' ';\n            }\n            else {\n                previousWhitespace = false;\n                print = letter;\n            }\n\n            result.append(print);\n        }\n\n        return result.toString();\n    }\n\n    /**\n     * Checks if the node starts with an {&#64;inheritDoc}.\n     *\n     * @param root the root node to examine.\n     * @return {@code true} if the javadoc starts with an {&#64;inheritDoc}.\n     */\n    private static boolean startsWithInheritDoc(DetailNode root) {\n        boolean found = false;\n        final DetailNode[] children = root.getChildren();\n\n        for (int i = 0; !found; i++) {\n            final DetailNode child = children[i];\n            if (child.getType() == JavadocTokenTypes.JAVADOC_INLINE_TAG\n                    && child.getChildren()[1].getType() == JavadocTokenTypes.INHERIT_DOC_LITERAL) {\n                found = true;\n            }\n            else if (child.getType() != JavadocTokenTypes.LEADING_ASTERISK\n                    && !CommonUtil.isBlank(child.getText())) {\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    /**\n     * Finds and returns summary sentence.\n     *\n     * @param ast javadoc root node.\n     * @return violation string.\n     */\n    private static String getSummarySentence(DetailNode ast) {\n        boolean flag = true;\n        final StringBuilder result = new StringBuilder(256);\n        for (DetailNode child : ast.getChildren()) {\n            if (ALLOWED_TYPES.contains(child.getType())) {\n                result.append(child.getText());\n            }\n            else if (child.getType() == JavadocTokenTypes.HTML_ELEMENT\n                    && CommonUtil.isBlank(result.toString().trim())) {\n                result.append(getStringInsideTag(result.toString(),\n                        child.getChildren()[0].getChildren()[0]));\n            }\n            else if (child.getType() == JavadocTokenTypes.JAVADOC_TAG) {\n                flag = false;\n            }\n            if (!flag) {\n                break;\n            }\n        }\n        return result.toString().trim();\n    }\n\n    /**\n     * Get concatenated string within text of html tags.\n     *\n     * @param result javadoc string\n     * @param detailNode javadoc tag node\n     * @return java doc tag content appended in result\n     */\n    private static String getStringInsideTag(String result, DetailNode detailNode) {\n        final StringBuilder contents = new StringBuilder(result);\n        DetailNode tempNode = detailNode;\n        while (tempNode != null) {\n            if (tempNode.getType() == JavadocTokenTypes.TEXT) {\n                contents.append(tempNode.getText());\n            }\n            tempNode = JavadocUtil.getNextSibling(tempNode);\n        }\n        return contents.toString();\n    }\n\n    /**\n     * Finds and returns first sentence.\n     *\n     * @param ast Javadoc root node.\n     * @return first sentence.\n     */\n    private static String getFirstSentence(DetailNode ast) {\n        final StringBuilder result = new StringBuilder(256);\n        final String periodSuffix = PERIOD + ' ';\n        for (DetailNode child : ast.getChildren()) {\n            final String text;\n            if (child.getChildren().length == 0) {\n                text = child.getText();\n            }\n            else {\n                text = getFirstSentence(child);\n            }\n\n            if (text.contains(periodSuffix)) {\n                result.append(text, 0, text.indexOf(periodSuffix) + 1);\n                break;\n            }\n\n            result.append(text);\n        }\n        return result.toString();\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate visitCtor(ast DetailAST) : void extracted from public visitToken(ast DetailAST) : void in class com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java", "startLine": 154, "endLine": 199, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java", "startLine": 154, "endLine": 183, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java", "startLine": 201, "endLine": 217, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public void visitToken(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                registerNestedSubclassToOuterSuperClasses(ast);\n\n                final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n                final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n                final String qualifiedClassName = getQualifiedClassName(ast);\n                classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n                    final ClassDesc desc = classes.peek();\n                    if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                        desc.registerNonPrivateCtor();\n                    }\n                    else {\n                        desc.registerPrivateCtor();\n                    }\n                }\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java", "isPureRefactoring": true, "commitId": "50a9a64b6d70aa722dcf754ad5d46e37784f5b05", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.design", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#visitToken", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#extractQualifiedName\n methodBody: private static String extractQualifiedName(DetailAST ast) {\nreturn FullIdent.createFullIdent(ast).getText();\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerNonPrivateCtor\n methodBody: private void registerNonPrivateCtor() {\nwithNonPrivateCtor=true;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#doesNameOfClassMatchAnonymousInnerClassName\n methodBody: private static boolean doesNameOfClassMatchAnonymousInnerClassName(DetailAST ast,\n                                                               ClassDesc classDesc) {\nfinal String[] className=classDesc.getQualifiedName().split(\"\\\\.\");\nreturn ast.getFirstChild().getText().equals(className[className.length - 1]);\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#registerNestedSubclassToOuterSuperClasses\n methodBody: private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {\nfinal String currentAstSuperClassName=getSuperClassName(classAst);\nif(currentAstSuperClassName != null){for(ClassDesc classDesc: classes){final String classDescQualifiedName=classDesc.getQualifiedName();\nif(doesNameInExtendMatchSuperClassName(classDescQualifiedName,currentAstSuperClassName)){classDesc.registerNestedSubclass();\n}}}}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerAnonymousInnerClass\n methodBody: private void registerAnonymousInnerClass() {\nwithAnonymousInnerClass=true;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#getQualifiedClassName\n methodBody: private static String getQualifiedClassName(String packageName, String outerClassQualifiedName,\n                                                String className) {\nfinal String qualifiedClassName;\nif(outerClassQualifiedName == null){if(packageName.isEmpty()){qualifiedClassName=className;\n}{qualifiedClassName=packageName + PACKAGE_SEPARATOR + className;\n}}{qualifiedClassName=outerClassQualifiedName + PACKAGE_SEPARATOR + className;\n}return qualifiedClassName;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerPrivateCtor\n methodBody: private void registerPrivateCtor() {\nwithPrivateCtor=true;\n}", "classSignatureBefore": "public class FinalClassCheck\n    extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#visitToken"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck"], "classSignatureBeforeSet": ["public class FinalClassCheck\n    extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes", "description": "Mapped statements in other refactorings - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.design;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n\n/**\n * <p>\n * Checks that a class which has only private constructors\n * is declared as final. Doesn't check for classes nested in interfaces\n * or annotations, as they are always {@code final} there.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;FinalClass&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * final class MyClass {  // OK\n *   private MyClass() { }\n * }\n *\n * class MyClass { // violation, class should be declared final\n *   private MyClass() { }\n * }\n *\n * class MyClass { // OK, since it has a public constructor\n *   int field1;\n *   String field2;\n *   private MyClass(int value) {\n *     this.field1 = value;\n *     this.field2 = \" \";\n *   }\n *   public MyClass(String value) {\n *     this.field2 = value;\n *     this.field1 = 0;\n *   }\n * }\n *\n * interface CheckInterface\n * {\n *   class MyClass { // OK, nested class in interface is always final\n *     private MyClass() {}\n *   }\n * }\n *\n * public @interface Test {\n *   public boolean enabled()\n *   default true;\n *   class MyClass { // OK, class nested in an annotation is always final\n *     private MyClass() { }\n *   }\n * }\n *\n * class TestAnonymousInnerClasses { // OK, class has an anonymous inner class.\n *     public static final TestAnonymousInnerClasses ONE = new TestAnonymousInnerClasses() {\n *\n *     };\n *\n *     private TestAnonymousInnerClasses() {\n *     }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code final.class}\n * </li>\n * </ul>\n *\n * @since 3.1\n */\n@FileStatefulCheck\npublic class FinalClassCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"final.class\";\n\n    /**\n     * Character separate package names in qualified name of java class.\n     */\n    private static final String PACKAGE_SEPARATOR = \".\";\n\n    /** Keeps ClassDesc objects for stack of declared classes. */\n    private Deque<ClassDesc> classes;\n\n    /** Full qualified name of the package. */\n    private String packageName;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CLASS_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n        };\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        classes = new ArrayDeque<>();\n        packageName = \"\";\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                registerNestedSubclassToOuterSuperClasses(ast);\n\n                final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n                final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n                final String qualifiedClassName = getQualifiedClassName(ast);\n                classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n                    final ClassDesc desc = classes.peek();\n                    if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                        desc.registerNonPrivateCtor();\n                    }\n                    else {\n                        desc.registerPrivateCtor();\n                    }\n                }\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.CLASS_DEF) {\n            final ClassDesc desc = classes.pop();\n            if (desc.isWithPrivateCtor()\n                && !(desc.isDeclaredAsAbstract()\n                    || desc.isWithAnonymousInnerClass())\n                && !desc.isDeclaredAsFinal()\n                && !desc.isWithNonPrivateCtor()\n                && !desc.isWithNestedSubclass()\n                && !ScopeUtil.isInInterfaceOrAnnotationBlock(ast)) {\n                final String qualifiedName = desc.getQualifiedName();\n                final String className = getClassNameFromQualifiedName(qualifiedName);\n                log(ast, MSG_KEY, className);\n            }\n        }\n    }\n\n    /**\n     * Get name of class (with qualified package if specified) in {@code ast}.\n     *\n     * @param ast ast to extract class name from\n     * @return qualified name\n     */\n    private static String extractQualifiedName(DetailAST ast) {\n        return FullIdent.createFullIdent(ast).getText();\n    }\n\n    /**\n     * Register to outer super classes of given classAst that\n     * given classAst is extending them.\n     *\n     * @param classAst class which outer super classes will be\n     *                 informed about nesting subclass\n     */\n    private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {\n        final String currentAstSuperClassName = getSuperClassName(classAst);\n        if (currentAstSuperClassName != null) {\n            for (ClassDesc classDesc : classes) {\n                final String classDescQualifiedName = classDesc.getQualifiedName();\n                if (doesNameInExtendMatchSuperClassName(classDescQualifiedName,\n                        currentAstSuperClassName)) {\n                    classDesc.registerNestedSubclass();\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if class name matches with anonymous inner class name.\n     *\n     * @param ast current ast.\n     * @param classDesc class to match.\n     * @return true if current class name matches anonymous inner\n     *         class name.\n     */\n    private static boolean doesNameOfClassMatchAnonymousInnerClassName(DetailAST ast,\n                                                               ClassDesc classDesc) {\n        final String[] className = classDesc.getQualifiedName().split(\"\\\\.\");\n        return ast.getFirstChild().getText().equals(className[className.length - 1]);\n    }\n\n    /**\n     * Get qualified class name from given class Ast.\n     *\n     * @param classAst class to get qualified class name\n     * @return qualified class name of a class\n     */\n    private String getQualifiedClassName(DetailAST classAst) {\n        final String className = classAst.findFirstToken(TokenTypes.IDENT).getText();\n        String outerClassQualifiedName = null;\n        if (!classes.isEmpty()) {\n            outerClassQualifiedName = classes.peek().getQualifiedName();\n        }\n        return getQualifiedClassName(packageName, outerClassQualifiedName, className);\n    }\n\n    /**\n     * Calculate qualified class name(package + class name) laying inside given\n     * outer class.\n     *\n     * @param packageName package name, empty string on default package\n     * @param outerClassQualifiedName qualified name(package + class) of outer class,\n     *                           null if doesn't exist\n     * @param className class name\n     * @return qualified class name(package + class name)\n     */\n    private static String getQualifiedClassName(String packageName, String outerClassQualifiedName,\n                                                String className) {\n        final String qualifiedClassName;\n\n        if (outerClassQualifiedName == null) {\n            if (packageName.isEmpty()) {\n                qualifiedClassName = className;\n            }\n            else {\n                qualifiedClassName = packageName + PACKAGE_SEPARATOR + className;\n            }\n        }\n        else {\n            qualifiedClassName = outerClassQualifiedName + PACKAGE_SEPARATOR + className;\n        }\n        return qualifiedClassName;\n    }\n\n    /**\n     * Get super class name of given class.\n     *\n     * @param classAst class\n     * @return super class name or null if super class is not specified\n     */\n    private static String getSuperClassName(DetailAST classAst) {\n        String superClassName = null;\n        final DetailAST classExtend = classAst.findFirstToken(TokenTypes.EXTENDS_CLAUSE);\n        if (classExtend != null) {\n            superClassName = extractQualifiedName(classExtend.getFirstChild());\n        }\n        return superClassName;\n    }\n\n    /**\n     * Checks if given super class name in extend clause match super class qualified name.\n     *\n     * @param superClassQualifiedName super class qualified name (with package)\n     * @param superClassInExtendClause name in extend clause\n     * @return true if given super class name in extend clause match super class qualified name,\n     *         false otherwise\n     */\n    private static boolean doesNameInExtendMatchSuperClassName(String superClassQualifiedName,\n                                                               String superClassInExtendClause) {\n        String superClassNormalizedName = superClassQualifiedName;\n        if (!superClassInExtendClause.contains(PACKAGE_SEPARATOR)) {\n            superClassNormalizedName = getClassNameFromQualifiedName(superClassQualifiedName);\n        }\n        return superClassNormalizedName.equals(superClassInExtendClause);\n    }\n\n    /**\n     * Get class name from qualified name.\n     *\n     * @param qualifiedName qualified class name\n     * @return class name\n     */\n    private static String getClassNameFromQualifiedName(String qualifiedName) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(PACKAGE_SEPARATOR) + 1);\n    }\n\n    /** Maintains information about class' ctors. */\n    private static final class ClassDesc {\n\n        /** Qualified class name(with package). */\n        private final String qualifiedName;\n\n        /** Is class declared as final. */\n        private final boolean declaredAsFinal;\n\n        /** Is class declared as abstract. */\n        private final boolean declaredAsAbstract;\n\n        /** Does class have non-private ctors. */\n        private boolean withNonPrivateCtor;\n\n        /** Does class have private ctors. */\n        private boolean withPrivateCtor;\n\n        /** Does class have nested subclass. */\n        private boolean withNestedSubclass;\n\n        /** Does class have anonymous inner class. */\n        private boolean withAnonymousInnerClass;\n\n        /**\n         *  Create a new ClassDesc instance.\n         *\n         *  @param qualifiedName qualified class name(with package)\n         *  @param declaredAsFinal indicates if the\n         *         class declared as final\n         *  @param declaredAsAbstract indicates if the\n         *         class declared as abstract\n         */\n        /* package */ ClassDesc(String qualifiedName, boolean declaredAsFinal,\n                boolean declaredAsAbstract) {\n            this.qualifiedName = qualifiedName;\n            this.declaredAsFinal = declaredAsFinal;\n            this.declaredAsAbstract = declaredAsAbstract;\n        }\n\n        /**\n         * Get qualified class name.\n         *\n         * @return qualified class name\n         */\n        private String getQualifiedName() {\n            return qualifiedName;\n        }\n\n        /** Adds private ctor. */\n        private void registerPrivateCtor() {\n            withPrivateCtor = true;\n        }\n\n        /** Adds non-private ctor. */\n        private void registerNonPrivateCtor() {\n            withNonPrivateCtor = true;\n        }\n\n        /** Adds nested subclass. */\n        private void registerNestedSubclass() {\n            withNestedSubclass = true;\n        }\n\n        /** Adds anonymous inner class. */\n        private void registerAnonymousInnerClass() {\n            withAnonymousInnerClass = true;\n        }\n\n        /**\n         *  Does class have private ctors.\n         *\n         *  @return true if class has private ctors\n         */\n        private boolean isWithPrivateCtor() {\n            return withPrivateCtor;\n        }\n\n        /**\n         *  Does class have non-private ctors.\n         *\n         *  @return true if class has non-private ctors\n         */\n        private boolean isWithNonPrivateCtor() {\n            return withNonPrivateCtor;\n        }\n\n        /**\n         * Does class have nested subclass.\n         *\n         * @return true if class has nested subclass\n         */\n        private boolean isWithNestedSubclass() {\n            return withNestedSubclass;\n        }\n\n        /**\n         *  Is class declared as final.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsFinal() {\n            return declaredAsFinal;\n        }\n\n        /**\n         *  Is class declared as abstract.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsAbstract() {\n            return declaredAsAbstract;\n        }\n\n        /**\n         * Does class have an anonymous inner class.\n         *\n         * @return true if class has anonymous inner class\n         */\n        private boolean isWithAnonymousInnerClass() {\n            return withAnonymousInnerClass;\n        }\n\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.design;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n\n/**\n * <p>\n * Checks that a class which has only private constructors\n * is declared as final. Doesn't check for classes nested in interfaces\n * or annotations, as they are always {@code final} there.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;FinalClass&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * final class MyClass {  // OK\n *   private MyClass() { }\n * }\n *\n * class MyClass { // violation, class should be declared final\n *   private MyClass() { }\n * }\n *\n * class MyClass { // OK, since it has a public constructor\n *   int field1;\n *   String field2;\n *   private MyClass(int value) {\n *     this.field1 = value;\n *     this.field2 = \" \";\n *   }\n *   public MyClass(String value) {\n *     this.field2 = value;\n *     this.field1 = 0;\n *   }\n * }\n *\n * interface CheckInterface\n * {\n *   class MyClass { // OK, nested class in interface is always final\n *     private MyClass() {}\n *   }\n * }\n *\n * public @interface Test {\n *   public boolean enabled()\n *   default true;\n *   class MyClass { // OK, class nested in an annotation is always final\n *     private MyClass() { }\n *   }\n * }\n *\n * class TestAnonymousInnerClasses { // OK, class has an anonymous inner class.\n *     public static final TestAnonymousInnerClasses ONE = new TestAnonymousInnerClasses() {\n *\n *     };\n *\n *     private TestAnonymousInnerClasses() {\n *     }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code final.class}\n * </li>\n * </ul>\n *\n * @since 3.1\n */\n@FileStatefulCheck\npublic class FinalClassCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"final.class\";\n\n    /**\n     * Character separate package names in qualified name of java class.\n     */\n    private static final String PACKAGE_SEPARATOR = \".\";\n\n    /** Keeps ClassDesc objects for stack of declared classes. */\n    private Deque<ClassDesc> classes;\n\n    /** Full qualified name of the package. */\n    private String packageName;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CLASS_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n        };\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        classes = new ArrayDeque<>();\n        packageName = \"\";\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                visitClass(ast);\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                visitCtor(ast);\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    /**\n     * Called to process a type definition.\n     *\n     * @param ast the token to process\n     */\n    private void visitClass(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n        registerNestedSubclassToOuterSuperClasses(ast);\n\n        final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n        final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n        final String qualifiedClassName = getQualifiedClassName(ast);\n        classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n    }\n\n    /**\n     * Called to process a constructor definition.\n     *\n     * @param ast the token to process\n     */\n    private void visitCtor(DetailAST ast) {\n        if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n            final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n            final ClassDesc desc = classes.peek();\n            if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                desc.registerNonPrivateCtor();\n            }\n            else {\n                desc.registerPrivateCtor();\n            }\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.CLASS_DEF) {\n            final ClassDesc desc = classes.pop();\n            if (desc.isWithPrivateCtor()\n                && !(desc.isDeclaredAsAbstract()\n                    || desc.isWithAnonymousInnerClass())\n                && !desc.isDeclaredAsFinal()\n                && !desc.isWithNonPrivateCtor()\n                && !desc.isWithNestedSubclass()\n                && !ScopeUtil.isInInterfaceOrAnnotationBlock(ast)) {\n                final String qualifiedName = desc.getQualifiedName();\n                final String className = getClassNameFromQualifiedName(qualifiedName);\n                log(ast, MSG_KEY, className);\n            }\n        }\n    }\n\n    /**\n     * Get name of class (with qualified package if specified) in {@code ast}.\n     *\n     * @param ast ast to extract class name from\n     * @return qualified name\n     */\n    private static String extractQualifiedName(DetailAST ast) {\n        return FullIdent.createFullIdent(ast).getText();\n    }\n\n    /**\n     * Register to outer super classes of given classAst that\n     * given classAst is extending them.\n     *\n     * @param classAst class which outer super classes will be\n     *                 informed about nesting subclass\n     */\n    private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {\n        final String currentAstSuperClassName = getSuperClassName(classAst);\n        if (currentAstSuperClassName != null) {\n            for (ClassDesc classDesc : classes) {\n                final String classDescQualifiedName = classDesc.getQualifiedName();\n                if (doesNameInExtendMatchSuperClassName(classDescQualifiedName,\n                        currentAstSuperClassName)) {\n                    classDesc.registerNestedSubclass();\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if class name matches with anonymous inner class name.\n     *\n     * @param ast current ast.\n     * @param classDesc class to match.\n     * @return true if current class name matches anonymous inner\n     *         class name.\n     */\n    private static boolean doesNameOfClassMatchAnonymousInnerClassName(DetailAST ast,\n                                                               ClassDesc classDesc) {\n        final String[] className = classDesc.getQualifiedName().split(\"\\\\.\");\n        return ast.getFirstChild().getText().equals(className[className.length - 1]);\n    }\n\n    /**\n     * Get qualified class name from given class Ast.\n     *\n     * @param classAst class to get qualified class name\n     * @return qualified class name of a class\n     */\n    private String getQualifiedClassName(DetailAST classAst) {\n        final String className = classAst.findFirstToken(TokenTypes.IDENT).getText();\n        String outerClassQualifiedName = null;\n        if (!classes.isEmpty()) {\n            outerClassQualifiedName = classes.peek().getQualifiedName();\n        }\n        return getQualifiedClassName(packageName, outerClassQualifiedName, className);\n    }\n\n    /**\n     * Calculate qualified class name(package + class name) laying inside given\n     * outer class.\n     *\n     * @param packageName package name, empty string on default package\n     * @param outerClassQualifiedName qualified name(package + class) of outer class,\n     *                           null if doesn't exist\n     * @param className class name\n     * @return qualified class name(package + class name)\n     */\n    private static String getQualifiedClassName(String packageName, String outerClassQualifiedName,\n                                                String className) {\n        final String qualifiedClassName;\n\n        if (outerClassQualifiedName == null) {\n            if (packageName.isEmpty()) {\n                qualifiedClassName = className;\n            }\n            else {\n                qualifiedClassName = packageName + PACKAGE_SEPARATOR + className;\n            }\n        }\n        else {\n            qualifiedClassName = outerClassQualifiedName + PACKAGE_SEPARATOR + className;\n        }\n        return qualifiedClassName;\n    }\n\n    /**\n     * Get super class name of given class.\n     *\n     * @param classAst class\n     * @return super class name or null if super class is not specified\n     */\n    private static String getSuperClassName(DetailAST classAst) {\n        String superClassName = null;\n        final DetailAST classExtend = classAst.findFirstToken(TokenTypes.EXTENDS_CLAUSE);\n        if (classExtend != null) {\n            superClassName = extractQualifiedName(classExtend.getFirstChild());\n        }\n        return superClassName;\n    }\n\n    /**\n     * Checks if given super class name in extend clause match super class qualified name.\n     *\n     * @param superClassQualifiedName super class qualified name (with package)\n     * @param superClassInExtendClause name in extend clause\n     * @return true if given super class name in extend clause match super class qualified name,\n     *         false otherwise\n     */\n    private static boolean doesNameInExtendMatchSuperClassName(String superClassQualifiedName,\n                                                               String superClassInExtendClause) {\n        String superClassNormalizedName = superClassQualifiedName;\n        if (!superClassInExtendClause.contains(PACKAGE_SEPARATOR)) {\n            superClassNormalizedName = getClassNameFromQualifiedName(superClassQualifiedName);\n        }\n        return superClassNormalizedName.equals(superClassInExtendClause);\n    }\n\n    /**\n     * Get class name from qualified name.\n     *\n     * @param qualifiedName qualified class name\n     * @return class name\n     */\n    private static String getClassNameFromQualifiedName(String qualifiedName) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(PACKAGE_SEPARATOR) + 1);\n    }\n\n    /** Maintains information about class' ctors. */\n    private static final class ClassDesc {\n\n        /** Qualified class name(with package). */\n        private final String qualifiedName;\n\n        /** Is class declared as final. */\n        private final boolean declaredAsFinal;\n\n        /** Is class declared as abstract. */\n        private final boolean declaredAsAbstract;\n\n        /** Does class have non-private ctors. */\n        private boolean withNonPrivateCtor;\n\n        /** Does class have private ctors. */\n        private boolean withPrivateCtor;\n\n        /** Does class have nested subclass. */\n        private boolean withNestedSubclass;\n\n        /** Does class have anonymous inner class. */\n        private boolean withAnonymousInnerClass;\n\n        /**\n         *  Create a new ClassDesc instance.\n         *\n         *  @param qualifiedName qualified class name(with package)\n         *  @param declaredAsFinal indicates if the\n         *         class declared as final\n         *  @param declaredAsAbstract indicates if the\n         *         class declared as abstract\n         */\n        /* package */ ClassDesc(String qualifiedName, boolean declaredAsFinal,\n                boolean declaredAsAbstract) {\n            this.qualifiedName = qualifiedName;\n            this.declaredAsFinal = declaredAsFinal;\n            this.declaredAsAbstract = declaredAsAbstract;\n        }\n\n        /**\n         * Get qualified class name.\n         *\n         * @return qualified class name\n         */\n        private String getQualifiedName() {\n            return qualifiedName;\n        }\n\n        /** Adds private ctor. */\n        private void registerPrivateCtor() {\n            withPrivateCtor = true;\n        }\n\n        /** Adds non-private ctor. */\n        private void registerNonPrivateCtor() {\n            withNonPrivateCtor = true;\n        }\n\n        /** Adds nested subclass. */\n        private void registerNestedSubclass() {\n            withNestedSubclass = true;\n        }\n\n        /** Adds anonymous inner class. */\n        private void registerAnonymousInnerClass() {\n            withAnonymousInnerClass = true;\n        }\n\n        /**\n         *  Does class have private ctors.\n         *\n         *  @return true if class has private ctors\n         */\n        private boolean isWithPrivateCtor() {\n            return withPrivateCtor;\n        }\n\n        /**\n         *  Does class have non-private ctors.\n         *\n         *  @return true if class has non-private ctors\n         */\n        private boolean isWithNonPrivateCtor() {\n            return withNonPrivateCtor;\n        }\n\n        /**\n         * Does class have nested subclass.\n         *\n         * @return true if class has nested subclass\n         */\n        private boolean isWithNestedSubclass() {\n            return withNestedSubclass;\n        }\n\n        /**\n         *  Is class declared as final.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsFinal() {\n            return declaredAsFinal;\n        }\n\n        /**\n         *  Is class declared as abstract.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsAbstract() {\n            return declaredAsAbstract;\n        }\n\n        /**\n         * Does class have an anonymous inner class.\n         *\n         * @return true if class has anonymous inner class\n         */\n        private boolean isWithAnonymousInnerClass() {\n            return withAnonymousInnerClass;\n        }\n\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Called to process a constructor definition.\n     *\n     * @param ast the token to process\n     */\n    private void visitCtor(DetailAST ast) {\n        if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n            final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n            final ClassDesc desc = classes.peek();\n            if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                desc.registerNonPrivateCtor();\n            }\n            else {\n                desc.registerPrivateCtor();\n            }\n        }\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#extractQualifiedName\n methodBody: private static String extractQualifiedName(DetailAST ast) {\nreturn FullIdent.createFullIdent(ast).getText();\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerNonPrivateCtor\n methodBody: private void registerNonPrivateCtor() {\nwithNonPrivateCtor=true;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#doesNameOfClassMatchAnonymousInnerClassName\n methodBody: private static boolean doesNameOfClassMatchAnonymousInnerClassName(DetailAST ast,\n                                                               ClassDesc classDesc) {\nfinal String[] className=classDesc.getQualifiedName().split(\"\\\\.\");\nreturn ast.getFirstChild().getText().equals(className[className.length - 1]);\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#registerNestedSubclassToOuterSuperClasses\n methodBody: private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {\nfinal String currentAstSuperClassName=getSuperClassName(classAst);\nif(currentAstSuperClassName != null){for(ClassDesc classDesc: classes){final String classDescQualifiedName=classDesc.getQualifiedName();\nif(doesNameInExtendMatchSuperClassName(classDescQualifiedName,currentAstSuperClassName)){classDesc.registerNestedSubclass();\n}}}}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerAnonymousInnerClass\n methodBody: private void registerAnonymousInnerClass() {\nwithAnonymousInnerClass=true;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#getQualifiedClassName\n methodBody: private static String getQualifiedClassName(String packageName, String outerClassQualifiedName,\n                                                String className) {\nfinal String qualifiedClassName;\nif(outerClassQualifiedName == null){if(packageName.isEmpty()){qualifiedClassName=className;\n}{qualifiedClassName=packageName + PACKAGE_SEPARATOR + className;\n}}{qualifiedClassName=outerClassQualifiedName + PACKAGE_SEPARATOR + className;\n}return qualifiedClassName;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerPrivateCtor\n methodBody: private void registerPrivateCtor() {\nwithPrivateCtor=true;\n}"], "sourceCodeAfterRefactoring": "@Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                visitClass(ast);\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                visitCtor(ast);\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n/**\n     * Called to process a constructor definition.\n     *\n     * @param ast the token to process\n     */\n    private void visitCtor(DetailAST ast) {\n        if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n            final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n            final ClassDesc desc = classes.peek();\n            if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                desc.registerNonPrivateCtor();\n            }\n            else {\n                desc.registerPrivateCtor();\n            }\n        }\n    }", "diffSourceCode": "   154:     @Override\n   155:     public void visitToken(DetailAST ast) {\n-  156:         final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n-  157: \n-  158:         switch (ast.getType()) {\n-  159:             case TokenTypes.PACKAGE_DEF:\n-  160:                 packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n-  161:                 break;\n-  162: \n-  163:             case TokenTypes.CLASS_DEF:\n-  164:                 registerNestedSubclassToOuterSuperClasses(ast);\n-  165: \n-  166:                 final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n-  167:                 final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n+  156:         switch (ast.getType()) {\n+  157:             case TokenTypes.PACKAGE_DEF:\n+  158:                 packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n+  159:                 break;\n+  160: \n+  161:             case TokenTypes.CLASS_DEF:\n+  162:                 visitClass(ast);\n+  163:                 break;\n+  164: \n+  165:             case TokenTypes.CTOR_DEF:\n+  166:                 visitCtor(ast);\n+  167:                 break;\n   168: \n-  169:                 final String qualifiedClassName = getQualifiedClassName(ast);\n-  170:                 classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n-  171:                 break;\n-  172: \n-  173:             case TokenTypes.CTOR_DEF:\n-  174:                 if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n-  175:                     final ClassDesc desc = classes.peek();\n-  176:                     if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n-  177:                         desc.registerNonPrivateCtor();\n-  178:                     }\n-  179:                     else {\n-  180:                         desc.registerPrivateCtor();\n-  181:                     }\n-  182:                 }\n-  183:                 break;\n+  169:             case TokenTypes.LITERAL_NEW:\n+  170:                 if (ast.getFirstChild() != null\n+  171:                         && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n+  172:                     for (ClassDesc classDesc : classes) {\n+  173:                         if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n+  174:                             classDesc.registerAnonymousInnerClass();\n+  175:                         }\n+  176:                     }\n+  177:                 }\n+  178:                 break;\n+  179: \n+  180:             default:\n+  181:                 throw new IllegalStateException(ast.toString());\n+  182:         }\n+  183:     }\n   184: \n-  185:             case TokenTypes.LITERAL_NEW:\n-  186:                 if (ast.getFirstChild() != null\n-  187:                         && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n-  188:                     for (ClassDesc classDesc : classes) {\n-  189:                         if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n-  190:                             classDesc.registerAnonymousInnerClass();\n-  191:                         }\n-  192:                     }\n-  193:                 }\n-  194:                 break;\n-  195: \n-  196:             default:\n-  197:                 throw new IllegalStateException(ast.toString());\n-  198:         }\n+  185:     /**\n+  186:      * Called to process a type definition.\n+  187:      *\n+  188:      * @param ast the token to process\n+  189:      */\n+  190:     private void visitClass(DetailAST ast) {\n+  191:         final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n+  192:         registerNestedSubclassToOuterSuperClasses(ast);\n+  193: \n+  194:         final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n+  195:         final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n+  196: \n+  197:         final String qualifiedClassName = getQualifiedClassName(ast);\n+  198:         classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n   199:     }\n-  201:     @Override\n-  202:     public void leaveToken(DetailAST ast) {\n-  203:         if (ast.getType() == TokenTypes.CLASS_DEF) {\n-  204:             final ClassDesc desc = classes.pop();\n-  205:             if (desc.isWithPrivateCtor()\n-  206:                 && !(desc.isDeclaredAsAbstract()\n-  207:                     || desc.isWithAnonymousInnerClass())\n-  208:                 && !desc.isDeclaredAsFinal()\n-  209:                 && !desc.isWithNonPrivateCtor()\n-  210:                 && !desc.isWithNestedSubclass()\n-  211:                 && !ScopeUtil.isInInterfaceOrAnnotationBlock(ast)) {\n-  212:                 final String qualifiedName = desc.getQualifiedName();\n-  213:                 final String className = getClassNameFromQualifiedName(qualifiedName);\n-  214:                 log(ast, MSG_KEY, className);\n+  201:     /**\n+  202:      * Called to process a constructor definition.\n+  203:      *\n+  204:      * @param ast the token to process\n+  205:      */\n+  206:     private void visitCtor(DetailAST ast) {\n+  207:         if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n+  208:             final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n+  209:             final ClassDesc desc = classes.peek();\n+  210:             if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n+  211:                 desc.registerNonPrivateCtor();\n+  212:             }\n+  213:             else {\n+  214:                 desc.registerPrivateCtor();\n   215:             }\n   216:         }\n   217:     }\n", "uniqueId": "50a9a64b6d70aa722dcf754ad5d46e37784f5b05_154_199_201_217_154_183", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": false, "compileJDK": 11, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 102}, "BRANCH": {"missed": 0, "covered": 23}, "LINE": {"missed": 0, "covered": 24}, "COMPLEXITY": {"missed": 0, "covered": 14}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "##########################\n// Refactored code after applying Extract Method refactoring\n\n@Override\npublic void visitToken(DetailAST ast) {\n    final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n\n    switch (ast.getType()) {\n        case TokenTypes.PACKAGE_DEF:\n            extractPackageName(ast);\n            break;\n\n        case TokenTypes.CLASS_DEF:\n            registerClass(ast, modifiers);\n            break;\n\n        case TokenTypes.CTOR_DEF:\n            processConstructor(ast, modifiers);\n            break;\n\n        case TokenTypes.LITERAL_NEW:\n            processNewLiteral(ast);\n            break;\n\n        default:\n            throw new IllegalStateException(ast.toString());\n    }\n}\n\nprivate void extractPackageName(DetailAST ast) {\n    packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n}\n\nprivate void registerClass(DetailAST ast, DetailAST modifiers) {\n    registerNestedSubclassToOuterSuperClasses(ast);\n\n    final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n    final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n    final String qualifiedClassName = getQualifiedClassName(ast);\n    classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n}\n\nprivate void processConstructor(DetailAST ast, DetailAST modifiers) {\n    if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n        final ClassDesc desc = classes.peek();\n        if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n            desc.registerNonPrivateCtor();\n        } else {\n            desc.registerPrivateCtor();\n        }\n    }\n}\n\nprivate void processNewLiteral(DetailAST ast) {\n    if (ast.getFirstChild() != null && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n        for (ClassDesc classDesc : classes) {\n            if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                classDesc.registerAnonymousInnerClass();\n            }\n        }\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public void visitToken(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                registerNestedSubclassToOuterSuperClasses(ast);\n\n                final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n                final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n                final String qualifiedClassName = getQualifiedClassName(ast);\n                classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n                    final ClassDesc desc = classes.peek();\n                    if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                        desc.registerNonPrivateCtor();\n                    }\n                    else {\n                        desc.registerPrivateCtor();\n                    }\n                }\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.design;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n\n/**\n * <p>\n * Checks that a class which has only private constructors\n * is declared as final. Doesn't check for classes nested in interfaces\n * or annotations, as they are always {@code final} there.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;FinalClass&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * final class MyClass {  // OK\n *   private MyClass() { }\n * }\n *\n * class MyClass { // violation, class should be declared final\n *   private MyClass() { }\n * }\n *\n * class MyClass { // OK, since it has a public constructor\n *   int field1;\n *   String field2;\n *   private MyClass(int value) {\n *     this.field1 = value;\n *     this.field2 = \" \";\n *   }\n *   public MyClass(String value) {\n *     this.field2 = value;\n *     this.field1 = 0;\n *   }\n * }\n *\n * interface CheckInterface\n * {\n *   class MyClass { // OK, nested class in interface is always final\n *     private MyClass() {}\n *   }\n * }\n *\n * public @interface Test {\n *   public boolean enabled()\n *   default true;\n *   class MyClass { // OK, class nested in an annotation is always final\n *     private MyClass() { }\n *   }\n * }\n *\n * class TestAnonymousInnerClasses { // OK, class has an anonymous inner class.\n *     public static final TestAnonymousInnerClasses ONE = new TestAnonymousInnerClasses() {\n *\n *     };\n *\n *     private TestAnonymousInnerClasses() {\n *     }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code final.class}\n * </li>\n * </ul>\n *\n * @since 3.1\n */\n@FileStatefulCheck\npublic class FinalClassCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"final.class\";\n\n    /**\n     * Character separate package names in qualified name of java class.\n     */\n    private static final String PACKAGE_SEPARATOR = \".\";\n\n    /** Keeps ClassDesc objects for stack of declared classes. */\n    private Deque<ClassDesc> classes;\n\n    /** Full qualified name of the package. */\n    private String packageName;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CLASS_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n        };\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        classes = new ArrayDeque<>();\n        packageName = \"\";\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                registerNestedSubclassToOuterSuperClasses(ast);\n\n                final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n                final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n                final String qualifiedClassName = getQualifiedClassName(ast);\n                classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n                    final ClassDesc desc = classes.peek();\n                    if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                        desc.registerNonPrivateCtor();\n                    }\n                    else {\n                        desc.registerPrivateCtor();\n                    }\n                }\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.CLASS_DEF) {\n            final ClassDesc desc = classes.pop();\n            if (desc.isWithPrivateCtor()\n                && !(desc.isDeclaredAsAbstract()\n                    || desc.isWithAnonymousInnerClass())\n                && !desc.isDeclaredAsFinal()\n                && !desc.isWithNonPrivateCtor()\n                && !desc.isWithNestedSubclass()\n                && !ScopeUtil.isInInterfaceOrAnnotationBlock(ast)) {\n                final String qualifiedName = desc.getQualifiedName();\n                final String className = getClassNameFromQualifiedName(qualifiedName);\n                log(ast, MSG_KEY, className);\n            }\n        }\n    }\n\n    /**\n     * Get name of class (with qualified package if specified) in {@code ast}.\n     *\n     * @param ast ast to extract class name from\n     * @return qualified name\n     */\n    private static String extractQualifiedName(DetailAST ast) {\n        return FullIdent.createFullIdent(ast).getText();\n    }\n\n    /**\n     * Register to outer super classes of given classAst that\n     * given classAst is extending them.\n     *\n     * @param classAst class which outer super classes will be\n     *                 informed about nesting subclass\n     */\n    private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {\n        final String currentAstSuperClassName = getSuperClassName(classAst);\n        if (currentAstSuperClassName != null) {\n            for (ClassDesc classDesc : classes) {\n                final String classDescQualifiedName = classDesc.getQualifiedName();\n                if (doesNameInExtendMatchSuperClassName(classDescQualifiedName,\n                        currentAstSuperClassName)) {\n                    classDesc.registerNestedSubclass();\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if class name matches with anonymous inner class name.\n     *\n     * @param ast current ast.\n     * @param classDesc class to match.\n     * @return true if current class name matches anonymous inner\n     *         class name.\n     */\n    private static boolean doesNameOfClassMatchAnonymousInnerClassName(DetailAST ast,\n                                                               ClassDesc classDesc) {\n        final String[] className = classDesc.getQualifiedName().split(\"\\\\.\");\n        return ast.getFirstChild().getText().equals(className[className.length - 1]);\n    }\n\n    /**\n     * Get qualified class name from given class Ast.\n     *\n     * @param classAst class to get qualified class name\n     * @return qualified class name of a class\n     */\n    private String getQualifiedClassName(DetailAST classAst) {\n        final String className = classAst.findFirstToken(TokenTypes.IDENT).getText();\n        String outerClassQualifiedName = null;\n        if (!classes.isEmpty()) {\n            outerClassQualifiedName = classes.peek().getQualifiedName();\n        }\n        return getQualifiedClassName(packageName, outerClassQualifiedName, className);\n    }\n\n    /**\n     * Calculate qualified class name(package + class name) laying inside given\n     * outer class.\n     *\n     * @param packageName package name, empty string on default package\n     * @param outerClassQualifiedName qualified name(package + class) of outer class,\n     *                           null if doesn't exist\n     * @param className class name\n     * @return qualified class name(package + class name)\n     */\n    private static String getQualifiedClassName(String packageName, String outerClassQualifiedName,\n                                                String className) {\n        final String qualifiedClassName;\n\n        if (outerClassQualifiedName == null) {\n            if (packageName.isEmpty()) {\n                qualifiedClassName = className;\n            }\n            else {\n                qualifiedClassName = packageName + PACKAGE_SEPARATOR + className;\n            }\n        }\n        else {\n            qualifiedClassName = outerClassQualifiedName + PACKAGE_SEPARATOR + className;\n        }\n        return qualifiedClassName;\n    }\n\n    /**\n     * Get super class name of given class.\n     *\n     * @param classAst class\n     * @return super class name or null if super class is not specified\n     */\n    private static String getSuperClassName(DetailAST classAst) {\n        String superClassName = null;\n        final DetailAST classExtend = classAst.findFirstToken(TokenTypes.EXTENDS_CLAUSE);\n        if (classExtend != null) {\n            superClassName = extractQualifiedName(classExtend.getFirstChild());\n        }\n        return superClassName;\n    }\n\n    /**\n     * Checks if given super class name in extend clause match super class qualified name.\n     *\n     * @param superClassQualifiedName super class qualified name (with package)\n     * @param superClassInExtendClause name in extend clause\n     * @return true if given super class name in extend clause match super class qualified name,\n     *         false otherwise\n     */\n    private static boolean doesNameInExtendMatchSuperClassName(String superClassQualifiedName,\n                                                               String superClassInExtendClause) {\n        String superClassNormalizedName = superClassQualifiedName;\n        if (!superClassInExtendClause.contains(PACKAGE_SEPARATOR)) {\n            superClassNormalizedName = getClassNameFromQualifiedName(superClassQualifiedName);\n        }\n        return superClassNormalizedName.equals(superClassInExtendClause);\n    }\n\n    /**\n     * Get class name from qualified name.\n     *\n     * @param qualifiedName qualified class name\n     * @return class name\n     */\n    private static String getClassNameFromQualifiedName(String qualifiedName) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(PACKAGE_SEPARATOR) + 1);\n    }\n\n    /** Maintains information about class' ctors. */\n    private static final class ClassDesc {\n\n        /** Qualified class name(with package). */\n        private final String qualifiedName;\n\n        /** Is class declared as final. */\n        private final boolean declaredAsFinal;\n\n        /** Is class declared as abstract. */\n        private final boolean declaredAsAbstract;\n\n        /** Does class have non-private ctors. */\n        private boolean withNonPrivateCtor;\n\n        /** Does class have private ctors. */\n        private boolean withPrivateCtor;\n\n        /** Does class have nested subclass. */\n        private boolean withNestedSubclass;\n\n        /** Does class have anonymous inner class. */\n        private boolean withAnonymousInnerClass;\n\n        /**\n         *  Create a new ClassDesc instance.\n         *\n         *  @param qualifiedName qualified class name(with package)\n         *  @param declaredAsFinal indicates if the\n         *         class declared as final\n         *  @param declaredAsAbstract indicates if the\n         *         class declared as abstract\n         */\n        /* package */ ClassDesc(String qualifiedName, boolean declaredAsFinal,\n                boolean declaredAsAbstract) {\n            this.qualifiedName = qualifiedName;\n            this.declaredAsFinal = declaredAsFinal;\n            this.declaredAsAbstract = declaredAsAbstract;\n        }\n\n        /**\n         * Get qualified class name.\n         *\n         * @return qualified class name\n         */\n        private String getQualifiedName() {\n            return qualifiedName;\n        }\n\n        /** Adds private ctor. */\n        private void registerPrivateCtor() {\n            withPrivateCtor = true;\n        }\n\n        /** Adds non-private ctor. */\n        private void registerNonPrivateCtor() {\n            withNonPrivateCtor = true;\n        }\n\n        /** Adds nested subclass. */\n        private void registerNestedSubclass() {\n            withNestedSubclass = true;\n        }\n\n        /** Adds anonymous inner class. */\n        private void registerAnonymousInnerClass() {\n            withAnonymousInnerClass = true;\n        }\n\n        /**\n         *  Does class have private ctors.\n         *\n         *  @return true if class has private ctors\n         */\n        private boolean isWithPrivateCtor() {\n            return withPrivateCtor;\n        }\n\n        /**\n         *  Does class have non-private ctors.\n         *\n         *  @return true if class has non-private ctors\n         */\n        private boolean isWithNonPrivateCtor() {\n            return withNonPrivateCtor;\n        }\n\n        /**\n         * Does class have nested subclass.\n         *\n         * @return true if class has nested subclass\n         */\n        private boolean isWithNestedSubclass() {\n            return withNestedSubclass;\n        }\n\n        /**\n         *  Is class declared as final.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsFinal() {\n            return declaredAsFinal;\n        }\n\n        /**\n         *  Is class declared as abstract.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsAbstract() {\n            return declaredAsAbstract;\n        }\n\n        /**\n         * Does class have an anonymous inner class.\n         *\n         * @return true if class has anonymous inner class\n         */\n        private boolean isWithAnonymousInnerClass() {\n            return withAnonymousInnerClass;\n        }\n\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate visitClass(ast DetailAST) : void extracted from public visitToken(ast DetailAST) : void in class com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java", "startLine": 154, "endLine": 199, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java", "startLine": 154, "endLine": 183, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java", "startLine": 185, "endLine": 199, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public void visitToken(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                registerNestedSubclassToOuterSuperClasses(ast);\n\n                final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n                final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n                final String qualifiedClassName = getQualifiedClassName(ast);\n                classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n                    final ClassDesc desc = classes.peek();\n                    if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                        desc.registerNonPrivateCtor();\n                    }\n                    else {\n                        desc.registerPrivateCtor();\n                    }\n                }\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java", "isPureRefactoring": true, "commitId": "50a9a64b6d70aa722dcf754ad5d46e37784f5b05", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.design", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#visitToken", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#extractQualifiedName\n methodBody: private static String extractQualifiedName(DetailAST ast) {\nreturn FullIdent.createFullIdent(ast).getText();\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerNonPrivateCtor\n methodBody: private void registerNonPrivateCtor() {\nwithNonPrivateCtor=true;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#doesNameOfClassMatchAnonymousInnerClassName\n methodBody: private static boolean doesNameOfClassMatchAnonymousInnerClassName(DetailAST ast,\n                                                               ClassDesc classDesc) {\nfinal String[] className=classDesc.getQualifiedName().split(\"\\\\.\");\nreturn ast.getFirstChild().getText().equals(className[className.length - 1]);\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#registerNestedSubclassToOuterSuperClasses\n methodBody: private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {\nfinal String currentAstSuperClassName=getSuperClassName(classAst);\nif(currentAstSuperClassName != null){for(ClassDesc classDesc: classes){final String classDescQualifiedName=classDesc.getQualifiedName();\nif(doesNameInExtendMatchSuperClassName(classDescQualifiedName,currentAstSuperClassName)){classDesc.registerNestedSubclass();\n}}}}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerAnonymousInnerClass\n methodBody: private void registerAnonymousInnerClass() {\nwithAnonymousInnerClass=true;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#getQualifiedClassName\n methodBody: private static String getQualifiedClassName(String packageName, String outerClassQualifiedName,\n                                                String className) {\nfinal String qualifiedClassName;\nif(outerClassQualifiedName == null){if(packageName.isEmpty()){qualifiedClassName=className;\n}{qualifiedClassName=packageName + PACKAGE_SEPARATOR + className;\n}}{qualifiedClassName=outerClassQualifiedName + PACKAGE_SEPARATOR + className;\n}return qualifiedClassName;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerPrivateCtor\n methodBody: private void registerPrivateCtor() {\nwithPrivateCtor=true;\n}", "classSignatureBefore": "public class FinalClassCheck\n    extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#visitToken"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck"], "classSignatureBeforeSet": ["public class FinalClassCheck\n    extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.design;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n\n/**\n * <p>\n * Checks that a class which has only private constructors\n * is declared as final. Doesn't check for classes nested in interfaces\n * or annotations, as they are always {@code final} there.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;FinalClass&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * final class MyClass {  // OK\n *   private MyClass() { }\n * }\n *\n * class MyClass { // violation, class should be declared final\n *   private MyClass() { }\n * }\n *\n * class MyClass { // OK, since it has a public constructor\n *   int field1;\n *   String field2;\n *   private MyClass(int value) {\n *     this.field1 = value;\n *     this.field2 = \" \";\n *   }\n *   public MyClass(String value) {\n *     this.field2 = value;\n *     this.field1 = 0;\n *   }\n * }\n *\n * interface CheckInterface\n * {\n *   class MyClass { // OK, nested class in interface is always final\n *     private MyClass() {}\n *   }\n * }\n *\n * public @interface Test {\n *   public boolean enabled()\n *   default true;\n *   class MyClass { // OK, class nested in an annotation is always final\n *     private MyClass() { }\n *   }\n * }\n *\n * class TestAnonymousInnerClasses { // OK, class has an anonymous inner class.\n *     public static final TestAnonymousInnerClasses ONE = new TestAnonymousInnerClasses() {\n *\n *     };\n *\n *     private TestAnonymousInnerClasses() {\n *     }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code final.class}\n * </li>\n * </ul>\n *\n * @since 3.1\n */\n@FileStatefulCheck\npublic class FinalClassCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"final.class\";\n\n    /**\n     * Character separate package names in qualified name of java class.\n     */\n    private static final String PACKAGE_SEPARATOR = \".\";\n\n    /** Keeps ClassDesc objects for stack of declared classes. */\n    private Deque<ClassDesc> classes;\n\n    /** Full qualified name of the package. */\n    private String packageName;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CLASS_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n        };\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        classes = new ArrayDeque<>();\n        packageName = \"\";\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                registerNestedSubclassToOuterSuperClasses(ast);\n\n                final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n                final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n                final String qualifiedClassName = getQualifiedClassName(ast);\n                classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n                    final ClassDesc desc = classes.peek();\n                    if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                        desc.registerNonPrivateCtor();\n                    }\n                    else {\n                        desc.registerPrivateCtor();\n                    }\n                }\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.CLASS_DEF) {\n            final ClassDesc desc = classes.pop();\n            if (desc.isWithPrivateCtor()\n                && !(desc.isDeclaredAsAbstract()\n                    || desc.isWithAnonymousInnerClass())\n                && !desc.isDeclaredAsFinal()\n                && !desc.isWithNonPrivateCtor()\n                && !desc.isWithNestedSubclass()\n                && !ScopeUtil.isInInterfaceOrAnnotationBlock(ast)) {\n                final String qualifiedName = desc.getQualifiedName();\n                final String className = getClassNameFromQualifiedName(qualifiedName);\n                log(ast, MSG_KEY, className);\n            }\n        }\n    }\n\n    /**\n     * Get name of class (with qualified package if specified) in {@code ast}.\n     *\n     * @param ast ast to extract class name from\n     * @return qualified name\n     */\n    private static String extractQualifiedName(DetailAST ast) {\n        return FullIdent.createFullIdent(ast).getText();\n    }\n\n    /**\n     * Register to outer super classes of given classAst that\n     * given classAst is extending them.\n     *\n     * @param classAst class which outer super classes will be\n     *                 informed about nesting subclass\n     */\n    private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {\n        final String currentAstSuperClassName = getSuperClassName(classAst);\n        if (currentAstSuperClassName != null) {\n            for (ClassDesc classDesc : classes) {\n                final String classDescQualifiedName = classDesc.getQualifiedName();\n                if (doesNameInExtendMatchSuperClassName(classDescQualifiedName,\n                        currentAstSuperClassName)) {\n                    classDesc.registerNestedSubclass();\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if class name matches with anonymous inner class name.\n     *\n     * @param ast current ast.\n     * @param classDesc class to match.\n     * @return true if current class name matches anonymous inner\n     *         class name.\n     */\n    private static boolean doesNameOfClassMatchAnonymousInnerClassName(DetailAST ast,\n                                                               ClassDesc classDesc) {\n        final String[] className = classDesc.getQualifiedName().split(\"\\\\.\");\n        return ast.getFirstChild().getText().equals(className[className.length - 1]);\n    }\n\n    /**\n     * Get qualified class name from given class Ast.\n     *\n     * @param classAst class to get qualified class name\n     * @return qualified class name of a class\n     */\n    private String getQualifiedClassName(DetailAST classAst) {\n        final String className = classAst.findFirstToken(TokenTypes.IDENT).getText();\n        String outerClassQualifiedName = null;\n        if (!classes.isEmpty()) {\n            outerClassQualifiedName = classes.peek().getQualifiedName();\n        }\n        return getQualifiedClassName(packageName, outerClassQualifiedName, className);\n    }\n\n    /**\n     * Calculate qualified class name(package + class name) laying inside given\n     * outer class.\n     *\n     * @param packageName package name, empty string on default package\n     * @param outerClassQualifiedName qualified name(package + class) of outer class,\n     *                           null if doesn't exist\n     * @param className class name\n     * @return qualified class name(package + class name)\n     */\n    private static String getQualifiedClassName(String packageName, String outerClassQualifiedName,\n                                                String className) {\n        final String qualifiedClassName;\n\n        if (outerClassQualifiedName == null) {\n            if (packageName.isEmpty()) {\n                qualifiedClassName = className;\n            }\n            else {\n                qualifiedClassName = packageName + PACKAGE_SEPARATOR + className;\n            }\n        }\n        else {\n            qualifiedClassName = outerClassQualifiedName + PACKAGE_SEPARATOR + className;\n        }\n        return qualifiedClassName;\n    }\n\n    /**\n     * Get super class name of given class.\n     *\n     * @param classAst class\n     * @return super class name or null if super class is not specified\n     */\n    private static String getSuperClassName(DetailAST classAst) {\n        String superClassName = null;\n        final DetailAST classExtend = classAst.findFirstToken(TokenTypes.EXTENDS_CLAUSE);\n        if (classExtend != null) {\n            superClassName = extractQualifiedName(classExtend.getFirstChild());\n        }\n        return superClassName;\n    }\n\n    /**\n     * Checks if given super class name in extend clause match super class qualified name.\n     *\n     * @param superClassQualifiedName super class qualified name (with package)\n     * @param superClassInExtendClause name in extend clause\n     * @return true if given super class name in extend clause match super class qualified name,\n     *         false otherwise\n     */\n    private static boolean doesNameInExtendMatchSuperClassName(String superClassQualifiedName,\n                                                               String superClassInExtendClause) {\n        String superClassNormalizedName = superClassQualifiedName;\n        if (!superClassInExtendClause.contains(PACKAGE_SEPARATOR)) {\n            superClassNormalizedName = getClassNameFromQualifiedName(superClassQualifiedName);\n        }\n        return superClassNormalizedName.equals(superClassInExtendClause);\n    }\n\n    /**\n     * Get class name from qualified name.\n     *\n     * @param qualifiedName qualified class name\n     * @return class name\n     */\n    private static String getClassNameFromQualifiedName(String qualifiedName) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(PACKAGE_SEPARATOR) + 1);\n    }\n\n    /** Maintains information about class' ctors. */\n    private static final class ClassDesc {\n\n        /** Qualified class name(with package). */\n        private final String qualifiedName;\n\n        /** Is class declared as final. */\n        private final boolean declaredAsFinal;\n\n        /** Is class declared as abstract. */\n        private final boolean declaredAsAbstract;\n\n        /** Does class have non-private ctors. */\n        private boolean withNonPrivateCtor;\n\n        /** Does class have private ctors. */\n        private boolean withPrivateCtor;\n\n        /** Does class have nested subclass. */\n        private boolean withNestedSubclass;\n\n        /** Does class have anonymous inner class. */\n        private boolean withAnonymousInnerClass;\n\n        /**\n         *  Create a new ClassDesc instance.\n         *\n         *  @param qualifiedName qualified class name(with package)\n         *  @param declaredAsFinal indicates if the\n         *         class declared as final\n         *  @param declaredAsAbstract indicates if the\n         *         class declared as abstract\n         */\n        /* package */ ClassDesc(String qualifiedName, boolean declaredAsFinal,\n                boolean declaredAsAbstract) {\n            this.qualifiedName = qualifiedName;\n            this.declaredAsFinal = declaredAsFinal;\n            this.declaredAsAbstract = declaredAsAbstract;\n        }\n\n        /**\n         * Get qualified class name.\n         *\n         * @return qualified class name\n         */\n        private String getQualifiedName() {\n            return qualifiedName;\n        }\n\n        /** Adds private ctor. */\n        private void registerPrivateCtor() {\n            withPrivateCtor = true;\n        }\n\n        /** Adds non-private ctor. */\n        private void registerNonPrivateCtor() {\n            withNonPrivateCtor = true;\n        }\n\n        /** Adds nested subclass. */\n        private void registerNestedSubclass() {\n            withNestedSubclass = true;\n        }\n\n        /** Adds anonymous inner class. */\n        private void registerAnonymousInnerClass() {\n            withAnonymousInnerClass = true;\n        }\n\n        /**\n         *  Does class have private ctors.\n         *\n         *  @return true if class has private ctors\n         */\n        private boolean isWithPrivateCtor() {\n            return withPrivateCtor;\n        }\n\n        /**\n         *  Does class have non-private ctors.\n         *\n         *  @return true if class has non-private ctors\n         */\n        private boolean isWithNonPrivateCtor() {\n            return withNonPrivateCtor;\n        }\n\n        /**\n         * Does class have nested subclass.\n         *\n         * @return true if class has nested subclass\n         */\n        private boolean isWithNestedSubclass() {\n            return withNestedSubclass;\n        }\n\n        /**\n         *  Is class declared as final.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsFinal() {\n            return declaredAsFinal;\n        }\n\n        /**\n         *  Is class declared as abstract.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsAbstract() {\n            return declaredAsAbstract;\n        }\n\n        /**\n         * Does class have an anonymous inner class.\n         *\n         * @return true if class has anonymous inner class\n         */\n        private boolean isWithAnonymousInnerClass() {\n            return withAnonymousInnerClass;\n        }\n\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.design;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n\n/**\n * <p>\n * Checks that a class which has only private constructors\n * is declared as final. Doesn't check for classes nested in interfaces\n * or annotations, as they are always {@code final} there.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;FinalClass&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * final class MyClass {  // OK\n *   private MyClass() { }\n * }\n *\n * class MyClass { // violation, class should be declared final\n *   private MyClass() { }\n * }\n *\n * class MyClass { // OK, since it has a public constructor\n *   int field1;\n *   String field2;\n *   private MyClass(int value) {\n *     this.field1 = value;\n *     this.field2 = \" \";\n *   }\n *   public MyClass(String value) {\n *     this.field2 = value;\n *     this.field1 = 0;\n *   }\n * }\n *\n * interface CheckInterface\n * {\n *   class MyClass { // OK, nested class in interface is always final\n *     private MyClass() {}\n *   }\n * }\n *\n * public @interface Test {\n *   public boolean enabled()\n *   default true;\n *   class MyClass { // OK, class nested in an annotation is always final\n *     private MyClass() { }\n *   }\n * }\n *\n * class TestAnonymousInnerClasses { // OK, class has an anonymous inner class.\n *     public static final TestAnonymousInnerClasses ONE = new TestAnonymousInnerClasses() {\n *\n *     };\n *\n *     private TestAnonymousInnerClasses() {\n *     }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code final.class}\n * </li>\n * </ul>\n *\n * @since 3.1\n */\n@FileStatefulCheck\npublic class FinalClassCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"final.class\";\n\n    /**\n     * Character separate package names in qualified name of java class.\n     */\n    private static final String PACKAGE_SEPARATOR = \".\";\n\n    /** Keeps ClassDesc objects for stack of declared classes. */\n    private Deque<ClassDesc> classes;\n\n    /** Full qualified name of the package. */\n    private String packageName;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CLASS_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n        };\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        classes = new ArrayDeque<>();\n        packageName = \"\";\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                visitClass(ast);\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                visitCtor(ast);\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    /**\n     * Called to process a type definition.\n     *\n     * @param ast the token to process\n     */\n    private void visitClass(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n        registerNestedSubclassToOuterSuperClasses(ast);\n\n        final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n        final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n        final String qualifiedClassName = getQualifiedClassName(ast);\n        classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n    }\n\n    /**\n     * Called to process a constructor definition.\n     *\n     * @param ast the token to process\n     */\n    private void visitCtor(DetailAST ast) {\n        if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n            final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n            final ClassDesc desc = classes.peek();\n            if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                desc.registerNonPrivateCtor();\n            }\n            else {\n                desc.registerPrivateCtor();\n            }\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.CLASS_DEF) {\n            final ClassDesc desc = classes.pop();\n            if (desc.isWithPrivateCtor()\n                && !(desc.isDeclaredAsAbstract()\n                    || desc.isWithAnonymousInnerClass())\n                && !desc.isDeclaredAsFinal()\n                && !desc.isWithNonPrivateCtor()\n                && !desc.isWithNestedSubclass()\n                && !ScopeUtil.isInInterfaceOrAnnotationBlock(ast)) {\n                final String qualifiedName = desc.getQualifiedName();\n                final String className = getClassNameFromQualifiedName(qualifiedName);\n                log(ast, MSG_KEY, className);\n            }\n        }\n    }\n\n    /**\n     * Get name of class (with qualified package if specified) in {@code ast}.\n     *\n     * @param ast ast to extract class name from\n     * @return qualified name\n     */\n    private static String extractQualifiedName(DetailAST ast) {\n        return FullIdent.createFullIdent(ast).getText();\n    }\n\n    /**\n     * Register to outer super classes of given classAst that\n     * given classAst is extending them.\n     *\n     * @param classAst class which outer super classes will be\n     *                 informed about nesting subclass\n     */\n    private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {\n        final String currentAstSuperClassName = getSuperClassName(classAst);\n        if (currentAstSuperClassName != null) {\n            for (ClassDesc classDesc : classes) {\n                final String classDescQualifiedName = classDesc.getQualifiedName();\n                if (doesNameInExtendMatchSuperClassName(classDescQualifiedName,\n                        currentAstSuperClassName)) {\n                    classDesc.registerNestedSubclass();\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if class name matches with anonymous inner class name.\n     *\n     * @param ast current ast.\n     * @param classDesc class to match.\n     * @return true if current class name matches anonymous inner\n     *         class name.\n     */\n    private static boolean doesNameOfClassMatchAnonymousInnerClassName(DetailAST ast,\n                                                               ClassDesc classDesc) {\n        final String[] className = classDesc.getQualifiedName().split(\"\\\\.\");\n        return ast.getFirstChild().getText().equals(className[className.length - 1]);\n    }\n\n    /**\n     * Get qualified class name from given class Ast.\n     *\n     * @param classAst class to get qualified class name\n     * @return qualified class name of a class\n     */\n    private String getQualifiedClassName(DetailAST classAst) {\n        final String className = classAst.findFirstToken(TokenTypes.IDENT).getText();\n        String outerClassQualifiedName = null;\n        if (!classes.isEmpty()) {\n            outerClassQualifiedName = classes.peek().getQualifiedName();\n        }\n        return getQualifiedClassName(packageName, outerClassQualifiedName, className);\n    }\n\n    /**\n     * Calculate qualified class name(package + class name) laying inside given\n     * outer class.\n     *\n     * @param packageName package name, empty string on default package\n     * @param outerClassQualifiedName qualified name(package + class) of outer class,\n     *                           null if doesn't exist\n     * @param className class name\n     * @return qualified class name(package + class name)\n     */\n    private static String getQualifiedClassName(String packageName, String outerClassQualifiedName,\n                                                String className) {\n        final String qualifiedClassName;\n\n        if (outerClassQualifiedName == null) {\n            if (packageName.isEmpty()) {\n                qualifiedClassName = className;\n            }\n            else {\n                qualifiedClassName = packageName + PACKAGE_SEPARATOR + className;\n            }\n        }\n        else {\n            qualifiedClassName = outerClassQualifiedName + PACKAGE_SEPARATOR + className;\n        }\n        return qualifiedClassName;\n    }\n\n    /**\n     * Get super class name of given class.\n     *\n     * @param classAst class\n     * @return super class name or null if super class is not specified\n     */\n    private static String getSuperClassName(DetailAST classAst) {\n        String superClassName = null;\n        final DetailAST classExtend = classAst.findFirstToken(TokenTypes.EXTENDS_CLAUSE);\n        if (classExtend != null) {\n            superClassName = extractQualifiedName(classExtend.getFirstChild());\n        }\n        return superClassName;\n    }\n\n    /**\n     * Checks if given super class name in extend clause match super class qualified name.\n     *\n     * @param superClassQualifiedName super class qualified name (with package)\n     * @param superClassInExtendClause name in extend clause\n     * @return true if given super class name in extend clause match super class qualified name,\n     *         false otherwise\n     */\n    private static boolean doesNameInExtendMatchSuperClassName(String superClassQualifiedName,\n                                                               String superClassInExtendClause) {\n        String superClassNormalizedName = superClassQualifiedName;\n        if (!superClassInExtendClause.contains(PACKAGE_SEPARATOR)) {\n            superClassNormalizedName = getClassNameFromQualifiedName(superClassQualifiedName);\n        }\n        return superClassNormalizedName.equals(superClassInExtendClause);\n    }\n\n    /**\n     * Get class name from qualified name.\n     *\n     * @param qualifiedName qualified class name\n     * @return class name\n     */\n    private static String getClassNameFromQualifiedName(String qualifiedName) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(PACKAGE_SEPARATOR) + 1);\n    }\n\n    /** Maintains information about class' ctors. */\n    private static final class ClassDesc {\n\n        /** Qualified class name(with package). */\n        private final String qualifiedName;\n\n        /** Is class declared as final. */\n        private final boolean declaredAsFinal;\n\n        /** Is class declared as abstract. */\n        private final boolean declaredAsAbstract;\n\n        /** Does class have non-private ctors. */\n        private boolean withNonPrivateCtor;\n\n        /** Does class have private ctors. */\n        private boolean withPrivateCtor;\n\n        /** Does class have nested subclass. */\n        private boolean withNestedSubclass;\n\n        /** Does class have anonymous inner class. */\n        private boolean withAnonymousInnerClass;\n\n        /**\n         *  Create a new ClassDesc instance.\n         *\n         *  @param qualifiedName qualified class name(with package)\n         *  @param declaredAsFinal indicates if the\n         *         class declared as final\n         *  @param declaredAsAbstract indicates if the\n         *         class declared as abstract\n         */\n        /* package */ ClassDesc(String qualifiedName, boolean declaredAsFinal,\n                boolean declaredAsAbstract) {\n            this.qualifiedName = qualifiedName;\n            this.declaredAsFinal = declaredAsFinal;\n            this.declaredAsAbstract = declaredAsAbstract;\n        }\n\n        /**\n         * Get qualified class name.\n         *\n         * @return qualified class name\n         */\n        private String getQualifiedName() {\n            return qualifiedName;\n        }\n\n        /** Adds private ctor. */\n        private void registerPrivateCtor() {\n            withPrivateCtor = true;\n        }\n\n        /** Adds non-private ctor. */\n        private void registerNonPrivateCtor() {\n            withNonPrivateCtor = true;\n        }\n\n        /** Adds nested subclass. */\n        private void registerNestedSubclass() {\n            withNestedSubclass = true;\n        }\n\n        /** Adds anonymous inner class. */\n        private void registerAnonymousInnerClass() {\n            withAnonymousInnerClass = true;\n        }\n\n        /**\n         *  Does class have private ctors.\n         *\n         *  @return true if class has private ctors\n         */\n        private boolean isWithPrivateCtor() {\n            return withPrivateCtor;\n        }\n\n        /**\n         *  Does class have non-private ctors.\n         *\n         *  @return true if class has non-private ctors\n         */\n        private boolean isWithNonPrivateCtor() {\n            return withNonPrivateCtor;\n        }\n\n        /**\n         * Does class have nested subclass.\n         *\n         * @return true if class has nested subclass\n         */\n        private boolean isWithNestedSubclass() {\n            return withNestedSubclass;\n        }\n\n        /**\n         *  Is class declared as final.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsFinal() {\n            return declaredAsFinal;\n        }\n\n        /**\n         *  Is class declared as abstract.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsAbstract() {\n            return declaredAsAbstract;\n        }\n\n        /**\n         * Does class have an anonymous inner class.\n         *\n         * @return true if class has anonymous inner class\n         */\n        private boolean isWithAnonymousInnerClass() {\n            return withAnonymousInnerClass;\n        }\n\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Called to process a type definition.\n     *\n     * @param ast the token to process\n     */\n    private void visitClass(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n        registerNestedSubclassToOuterSuperClasses(ast);\n\n        final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n        final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n        final String qualifiedClassName = getQualifiedClassName(ast);\n        classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#extractQualifiedName\n methodBody: private static String extractQualifiedName(DetailAST ast) {\nreturn FullIdent.createFullIdent(ast).getText();\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerNonPrivateCtor\n methodBody: private void registerNonPrivateCtor() {\nwithNonPrivateCtor=true;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#doesNameOfClassMatchAnonymousInnerClassName\n methodBody: private static boolean doesNameOfClassMatchAnonymousInnerClassName(DetailAST ast,\n                                                               ClassDesc classDesc) {\nfinal String[] className=classDesc.getQualifiedName().split(\"\\\\.\");\nreturn ast.getFirstChild().getText().equals(className[className.length - 1]);\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#registerNestedSubclassToOuterSuperClasses\n methodBody: private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {\nfinal String currentAstSuperClassName=getSuperClassName(classAst);\nif(currentAstSuperClassName != null){for(ClassDesc classDesc: classes){final String classDescQualifiedName=classDesc.getQualifiedName();\nif(doesNameInExtendMatchSuperClassName(classDescQualifiedName,currentAstSuperClassName)){classDesc.registerNestedSubclass();\n}}}}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerAnonymousInnerClass\n methodBody: private void registerAnonymousInnerClass() {\nwithAnonymousInnerClass=true;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck#getQualifiedClassName\n methodBody: private static String getQualifiedClassName(String packageName, String outerClassQualifiedName,\n                                                String className) {\nfinal String qualifiedClassName;\nif(outerClassQualifiedName == null){if(packageName.isEmpty()){qualifiedClassName=className;\n}{qualifiedClassName=packageName + PACKAGE_SEPARATOR + className;\n}}{qualifiedClassName=outerClassQualifiedName + PACKAGE_SEPARATOR + className;\n}return qualifiedClassName;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.design.FinalClassCheck.ClassDesc#registerPrivateCtor\n methodBody: private void registerPrivateCtor() {\nwithPrivateCtor=true;\n}"], "sourceCodeAfterRefactoring": "@Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                visitClass(ast);\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                visitCtor(ast);\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n/**\n     * Called to process a type definition.\n     *\n     * @param ast the token to process\n     */\n    private void visitClass(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n        registerNestedSubclassToOuterSuperClasses(ast);\n\n        final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n        final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n        final String qualifiedClassName = getQualifiedClassName(ast);\n        classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n    }", "diffSourceCode": "   154:     @Override\n   155:     public void visitToken(DetailAST ast) {\n-  156:         final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n-  157: \n-  158:         switch (ast.getType()) {\n-  159:             case TokenTypes.PACKAGE_DEF:\n-  160:                 packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n-  161:                 break;\n-  162: \n-  163:             case TokenTypes.CLASS_DEF:\n-  164:                 registerNestedSubclassToOuterSuperClasses(ast);\n-  165: \n-  166:                 final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n-  167:                 final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n+  156:         switch (ast.getType()) {\n+  157:             case TokenTypes.PACKAGE_DEF:\n+  158:                 packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n+  159:                 break;\n+  160: \n+  161:             case TokenTypes.CLASS_DEF:\n+  162:                 visitClass(ast);\n+  163:                 break;\n+  164: \n+  165:             case TokenTypes.CTOR_DEF:\n+  166:                 visitCtor(ast);\n+  167:                 break;\n   168: \n-  169:                 final String qualifiedClassName = getQualifiedClassName(ast);\n-  170:                 classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n-  171:                 break;\n-  172: \n-  173:             case TokenTypes.CTOR_DEF:\n-  174:                 if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n-  175:                     final ClassDesc desc = classes.peek();\n-  176:                     if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n-  177:                         desc.registerNonPrivateCtor();\n-  178:                     }\n-  179:                     else {\n-  180:                         desc.registerPrivateCtor();\n-  181:                     }\n-  182:                 }\n-  183:                 break;\n+  169:             case TokenTypes.LITERAL_NEW:\n+  170:                 if (ast.getFirstChild() != null\n+  171:                         && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n+  172:                     for (ClassDesc classDesc : classes) {\n+  173:                         if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n+  174:                             classDesc.registerAnonymousInnerClass();\n+  175:                         }\n+  176:                     }\n+  177:                 }\n+  178:                 break;\n+  179: \n+  180:             default:\n+  181:                 throw new IllegalStateException(ast.toString());\n+  182:         }\n+  183:     }\n   184: \n-  185:             case TokenTypes.LITERAL_NEW:\n-  186:                 if (ast.getFirstChild() != null\n-  187:                         && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n-  188:                     for (ClassDesc classDesc : classes) {\n-  189:                         if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n-  190:                             classDesc.registerAnonymousInnerClass();\n-  191:                         }\n-  192:                     }\n-  193:                 }\n-  194:                 break;\n-  195: \n-  196:             default:\n-  197:                 throw new IllegalStateException(ast.toString());\n-  198:         }\n+  185:     /**\n+  186:      * Called to process a type definition.\n+  187:      *\n+  188:      * @param ast the token to process\n+  189:      */\n+  190:     private void visitClass(DetailAST ast) {\n+  191:         final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n+  192:         registerNestedSubclassToOuterSuperClasses(ast);\n+  193: \n+  194:         final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n+  195:         final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n+  196: \n+  197:         final String qualifiedClassName = getQualifiedClassName(ast);\n+  198:         classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n   199:     }\n", "uniqueId": "50a9a64b6d70aa722dcf754ad5d46e37784f5b05_154_199_185_199_154_183", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": false, "compileJDK": 11, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 102}, "BRANCH": {"missed": 0, "covered": 23}, "LINE": {"missed": 0, "covered": 24}, "COMPLEXITY": {"missed": 0, "covered": 14}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "##########################\n// Refactored code after applying Extract Method refactoring\n\n@Override\npublic void visitToken(DetailAST ast) {\n    final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n\n    switch (ast.getType()) {\n        case TokenTypes.PACKAGE_DEF:\n            extractPackageName(ast);\n            break;\n\n        case TokenTypes.CLASS_DEF:\n            registerClass(ast, modifiers);\n            break;\n\n        case TokenTypes.CTOR_DEF:\n            processConstructor(ast, modifiers);\n            break;\n\n        case TokenTypes.LITERAL_NEW:\n            processNewLiteral(ast);\n            break;\n\n        default:\n            throw new IllegalStateException(ast.toString());\n    }\n}\n\nprivate void extractPackageName(DetailAST ast) {\n    packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n}\n\nprivate void registerClass(DetailAST ast, DetailAST modifiers) {\n    registerNestedSubclassToOuterSuperClasses(ast);\n\n    final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n    final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n    final String qualifiedClassName = getQualifiedClassName(ast);\n    classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n}\n\nprivate void processConstructor(DetailAST ast, DetailAST modifiers) {\n    if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n        final ClassDesc desc = classes.peek();\n        if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n            desc.registerNonPrivateCtor();\n        } else {\n            desc.registerPrivateCtor();\n        }\n    }\n}\n\nprivate void processNewLiteral(DetailAST ast) {\n    if (ast.getFirstChild() != null && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n        for (ClassDesc classDesc : classes) {\n            if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                classDesc.registerAnonymousInnerClass();\n            }\n        }\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public void visitToken(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                registerNestedSubclassToOuterSuperClasses(ast);\n\n                final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n                final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n                final String qualifiedClassName = getQualifiedClassName(ast);\n                classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n                    final ClassDesc desc = classes.peek();\n                    if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                        desc.registerNonPrivateCtor();\n                    }\n                    else {\n                        desc.registerPrivateCtor();\n                    }\n                }\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.design;\n\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.ScopeUtil;\n\n/**\n * <p>\n * Checks that a class which has only private constructors\n * is declared as final. Doesn't check for classes nested in interfaces\n * or annotations, as they are always {@code final} there.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;FinalClass&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * final class MyClass {  // OK\n *   private MyClass() { }\n * }\n *\n * class MyClass { // violation, class should be declared final\n *   private MyClass() { }\n * }\n *\n * class MyClass { // OK, since it has a public constructor\n *   int field1;\n *   String field2;\n *   private MyClass(int value) {\n *     this.field1 = value;\n *     this.field2 = \" \";\n *   }\n *   public MyClass(String value) {\n *     this.field2 = value;\n *     this.field1 = 0;\n *   }\n * }\n *\n * interface CheckInterface\n * {\n *   class MyClass { // OK, nested class in interface is always final\n *     private MyClass() {}\n *   }\n * }\n *\n * public @interface Test {\n *   public boolean enabled()\n *   default true;\n *   class MyClass { // OK, class nested in an annotation is always final\n *     private MyClass() { }\n *   }\n * }\n *\n * class TestAnonymousInnerClasses { // OK, class has an anonymous inner class.\n *     public static final TestAnonymousInnerClasses ONE = new TestAnonymousInnerClasses() {\n *\n *     };\n *\n *     private TestAnonymousInnerClasses() {\n *     }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code final.class}\n * </li>\n * </ul>\n *\n * @since 3.1\n */\n@FileStatefulCheck\npublic class FinalClassCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"final.class\";\n\n    /**\n     * Character separate package names in qualified name of java class.\n     */\n    private static final String PACKAGE_SEPARATOR = \".\";\n\n    /** Keeps ClassDesc objects for stack of declared classes. */\n    private Deque<ClassDesc> classes;\n\n    /** Full qualified name of the package. */\n    private String packageName;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CLASS_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.LITERAL_NEW,\n        };\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        classes = new ArrayDeque<>();\n        packageName = \"\";\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                packageName = extractQualifiedName(ast.getFirstChild().getNextSibling());\n                break;\n\n            case TokenTypes.CLASS_DEF:\n                registerNestedSubclassToOuterSuperClasses(ast);\n\n                final boolean isFinal = modifiers.findFirstToken(TokenTypes.FINAL) != null;\n                final boolean isAbstract = modifiers.findFirstToken(TokenTypes.ABSTRACT) != null;\n\n                final String qualifiedClassName = getQualifiedClassName(ast);\n                classes.push(new ClassDesc(qualifiedClassName, isFinal, isAbstract));\n                break;\n\n            case TokenTypes.CTOR_DEF:\n                if (!ScopeUtil.isInEnumBlock(ast) && !ScopeUtil.isInRecordBlock(ast)) {\n                    final ClassDesc desc = classes.peek();\n                    if (modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) == null) {\n                        desc.registerNonPrivateCtor();\n                    }\n                    else {\n                        desc.registerPrivateCtor();\n                    }\n                }\n                break;\n\n            case TokenTypes.LITERAL_NEW:\n                if (ast.getFirstChild() != null\n                        && ast.getLastChild().getType() == TokenTypes.OBJBLOCK) {\n                    for (ClassDesc classDesc : classes) {\n                        if (doesNameOfClassMatchAnonymousInnerClassName(ast, classDesc)) {\n                            classDesc.registerAnonymousInnerClass();\n                        }\n                    }\n                }\n                break;\n\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.CLASS_DEF) {\n            final ClassDesc desc = classes.pop();\n            if (desc.isWithPrivateCtor()\n                && !(desc.isDeclaredAsAbstract()\n                    || desc.isWithAnonymousInnerClass())\n                && !desc.isDeclaredAsFinal()\n                && !desc.isWithNonPrivateCtor()\n                && !desc.isWithNestedSubclass()\n                && !ScopeUtil.isInInterfaceOrAnnotationBlock(ast)) {\n                final String qualifiedName = desc.getQualifiedName();\n                final String className = getClassNameFromQualifiedName(qualifiedName);\n                log(ast, MSG_KEY, className);\n            }\n        }\n    }\n\n    /**\n     * Get name of class (with qualified package if specified) in {@code ast}.\n     *\n     * @param ast ast to extract class name from\n     * @return qualified name\n     */\n    private static String extractQualifiedName(DetailAST ast) {\n        return FullIdent.createFullIdent(ast).getText();\n    }\n\n    /**\n     * Register to outer super classes of given classAst that\n     * given classAst is extending them.\n     *\n     * @param classAst class which outer super classes will be\n     *                 informed about nesting subclass\n     */\n    private void registerNestedSubclassToOuterSuperClasses(DetailAST classAst) {\n        final String currentAstSuperClassName = getSuperClassName(classAst);\n        if (currentAstSuperClassName != null) {\n            for (ClassDesc classDesc : classes) {\n                final String classDescQualifiedName = classDesc.getQualifiedName();\n                if (doesNameInExtendMatchSuperClassName(classDescQualifiedName,\n                        currentAstSuperClassName)) {\n                    classDesc.registerNestedSubclass();\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if class name matches with anonymous inner class name.\n     *\n     * @param ast current ast.\n     * @param classDesc class to match.\n     * @return true if current class name matches anonymous inner\n     *         class name.\n     */\n    private static boolean doesNameOfClassMatchAnonymousInnerClassName(DetailAST ast,\n                                                               ClassDesc classDesc) {\n        final String[] className = classDesc.getQualifiedName().split(\"\\\\.\");\n        return ast.getFirstChild().getText().equals(className[className.length - 1]);\n    }\n\n    /**\n     * Get qualified class name from given class Ast.\n     *\n     * @param classAst class to get qualified class name\n     * @return qualified class name of a class\n     */\n    private String getQualifiedClassName(DetailAST classAst) {\n        final String className = classAst.findFirstToken(TokenTypes.IDENT).getText();\n        String outerClassQualifiedName = null;\n        if (!classes.isEmpty()) {\n            outerClassQualifiedName = classes.peek().getQualifiedName();\n        }\n        return getQualifiedClassName(packageName, outerClassQualifiedName, className);\n    }\n\n    /**\n     * Calculate qualified class name(package + class name) laying inside given\n     * outer class.\n     *\n     * @param packageName package name, empty string on default package\n     * @param outerClassQualifiedName qualified name(package + class) of outer class,\n     *                           null if doesn't exist\n     * @param className class name\n     * @return qualified class name(package + class name)\n     */\n    private static String getQualifiedClassName(String packageName, String outerClassQualifiedName,\n                                                String className) {\n        final String qualifiedClassName;\n\n        if (outerClassQualifiedName == null) {\n            if (packageName.isEmpty()) {\n                qualifiedClassName = className;\n            }\n            else {\n                qualifiedClassName = packageName + PACKAGE_SEPARATOR + className;\n            }\n        }\n        else {\n            qualifiedClassName = outerClassQualifiedName + PACKAGE_SEPARATOR + className;\n        }\n        return qualifiedClassName;\n    }\n\n    /**\n     * Get super class name of given class.\n     *\n     * @param classAst class\n     * @return super class name or null if super class is not specified\n     */\n    private static String getSuperClassName(DetailAST classAst) {\n        String superClassName = null;\n        final DetailAST classExtend = classAst.findFirstToken(TokenTypes.EXTENDS_CLAUSE);\n        if (classExtend != null) {\n            superClassName = extractQualifiedName(classExtend.getFirstChild());\n        }\n        return superClassName;\n    }\n\n    /**\n     * Checks if given super class name in extend clause match super class qualified name.\n     *\n     * @param superClassQualifiedName super class qualified name (with package)\n     * @param superClassInExtendClause name in extend clause\n     * @return true if given super class name in extend clause match super class qualified name,\n     *         false otherwise\n     */\n    private static boolean doesNameInExtendMatchSuperClassName(String superClassQualifiedName,\n                                                               String superClassInExtendClause) {\n        String superClassNormalizedName = superClassQualifiedName;\n        if (!superClassInExtendClause.contains(PACKAGE_SEPARATOR)) {\n            superClassNormalizedName = getClassNameFromQualifiedName(superClassQualifiedName);\n        }\n        return superClassNormalizedName.equals(superClassInExtendClause);\n    }\n\n    /**\n     * Get class name from qualified name.\n     *\n     * @param qualifiedName qualified class name\n     * @return class name\n     */\n    private static String getClassNameFromQualifiedName(String qualifiedName) {\n        return qualifiedName.substring(qualifiedName.lastIndexOf(PACKAGE_SEPARATOR) + 1);\n    }\n\n    /** Maintains information about class' ctors. */\n    private static final class ClassDesc {\n\n        /** Qualified class name(with package). */\n        private final String qualifiedName;\n\n        /** Is class declared as final. */\n        private final boolean declaredAsFinal;\n\n        /** Is class declared as abstract. */\n        private final boolean declaredAsAbstract;\n\n        /** Does class have non-private ctors. */\n        private boolean withNonPrivateCtor;\n\n        /** Does class have private ctors. */\n        private boolean withPrivateCtor;\n\n        /** Does class have nested subclass. */\n        private boolean withNestedSubclass;\n\n        /** Does class have anonymous inner class. */\n        private boolean withAnonymousInnerClass;\n\n        /**\n         *  Create a new ClassDesc instance.\n         *\n         *  @param qualifiedName qualified class name(with package)\n         *  @param declaredAsFinal indicates if the\n         *         class declared as final\n         *  @param declaredAsAbstract indicates if the\n         *         class declared as abstract\n         */\n        /* package */ ClassDesc(String qualifiedName, boolean declaredAsFinal,\n                boolean declaredAsAbstract) {\n            this.qualifiedName = qualifiedName;\n            this.declaredAsFinal = declaredAsFinal;\n            this.declaredAsAbstract = declaredAsAbstract;\n        }\n\n        /**\n         * Get qualified class name.\n         *\n         * @return qualified class name\n         */\n        private String getQualifiedName() {\n            return qualifiedName;\n        }\n\n        /** Adds private ctor. */\n        private void registerPrivateCtor() {\n            withPrivateCtor = true;\n        }\n\n        /** Adds non-private ctor. */\n        private void registerNonPrivateCtor() {\n            withNonPrivateCtor = true;\n        }\n\n        /** Adds nested subclass. */\n        private void registerNestedSubclass() {\n            withNestedSubclass = true;\n        }\n\n        /** Adds anonymous inner class. */\n        private void registerAnonymousInnerClass() {\n            withAnonymousInnerClass = true;\n        }\n\n        /**\n         *  Does class have private ctors.\n         *\n         *  @return true if class has private ctors\n         */\n        private boolean isWithPrivateCtor() {\n            return withPrivateCtor;\n        }\n\n        /**\n         *  Does class have non-private ctors.\n         *\n         *  @return true if class has non-private ctors\n         */\n        private boolean isWithNonPrivateCtor() {\n            return withNonPrivateCtor;\n        }\n\n        /**\n         * Does class have nested subclass.\n         *\n         * @return true if class has nested subclass\n         */\n        private boolean isWithNestedSubclass() {\n            return withNestedSubclass;\n        }\n\n        /**\n         *  Is class declared as final.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsFinal() {\n            return declaredAsFinal;\n        }\n\n        /**\n         *  Is class declared as abstract.\n         *\n         *  @return true if class is declared as final\n         */\n        private boolean isDeclaredAsAbstract() {\n            return declaredAsAbstract;\n        }\n\n        /**\n         * Does class have an anonymous inner class.\n         *\n         * @return true if class has anonymous inner class\n         */\n        private boolean isWithAnonymousInnerClass() {\n            return withAnonymousInnerClass;\n        }\n\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate checkConstructorModifiers(ctorDefAst DetailAST) : void extracted from public visitToken(ast DetailAST) : void in class com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java", "startLine": 231, "endLine": 259, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java", "startLine": 232, "endLine": 262, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java", "startLine": 264, "endLine": 276, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public void visitToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.INTERFACE_DEF) {\n            checkInterfaceModifiers(ast);\n        }\n        else if (ast.getType() == TokenTypes.ENUM_DEF) {\n            checkEnumDef(ast);\n        }\n        else {\n            if (ast.getType() == TokenTypes.CTOR_DEF) {\n                if (isEnumMember(ast)) {\n                    checkEnumConstructorModifiers(ast);\n                }\n                else {\n                    checkClassConstructorModifiers(ast);\n                }\n            }\n            else if (ast.getType() == TokenTypes.METHOD_DEF) {\n                processMethods(ast);\n            }\n            else if (ast.getType() == TokenTypes.RESOURCE) {\n                processResources(ast);\n            }\n\n            if (isInterfaceOrAnnotationMember(ast)) {\n                processInterfaceOrAnnotation(ast);\n            }\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java", "isPureRefactoring": true, "commitId": "466a1668f4b132a2f9029b1a035c6de304779e6b", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.modifier", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#visitToken", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#processResources\n methodBody: private void processResources(DetailAST ast) {\ncheckForRedundantModifier(ast,TokenTypes.FINAL);\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#checkClassConstructorModifiers\n methodBody: private void checkClassConstructorModifiers(DetailAST classCtorAst) {\nfinal DetailAST classDef=classCtorAst.getParent().getParent();\nif(!isClassPublic(classDef) && !isClassProtected(classDef)){checkForRedundantModifier(classCtorAst,TokenTypes.LITERAL_PUBLIC);\n}}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#processInterfaceOrAnnotation\n methodBody: private void processInterfaceOrAnnotation(DetailAST ast) {\nfinal DetailAST modifiers=ast.findFirstToken(TokenTypes.MODIFIERS);\nDetailAST modifier=modifiers.getFirstChild();\nwhile(modifier != null){final int type=modifier.getType();\nif(type == TokenTypes.LITERAL_PUBLIC || type == TokenTypes.LITERAL_STATIC && ast.getType() != TokenTypes.METHOD_DEF || type == TokenTypes.ABSTRACT && ast.getType() != TokenTypes.CLASS_DEF || type == TokenTypes.FINAL && ast.getType() != TokenTypes.CLASS_DEF){log(modifier,MSG_KEY,modifier.getText());\n}modifier=modifier.getNextSibling();\n}}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#processMethods\n methodBody: private void processMethods(DetailAST ast) {\nfinal DetailAST modifiers=ast.findFirstToken(TokenTypes.MODIFIERS);\nboolean checkFinal=modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) != null;\nDetailAST parent=ast.getParent();\nwhile(parent != null && !checkFinal){if(parent.getType() == TokenTypes.CLASS_DEF){final DetailAST classModifiers=parent.findFirstToken(TokenTypes.MODIFIERS);\ncheckFinal=classModifiers.findFirstToken(TokenTypes.FINAL) != null;\nparent=null;\n}if(parent.getType() == TokenTypes.LITERAL_NEW || parent.getType() == TokenTypes.ENUM_CONSTANT_DEF){checkFinal=true;\nparent=null;\n}if(parent.getType() == TokenTypes.ENUM_DEF){checkFinal=modifiers.findFirstToken(TokenTypes.LITERAL_STATIC) != null;\nparent=null;\n}{parent=parent.getParent();\n}}if(checkFinal && !isAnnotatedWithSafeVarargs(ast)){checkForRedundantModifier(ast,TokenTypes.FINAL);\n}if(ast.findFirstToken(TokenTypes.SLIST) == null){processAbstractMethodParameters(ast);\n}}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#checkInterfaceModifiers\n methodBody: private void checkInterfaceModifiers(DetailAST ast) {\nfinal DetailAST modifiers=ast.findFirstToken(TokenTypes.MODIFIERS);\nfor(final int tokenType: TOKENS_FOR_INTERFACE_MODIFIERS){final DetailAST modifier=modifiers.findFirstToken(tokenType);\nif(modifier != null){log(modifier,MSG_KEY,modifier.getText());\n}}}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#isEnumMember\n methodBody: private static boolean isEnumMember(DetailAST ast) {\nfinal DetailAST parentTypeDef=ast.getParent().getParent();\nreturn parentTypeDef.getType() == TokenTypes.ENUM_DEF;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#checkEnumConstructorModifiers\n methodBody: private void checkEnumConstructorModifiers(DetailAST ast) {\nfinal DetailAST modifiers=ast.findFirstToken(TokenTypes.MODIFIERS);\nTokenUtil.findFirstTokenByPredicate(modifiers,mod -> mod.getType() != TokenTypes.ANNOTATION).ifPresent(modifier -> log(modifier,MSG_KEY,modifier.getText()));\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#checkEnumDef\n methodBody: private void checkEnumDef(DetailAST ast) {\nif(isInterfaceOrAnnotationMember(ast)){processInterfaceOrAnnotation(ast);\n}{checkForRedundantModifier(ast,TokenTypes.LITERAL_STATIC);\n}}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#isInterfaceOrAnnotationMember\n methodBody: private static boolean isInterfaceOrAnnotationMember(DetailAST ast) {\nDetailAST parentTypeDef=ast.getParent();\nparentTypeDef=parentTypeDef.getParent();\nreturn parentTypeDef != null && (parentTypeDef.getType() == TokenTypes.INTERFACE_DEF || parentTypeDef.getType() == TokenTypes.ANNOTATION_DEF);\n}", "classSignatureBefore": "public class RedundantModifierCheck\n    extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#visitToken"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck"], "classSignatureBeforeSet": ["public class RedundantModifierCheck\n    extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All the mappings are matched! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.modifier;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * <p>\n * Checks for redundant modifiers.\n * </p>\n * <p>\n * Rationale: The Java Language Specification strongly discourages the usage\n * of {@code public} and {@code abstract} for method declarations in interface\n * definitions as a matter of style.\n * </p>\n * <p>The check validates:</p>\n * <ol>\n * <li>\n * Interface and annotation definitions.\n * </li>\n * <li>\n * Final modifier on methods of final and anonymous classes.\n * </li>\n * <li>\n * Inner {@code interface} declarations that are declared as {@code static}.\n * </li>\n * <li>\n * Class constructors.\n * </li>\n * <li>\n * Nested {@code enum} definitions that are declared as {@code static}.\n * </li>\n * </ol>\n * <p>\n * Interfaces by definition are abstract so the {@code abstract}\n * modifier on the interface is redundant.\n * </p>\n * <p>Classes inside of interfaces by definition are public and static,\n * so the {@code public} and {@code static} modifiers\n * on the inner classes are redundant. On the other hand, classes\n * inside of interfaces can be abstract or non abstract.\n * So, {@code abstract} modifier is allowed.\n * </p>\n * <p>Fields in interfaces and annotations are automatically\n * public, static and final, so these modifiers are redundant as\n * well.</p>\n *\n * <p>As annotations are a form of interface, their fields are also\n * automatically public, static and final just as their\n * annotation fields are automatically public and abstract.</p>\n *\n * <p>Enums by definition are static implicit subclasses of java.lang.Enum&#60;E&#62;.\n * So, the {@code static} modifier on the enums is redundant. In addition,\n * if enum is inside of interface, {@code public} modifier is also redundant.</p>\n *\n * <p>Enums can also contain abstract methods and methods which can be overridden by the declared\n * enumeration fields.\n * See the following example:</p>\n * <pre>\n * public enum EnumClass {\n *   FIELD_1,\n *   FIELD_2 {\n *     &#64;Override\n *     public final void method1() {} // violation expected\n *   };\n *\n *   public void method1() {}\n *   public final void method2() {} // no violation expected\n * }\n * </pre>\n *\n * <p>Since these methods can be overridden in these situations, the final methods are not\n * marked as redundant even though they can't be extended by other classes/enums.</p>\n * <p>\n * Nested {@code enum} types are always static by default.\n * </p>\n * <p>Final classes by definition cannot be extended so the {@code final}\n * modifier on the method of a final class is redundant.\n * </p>\n * <p>Public modifier for constructors in non-public non-protected classes\n * is always obsolete: </p>\n *\n * <pre>\n * public class PublicClass {\n *   public PublicClass() {} // OK\n * }\n *\n * class PackagePrivateClass {\n *   public PackagePrivateClass() {} // violation expected\n * }\n * </pre>\n *\n * <p>There is no violation in the following example,\n * because removing public modifier from ProtectedInnerClass\n * constructor will make this code not compiling: </p>\n *\n * <pre>\n * package a;\n * public class ClassExample {\n *   protected class ProtectedInnerClass {\n *     public ProtectedInnerClass () {}\n *   }\n * }\n *\n * package b;\n * import a.ClassExample;\n * public class ClassExtending extends ClassExample {\n *   ProtectedInnerClass pc = new ProtectedInnerClass();\n * }\n * </pre>\n * <ul>\n * <li>\n * Property {@code tokens} - tokens to check\n * Type is {@code java.lang.String[]}.\n * Validation type is {@code tokenSet}.\n * Default value is:\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#METHOD_DEF\">\n * METHOD_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#VARIABLE_DEF\">\n * VARIABLE_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ANNOTATION_FIELD_DEF\">\n * ANNOTATION_FIELD_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#INTERFACE_DEF\">\n * INTERFACE_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#CTOR_DEF\">\n * CTOR_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#CLASS_DEF\">\n * CLASS_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ENUM_DEF\">\n * ENUM_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#RESOURCE\">\n * RESOURCE</a>.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=\"RedundantModifier\"/&gt;\n * </pre>\n * <p>\n * To configure the check to check only methods and not variables:\n * </p>\n * <pre>\n * &lt;module name=\"RedundantModifier\"&gt;\n *   &lt;property name=\"tokens\" value=\"METHOD_DEF\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code redundantModifier}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@StatelessCheck\npublic class RedundantModifierCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"redundantModifier\";\n\n    /**\n     * An array of tokens for interface modifiers.\n     */\n    private static final int[] TOKENS_FOR_INTERFACE_MODIFIERS = {\n        TokenTypes.LITERAL_STATIC,\n        TokenTypes.ABSTRACT,\n    };\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getAcceptableTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return CommonUtil.EMPTY_INT_ARRAY;\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.METHOD_DEF,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.ANNOTATION_FIELD_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.RESOURCE,\n        };\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.INTERFACE_DEF) {\n            checkInterfaceModifiers(ast);\n        }\n        else if (ast.getType() == TokenTypes.ENUM_DEF) {\n            checkEnumDef(ast);\n        }\n        else {\n            if (ast.getType() == TokenTypes.CTOR_DEF) {\n                if (isEnumMember(ast)) {\n                    checkEnumConstructorModifiers(ast);\n                }\n                else {\n                    checkClassConstructorModifiers(ast);\n                }\n            }\n            else if (ast.getType() == TokenTypes.METHOD_DEF) {\n                processMethods(ast);\n            }\n            else if (ast.getType() == TokenTypes.RESOURCE) {\n                processResources(ast);\n            }\n\n            if (isInterfaceOrAnnotationMember(ast)) {\n                processInterfaceOrAnnotation(ast);\n            }\n        }\n    }\n\n    /**\n     * Checks if interface has proper modifiers.\n     *\n     * @param ast interface to check\n     */\n    private void checkInterfaceModifiers(DetailAST ast) {\n        final DetailAST modifiers =\n            ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        for (final int tokenType : TOKENS_FOR_INTERFACE_MODIFIERS) {\n            final DetailAST modifier =\n                    modifiers.findFirstToken(tokenType);\n            if (modifier != null) {\n                log(modifier, MSG_KEY, modifier.getText());\n            }\n        }\n    }\n\n    /**\n     * Check if enum constructor has proper modifiers.\n     *\n     * @param ast constructor of enum\n     */\n    private void checkEnumConstructorModifiers(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n        TokenUtil.findFirstTokenByPredicate(\n            modifiers, mod -> mod.getType() != TokenTypes.ANNOTATION\n        ).ifPresent(modifier -> log(modifier, MSG_KEY, modifier.getText()));\n    }\n\n    /**\n     * Checks whether enum has proper modifiers.\n     *\n     * @param ast enum definition.\n     */\n    private void checkEnumDef(DetailAST ast) {\n        if (isInterfaceOrAnnotationMember(ast)) {\n            processInterfaceOrAnnotation(ast);\n        }\n        else {\n            checkForRedundantModifier(ast, TokenTypes.LITERAL_STATIC);\n        }\n    }\n\n    /**\n     * Do validation of interface of annotation.\n     *\n     * @param ast token AST\n     */\n    private void processInterfaceOrAnnotation(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n        DetailAST modifier = modifiers.getFirstChild();\n        while (modifier != null) {\n            // javac does not allow final or static in interface methods\n            // order annotation fields hence no need to check that this\n            // is not a method or annotation field\n\n            final int type = modifier.getType();\n            if (type == TokenTypes.LITERAL_PUBLIC\n                || type == TokenTypes.LITERAL_STATIC\n                        && ast.getType() != TokenTypes.METHOD_DEF\n                || type == TokenTypes.ABSTRACT\n                        && ast.getType() != TokenTypes.CLASS_DEF\n                || type == TokenTypes.FINAL\n                        && ast.getType() != TokenTypes.CLASS_DEF) {\n                log(modifier, MSG_KEY, modifier.getText());\n            }\n\n            modifier = modifier.getNextSibling();\n        }\n    }\n\n    /**\n     * Process validation of Methods.\n     *\n     * @param ast method AST\n     */\n    private void processMethods(DetailAST ast) {\n        final DetailAST modifiers =\n                        ast.findFirstToken(TokenTypes.MODIFIERS);\n        // private method?\n        boolean checkFinal =\n            modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) != null;\n        // declared in a final class?\n        DetailAST parent = ast.getParent();\n        while (parent != null && !checkFinal) {\n            if (parent.getType() == TokenTypes.CLASS_DEF) {\n                final DetailAST classModifiers =\n                    parent.findFirstToken(TokenTypes.MODIFIERS);\n                checkFinal = classModifiers.findFirstToken(TokenTypes.FINAL) != null;\n                parent = null;\n            }\n            else if (parent.getType() == TokenTypes.LITERAL_NEW\n                    || parent.getType() == TokenTypes.ENUM_CONSTANT_DEF) {\n                checkFinal = true;\n                parent = null;\n            }\n            else if (parent.getType() == TokenTypes.ENUM_DEF) {\n                checkFinal = modifiers.findFirstToken(TokenTypes.LITERAL_STATIC) != null;\n                parent = null;\n            }\n            else {\n                parent = parent.getParent();\n            }\n        }\n        if (checkFinal && !isAnnotatedWithSafeVarargs(ast)) {\n            checkForRedundantModifier(ast, TokenTypes.FINAL);\n        }\n\n        if (ast.findFirstToken(TokenTypes.SLIST) == null) {\n            processAbstractMethodParameters(ast);\n        }\n    }\n\n    /**\n     * Process validation of parameters for Methods with no definition.\n     *\n     * @param ast method AST\n     */\n    private void processAbstractMethodParameters(DetailAST ast) {\n        final DetailAST parameters = ast.findFirstToken(TokenTypes.PARAMETERS);\n        TokenUtil.forEachChild(parameters, TokenTypes.PARAMETER_DEF, paramDef -> {\n            checkForRedundantModifier(paramDef, TokenTypes.FINAL);\n        });\n    }\n\n    /**\n     * Check if class constructor has proper modifiers.\n     *\n     * @param classCtorAst class constructor ast\n     */\n    private void checkClassConstructorModifiers(DetailAST classCtorAst) {\n        final DetailAST classDef = classCtorAst.getParent().getParent();\n        if (!isClassPublic(classDef) && !isClassProtected(classDef)) {\n            checkForRedundantModifier(classCtorAst, TokenTypes.LITERAL_PUBLIC);\n        }\n    }\n\n    /**\n     * Checks if given resource has redundant modifiers.\n     *\n     * @param ast ast\n     */\n    private void processResources(DetailAST ast) {\n        checkForRedundantModifier(ast, TokenTypes.FINAL);\n    }\n\n    /**\n     * Checks if given ast has a redundant modifier.\n     *\n     * @param ast ast\n     * @param modifierType The modifier to check for.\n     */\n    private void checkForRedundantModifier(DetailAST ast, int modifierType) {\n        Optional.ofNullable(ast.findFirstToken(TokenTypes.MODIFIERS))\n            .ifPresent(modifiers -> {\n                TokenUtil.forEachChild(modifiers, modifierType, modifier -> {\n                    log(modifier, MSG_KEY, modifier.getText());\n                });\n            });\n    }\n\n    /**\n     * Checks if given class ast has protected modifier.\n     *\n     * @param classDef class ast\n     * @return true if class is protected, false otherwise\n     */\n    private static boolean isClassProtected(DetailAST classDef) {\n        final DetailAST classModifiers =\n                classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classModifiers.findFirstToken(TokenTypes.LITERAL_PROTECTED) != null;\n    }\n\n    /**\n     * Checks if given class is accessible from \"public\" scope.\n     *\n     * @param ast class def to check\n     * @return true if class is accessible from public scope,false otherwise\n     */\n    private static boolean isClassPublic(DetailAST ast) {\n        boolean isAccessibleFromPublic = false;\n        final DetailAST modifiersAst = ast.findFirstToken(TokenTypes.MODIFIERS);\n        final boolean hasPublicModifier =\n                modifiersAst.findFirstToken(TokenTypes.LITERAL_PUBLIC) != null;\n\n        if (TokenUtil.isRootNode(ast.getParent())) {\n            isAccessibleFromPublic = hasPublicModifier;\n        }\n        else {\n            final DetailAST parentClassAst = ast.getParent().getParent();\n\n            if (hasPublicModifier || parentClassAst.getType() == TokenTypes.INTERFACE_DEF) {\n                isAccessibleFromPublic = isClassPublic(parentClassAst);\n            }\n        }\n\n        return isAccessibleFromPublic;\n    }\n\n    /**\n     * Checks if current AST node is member of Enum.\n     *\n     * @param ast AST node\n     * @return true if it is an enum member\n     */\n    private static boolean isEnumMember(DetailAST ast) {\n        final DetailAST parentTypeDef = ast.getParent().getParent();\n        return parentTypeDef.getType() == TokenTypes.ENUM_DEF;\n    }\n\n    /**\n     * Checks if current AST node is member of Interface or Annotation, not of their subnodes.\n     *\n     * @param ast AST node\n     * @return true or false\n     */\n    private static boolean isInterfaceOrAnnotationMember(DetailAST ast) {\n        DetailAST parentTypeDef = ast.getParent();\n        parentTypeDef = parentTypeDef.getParent();\n        return parentTypeDef != null\n                && (parentTypeDef.getType() == TokenTypes.INTERFACE_DEF\n                    || parentTypeDef.getType() == TokenTypes.ANNOTATION_DEF);\n    }\n\n    /**\n     * Checks if method definition is annotated with.\n     * <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html\">\n     * SafeVarargs</a> annotation\n     *\n     * @param methodDef method definition node\n     * @return true or false\n     */\n    private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        boolean result = false;\n        final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n        for (DetailAST annotationNode : methodAnnotationsList) {\n            if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the list of annotations on method definition.\n     *\n     * @param methodDef method definition node\n     * @return List of annotations\n     */\n    private static List<DetailAST> getMethodAnnotationsList(DetailAST methodDef) {\n        final List<DetailAST> annotationsList = new ArrayList<>();\n        final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);\n        TokenUtil.forEachChild(modifiers, TokenTypes.ANNOTATION, annotationsList::add);\n        return annotationsList;\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.modifier;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * <p>\n * Checks for redundant modifiers.\n * </p>\n * <p>\n * Rationale: The Java Language Specification strongly discourages the usage\n * of {@code public} and {@code abstract} for method declarations in interface\n * definitions as a matter of style.\n * </p>\n * <p>The check validates:</p>\n * <ol>\n * <li>\n * Interface and annotation definitions.\n * </li>\n * <li>\n * Final modifier on methods of final and anonymous classes.\n * </li>\n * <li>\n * Type declarations nested under interfaces that are declared as {@code public} or {@code static}.\n * </li>\n * <li>\n * Class constructors.\n * </li>\n * <li>\n * Nested {@code enum} definitions that are declared as {@code static}.\n * </li>\n * </ol>\n * <p>\n * interfaces by definition are abstract so the {@code abstract} modifier is redundant on them.\n * </p>\n * <p>Type declarations nested under interfaces by definition are public and static,\n * so the {@code public} and {@code static} modifiers on nested type declarations are redundant.\n * On the other hand, classes inside of interfaces can be abstract or non abstract.\n * So, {@code abstract} modifier is allowed.\n * </p>\n * <p>Fields in interfaces and annotations are automatically\n * public, static and final, so these modifiers are redundant as\n * well.</p>\n *\n * <p>As annotations are a form of interface, their fields are also\n * automatically public, static and final just as their\n * annotation fields are automatically public and abstract.</p>\n *\n * <p>Enums by definition are static implicit subclasses of java.lang.Enum&#60;E&#62;.\n * So, the {@code static} modifier on the enums is redundant. In addition,\n * if enum is inside of interface, {@code public} modifier is also redundant.</p>\n *\n * <p>Enums can also contain abstract methods and methods which can be overridden by the declared\n * enumeration fields.\n * See the following example:</p>\n * <pre>\n * public enum EnumClass {\n *   FIELD_1,\n *   FIELD_2 {\n *     &#64;Override\n *     public final void method1() {} // violation expected\n *   };\n *\n *   public void method1() {}\n *   public final void method2() {} // no violation expected\n * }\n * </pre>\n *\n * <p>Since these methods can be overridden in these situations, the final methods are not\n * marked as redundant even though they can't be extended by other classes/enums.</p>\n * <p>\n * Nested {@code enum} types are always static by default.\n * </p>\n * <p>Final classes by definition cannot be extended so the {@code final}\n * modifier on the method of a final class is redundant.\n * </p>\n * <p>Public modifier for constructors in non-public non-protected classes\n * is always obsolete: </p>\n *\n * <pre>\n * public class PublicClass {\n *   public PublicClass() {} // OK\n * }\n *\n * class PackagePrivateClass {\n *   public PackagePrivateClass() {} // violation expected\n * }\n * </pre>\n *\n * <p>There is no violation in the following example,\n * because removing public modifier from ProtectedInnerClass\n * constructor will make this code not compiling: </p>\n *\n * <pre>\n * package a;\n * public class ClassExample {\n *   protected class ProtectedInnerClass {\n *     public ProtectedInnerClass () {}\n *   }\n * }\n *\n * package b;\n * import a.ClassExample;\n * public class ClassExtending extends ClassExample {\n *   ProtectedInnerClass pc = new ProtectedInnerClass();\n * }\n * </pre>\n * <ul>\n * <li>\n * Property {@code tokens} - tokens to check\n * Type is {@code java.lang.String[]}.\n * Validation type is {@code tokenSet}.\n * Default value is:\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#METHOD_DEF\">\n * METHOD_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#VARIABLE_DEF\">\n * VARIABLE_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ANNOTATION_FIELD_DEF\">\n * ANNOTATION_FIELD_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#INTERFACE_DEF\">\n * INTERFACE_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#CTOR_DEF\">\n * CTOR_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#CLASS_DEF\">\n * CLASS_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ENUM_DEF\">\n * ENUM_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#RESOURCE\">\n * RESOURCE</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ANNOTATION_DEF\">\n * ANNOTATION_DEF</a>.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=\"RedundantModifier\"/&gt;\n * </pre>\n * <p>\n * To configure the check to check only methods and not variables:\n * </p>\n * <pre>\n * &lt;module name=\"RedundantModifier\"&gt;\n *   &lt;property name=\"tokens\" value=\"METHOD_DEF\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code redundantModifier}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@StatelessCheck\npublic class RedundantModifierCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"redundantModifier\";\n\n    /**\n     * An array of tokens for interface modifiers.\n     */\n    private static final int[] TOKENS_FOR_INTERFACE_MODIFIERS = {\n        TokenTypes.LITERAL_STATIC,\n        TokenTypes.ABSTRACT,\n    };\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getAcceptableTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return CommonUtil.EMPTY_INT_ARRAY;\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.METHOD_DEF,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.ANNOTATION_FIELD_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.RESOURCE,\n            TokenTypes.ANNOTATION_DEF,\n        };\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.INTERFACE_DEF:\n            case TokenTypes.ANNOTATION_DEF:\n                checkInterfaceModifiers(ast);\n                break;\n            case TokenTypes.ENUM_DEF:\n                checkForRedundantModifier(ast, TokenTypes.LITERAL_STATIC);\n                break;\n            case TokenTypes.CTOR_DEF:\n                checkConstructorModifiers(ast);\n                break;\n            case TokenTypes.METHOD_DEF:\n                processMethods(ast);\n                break;\n            case TokenTypes.RESOURCE:\n                processResources(ast);\n                break;\n            case TokenTypes.CLASS_DEF:\n            case TokenTypes.VARIABLE_DEF:\n            case TokenTypes.ANNOTATION_FIELD_DEF:\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected token type: \" + ast.getType());\n        }\n\n        if (isInterfaceOrAnnotationMember(ast)) {\n            processInterfaceOrAnnotation(ast);\n        }\n    }\n\n    /**\n     * Check modifiers of constructor.\n     *\n     * @param ctorDefAst ast node of type {@link TokenTypes#CTOR_DEF}\n     */\n    private void checkConstructorModifiers(DetailAST ctorDefAst) {\n        if (isEnumMember(ctorDefAst)) {\n            checkEnumConstructorModifiers(ctorDefAst);\n        }\n        else {\n            checkClassConstructorModifiers(ctorDefAst);\n        }\n    }\n\n    /**\n     * Checks if interface has proper modifiers.\n     *\n     * @param ast interface to check\n     */\n    private void checkInterfaceModifiers(DetailAST ast) {\n        final DetailAST modifiers =\n            ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        for (final int tokenType : TOKENS_FOR_INTERFACE_MODIFIERS) {\n            final DetailAST modifier =\n                    modifiers.findFirstToken(tokenType);\n            if (modifier != null) {\n                log(modifier, MSG_KEY, modifier.getText());\n            }\n        }\n    }\n\n    /**\n     * Check if enum constructor has proper modifiers.\n     *\n     * @param ast constructor of enum\n     */\n    private void checkEnumConstructorModifiers(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n        TokenUtil.findFirstTokenByPredicate(\n            modifiers, mod -> mod.getType() != TokenTypes.ANNOTATION\n        ).ifPresent(modifier -> log(modifier, MSG_KEY, modifier.getText()));\n    }\n\n    /**\n     * Do validation of interface of annotation.\n     *\n     * @param ast token AST\n     */\n    private void processInterfaceOrAnnotation(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n        DetailAST modifier = modifiers.getFirstChild();\n        while (modifier != null) {\n            // javac does not allow final or static in interface methods\n            // order annotation fields hence no need to check that this\n            // is not a method or annotation field\n\n            final int type = modifier.getType();\n            if (type == TokenTypes.LITERAL_PUBLIC\n                || type == TokenTypes.LITERAL_STATIC\n                        && ast.getType() != TokenTypes.METHOD_DEF\n                || type == TokenTypes.ABSTRACT\n                        && ast.getType() != TokenTypes.CLASS_DEF\n                || type == TokenTypes.FINAL\n                        && ast.getType() != TokenTypes.CLASS_DEF) {\n                log(modifier, MSG_KEY, modifier.getText());\n            }\n\n            modifier = modifier.getNextSibling();\n        }\n    }\n\n    /**\n     * Process validation of Methods.\n     *\n     * @param ast method AST\n     */\n    private void processMethods(DetailAST ast) {\n        final DetailAST modifiers =\n                        ast.findFirstToken(TokenTypes.MODIFIERS);\n        // private method?\n        boolean checkFinal =\n            modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) != null;\n        // declared in a final class?\n        DetailAST parent = ast.getParent();\n        while (parent != null && !checkFinal) {\n            if (parent.getType() == TokenTypes.CLASS_DEF) {\n                final DetailAST classModifiers =\n                    parent.findFirstToken(TokenTypes.MODIFIERS);\n                checkFinal = classModifiers.findFirstToken(TokenTypes.FINAL) != null;\n                parent = null;\n            }\n            else if (parent.getType() == TokenTypes.LITERAL_NEW\n                    || parent.getType() == TokenTypes.ENUM_CONSTANT_DEF) {\n                checkFinal = true;\n                parent = null;\n            }\n            else if (parent.getType() == TokenTypes.ENUM_DEF) {\n                checkFinal = modifiers.findFirstToken(TokenTypes.LITERAL_STATIC) != null;\n                parent = null;\n            }\n            else {\n                parent = parent.getParent();\n            }\n        }\n        if (checkFinal && !isAnnotatedWithSafeVarargs(ast)) {\n            checkForRedundantModifier(ast, TokenTypes.FINAL);\n        }\n\n        if (ast.findFirstToken(TokenTypes.SLIST) == null) {\n            processAbstractMethodParameters(ast);\n        }\n    }\n\n    /**\n     * Process validation of parameters for Methods with no definition.\n     *\n     * @param ast method AST\n     */\n    private void processAbstractMethodParameters(DetailAST ast) {\n        final DetailAST parameters = ast.findFirstToken(TokenTypes.PARAMETERS);\n        TokenUtil.forEachChild(parameters, TokenTypes.PARAMETER_DEF, paramDef -> {\n            checkForRedundantModifier(paramDef, TokenTypes.FINAL);\n        });\n    }\n\n    /**\n     * Check if class constructor has proper modifiers.\n     *\n     * @param classCtorAst class constructor ast\n     */\n    private void checkClassConstructorModifiers(DetailAST classCtorAst) {\n        final DetailAST classDef = classCtorAst.getParent().getParent();\n        if (!isClassPublic(classDef) && !isClassProtected(classDef)) {\n            checkForRedundantModifier(classCtorAst, TokenTypes.LITERAL_PUBLIC);\n        }\n    }\n\n    /**\n     * Checks if given resource has redundant modifiers.\n     *\n     * @param ast ast\n     */\n    private void processResources(DetailAST ast) {\n        checkForRedundantModifier(ast, TokenTypes.FINAL);\n    }\n\n    /**\n     * Checks if given ast has a redundant modifier.\n     *\n     * @param ast ast\n     * @param modifierType The modifier to check for.\n     */\n    private void checkForRedundantModifier(DetailAST ast, int modifierType) {\n        Optional.ofNullable(ast.findFirstToken(TokenTypes.MODIFIERS))\n            .ifPresent(modifiers -> {\n                TokenUtil.forEachChild(modifiers, modifierType, modifier -> {\n                    log(modifier, MSG_KEY, modifier.getText());\n                });\n            });\n    }\n\n    /**\n     * Checks if given class ast has protected modifier.\n     *\n     * @param classDef class ast\n     * @return true if class is protected, false otherwise\n     */\n    private static boolean isClassProtected(DetailAST classDef) {\n        final DetailAST classModifiers =\n                classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classModifiers.findFirstToken(TokenTypes.LITERAL_PROTECTED) != null;\n    }\n\n    /**\n     * Checks if given class is accessible from \"public\" scope.\n     *\n     * @param ast class def to check\n     * @return true if class is accessible from public scope,false otherwise\n     */\n    private static boolean isClassPublic(DetailAST ast) {\n        boolean isAccessibleFromPublic = false;\n        final DetailAST modifiersAst = ast.findFirstToken(TokenTypes.MODIFIERS);\n        final boolean hasPublicModifier =\n                modifiersAst.findFirstToken(TokenTypes.LITERAL_PUBLIC) != null;\n\n        if (TokenUtil.isRootNode(ast.getParent())) {\n            isAccessibleFromPublic = hasPublicModifier;\n        }\n        else {\n            final DetailAST parentClassAst = ast.getParent().getParent();\n\n            if (hasPublicModifier || parentClassAst.getType() == TokenTypes.INTERFACE_DEF) {\n                isAccessibleFromPublic = isClassPublic(parentClassAst);\n            }\n        }\n\n        return isAccessibleFromPublic;\n    }\n\n    /**\n     * Checks if current AST node is member of Enum.\n     *\n     * @param ast AST node\n     * @return true if it is an enum member\n     */\n    private static boolean isEnumMember(DetailAST ast) {\n        final DetailAST parentTypeDef = ast.getParent().getParent();\n        return parentTypeDef.getType() == TokenTypes.ENUM_DEF;\n    }\n\n    /**\n     * Checks if current AST node is member of Interface or Annotation, not of their subnodes.\n     *\n     * @param ast AST node\n     * @return true or false\n     */\n    private static boolean isInterfaceOrAnnotationMember(DetailAST ast) {\n        DetailAST parentTypeDef = ast.getParent();\n        parentTypeDef = parentTypeDef.getParent();\n        return parentTypeDef != null\n                && (parentTypeDef.getType() == TokenTypes.INTERFACE_DEF\n                    || parentTypeDef.getType() == TokenTypes.ANNOTATION_DEF);\n    }\n\n    /**\n     * Checks if method definition is annotated with.\n     * <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html\">\n     * SafeVarargs</a> annotation\n     *\n     * @param methodDef method definition node\n     * @return true or false\n     */\n    private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        boolean result = false;\n        final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n        for (DetailAST annotationNode : methodAnnotationsList) {\n            if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the list of annotations on method definition.\n     *\n     * @param methodDef method definition node\n     * @return List of annotations\n     */\n    private static List<DetailAST> getMethodAnnotationsList(DetailAST methodDef) {\n        final List<DetailAST> annotationsList = new ArrayList<>();\n        final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);\n        TokenUtil.forEachChild(modifiers, TokenTypes.ANNOTATION, annotationsList::add);\n        return annotationsList;\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Check modifiers of constructor.\n     *\n     * @param ctorDefAst ast node of type {@link TokenTypes#CTOR_DEF}\n     */\n    private void checkConstructorModifiers(DetailAST ctorDefAst) {\n        if (isEnumMember(ctorDefAst)) {\n            checkEnumConstructorModifiers(ctorDefAst);\n        }\n        else {\n            checkClassConstructorModifiers(ctorDefAst);\n        }\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#processResources\n methodBody: private void processResources(DetailAST ast) {\ncheckForRedundantModifier(ast,TokenTypes.FINAL);\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#checkClassConstructorModifiers\n methodBody: private void checkClassConstructorModifiers(DetailAST classCtorAst) {\nfinal DetailAST classDef=classCtorAst.getParent().getParent();\nif(!isClassPublic(classDef) && !isClassProtected(classDef)){checkForRedundantModifier(classCtorAst,TokenTypes.LITERAL_PUBLIC);\n}}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#processInterfaceOrAnnotation\n methodBody: private void processInterfaceOrAnnotation(DetailAST ast) {\nfinal DetailAST modifiers=ast.findFirstToken(TokenTypes.MODIFIERS);\nDetailAST modifier=modifiers.getFirstChild();\nwhile(modifier != null){final int type=modifier.getType();\nif(type == TokenTypes.LITERAL_PUBLIC || type == TokenTypes.LITERAL_STATIC && ast.getType() != TokenTypes.METHOD_DEF || type == TokenTypes.ABSTRACT && ast.getType() != TokenTypes.CLASS_DEF || type == TokenTypes.FINAL && ast.getType() != TokenTypes.CLASS_DEF){log(modifier,MSG_KEY,modifier.getText());\n}modifier=modifier.getNextSibling();\n}}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#processMethods\n methodBody: private void processMethods(DetailAST ast) {\nfinal DetailAST modifiers=ast.findFirstToken(TokenTypes.MODIFIERS);\nboolean checkFinal=modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) != null;\nDetailAST parent=ast.getParent();\nwhile(parent != null && !checkFinal){if(parent.getType() == TokenTypes.CLASS_DEF){final DetailAST classModifiers=parent.findFirstToken(TokenTypes.MODIFIERS);\ncheckFinal=classModifiers.findFirstToken(TokenTypes.FINAL) != null;\nparent=null;\n}if(parent.getType() == TokenTypes.LITERAL_NEW || parent.getType() == TokenTypes.ENUM_CONSTANT_DEF){checkFinal=true;\nparent=null;\n}if(parent.getType() == TokenTypes.ENUM_DEF){checkFinal=modifiers.findFirstToken(TokenTypes.LITERAL_STATIC) != null;\nparent=null;\n}{parent=parent.getParent();\n}}if(checkFinal && !isAnnotatedWithSafeVarargs(ast)){checkForRedundantModifier(ast,TokenTypes.FINAL);\n}if(ast.findFirstToken(TokenTypes.SLIST) == null){processAbstractMethodParameters(ast);\n}}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#checkInterfaceModifiers\n methodBody: private void checkInterfaceModifiers(DetailAST ast) {\nfinal DetailAST modifiers=ast.findFirstToken(TokenTypes.MODIFIERS);\nfor(final int tokenType: TOKENS_FOR_INTERFACE_MODIFIERS){final DetailAST modifier=modifiers.findFirstToken(tokenType);\nif(modifier != null){log(modifier,MSG_KEY,modifier.getText());\n}}}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#isEnumMember\n methodBody: private static boolean isEnumMember(DetailAST ast) {\nfinal DetailAST parentTypeDef=ast.getParent().getParent();\nreturn parentTypeDef.getType() == TokenTypes.ENUM_DEF;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#checkEnumConstructorModifiers\n methodBody: private void checkEnumConstructorModifiers(DetailAST ast) {\nfinal DetailAST modifiers=ast.findFirstToken(TokenTypes.MODIFIERS);\nTokenUtil.findFirstTokenByPredicate(modifiers,mod -> mod.getType() != TokenTypes.ANNOTATION).ifPresent(modifier -> log(modifier,MSG_KEY,modifier.getText()));\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#checkEnumDef\n methodBody: private void checkEnumDef(DetailAST ast) {\nif(isInterfaceOrAnnotationMember(ast)){processInterfaceOrAnnotation(ast);\n}{checkForRedundantModifier(ast,TokenTypes.LITERAL_STATIC);\n}}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.modifier.RedundantModifierCheck#isInterfaceOrAnnotationMember\n methodBody: private static boolean isInterfaceOrAnnotationMember(DetailAST ast) {\nDetailAST parentTypeDef=ast.getParent();\nparentTypeDef=parentTypeDef.getParent();\nreturn parentTypeDef != null && (parentTypeDef.getType() == TokenTypes.INTERFACE_DEF || parentTypeDef.getType() == TokenTypes.ANNOTATION_DEF);\n}"], "sourceCodeAfterRefactoring": "@Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.INTERFACE_DEF:\n            case TokenTypes.ANNOTATION_DEF:\n                checkInterfaceModifiers(ast);\n                break;\n            case TokenTypes.ENUM_DEF:\n                checkForRedundantModifier(ast, TokenTypes.LITERAL_STATIC);\n                break;\n            case TokenTypes.CTOR_DEF:\n                checkConstructorModifiers(ast);\n                break;\n            case TokenTypes.METHOD_DEF:\n                processMethods(ast);\n                break;\n            case TokenTypes.RESOURCE:\n                processResources(ast);\n                break;\n            case TokenTypes.CLASS_DEF:\n            case TokenTypes.VARIABLE_DEF:\n            case TokenTypes.ANNOTATION_FIELD_DEF:\n                break;\n            default:\n                throw new IllegalStateException(\"Unexpected token type: \" + ast.getType());\n        }\n\n        if (isInterfaceOrAnnotationMember(ast)) {\n            processInterfaceOrAnnotation(ast);\n        }\n    }\n/**\n     * Check modifiers of constructor.\n     *\n     * @param ctorDefAst ast node of type {@link TokenTypes#CTOR_DEF}\n     */\n    private void checkConstructorModifiers(DetailAST ctorDefAst) {\n        if (isEnumMember(ctorDefAst)) {\n            checkEnumConstructorModifiers(ctorDefAst);\n        }\n        else {\n            checkClassConstructorModifiers(ctorDefAst);\n        }\n    }", "diffSourceCode": "-  231:     @Override\n-  232:     public void visitToken(DetailAST ast) {\n-  233:         if (ast.getType() == TokenTypes.INTERFACE_DEF) {\n-  234:             checkInterfaceModifiers(ast);\n-  235:         }\n-  236:         else if (ast.getType() == TokenTypes.ENUM_DEF) {\n-  237:             checkEnumDef(ast);\n-  238:         }\n-  239:         else {\n-  240:             if (ast.getType() == TokenTypes.CTOR_DEF) {\n-  241:                 if (isEnumMember(ast)) {\n-  242:                     checkEnumConstructorModifiers(ast);\n-  243:                 }\n-  244:                 else {\n-  245:                     checkClassConstructorModifiers(ast);\n-  246:                 }\n-  247:             }\n-  248:             else if (ast.getType() == TokenTypes.METHOD_DEF) {\n-  249:                 processMethods(ast);\n-  250:             }\n-  251:             else if (ast.getType() == TokenTypes.RESOURCE) {\n-  252:                 processResources(ast);\n-  253:             }\n-  254: \n-  255:             if (isInterfaceOrAnnotationMember(ast)) {\n-  256:                 processInterfaceOrAnnotation(ast);\n-  257:             }\n-  258:         }\n-  259:     }\n-  260: \n-  261:     /**\n-  262:      * Checks if interface has proper modifiers.\n-  264:      * @param ast interface to check\n-  265:      */\n-  266:     private void checkInterfaceModifiers(DetailAST ast) {\n-  267:         final DetailAST modifiers =\n-  268:             ast.findFirstToken(TokenTypes.MODIFIERS);\n-  269: \n-  270:         for (final int tokenType : TOKENS_FOR_INTERFACE_MODIFIERS) {\n-  271:             final DetailAST modifier =\n-  272:                     modifiers.findFirstToken(tokenType);\n-  273:             if (modifier != null) {\n-  274:                 log(modifier, MSG_KEY, modifier.getText());\n-  275:             }\n-  276:         }\n+  231: \n+  232:     @Override\n+  233:     public void visitToken(DetailAST ast) {\n+  234:         switch (ast.getType()) {\n+  235:             case TokenTypes.INTERFACE_DEF:\n+  236:             case TokenTypes.ANNOTATION_DEF:\n+  237:                 checkInterfaceModifiers(ast);\n+  238:                 break;\n+  239:             case TokenTypes.ENUM_DEF:\n+  240:                 checkForRedundantModifier(ast, TokenTypes.LITERAL_STATIC);\n+  241:                 break;\n+  242:             case TokenTypes.CTOR_DEF:\n+  243:                 checkConstructorModifiers(ast);\n+  244:                 break;\n+  245:             case TokenTypes.METHOD_DEF:\n+  246:                 processMethods(ast);\n+  247:                 break;\n+  248:             case TokenTypes.RESOURCE:\n+  249:                 processResources(ast);\n+  250:                 break;\n+  251:             case TokenTypes.CLASS_DEF:\n+  252:             case TokenTypes.VARIABLE_DEF:\n+  253:             case TokenTypes.ANNOTATION_FIELD_DEF:\n+  254:                 break;\n+  255:             default:\n+  256:                 throw new IllegalStateException(\"Unexpected token type: \" + ast.getType());\n+  257:         }\n+  258: \n+  259:         if (isInterfaceOrAnnotationMember(ast)) {\n+  260:             processInterfaceOrAnnotation(ast);\n+  261:         }\n+  262:     }\n+  264:     /**\n+  265:      * Check modifiers of constructor.\n+  266:      *\n+  267:      * @param ctorDefAst ast node of type {@link TokenTypes#CTOR_DEF}\n+  268:      */\n+  269:     private void checkConstructorModifiers(DetailAST ctorDefAst) {\n+  270:         if (isEnumMember(ctorDefAst)) {\n+  271:             checkEnumConstructorModifiers(ctorDefAst);\n+  272:         }\n+  273:         else {\n+  274:             checkClassConstructorModifiers(ctorDefAst);\n+  275:         }\n+  276:     }\n", "uniqueId": "466a1668f4b132a2f9029b1a035c6de304779e6b_231_259_264_276_232_262", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 53}, "BRANCH": {"missed": 0, "covered": 14}, "LINE": {"missed": 0, "covered": 15}, "COMPLEXITY": {"missed": 0, "covered": 8}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nRefactored Method Code:\n\nprivate void processEnumMember(DetailAST ast) {\n    if (isEnumMember(ast)) {\n        checkEnumConstructorModifiers(ast);\n    } else {\n        checkClassConstructorModifiers(ast);\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public void visitToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.INTERFACE_DEF) {\n            checkInterfaceModifiers(ast);\n        }\n        else if (ast.getType() == TokenTypes.ENUM_DEF) {\n            checkEnumDef(ast);\n        }\n        else {\n            if (ast.getType() == TokenTypes.CTOR_DEF) {\n                if (isEnumMember(ast)) {\n                    checkEnumConstructorModifiers(ast);\n                }\n                else {\n                    checkClassConstructorModifiers(ast);\n                }\n            }\n            else if (ast.getType() == TokenTypes.METHOD_DEF) {\n                processMethods(ast);\n            }\n            else if (ast.getType() == TokenTypes.RESOURCE) {\n                processResources(ast);\n            }\n\n            if (isInterfaceOrAnnotationMember(ast)) {\n                processInterfaceOrAnnotation(ast);\n            }\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2022 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.modifier;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * <p>\n * Checks for redundant modifiers.\n * </p>\n * <p>\n * Rationale: The Java Language Specification strongly discourages the usage\n * of {@code public} and {@code abstract} for method declarations in interface\n * definitions as a matter of style.\n * </p>\n * <p>The check validates:</p>\n * <ol>\n * <li>\n * Interface and annotation definitions.\n * </li>\n * <li>\n * Final modifier on methods of final and anonymous classes.\n * </li>\n * <li>\n * Inner {@code interface} declarations that are declared as {@code static}.\n * </li>\n * <li>\n * Class constructors.\n * </li>\n * <li>\n * Nested {@code enum} definitions that are declared as {@code static}.\n * </li>\n * </ol>\n * <p>\n * Interfaces by definition are abstract so the {@code abstract}\n * modifier on the interface is redundant.\n * </p>\n * <p>Classes inside of interfaces by definition are public and static,\n * so the {@code public} and {@code static} modifiers\n * on the inner classes are redundant. On the other hand, classes\n * inside of interfaces can be abstract or non abstract.\n * So, {@code abstract} modifier is allowed.\n * </p>\n * <p>Fields in interfaces and annotations are automatically\n * public, static and final, so these modifiers are redundant as\n * well.</p>\n *\n * <p>As annotations are a form of interface, their fields are also\n * automatically public, static and final just as their\n * annotation fields are automatically public and abstract.</p>\n *\n * <p>Enums by definition are static implicit subclasses of java.lang.Enum&#60;E&#62;.\n * So, the {@code static} modifier on the enums is redundant. In addition,\n * if enum is inside of interface, {@code public} modifier is also redundant.</p>\n *\n * <p>Enums can also contain abstract methods and methods which can be overridden by the declared\n * enumeration fields.\n * See the following example:</p>\n * <pre>\n * public enum EnumClass {\n *   FIELD_1,\n *   FIELD_2 {\n *     &#64;Override\n *     public final void method1() {} // violation expected\n *   };\n *\n *   public void method1() {}\n *   public final void method2() {} // no violation expected\n * }\n * </pre>\n *\n * <p>Since these methods can be overridden in these situations, the final methods are not\n * marked as redundant even though they can't be extended by other classes/enums.</p>\n * <p>\n * Nested {@code enum} types are always static by default.\n * </p>\n * <p>Final classes by definition cannot be extended so the {@code final}\n * modifier on the method of a final class is redundant.\n * </p>\n * <p>Public modifier for constructors in non-public non-protected classes\n * is always obsolete: </p>\n *\n * <pre>\n * public class PublicClass {\n *   public PublicClass() {} // OK\n * }\n *\n * class PackagePrivateClass {\n *   public PackagePrivateClass() {} // violation expected\n * }\n * </pre>\n *\n * <p>There is no violation in the following example,\n * because removing public modifier from ProtectedInnerClass\n * constructor will make this code not compiling: </p>\n *\n * <pre>\n * package a;\n * public class ClassExample {\n *   protected class ProtectedInnerClass {\n *     public ProtectedInnerClass () {}\n *   }\n * }\n *\n * package b;\n * import a.ClassExample;\n * public class ClassExtending extends ClassExample {\n *   ProtectedInnerClass pc = new ProtectedInnerClass();\n * }\n * </pre>\n * <ul>\n * <li>\n * Property {@code tokens} - tokens to check\n * Type is {@code java.lang.String[]}.\n * Validation type is {@code tokenSet}.\n * Default value is:\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#METHOD_DEF\">\n * METHOD_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#VARIABLE_DEF\">\n * VARIABLE_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ANNOTATION_FIELD_DEF\">\n * ANNOTATION_FIELD_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#INTERFACE_DEF\">\n * INTERFACE_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#CTOR_DEF\">\n * CTOR_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#CLASS_DEF\">\n * CLASS_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ENUM_DEF\">\n * ENUM_DEF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#RESOURCE\">\n * RESOURCE</a>.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=\"RedundantModifier\"/&gt;\n * </pre>\n * <p>\n * To configure the check to check only methods and not variables:\n * </p>\n * <pre>\n * &lt;module name=\"RedundantModifier\"&gt;\n *   &lt;property name=\"tokens\" value=\"METHOD_DEF\"/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code redundantModifier}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@StatelessCheck\npublic class RedundantModifierCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"redundantModifier\";\n\n    /**\n     * An array of tokens for interface modifiers.\n     */\n    private static final int[] TOKENS_FOR_INTERFACE_MODIFIERS = {\n        TokenTypes.LITERAL_STATIC,\n        TokenTypes.ABSTRACT,\n    };\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getAcceptableTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return CommonUtil.EMPTY_INT_ARRAY;\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.METHOD_DEF,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.ANNOTATION_FIELD_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.RESOURCE,\n        };\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.INTERFACE_DEF) {\n            checkInterfaceModifiers(ast);\n        }\n        else if (ast.getType() == TokenTypes.ENUM_DEF) {\n            checkEnumDef(ast);\n        }\n        else {\n            if (ast.getType() == TokenTypes.CTOR_DEF) {\n                if (isEnumMember(ast)) {\n                    checkEnumConstructorModifiers(ast);\n                }\n                else {\n                    checkClassConstructorModifiers(ast);\n                }\n            }\n            else if (ast.getType() == TokenTypes.METHOD_DEF) {\n                processMethods(ast);\n            }\n            else if (ast.getType() == TokenTypes.RESOURCE) {\n                processResources(ast);\n            }\n\n            if (isInterfaceOrAnnotationMember(ast)) {\n                processInterfaceOrAnnotation(ast);\n            }\n        }\n    }\n\n    /**\n     * Checks if interface has proper modifiers.\n     *\n     * @param ast interface to check\n     */\n    private void checkInterfaceModifiers(DetailAST ast) {\n        final DetailAST modifiers =\n            ast.findFirstToken(TokenTypes.MODIFIERS);\n\n        for (final int tokenType : TOKENS_FOR_INTERFACE_MODIFIERS) {\n            final DetailAST modifier =\n                    modifiers.findFirstToken(tokenType);\n            if (modifier != null) {\n                log(modifier, MSG_KEY, modifier.getText());\n            }\n        }\n    }\n\n    /**\n     * Check if enum constructor has proper modifiers.\n     *\n     * @param ast constructor of enum\n     */\n    private void checkEnumConstructorModifiers(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n        TokenUtil.findFirstTokenByPredicate(\n            modifiers, mod -> mod.getType() != TokenTypes.ANNOTATION\n        ).ifPresent(modifier -> log(modifier, MSG_KEY, modifier.getText()));\n    }\n\n    /**\n     * Checks whether enum has proper modifiers.\n     *\n     * @param ast enum definition.\n     */\n    private void checkEnumDef(DetailAST ast) {\n        if (isInterfaceOrAnnotationMember(ast)) {\n            processInterfaceOrAnnotation(ast);\n        }\n        else {\n            checkForRedundantModifier(ast, TokenTypes.LITERAL_STATIC);\n        }\n    }\n\n    /**\n     * Do validation of interface of annotation.\n     *\n     * @param ast token AST\n     */\n    private void processInterfaceOrAnnotation(DetailAST ast) {\n        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);\n        DetailAST modifier = modifiers.getFirstChild();\n        while (modifier != null) {\n            // javac does not allow final or static in interface methods\n            // order annotation fields hence no need to check that this\n            // is not a method or annotation field\n\n            final int type = modifier.getType();\n            if (type == TokenTypes.LITERAL_PUBLIC\n                || type == TokenTypes.LITERAL_STATIC\n                        && ast.getType() != TokenTypes.METHOD_DEF\n                || type == TokenTypes.ABSTRACT\n                        && ast.getType() != TokenTypes.CLASS_DEF\n                || type == TokenTypes.FINAL\n                        && ast.getType() != TokenTypes.CLASS_DEF) {\n                log(modifier, MSG_KEY, modifier.getText());\n            }\n\n            modifier = modifier.getNextSibling();\n        }\n    }\n\n    /**\n     * Process validation of Methods.\n     *\n     * @param ast method AST\n     */\n    private void processMethods(DetailAST ast) {\n        final DetailAST modifiers =\n                        ast.findFirstToken(TokenTypes.MODIFIERS);\n        // private method?\n        boolean checkFinal =\n            modifiers.findFirstToken(TokenTypes.LITERAL_PRIVATE) != null;\n        // declared in a final class?\n        DetailAST parent = ast.getParent();\n        while (parent != null && !checkFinal) {\n            if (parent.getType() == TokenTypes.CLASS_DEF) {\n                final DetailAST classModifiers =\n                    parent.findFirstToken(TokenTypes.MODIFIERS);\n                checkFinal = classModifiers.findFirstToken(TokenTypes.FINAL) != null;\n                parent = null;\n            }\n            else if (parent.getType() == TokenTypes.LITERAL_NEW\n                    || parent.getType() == TokenTypes.ENUM_CONSTANT_DEF) {\n                checkFinal = true;\n                parent = null;\n            }\n            else if (parent.getType() == TokenTypes.ENUM_DEF) {\n                checkFinal = modifiers.findFirstToken(TokenTypes.LITERAL_STATIC) != null;\n                parent = null;\n            }\n            else {\n                parent = parent.getParent();\n            }\n        }\n        if (checkFinal && !isAnnotatedWithSafeVarargs(ast)) {\n            checkForRedundantModifier(ast, TokenTypes.FINAL);\n        }\n\n        if (ast.findFirstToken(TokenTypes.SLIST) == null) {\n            processAbstractMethodParameters(ast);\n        }\n    }\n\n    /**\n     * Process validation of parameters for Methods with no definition.\n     *\n     * @param ast method AST\n     */\n    private void processAbstractMethodParameters(DetailAST ast) {\n        final DetailAST parameters = ast.findFirstToken(TokenTypes.PARAMETERS);\n        TokenUtil.forEachChild(parameters, TokenTypes.PARAMETER_DEF, paramDef -> {\n            checkForRedundantModifier(paramDef, TokenTypes.FINAL);\n        });\n    }\n\n    /**\n     * Check if class constructor has proper modifiers.\n     *\n     * @param classCtorAst class constructor ast\n     */\n    private void checkClassConstructorModifiers(DetailAST classCtorAst) {\n        final DetailAST classDef = classCtorAst.getParent().getParent();\n        if (!isClassPublic(classDef) && !isClassProtected(classDef)) {\n            checkForRedundantModifier(classCtorAst, TokenTypes.LITERAL_PUBLIC);\n        }\n    }\n\n    /**\n     * Checks if given resource has redundant modifiers.\n     *\n     * @param ast ast\n     */\n    private void processResources(DetailAST ast) {\n        checkForRedundantModifier(ast, TokenTypes.FINAL);\n    }\n\n    /**\n     * Checks if given ast has a redundant modifier.\n     *\n     * @param ast ast\n     * @param modifierType The modifier to check for.\n     */\n    private void checkForRedundantModifier(DetailAST ast, int modifierType) {\n        Optional.ofNullable(ast.findFirstToken(TokenTypes.MODIFIERS))\n            .ifPresent(modifiers -> {\n                TokenUtil.forEachChild(modifiers, modifierType, modifier -> {\n                    log(modifier, MSG_KEY, modifier.getText());\n                });\n            });\n    }\n\n    /**\n     * Checks if given class ast has protected modifier.\n     *\n     * @param classDef class ast\n     * @return true if class is protected, false otherwise\n     */\n    private static boolean isClassProtected(DetailAST classDef) {\n        final DetailAST classModifiers =\n                classDef.findFirstToken(TokenTypes.MODIFIERS);\n        return classModifiers.findFirstToken(TokenTypes.LITERAL_PROTECTED) != null;\n    }\n\n    /**\n     * Checks if given class is accessible from \"public\" scope.\n     *\n     * @param ast class def to check\n     * @return true if class is accessible from public scope,false otherwise\n     */\n    private static boolean isClassPublic(DetailAST ast) {\n        boolean isAccessibleFromPublic = false;\n        final DetailAST modifiersAst = ast.findFirstToken(TokenTypes.MODIFIERS);\n        final boolean hasPublicModifier =\n                modifiersAst.findFirstToken(TokenTypes.LITERAL_PUBLIC) != null;\n\n        if (TokenUtil.isRootNode(ast.getParent())) {\n            isAccessibleFromPublic = hasPublicModifier;\n        }\n        else {\n            final DetailAST parentClassAst = ast.getParent().getParent();\n\n            if (hasPublicModifier || parentClassAst.getType() == TokenTypes.INTERFACE_DEF) {\n                isAccessibleFromPublic = isClassPublic(parentClassAst);\n            }\n        }\n\n        return isAccessibleFromPublic;\n    }\n\n    /**\n     * Checks if current AST node is member of Enum.\n     *\n     * @param ast AST node\n     * @return true if it is an enum member\n     */\n    private static boolean isEnumMember(DetailAST ast) {\n        final DetailAST parentTypeDef = ast.getParent().getParent();\n        return parentTypeDef.getType() == TokenTypes.ENUM_DEF;\n    }\n\n    /**\n     * Checks if current AST node is member of Interface or Annotation, not of their subnodes.\n     *\n     * @param ast AST node\n     * @return true or false\n     */\n    private static boolean isInterfaceOrAnnotationMember(DetailAST ast) {\n        DetailAST parentTypeDef = ast.getParent();\n        parentTypeDef = parentTypeDef.getParent();\n        return parentTypeDef != null\n                && (parentTypeDef.getType() == TokenTypes.INTERFACE_DEF\n                    || parentTypeDef.getType() == TokenTypes.ANNOTATION_DEF);\n    }\n\n    /**\n     * Checks if method definition is annotated with.\n     * <a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html\">\n     * SafeVarargs</a> annotation\n     *\n     * @param methodDef method definition node\n     * @return true or false\n     */\n    private static boolean isAnnotatedWithSafeVarargs(DetailAST methodDef) {\n        boolean result = false;\n        final List<DetailAST> methodAnnotationsList = getMethodAnnotationsList(methodDef);\n        for (DetailAST annotationNode : methodAnnotationsList) {\n            if (\"SafeVarargs\".equals(annotationNode.getLastChild().getText())) {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets the list of annotations on method definition.\n     *\n     * @param methodDef method definition node\n     * @return List of annotations\n     */\n    private static List<DetailAST> getMethodAnnotationsList(DetailAST methodDef) {\n        final List<DetailAST> annotationsList = new ArrayList<>();\n        final DetailAST modifiers = methodDef.findFirstToken(TokenTypes.MODIFIERS);\n        TokenUtil.forEachChild(modifiers, TokenTypes.ANNOTATION, annotationsList::add);\n        return annotationsList;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tprivate isBooleanLiteralType(tokenType int) : boolean from class com.puppycrawl.tools.checkstyle.checks.coding.SimplifyBooleanReturnCheck to public isBooleanLiteralType(tokenType int) : boolean from class com.puppycrawl.tools.checkstyle.utils.TokenUtil", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanReturnCheck.java", "startLine": 220, "endLine": 230, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/utils/TokenUtil.java", "startLine": 310, "endLine": 320, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks if a token type is a literal true or false.\n     *\n     * @param tokenType the TokenType\n     * @return true iff tokenType is LITERAL_TRUE or LITERAL_FALSE\n     */\n    private static boolean isBooleanLiteralType(final int tokenType) {\n        final boolean isTrue = tokenType == TokenTypes.LITERAL_TRUE;\n        final boolean isFalse = tokenType == TokenTypes.LITERAL_FALSE;\n        return isTrue || isFalse;\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanReturnCheck.java", "isPureRefactoring": true, "commitId": "ba5cda785bd5a9cca76a71a891e675878aadacc2", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding.SimplifyBooleanReturnCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding.SimplifyBooleanReturnCheck#isBooleanLiteralType", "classSignatureBefore": "public class SimplifyBooleanReturnCheck\n    extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.coding.SimplifyBooleanReturnCheck#isBooleanLiteralType"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.coding.SimplifyBooleanReturnCheck"], "classSignatureBeforeSet": ["public class SimplifyBooleanReturnCheck\n    extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\n\n/**\n * <p>\n * Checks for over-complicated boolean return statements.\n * For example the following code\n * </p>\n * <pre>\n * if (valid())\n *   return false;\n * else\n *   return true;\n * </pre>\n * <p>\n * could be written as\n * </p>\n * <pre>\n * return !valid();\n * </pre>\n * <p>\n * The idea for this Check has been shamelessly stolen from the equivalent\n * <a href=\"https://pmd.github.io/\">PMD</a> rule.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;SimplifyBooleanReturn&quot;/&gt;\n * </pre>\n * <p>Example:</p>\n * <pre>\n * public class Test {\n *\n *  private boolean cond;\n *  private Foo a;\n *  private Foo b;\n *\n *  public boolean check1() {\n *   if (cond) { // violation, can be simplified\n *     return true;\n *   }\n *   else {\n *     return false;\n *   }\n *  }\n *\n *  // Ok, simplified version of check1()\n *  public boolean check2() {\n *   return cond;\n *  }\n *\n *  // violations, can be simplified\n *  public boolean check3() {\n *   if (cond == true) { // can be simplified to \"if (cond)\"\n *     return false;\n *   }\n *   else {\n *     return true; // can be simplified to \"return !cond\"\n *   }\n *  }\n *\n *  // Ok, can be simplified but doesn't return a Boolean\n *  public Foo choose1() {\n *   if (cond) {\n *     return a;\n *   }\n *   else {\n *     return b;\n *   }\n *  }\n *\n *  // Ok, simplified version of choose1()\n *  public Foo choose2() {\n *   return cond ? a: b;\n *  }\n *\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code simplify.boolReturn}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@StatelessCheck\npublic class SimplifyBooleanReturnCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"simplify.boolReturn\";\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {TokenTypes.LITERAL_IF};\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        // LITERAL_IF has the following four or five children:\n        // '('\n        // condition\n        // ')'\n        // thenStatement\n        // [ LITERAL_ELSE (with the elseStatement as a child) ]\n\n        // don't bother if this is not if then else\n        final DetailAST elseLiteral =\n            ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n        if (elseLiteral != null) {\n            final DetailAST elseStatement = elseLiteral.getFirstChild();\n\n            // skip '(' and ')'\n            final DetailAST condition = ast.getFirstChild().getNextSibling();\n            final DetailAST thenStatement = condition.getNextSibling().getNextSibling();\n\n            if (canReturnOnlyBooleanLiteral(thenStatement)\n                && canReturnOnlyBooleanLiteral(elseStatement)) {\n                log(ast, MSG_KEY);\n            }\n        }\n    }\n\n    /**\n     * Returns if an AST is a return statement with a boolean literal\n     * or a compound statement that contains only such a return statement.\n     *\n     * <p>Returns {@code true} iff ast represents\n     * <pre>\n     * return true/false;\n     * </pre>\n     * or\n     * <pre>\n     * {\n     *   return true/false;\n     * }\n     * </pre>\n     *\n     * @param ast the syntax tree to check\n     * @return if ast is a return statement with a boolean literal.\n     */\n    private static boolean canReturnOnlyBooleanLiteral(DetailAST ast) {\n        boolean result = true;\n        if (!isBooleanLiteralReturnStatement(ast)) {\n            final DetailAST firstStatement = ast.getFirstChild();\n            result = isBooleanLiteralReturnStatement(firstStatement);\n        }\n        return result;\n    }\n\n    /**\n     * Returns if an AST is a return statement with a boolean literal.\n     *\n     * <p>Returns {@code true} iff ast represents\n     * <pre>\n     * return true/false;\n     * </pre>\n     *\n     * @param ast the syntax tree to check\n     * @return if ast is a return statement with a boolean literal.\n     */\n    private static boolean isBooleanLiteralReturnStatement(DetailAST ast) {\n        boolean booleanReturnStatement = false;\n\n        if (ast != null && ast.getType() == TokenTypes.LITERAL_RETURN) {\n            final DetailAST expr = ast.getFirstChild();\n\n            if (expr.getType() != TokenTypes.SEMI) {\n                final DetailAST value = expr.getFirstChild();\n                booleanReturnStatement = isBooleanLiteralType(value.getType());\n            }\n        }\n        return booleanReturnStatement;\n    }\n\n    /**\n     * Checks if a token type is a literal true or false.\n     *\n     * @param tokenType the TokenType\n     * @return true iff tokenType is LITERAL_TRUE or LITERAL_FALSE\n     */\n    private static boolean isBooleanLiteralType(final int tokenType) {\n        final boolean isTrue = tokenType == TokenTypes.LITERAL_TRUE;\n        final boolean isFalse = tokenType == TokenTypes.LITERAL_FALSE;\n        return isTrue || isFalse;\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/utils/TokenUtil.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.utils;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.ResourceBundle;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\n\n/**\n * Contains utility methods for tokens.\n *\n */\npublic final class TokenUtil {\n\n    /** Maps from a token name to value. */\n    private static final Map<String, Integer> TOKEN_NAME_TO_VALUE;\n    /** Maps from a token value to name. */\n    private static final Map<Integer, String> TOKEN_VALUE_TO_NAME;\n\n    /** Array of all token IDs. */\n    private static final int[] TOKEN_IDS;\n\n    /** Format for exception message when getting token by given id. */\n    private static final String TOKEN_ID_EXCEPTION_FORMAT = \"unknown TokenTypes id '%s'\";\n\n    /** Format for exception message when getting token by given name. */\n    private static final String TOKEN_NAME_EXCEPTION_FORMAT = \"unknown TokenTypes value '%s'\";\n\n    // initialise the constants\n    static {\n        TOKEN_NAME_TO_VALUE = nameToValueMapFromPublicIntFields(TokenTypes.class);\n        TOKEN_VALUE_TO_NAME = invertMap(TOKEN_NAME_TO_VALUE);\n        TOKEN_IDS = TOKEN_NAME_TO_VALUE.values().stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    /** Stop instances being created. **/\n    private TokenUtil() {\n    }\n\n    /**\n     * Gets the value of a static or instance field of type int or of another primitive type\n     * convertible to type int via a widening conversion. Does not throw any checked exceptions.\n     *\n     * @param field from which the int should be extracted\n     * @param object to extract the int value from\n     * @return the value of the field converted to type int\n     * @throws IllegalStateException if this Field object is enforcing Java language access control\n     *         and the underlying field is inaccessible\n     * @see Field#getInt(Object)\n     */\n    public static int getIntFromField(Field field, Object object) {\n        try {\n            return field.getInt(object);\n        }\n        catch (final IllegalAccessException exception) {\n            throw new IllegalStateException(exception);\n        }\n    }\n\n    /**\n     * Creates a map of 'field name' to 'field value' from all {@code public} {@code int} fields\n     * of a class.\n     *\n     * @param cls source class\n     * @return unmodifiable name to value map\n     */\n    public static Map<String, Integer> nameToValueMapFromPublicIntFields(Class<?> cls) {\n        final Map<String, Integer> map = Arrays.stream(cls.getDeclaredFields())\n            .filter(fld -> Modifier.isPublic(fld.getModifiers()) && fld.getType() == Integer.TYPE)\n            .collect(Collectors.toMap(Field::getName, fld -> getIntFromField(fld, fld.getName())));\n        return Collections.unmodifiableMap(map);\n    }\n\n    /**\n     * Inverts a given map by exchanging each entry's key and value.\n     *\n     * @param map source map\n     * @return inverted map\n     */\n    public static Map<Integer, String> invertMap(Map<String, Integer> map) {\n        return map.entrySet().stream()\n            .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));\n    }\n\n    /**\n     * Get total number of TokenTypes.\n     *\n     * @return total number of TokenTypes.\n     */\n    public static int getTokenTypesTotalNumber() {\n        return TOKEN_IDS.length;\n    }\n\n    /**\n     * Get all token IDs that are available in TokenTypes.\n     *\n     * @return array of token IDs\n     */\n    public static int[] getAllTokenIds() {\n        final int[] safeCopy = new int[TOKEN_IDS.length];\n        System.arraycopy(TOKEN_IDS, 0, safeCopy, 0, TOKEN_IDS.length);\n        return safeCopy;\n    }\n\n    /**\n     * Returns the name of a token for a given ID.\n     *\n     * @param id the ID of the token name to get\n     * @return a token name\n     * @throws IllegalArgumentException when id is not valid\n     */\n    public static String getTokenName(int id) {\n        final String name = TOKEN_VALUE_TO_NAME.get(id);\n        if (name == null) {\n            throw new IllegalArgumentException(\n                String.format(Locale.ROOT, TOKEN_ID_EXCEPTION_FORMAT, id));\n        }\n        return name;\n    }\n\n    /**\n     * Returns the ID of a token for a given name.\n     *\n     * @param name the name of the token ID to get\n     * @return a token ID\n     * @throws IllegalArgumentException when id is null\n     */\n    public static int getTokenId(String name) {\n        final Integer id = TOKEN_NAME_TO_VALUE.get(name);\n        if (id == null) {\n            throw new IllegalArgumentException(\n                String.format(Locale.ROOT, TOKEN_NAME_EXCEPTION_FORMAT, name));\n        }\n        return id;\n    }\n\n    /**\n     * Returns the short description of a token for a given name.\n     *\n     * @param name the name of the token ID to get\n     * @return a short description\n     * @throws IllegalArgumentException when name is unknown\n     */\n    public static String getShortDescription(String name) {\n        if (!TOKEN_NAME_TO_VALUE.containsKey(name)) {\n            throw new IllegalArgumentException(\n                String.format(Locale.ROOT, TOKEN_NAME_EXCEPTION_FORMAT, name));\n        }\n\n        final String tokenTypes =\n            \"com.puppycrawl.tools.checkstyle.api.tokentypes\";\n        final ResourceBundle bundle = ResourceBundle.getBundle(tokenTypes, Locale.ROOT);\n        return bundle.getString(name);\n    }\n\n    /**\n     * Is argument comment-related type (SINGLE_LINE_COMMENT,\n     * BLOCK_COMMENT_BEGIN, BLOCK_COMMENT_END, COMMENT_CONTENT).\n     *\n     * @param type\n     *        token type.\n     * @return true if type is comment-related type.\n     */\n    public static boolean isCommentType(int type) {\n        return type == TokenTypes.SINGLE_LINE_COMMENT\n                || type == TokenTypes.BLOCK_COMMENT_BEGIN\n                || type == TokenTypes.BLOCK_COMMENT_END\n                || type == TokenTypes.COMMENT_CONTENT;\n    }\n\n    /**\n     * Is argument comment-related type name (SINGLE_LINE_COMMENT,\n     * BLOCK_COMMENT_BEGIN, BLOCK_COMMENT_END, COMMENT_CONTENT).\n     *\n     * @param type\n     *        token type name.\n     * @return true if type is comment-related type name.\n     */\n    public static boolean isCommentType(String type) {\n        return isCommentType(getTokenId(type));\n    }\n\n    /**\n     * Finds the first {@link Optional} child token of {@link DetailAST} root node\n     * which matches the given predicate.\n     *\n     * @param root root node.\n     * @param predicate predicate.\n     * @return {@link Optional} of {@link DetailAST} node which matches the predicate.\n     */\n    public static Optional<DetailAST> findFirstTokenByPredicate(DetailAST root,\n                                                                Predicate<DetailAST> predicate) {\n        Optional<DetailAST> result = Optional.empty();\n        for (DetailAST ast = root.getFirstChild(); ast != null; ast = ast.getNextSibling()) {\n            if (predicate.test(ast)) {\n                result = Optional.of(ast);\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Performs an action for each child of {@link DetailAST} root node\n     * which matches the given token type.\n     *\n     * @param root root node.\n     * @param type token type to match.\n     * @param action action to perform on the nodes.\n     */\n    public static void forEachChild(DetailAST root, int type, Consumer<DetailAST> action) {\n        for (DetailAST ast = root.getFirstChild(); ast != null; ast = ast.getNextSibling()) {\n            if (ast.getType() == type) {\n                action.accept(ast);\n            }\n        }\n    }\n\n    /**\n     * Determines if two ASTs are on the same line.\n     *\n     * @param ast1   the first AST\n     * @param ast2   the second AST\n     *\n     * @return true if they are on the same line.\n     */\n    public static boolean areOnSameLine(DetailAST ast1, DetailAST ast2) {\n        return ast1.getLineNo() == ast2.getLineNo();\n    }\n\n    /**\n     * Is type declaration token type (CLASS_DEF, INTERFACE_DEF,\n     * ANNOTATION_DEF, ENUM_DEF, RECORD_DEF).\n     *\n     * @param type\n     *        token type.\n     * @return true if type is type declaration token type.\n     */\n    public static boolean isTypeDeclaration(int type) {\n        return type == TokenTypes.CLASS_DEF\n                || type == TokenTypes.INTERFACE_DEF\n                || type == TokenTypes.ANNOTATION_DEF\n                || type == TokenTypes.ENUM_DEF\n                || type == TokenTypes.RECORD_DEF;\n    }\n\n    /**\n     * Determines if the token type belongs to the given types.\n     *\n     * @param type the Token Type to check\n     * @param types the acceptable types\n     *\n     * @return true if type matches one of the given types.\n     */\n    public static boolean isOfType(int type, int... types) {\n        return Arrays.stream(types).anyMatch(tokenType -> tokenType == type);\n    }\n\n    /**\n     * Determines if the AST belongs to the given types.\n     *\n     * @param ast the AST node to check\n     * @param types the acceptable types\n     *\n     * @return true if type matches one of the given types.\n     */\n    public static boolean isOfType(DetailAST ast, int... types) {\n        return ast != null && isOfType(ast.getType(), types);\n    }\n\n    /**\n     * Determines if given AST is a root node, i.e. if the type\n     * of the token we are checking is {@code COMPILATION_UNIT}.\n     *\n     * @param ast AST to check\n     * @return true if AST is a root node\n     */\n    public static boolean isRootNode(DetailAST ast) {\n        return ast.getType() == TokenTypes.COMPILATION_UNIT;\n    }\n\n    /**\n     * Checks if a token type is a literal true or false.\n     *\n     * @param tokenType the TokenType\n     * @return true if tokenType is LITERAL_TRUE or LITERAL_FALSE\n     */\n    public static boolean isBooleanLiteralType(final int tokenType) {\n        final boolean isTrue = tokenType == TokenTypes.LITERAL_TRUE;\n        final boolean isFalse = tokenType == TokenTypes.LITERAL_FALSE;\n        return isTrue || isFalse;\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Checks if a token type is a literal true or false.\n     *\n     * @param tokenType the TokenType\n     * @return true if tokenType is LITERAL_TRUE or LITERAL_FALSE\n     */\n    public static boolean isBooleanLiteralType(final int tokenType) {\n        final boolean isTrue = tokenType == TokenTypes.LITERAL_TRUE;\n        final boolean isFalse = tokenType == TokenTypes.LITERAL_FALSE;\n        return isTrue || isFalse;\n    }", "diffSourceCode": "-  220:     /**\n-  221:      * Checks if a token type is a literal true or false.\n-  222:      *\n-  223:      * @param tokenType the TokenType\n-  224:      * @return true iff tokenType is LITERAL_TRUE or LITERAL_FALSE\n-  225:      */\n-  226:     private static boolean isBooleanLiteralType(final int tokenType) {\n-  227:         final boolean isTrue = tokenType == TokenTypes.LITERAL_TRUE;\n-  228:         final boolean isFalse = tokenType == TokenTypes.LITERAL_FALSE;\n-  229:         return isTrue || isFalse;\n-  230:     }\n+  220:                                                                 Predicate<DetailAST> predicate) {\n+  221:         Optional<DetailAST> result = Optional.empty();\n+  222:         for (DetailAST ast = root.getFirstChild(); ast != null; ast = ast.getNextSibling()) {\n+  223:             if (predicate.test(ast)) {\n+  224:                 result = Optional.of(ast);\n+  225:                 break;\n+  226:             }\n+  227:         }\n+  228:         return result;\n+  229:     }\n+  230: \n+  310:     /**\n+  311:      * Checks if a token type is a literal true or false.\n+  312:      *\n+  313:      * @param tokenType the TokenType\n+  314:      * @return true if tokenType is LITERAL_TRUE or LITERAL_FALSE\n+  315:      */\n+  316:     public static boolean isBooleanLiteralType(final int tokenType) {\n+  317:         final boolean isTrue = tokenType == TokenTypes.LITERAL_TRUE;\n+  318:         final boolean isFalse = tokenType == TokenTypes.LITERAL_FALSE;\n+  319:         return isTrue || isFalse;\n+  320:     }\n", "uniqueId": "ba5cda785bd5a9cca76a71a891e675878aadacc2_220_230__310_320", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 22}, "BRANCH": {"missed": 0, "covered": 8}, "LINE": {"missed": 0, "covered": 3}, "COMPLEXITY": {"missed": 0, "covered": 5}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nsrc/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanReturnCheck.java\n##########################\n/**\n * Checks if a token type is a literal true or false.\n *\n * @param tokenType the TokenType\n * @return true iff tokenType is LITERAL_TRUE or LITERAL_FALSE\n */\nprivate static boolean isBooleanLiteralType(final int tokenType) {\n    return AstTreeStringPrinter.isBooleanLiteralType(tokenType);\n}\n##########################\nprivate static boolean isBooleanLiteralType(final int tokenType) {\n    final boolean isTrue = tokenType == TokenTypes.LITERAL_TRUE;\n    final boolean isFalse = tokenType == TokenTypes.LITERAL_FALSE;\n    return isTrue || isFalse;\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Checks if a token type is a literal true or false.\n     *\n     * @param tokenType the TokenType\n     * @return true iff tokenType is LITERAL_TRUE or LITERAL_FALSE\n     */\n    private static boolean isBooleanLiteralType(final int tokenType) {\n        final boolean isTrue = tokenType == TokenTypes.LITERAL_TRUE;\n        final boolean isFalse = tokenType == TokenTypes.LITERAL_FALSE;\n        return isTrue || isFalse;\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\n\n/**\n * <p>\n * Checks for over-complicated boolean return statements.\n * For example the following code\n * </p>\n * <pre>\n * if (valid())\n *   return false;\n * else\n *   return true;\n * </pre>\n * <p>\n * could be written as\n * </p>\n * <pre>\n * return !valid();\n * </pre>\n * <p>\n * The idea for this Check has been shamelessly stolen from the equivalent\n * <a href=\"https://pmd.github.io/\">PMD</a> rule.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;SimplifyBooleanReturn&quot;/&gt;\n * </pre>\n * <p>Example:</p>\n * <pre>\n * public class Test {\n *\n *  private boolean cond;\n *  private Foo a;\n *  private Foo b;\n *\n *  public boolean check1() {\n *   if (cond) { // violation, can be simplified\n *     return true;\n *   }\n *   else {\n *     return false;\n *   }\n *  }\n *\n *  // Ok, simplified version of check1()\n *  public boolean check2() {\n *   return cond;\n *  }\n *\n *  // violations, can be simplified\n *  public boolean check3() {\n *   if (cond == true) { // can be simplified to \"if (cond)\"\n *     return false;\n *   }\n *   else {\n *     return true; // can be simplified to \"return !cond\"\n *   }\n *  }\n *\n *  // Ok, can be simplified but doesn't return a Boolean\n *  public Foo choose1() {\n *   if (cond) {\n *     return a;\n *   }\n *   else {\n *     return b;\n *   }\n *  }\n *\n *  // Ok, simplified version of choose1()\n *  public Foo choose2() {\n *   return cond ? a: b;\n *  }\n *\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code simplify.boolReturn}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@StatelessCheck\npublic class SimplifyBooleanReturnCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"simplify.boolReturn\";\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {TokenTypes.LITERAL_IF};\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        // LITERAL_IF has the following four or five children:\n        // '('\n        // condition\n        // ')'\n        // thenStatement\n        // [ LITERAL_ELSE (with the elseStatement as a child) ]\n\n        // don't bother if this is not if then else\n        final DetailAST elseLiteral =\n            ast.findFirstToken(TokenTypes.LITERAL_ELSE);\n        if (elseLiteral != null) {\n            final DetailAST elseStatement = elseLiteral.getFirstChild();\n\n            // skip '(' and ')'\n            final DetailAST condition = ast.getFirstChild().getNextSibling();\n            final DetailAST thenStatement = condition.getNextSibling().getNextSibling();\n\n            if (canReturnOnlyBooleanLiteral(thenStatement)\n                && canReturnOnlyBooleanLiteral(elseStatement)) {\n                log(ast, MSG_KEY);\n            }\n        }\n    }\n\n    /**\n     * Returns if an AST is a return statement with a boolean literal\n     * or a compound statement that contains only such a return statement.\n     *\n     * <p>Returns {@code true} iff ast represents\n     * <pre>\n     * return true/false;\n     * </pre>\n     * or\n     * <pre>\n     * {\n     *   return true/false;\n     * }\n     * </pre>\n     *\n     * @param ast the syntax tree to check\n     * @return if ast is a return statement with a boolean literal.\n     */\n    private static boolean canReturnOnlyBooleanLiteral(DetailAST ast) {\n        boolean result = true;\n        if (!isBooleanLiteralReturnStatement(ast)) {\n            final DetailAST firstStatement = ast.getFirstChild();\n            result = isBooleanLiteralReturnStatement(firstStatement);\n        }\n        return result;\n    }\n\n    /**\n     * Returns if an AST is a return statement with a boolean literal.\n     *\n     * <p>Returns {@code true} iff ast represents\n     * <pre>\n     * return true/false;\n     * </pre>\n     *\n     * @param ast the syntax tree to check\n     * @return if ast is a return statement with a boolean literal.\n     */\n    private static boolean isBooleanLiteralReturnStatement(DetailAST ast) {\n        boolean booleanReturnStatement = false;\n\n        if (ast != null && ast.getType() == TokenTypes.LITERAL_RETURN) {\n            final DetailAST expr = ast.getFirstChild();\n\n            if (expr.getType() != TokenTypes.SEMI) {\n                final DetailAST value = expr.getFirstChild();\n                booleanReturnStatement = isBooleanLiteralType(value.getType());\n            }\n        }\n        return booleanReturnStatement;\n    }\n\n    /**\n     * Checks if a token type is a literal true or false.\n     *\n     * @param tokenType the TokenType\n     * @return true iff tokenType is LITERAL_TRUE or LITERAL_FALSE\n     */\n    private static boolean isBooleanLiteralType(final int tokenType) {\n        final boolean isTrue = tokenType == TokenTypes.LITERAL_TRUE;\n        final boolean isFalse = tokenType == TokenTypes.LITERAL_FALSE;\n        return isTrue || isFalse;\n    }\n\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/main/java/com/puppycrawl/tools/checkstyle/AstTreeStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/AuditEventDefaultFormatter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/AuditEventFormatter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Checker.java', 'src/main/java/com/puppycrawl/tools/checkstyle/CheckstyleParserErrorStrategy.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultContext.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Definitions.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DetailAstImpl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DetailNodeTreeStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/FileStatefulCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/GlobalStatefulCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavaAstVisitor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavaParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavadocPropertiesGenerator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Main.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ModuleFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PackageNamesLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertiesExpander.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertyResolver.java', 'src/main/java/com/puppycrawl/tools/checkstyle/SarifLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/StatelessCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/SuppressionsStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ThreadModeSettings.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalkerAuditEvent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalkerFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XMLLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XmlLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAstFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAuditListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ant/CheckstyleAntTask.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ant/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractFileSetCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractViolationReporter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AuditEvent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AuditListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AutomaticBean.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilterSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/CheckstyleException.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Comment.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Configurable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Configuration.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Context.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Contextualizable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/DetailNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/ExternalResourceHolder.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileContents.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileSetCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Filter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FilterSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FullIdent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/JavadocTokenTypes.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/LineColumn.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/MessageDispatcher.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/RootModule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Scope.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/SeverityLevel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/SeverityLevelCounter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/TextBlock.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/TokenTypes.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Violation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/ArrayTypeStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/FinalParametersCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/LineSeparatorOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/NoCodeInFileCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/OrderedPropertiesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/OuterTypeFilenameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TodoCommentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UniquePropertiesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UpperEllCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationOnSameLineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingDeprecatedCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingOverrideCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/PackageAnnotationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/AvoidNestedBlocksCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/BlockOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyBlockCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AbstractSuperCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ArrayTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidDoubleBraceInitializationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidInlineConditionalsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidNoArgumentSuperConstructorCallCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/CovariantEqualsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DefaultComesLastCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EmptyStatementCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsHashCodeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ExplicitInitializationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/HiddenFieldCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalCatchCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenTextCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MagicNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MatchXpathCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingCtorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingSwitchDefaultCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ModifiedControlVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleVariableDeclarationsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedForDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedIfDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedTryDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoArrayTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoCloneCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoEnumTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoFinalizerCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/PackageDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ReturnCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanExpressionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanReturnCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/StringLiteralEqualityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperCloneCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperFinalizeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterOuterTypeDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterTypeMemberDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInEnumerationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInTryWithResourcesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/HideUtilityClassConstructorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/InnerTypeLastCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/InterfaceIsTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/OneTopLevelClassCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/ThrowsCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/HeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AbstractImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AbstractImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AccessResult.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStarImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStaticImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ClassImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/FileImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/IllegalImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/MismatchStrategy.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/RedundantImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AbstractExpressionHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AnnotationArrayInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ArrayInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/BlockParentHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CaseHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CatchHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/DetailAstSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/DoWhileHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ElseHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/FinallyHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ForHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IfHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ImportHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentLevel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndexHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LabelHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LambdaHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MemberDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodCallHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/NewHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ObjectBlockHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/PackageDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/PrimordialHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SlistHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/StaticInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SwitchHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SwitchRuleHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SynchronizedHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/TryHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/WhileHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/YieldHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AtclauseOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/HtmlTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocPositionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocBlockTagLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMissingLeadingAsteriskCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMissingWhitespaceAfterAsteriskCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocNodeImpl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocPackageCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocParagraphCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagContinuationIndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagInfo.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTags.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocMethodCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocPackageCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/NonEmptyAtclauseDescriptionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/RequireEmptyLineBeforeBlockTagGroupCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SingleLineJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/WriteTagCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/BlockTagUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/InlineTagUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/TagInfo.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassDataAbstractionCouplingCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassFanOutComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/CyclomaticComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/JavaNCSSCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ClassMemberImpliedModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/InterfaceMemberImpliedModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ModifierOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbbreviationAsWordInNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractAccessControlNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AccessModifierOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/CatchParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ClassTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ConstantNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/IllegalIdentifierNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/InterfaceTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LambdaParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalFinalVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MemberNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/PackageNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/PatternVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/RecordComponentNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/RecordTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/StaticVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/TypeNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/CommentSuppressor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/DetectorOptions.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/MatchSuppressor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/MultilineDetector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/NeverSuppress.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpMultilineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpOnFilenameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineJavaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/SinglelineDetector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/AnonInnerLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/ExecutableStatementCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/FileLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/LambdaBodyLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/LineLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/OuterTypeNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/ParameterNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/RecordComponentNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/AbstractParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForInitializerPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForIteratorPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/FileTabCharacterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/MethodParamPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoLineWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCaseDefaultColonCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/OperatorWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/PadOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SeparatorWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SingleSpaceSeparatorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/TypecastParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAfterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WrapOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filefilters/BeforeExecutionExclusionFileFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filefilters/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/CsvFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntMatchFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntRangeFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SeverityMatchFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWarningsFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithPlainTextCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionSingleFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathSingleFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionsLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/XpathFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/CommentListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/CrAwareLexerSimulator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/BaseCellEditor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/CodeSelector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/CodeSelectorPresentation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ListToTreeSelectionModelWrapper.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/Main.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/MainFrame.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/MainFrameModel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTableModel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTablePresentation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTableCellRenderer.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTableModelAdapter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/MetadataGenerationException.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModuleDetails.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModulePropertyDetails.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModuleType.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaReader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaWriter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/AnnotationUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/BlockCommentPosition.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ChainedPropertyUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/FilterUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ModuleReflectionUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ParserUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ScopeUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/TokenUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/XpathUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/AbstractNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/AttributeNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/ElementNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/RootNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/XpathQueryGenerator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/package-info.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic getCheckstyleResource(name String) : URL extracted from public getResourceFromClassPath(filename String) : URI in class com.puppycrawl.tools.checkstyle.utils.CommonUtil", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java", "startLine": 440, "endLine": 469, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java", "startLine": 440, "endLine": 469, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java", "startLine": 471, "endLine": 481, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Gets a resource from the classpath.\n     *\n     * @param filename name of file\n     * @return URI of file in classpath\n     * @throws CheckstyleException on failure\n     */\n    public static URI getResourceFromClassPath(String filename) throws CheckstyleException {\n        final URL configUrl;\n        if (filename.charAt(0) == '/') {\n            configUrl = CommonUtil.class.getResource(filename);\n        }\n        else {\n            configUrl = ClassLoader.getSystemResource(filename);\n        }\n\n        if (configUrl == null) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename);\n        }\n\n        final URI uri;\n        try {\n            uri = configUrl.toURI();\n        }\n        catch (final URISyntaxException ex) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename, ex);\n        }\n\n        return uri;\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java", "isPureRefactoring": true, "commitId": "8129a4f69cf30d059ed7b34b4dca4b8118690526", "packageNameBefore": "com.puppycrawl.tools.checkstyle.utils", "classNameBefore": "com.puppycrawl.tools.checkstyle.utils.CommonUtil", "methodNameBefore": "com.puppycrawl.tools.checkstyle.utils.CommonUtil#getResourceFromClassPath", "classSignatureBefore": "public final class CommonUtil ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.utils.CommonUtil#getResourceFromClassPath"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.utils.CommonUtil"], "classSignatureBeforeSet": ["public final class CommonUtil "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.utils;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Contains utility methods.\n *\n */\npublic final class CommonUtil {\n\n    /** Default tab width for column reporting. */\n    public static final int DEFAULT_TAB_WIDTH = 8;\n\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final int[] EMPTY_INT_ARRAY = new int[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n    /** Pseudo URL protocol for loading from the class path. */\n    public static final String CLASSPATH_URL_PROTOCOL = \"classpath:\";\n\n    /** Prefix for the exception when unable to find resource. */\n    private static final String UNABLE_TO_FIND_EXCEPTION_PREFIX = \"Unable to find: \";\n\n    /** Stop instances being created. **/\n    private CommonUtil() {\n    }\n\n    /**\n     * Helper method to create a regular expression.\n     *\n     * @param pattern\n     *            the pattern to match\n     * @return a created regexp object\n     * @throws IllegalArgumentException\n     *             if unable to create Pattern object.\n     **/\n    public static Pattern createPattern(String pattern) {\n        return createPattern(pattern, 0);\n    }\n\n    /**\n     * Helper method to create a regular expression with a specific flags.\n     *\n     * @param pattern\n     *            the pattern to match\n     * @param flags\n     *            the flags to set\n     * @return a created regexp object\n     * @throws IllegalArgumentException\n     *             if unable to create Pattern object.\n     **/\n    public static Pattern createPattern(String pattern, int flags) {\n        try {\n            return Pattern.compile(pattern, flags);\n        }\n        catch (final PatternSyntaxException ex) {\n            throw new IllegalArgumentException(\n                \"Failed to initialise regular expression \" + pattern, ex);\n        }\n    }\n\n    /**\n     * Returns whether the file extension matches what we are meant to process.\n     *\n     * @param file\n     *            the file to be checked.\n     * @param fileExtensions\n     *            files extensions, empty property in config makes it matches to all.\n     * @return whether there is a match.\n     */\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        boolean result = false;\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            result = true;\n        }\n        else {\n            // normalize extensions so all of them have a leading dot\n            final String[] withDotExtensions = new String[fileExtensions.length];\n            for (int i = 0; i < fileExtensions.length; i++) {\n                final String extension = fileExtensions[i];\n                if (startsWithChar(extension, '.')) {\n                    withDotExtensions[i] = extension;\n                }\n                else {\n                    withDotExtensions[i] = \".\" + extension;\n                }\n            }\n\n            final String fileName = file.getName();\n            for (final String fileExtension : withDotExtensions) {\n                if (fileName.endsWith(fileExtension)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns whether the specified string contains only whitespace up to the specified index.\n     *\n     * @param index\n     *            index to check up to\n     * @param line\n     *            the line to check\n     * @return whether there is only whitespace\n     */\n    public static boolean hasWhitespaceBefore(int index, String line) {\n        boolean result = true;\n        for (int i = 0; i < index; i++) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                result = false;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the length of a string ignoring all trailing whitespace.\n     * It is a pity that there is not a trim() like\n     * method that only removed the trailing whitespace.\n     *\n     * @param line\n     *            the string to process\n     * @return the length of the string ignoring all trailing whitespace\n     **/\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int len = line.length();\n        for (int i = len - 1; i >= 0; i--) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                break;\n            }\n            len--;\n        }\n        return len;\n    }\n\n    /**\n     * Returns the length of a String prefix with tabs expanded.\n     * Each tab is counted as the number of characters is\n     * takes to jump to the next tab stop.\n     *\n     * @param inputString\n     *            the input String\n     * @param toIdx\n     *            index in string (exclusive) where the calculation stops\n     * @param tabWidth\n     *            the distance between tab stop position.\n     * @return the length of string.substring(0, toIdx) with tabs expanded.\n     */\n    public static int lengthExpandedTabs(String inputString,\n            int toIdx,\n            int tabWidth) {\n        int len = 0;\n        for (int idx = 0; idx < toIdx; idx++) {\n            if (inputString.codePointAt(idx) == '\\t') {\n                len = (len / tabWidth + 1) * tabWidth;\n            }\n            else {\n                len++;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * Validates whether passed string is a valid pattern or not.\n     *\n     * @param pattern\n     *            string to validate\n     * @return true if the pattern is valid false otherwise\n     */\n    public static boolean isPatternValid(String pattern) {\n        boolean isValid = true;\n        try {\n            Pattern.compile(pattern);\n        }\n        catch (final PatternSyntaxException ignored) {\n            isValid = false;\n        }\n        return isValid;\n    }\n\n    /**\n     * Returns base class name from qualified name.\n     *\n     * @param type\n     *            the fully qualified name. Cannot be null\n     * @return the base class name from a fully qualified name\n     */\n    public static String baseClassName(String type) {\n        final String className;\n        final int index = type.lastIndexOf('.');\n        if (index == -1) {\n            className = type;\n        }\n        else {\n            className = type.substring(index + 1);\n        }\n        return className;\n    }\n\n    /**\n     * Constructs a normalized relative path between base directory and a given path.\n     *\n     * @param baseDirectory\n     *            the base path to which given path is relativized\n     * @param path\n     *            the path to relativize against base directory\n     * @return the relative normalized path between base directory and\n     *     path or path if base directory is null.\n     */\n    public static String relativizeAndNormalizePath(final String baseDirectory, final String path) {\n        final String resultPath;\n        if (baseDirectory == null) {\n            resultPath = path;\n        }\n        else {\n            final Path pathAbsolute = Paths.get(path).normalize();\n            final Path pathBase = Paths.get(baseDirectory).normalize();\n            resultPath = pathBase.relativize(pathAbsolute).toString();\n        }\n        return resultPath;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     * <p>\n     * It is faster version of {@link String#startsWith(String)} optimized for\n     *  one-character prefixes at the expense of\n     * some readability. Suggested by SimplifyStartsWith PMD rule:\n     * http://pmd.sourceforge.net/pmd-5.3.1/pmd-java/rules/java/optimizations.html#SimplifyStartsWith\n     * </p>\n     *\n     * @param value\n     *            the {@code String} to check\n     * @param prefix\n     *            the prefix to find\n     * @return {@code true} if the {@code char} is a prefix of the given {@code String};\n     *     {@code false} otherwise.\n     */\n    public static boolean startsWithChar(String value, char prefix) {\n        return !value.isEmpty() && value.charAt(0) == prefix;\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     * <p>\n     * It is faster version of {@link String#endsWith(String)} optimized for\n     *  one-character suffixes at the expense of\n     * some readability. Suggested by SimplifyStartsWith PMD rule:\n     * http://pmd.sourceforge.net/pmd-5.3.1/pmd-java/rules/java/optimizations.html#SimplifyStartsWith\n     * </p>\n     *\n     * @param value\n     *            the {@code String} to check\n     * @param suffix\n     *            the suffix to find\n     * @return {@code true} if the {@code char} is a suffix of the given {@code String};\n     *     {@code false} otherwise.\n     */\n    public static boolean endsWithChar(String value, char suffix) {\n        return !value.isEmpty() && value.charAt(value.length() - 1) == suffix;\n    }\n\n    /**\n     * Gets constructor of targetClass.\n     *\n     * @param <T> type of the target class object.\n     * @param targetClass\n     *            from which constructor is returned\n     * @param parameterTypes\n     *            of constructor\n     * @return constructor of targetClass\n     * @throws IllegalStateException if any exception occurs\n     * @see Class#getConstructor(Class[])\n     */\n    public static <T> Constructor<T> getConstructor(Class<T> targetClass,\n                                                    Class<?>... parameterTypes) {\n        try {\n            return targetClass.getConstructor(parameterTypes);\n        }\n        catch (NoSuchMethodException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    /**\n     * Returns new instance of a class.\n     *\n     * @param <T>\n     *            type of constructor\n     * @param constructor\n     *            to invoke\n     * @param parameters\n     *            to pass to constructor\n     * @return new instance of class\n     * @throws IllegalStateException if any exception occurs\n     * @see Constructor#newInstance(Object...)\n     */\n    public static <T> T invokeConstructor(Constructor<T> constructor, Object... parameters) {\n        try {\n            return constructor.newInstance(parameters);\n        }\n        catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    /**\n     * Closes a stream re-throwing IOException as IllegalStateException.\n     *\n     * @param closeable\n     *            Closeable object\n     * @throws IllegalStateException when any IOException occurs\n     */\n    public static void close(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            }\n            catch (IOException ex) {\n                throw new IllegalStateException(\"Cannot close the stream\", ex);\n            }\n        }\n    }\n\n    /**\n     * Resolve the specified filename to a URI.\n     *\n     * @param filename name of the file\n     * @return resolved file URI\n     * @throws CheckstyleException on failure\n     */\n    public static URI getUriByFilename(String filename) throws CheckstyleException {\n        URI uri = getWebOrFileProtocolUri(filename);\n\n        if (uri == null) {\n            uri = getFilepathOrClasspathUri(filename);\n        }\n\n        return uri;\n    }\n\n    /**\n     * Resolves the specified filename containing 'http', 'https', 'ftp',\n     * and 'file' protocols (or any RFC 2396 compliant URL) to a URI.\n     *\n     * @param filename name of the file\n     * @return resolved file URI or null if URL is malformed or non-existent\n     */\n    public static URI getWebOrFileProtocolUri(String filename) {\n        URI uri;\n        try {\n            final URL url = new URL(filename);\n            uri = url.toURI();\n        }\n        catch (URISyntaxException | MalformedURLException ignored) {\n            uri = null;\n        }\n        return uri;\n    }\n\n    /**\n     * Resolves the specified local filename, possibly with 'classpath:'\n     * protocol, to a URI.  First we attempt to create a new file with\n     * given filename, then attempt to load file from class path.\n     *\n     * @param filename name of the file\n     * @return resolved file URI\n     * @throws CheckstyleException on failure\n     */\n    private static URI getFilepathOrClasspathUri(String filename) throws CheckstyleException {\n        final URI uri;\n        final File file = new File(filename);\n\n        if (file.exists()) {\n            uri = file.toURI();\n        }\n        else {\n            final int lastIndexOfClasspathProtocol;\n            if (filename.lastIndexOf(CLASSPATH_URL_PROTOCOL) == 0) {\n                lastIndexOfClasspathProtocol = CLASSPATH_URL_PROTOCOL.length();\n            }\n            else {\n                lastIndexOfClasspathProtocol = 0;\n            }\n            uri = getResourceFromClassPath(filename\n                .substring(lastIndexOfClasspathProtocol));\n        }\n        return uri;\n    }\n\n    /**\n     * Gets a resource from the classpath.\n     *\n     * @param filename name of file\n     * @return URI of file in classpath\n     * @throws CheckstyleException on failure\n     */\n    public static URI getResourceFromClassPath(String filename) throws CheckstyleException {\n        final URL configUrl;\n        if (filename.charAt(0) == '/') {\n            configUrl = CommonUtil.class.getResource(filename);\n        }\n        else {\n            configUrl = ClassLoader.getSystemResource(filename);\n        }\n\n        if (configUrl == null) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename);\n        }\n\n        final URI uri;\n        try {\n            uri = configUrl.toURI();\n        }\n        catch (final URISyntaxException ex) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename, ex);\n        }\n\n        return uri;\n    }\n\n    /**\n     * Puts part of line, which matches regexp into given template\n     * on positions $n where 'n' is number of matched part in line.\n     *\n     * @param template the string to expand.\n     * @param lineToPlaceInTemplate contains expression which should be placed into string.\n     * @param regexp expression to find in comment.\n     * @return the string, based on template filled with given lines\n     */\n    public static String fillTemplateWithStringsByRegexp(\n        String template, String lineToPlaceInTemplate, Pattern regexp) {\n        final Matcher matcher = regexp.matcher(lineToPlaceInTemplate);\n        String result = template;\n        if (matcher.find()) {\n            for (int i = 0; i <= matcher.groupCount(); i++) {\n                // $n expands comment match like in Pattern.subst().\n                result = result.replaceAll(\"\\\\$\" + i, matcher.group(i));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns file name without extension.\n     * We do not use the method from Guava library to reduce Checkstyle's dependencies\n     * on external libraries.\n     *\n     * @param fullFilename file name with extension.\n     * @return file name without extension.\n     */\n    public static String getFileNameWithoutExtension(String fullFilename) {\n        final String fileName = new File(fullFilename).getName();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String fileNameWithoutExtension;\n        if (dotIndex == -1) {\n            fileNameWithoutExtension = fileName;\n        }\n        else {\n            fileNameWithoutExtension = fileName.substring(0, dotIndex);\n        }\n        return fileNameWithoutExtension;\n    }\n\n    /**\n     * Returns file extension for the given file name\n     * or empty string if file does not have an extension.\n     * We do not use the method from Guava library to reduce Checkstyle's dependencies\n     * on external libraries.\n     *\n     * @param fileNameWithExtension file name with extension.\n     * @return file extension for the given file name\n     *         or empty string if file does not have an extension.\n     */\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n    }\n\n    /**\n     * Checks whether the given string is a valid identifier.\n     *\n     * @param str A string to check.\n     * @return true when the given string contains valid identifier.\n     */\n    public static boolean isIdentifier(String str) {\n        boolean isIdentifier = !str.isEmpty();\n\n        for (int i = 0; isIdentifier && i < str.length(); i++) {\n            if (i == 0) {\n                isIdentifier = Character.isJavaIdentifierStart(str.charAt(0));\n            }\n            else {\n                isIdentifier = Character.isJavaIdentifierPart(str.charAt(i));\n            }\n        }\n\n        return isIdentifier;\n    }\n\n    /**\n     * Checks whether the given string is a valid name.\n     *\n     * @param str A string to check.\n     * @return true when the given string contains valid name.\n     */\n    public static boolean isName(String str) {\n        boolean isName = !str.isEmpty();\n\n        final String[] identifiers = str.split(\"\\\\.\", -1);\n        for (int i = 0; isName && i < identifiers.length; i++) {\n            isName = isIdentifier(identifiers[i]);\n        }\n\n        return isName;\n    }\n\n    /**\n     * Checks if the value arg is blank by either being null,\n     * empty, or contains only whitespace characters.\n     *\n     * @param value A string to check.\n     * @return true if the arg is blank.\n     */\n    public static boolean isBlank(String value) {\n        return Objects.isNull(value)\n                || indexOfNonWhitespace(value) >= value.length();\n    }\n\n    /**\n     * Method to find the index of the first non-whitespace character in a string.\n     *\n     * @param value the string to find the first index of a non-whitespace character for.\n     * @return the index of the first non-whitespace character.\n     */\n    public static int indexOfNonWhitespace(String value) {\n        final int length = value.length();\n        int left = 0;\n        while (left < length) {\n            final int codePointAt = value.codePointAt(left);\n            if (!Character.isWhitespace(codePointAt)) {\n                break;\n            }\n            left += Character.charCount(codePointAt);\n        }\n        return left;\n    }\n\n    /**\n     * Checks whether the string contains an integer value.\n     *\n     * @param str a string to check\n     * @return true if the given string is an integer, false otherwise.\n     */\n    public static boolean isInt(String str) {\n        boolean isInt;\n        if (str == null) {\n            isInt = false;\n        }\n        else {\n            try {\n                Integer.parseInt(str);\n                isInt = true;\n            }\n            catch (NumberFormatException ignored) {\n                isInt = false;\n            }\n        }\n        return isInt;\n    }\n\n    /**\n     * Converts the Unicode code point at index {@code index} to it's UTF-16\n     * representation, then checks if the character is whitespace. Note that the given\n     * index {@code index} should correspond to the location of the character\n     * to check in the string, not in code points.\n     *\n     * @param codePoints the array of Unicode code points\n     * @param index the index of the character to check\n     * @return true if character at {@code index} is whitespace\n     */\n    public static boolean isCodePointWhitespace(int[] codePoints, int index) {\n        //  We only need to check the first member of a surrogate pair to verify that\n        //  it is not whitespace.\n        final char character = Character.toChars(codePoints[index])[0];\n        return Character.isWhitespace(character);\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.utils;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Contains utility methods.\n *\n */\npublic final class CommonUtil {\n\n    /** Default tab width for column reporting. */\n    public static final int DEFAULT_TAB_WIDTH = 8;\n\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final int[] EMPTY_INT_ARRAY = new int[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n    /** Pseudo URL protocol for loading from the class path. */\n    public static final String CLASSPATH_URL_PROTOCOL = \"classpath:\";\n\n    /** Prefix for the exception when unable to find resource. */\n    private static final String UNABLE_TO_FIND_EXCEPTION_PREFIX = \"Unable to find: \";\n\n    /** Stop instances being created. **/\n    private CommonUtil() {\n    }\n\n    /**\n     * Helper method to create a regular expression.\n     *\n     * @param pattern\n     *            the pattern to match\n     * @return a created regexp object\n     * @throws IllegalArgumentException\n     *             if unable to create Pattern object.\n     **/\n    public static Pattern createPattern(String pattern) {\n        return createPattern(pattern, 0);\n    }\n\n    /**\n     * Helper method to create a regular expression with a specific flags.\n     *\n     * @param pattern\n     *            the pattern to match\n     * @param flags\n     *            the flags to set\n     * @return a created regexp object\n     * @throws IllegalArgumentException\n     *             if unable to create Pattern object.\n     **/\n    public static Pattern createPattern(String pattern, int flags) {\n        try {\n            return Pattern.compile(pattern, flags);\n        }\n        catch (final PatternSyntaxException ex) {\n            throw new IllegalArgumentException(\n                \"Failed to initialise regular expression \" + pattern, ex);\n        }\n    }\n\n    /**\n     * Returns whether the file extension matches what we are meant to process.\n     *\n     * @param file\n     *            the file to be checked.\n     * @param fileExtensions\n     *            files extensions, empty property in config makes it matches to all.\n     * @return whether there is a match.\n     */\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        boolean result = false;\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            result = true;\n        }\n        else {\n            // normalize extensions so all of them have a leading dot\n            final String[] withDotExtensions = new String[fileExtensions.length];\n            for (int i = 0; i < fileExtensions.length; i++) {\n                final String extension = fileExtensions[i];\n                if (startsWithChar(extension, '.')) {\n                    withDotExtensions[i] = extension;\n                }\n                else {\n                    withDotExtensions[i] = \".\" + extension;\n                }\n            }\n\n            final String fileName = file.getName();\n            for (final String fileExtension : withDotExtensions) {\n                if (fileName.endsWith(fileExtension)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns whether the specified string contains only whitespace up to the specified index.\n     *\n     * @param index\n     *            index to check up to\n     * @param line\n     *            the line to check\n     * @return whether there is only whitespace\n     */\n    public static boolean hasWhitespaceBefore(int index, String line) {\n        boolean result = true;\n        for (int i = 0; i < index; i++) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                result = false;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the length of a string ignoring all trailing whitespace.\n     * It is a pity that there is not a trim() like\n     * method that only removed the trailing whitespace.\n     *\n     * @param line\n     *            the string to process\n     * @return the length of the string ignoring all trailing whitespace\n     **/\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int len = line.length();\n        for (int i = len - 1; i >= 0; i--) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                break;\n            }\n            len--;\n        }\n        return len;\n    }\n\n    /**\n     * Returns the length of a String prefix with tabs expanded.\n     * Each tab is counted as the number of characters is\n     * takes to jump to the next tab stop.\n     *\n     * @param inputString\n     *            the input String\n     * @param toIdx\n     *            index in string (exclusive) where the calculation stops\n     * @param tabWidth\n     *            the distance between tab stop position.\n     * @return the length of string.substring(0, toIdx) with tabs expanded.\n     */\n    public static int lengthExpandedTabs(String inputString,\n            int toIdx,\n            int tabWidth) {\n        int len = 0;\n        for (int idx = 0; idx < toIdx; idx++) {\n            if (inputString.codePointAt(idx) == '\\t') {\n                len = (len / tabWidth + 1) * tabWidth;\n            }\n            else {\n                len++;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * Validates whether passed string is a valid pattern or not.\n     *\n     * @param pattern\n     *            string to validate\n     * @return true if the pattern is valid false otherwise\n     */\n    public static boolean isPatternValid(String pattern) {\n        boolean isValid = true;\n        try {\n            Pattern.compile(pattern);\n        }\n        catch (final PatternSyntaxException ignored) {\n            isValid = false;\n        }\n        return isValid;\n    }\n\n    /**\n     * Returns base class name from qualified name.\n     *\n     * @param type\n     *            the fully qualified name. Cannot be null\n     * @return the base class name from a fully qualified name\n     */\n    public static String baseClassName(String type) {\n        final String className;\n        final int index = type.lastIndexOf('.');\n        if (index == -1) {\n            className = type;\n        }\n        else {\n            className = type.substring(index + 1);\n        }\n        return className;\n    }\n\n    /**\n     * Constructs a normalized relative path between base directory and a given path.\n     *\n     * @param baseDirectory\n     *            the base path to which given path is relativized\n     * @param path\n     *            the path to relativize against base directory\n     * @return the relative normalized path between base directory and\n     *     path or path if base directory is null.\n     */\n    public static String relativizeAndNormalizePath(final String baseDirectory, final String path) {\n        final String resultPath;\n        if (baseDirectory == null) {\n            resultPath = path;\n        }\n        else {\n            final Path pathAbsolute = Paths.get(path).normalize();\n            final Path pathBase = Paths.get(baseDirectory).normalize();\n            resultPath = pathBase.relativize(pathAbsolute).toString();\n        }\n        return resultPath;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     * <p>\n     * It is faster version of {@link String#startsWith(String)} optimized for\n     *  one-character prefixes at the expense of\n     * some readability. Suggested by SimplifyStartsWith PMD rule:\n     * http://pmd.sourceforge.net/pmd-5.3.1/pmd-java/rules/java/optimizations.html#SimplifyStartsWith\n     * </p>\n     *\n     * @param value\n     *            the {@code String} to check\n     * @param prefix\n     *            the prefix to find\n     * @return {@code true} if the {@code char} is a prefix of the given {@code String};\n     *     {@code false} otherwise.\n     */\n    public static boolean startsWithChar(String value, char prefix) {\n        return !value.isEmpty() && value.charAt(0) == prefix;\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     * <p>\n     * It is faster version of {@link String#endsWith(String)} optimized for\n     *  one-character suffixes at the expense of\n     * some readability. Suggested by SimplifyStartsWith PMD rule:\n     * http://pmd.sourceforge.net/pmd-5.3.1/pmd-java/rules/java/optimizations.html#SimplifyStartsWith\n     * </p>\n     *\n     * @param value\n     *            the {@code String} to check\n     * @param suffix\n     *            the suffix to find\n     * @return {@code true} if the {@code char} is a suffix of the given {@code String};\n     *     {@code false} otherwise.\n     */\n    public static boolean endsWithChar(String value, char suffix) {\n        return !value.isEmpty() && value.charAt(value.length() - 1) == suffix;\n    }\n\n    /**\n     * Gets constructor of targetClass.\n     *\n     * @param <T> type of the target class object.\n     * @param targetClass\n     *            from which constructor is returned\n     * @param parameterTypes\n     *            of constructor\n     * @return constructor of targetClass\n     * @throws IllegalStateException if any exception occurs\n     * @see Class#getConstructor(Class[])\n     */\n    public static <T> Constructor<T> getConstructor(Class<T> targetClass,\n                                                    Class<?>... parameterTypes) {\n        try {\n            return targetClass.getConstructor(parameterTypes);\n        }\n        catch (NoSuchMethodException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    /**\n     * Returns new instance of a class.\n     *\n     * @param <T>\n     *            type of constructor\n     * @param constructor\n     *            to invoke\n     * @param parameters\n     *            to pass to constructor\n     * @return new instance of class\n     * @throws IllegalStateException if any exception occurs\n     * @see Constructor#newInstance(Object...)\n     */\n    public static <T> T invokeConstructor(Constructor<T> constructor, Object... parameters) {\n        try {\n            return constructor.newInstance(parameters);\n        }\n        catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    /**\n     * Closes a stream re-throwing IOException as IllegalStateException.\n     *\n     * @param closeable\n     *            Closeable object\n     * @throws IllegalStateException when any IOException occurs\n     */\n    public static void close(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            }\n            catch (IOException ex) {\n                throw new IllegalStateException(\"Cannot close the stream\", ex);\n            }\n        }\n    }\n\n    /**\n     * Resolve the specified filename to a URI.\n     *\n     * @param filename name of the file\n     * @return resolved file URI\n     * @throws CheckstyleException on failure\n     */\n    public static URI getUriByFilename(String filename) throws CheckstyleException {\n        URI uri = getWebOrFileProtocolUri(filename);\n\n        if (uri == null) {\n            uri = getFilepathOrClasspathUri(filename);\n        }\n\n        return uri;\n    }\n\n    /**\n     * Resolves the specified filename containing 'http', 'https', 'ftp',\n     * and 'file' protocols (or any RFC 2396 compliant URL) to a URI.\n     *\n     * @param filename name of the file\n     * @return resolved file URI or null if URL is malformed or non-existent\n     */\n    public static URI getWebOrFileProtocolUri(String filename) {\n        URI uri;\n        try {\n            final URL url = new URL(filename);\n            uri = url.toURI();\n        }\n        catch (URISyntaxException | MalformedURLException ignored) {\n            uri = null;\n        }\n        return uri;\n    }\n\n    /**\n     * Resolves the specified local filename, possibly with 'classpath:'\n     * protocol, to a URI.  First we attempt to create a new file with\n     * given filename, then attempt to load file from class path.\n     *\n     * @param filename name of the file\n     * @return resolved file URI\n     * @throws CheckstyleException on failure\n     */\n    private static URI getFilepathOrClasspathUri(String filename) throws CheckstyleException {\n        final URI uri;\n        final File file = new File(filename);\n\n        if (file.exists()) {\n            uri = file.toURI();\n        }\n        else {\n            final int lastIndexOfClasspathProtocol;\n            if (filename.lastIndexOf(CLASSPATH_URL_PROTOCOL) == 0) {\n                lastIndexOfClasspathProtocol = CLASSPATH_URL_PROTOCOL.length();\n            }\n            else {\n                lastIndexOfClasspathProtocol = 0;\n            }\n            uri = getResourceFromClassPath(filename\n                .substring(lastIndexOfClasspathProtocol));\n        }\n        return uri;\n    }\n\n    /**\n     * Gets a resource from the classpath.\n     *\n     * @param filename name of file\n     * @return URI of file in classpath\n     * @throws CheckstyleException on failure\n     */\n    public static URI getResourceFromClassPath(String filename) throws CheckstyleException {\n        final URL configUrl;\n        if (filename.charAt(0) == '/') {\n            configUrl = getCheckstyleResource(filename);\n        }\n        else {\n            configUrl = ClassLoader.getSystemResource(filename);\n        }\n\n        if (configUrl == null) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename);\n        }\n\n        final URI uri;\n        try {\n            uri = configUrl.toURI();\n        }\n        catch (final URISyntaxException ex) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename, ex);\n        }\n\n        return uri;\n    }\n\n    /**\n     * Finds a resource with a given name in the Checkstyle resource bundle.\n     * This method is intended only for internal use in Checkstyle tests for\n     * easy mocking to gain 100% coverage.\n     *\n     * @param name name of the desired resource\n     * @return URI of the resource\n     */\n    public static URL getCheckstyleResource(String name) {\n        return CommonUtil.class.getResource(name);\n    }\n\n    /**\n     * Puts part of line, which matches regexp into given template\n     * on positions $n where 'n' is number of matched part in line.\n     *\n     * @param template the string to expand.\n     * @param lineToPlaceInTemplate contains expression which should be placed into string.\n     * @param regexp expression to find in comment.\n     * @return the string, based on template filled with given lines\n     */\n    public static String fillTemplateWithStringsByRegexp(\n        String template, String lineToPlaceInTemplate, Pattern regexp) {\n        final Matcher matcher = regexp.matcher(lineToPlaceInTemplate);\n        String result = template;\n        if (matcher.find()) {\n            for (int i = 0; i <= matcher.groupCount(); i++) {\n                // $n expands comment match like in Pattern.subst().\n                result = result.replaceAll(\"\\\\$\" + i, matcher.group(i));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns file name without extension.\n     * We do not use the method from Guava library to reduce Checkstyle's dependencies\n     * on external libraries.\n     *\n     * @param fullFilename file name with extension.\n     * @return file name without extension.\n     */\n    public static String getFileNameWithoutExtension(String fullFilename) {\n        final String fileName = new File(fullFilename).getName();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String fileNameWithoutExtension;\n        if (dotIndex == -1) {\n            fileNameWithoutExtension = fileName;\n        }\n        else {\n            fileNameWithoutExtension = fileName.substring(0, dotIndex);\n        }\n        return fileNameWithoutExtension;\n    }\n\n    /**\n     * Returns file extension for the given file name\n     * or empty string if file does not have an extension.\n     * We do not use the method from Guava library to reduce Checkstyle's dependencies\n     * on external libraries.\n     *\n     * @param fileNameWithExtension file name with extension.\n     * @return file extension for the given file name\n     *         or empty string if file does not have an extension.\n     */\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n    }\n\n    /**\n     * Checks whether the given string is a valid identifier.\n     *\n     * @param str A string to check.\n     * @return true when the given string contains valid identifier.\n     */\n    public static boolean isIdentifier(String str) {\n        boolean isIdentifier = !str.isEmpty();\n\n        for (int i = 0; isIdentifier && i < str.length(); i++) {\n            if (i == 0) {\n                isIdentifier = Character.isJavaIdentifierStart(str.charAt(0));\n            }\n            else {\n                isIdentifier = Character.isJavaIdentifierPart(str.charAt(i));\n            }\n        }\n\n        return isIdentifier;\n    }\n\n    /**\n     * Checks whether the given string is a valid name.\n     *\n     * @param str A string to check.\n     * @return true when the given string contains valid name.\n     */\n    public static boolean isName(String str) {\n        boolean isName = !str.isEmpty();\n\n        final String[] identifiers = str.split(\"\\\\.\", -1);\n        for (int i = 0; isName && i < identifiers.length; i++) {\n            isName = isIdentifier(identifiers[i]);\n        }\n\n        return isName;\n    }\n\n    /**\n     * Checks if the value arg is blank by either being null,\n     * empty, or contains only whitespace characters.\n     *\n     * @param value A string to check.\n     * @return true if the arg is blank.\n     */\n    public static boolean isBlank(String value) {\n        return Objects.isNull(value)\n                || indexOfNonWhitespace(value) >= value.length();\n    }\n\n    /**\n     * Method to find the index of the first non-whitespace character in a string.\n     *\n     * @param value the string to find the first index of a non-whitespace character for.\n     * @return the index of the first non-whitespace character.\n     */\n    public static int indexOfNonWhitespace(String value) {\n        final int length = value.length();\n        int left = 0;\n        while (left < length) {\n            final int codePointAt = value.codePointAt(left);\n            if (!Character.isWhitespace(codePointAt)) {\n                break;\n            }\n            left += Character.charCount(codePointAt);\n        }\n        return left;\n    }\n\n    /**\n     * Checks whether the string contains an integer value.\n     *\n     * @param str a string to check\n     * @return true if the given string is an integer, false otherwise.\n     */\n    public static boolean isInt(String str) {\n        boolean isInt;\n        if (str == null) {\n            isInt = false;\n        }\n        else {\n            try {\n                Integer.parseInt(str);\n                isInt = true;\n            }\n            catch (NumberFormatException ignored) {\n                isInt = false;\n            }\n        }\n        return isInt;\n    }\n\n    /**\n     * Converts the Unicode code point at index {@code index} to it's UTF-16\n     * representation, then checks if the character is whitespace. Note that the given\n     * index {@code index} should correspond to the location of the character\n     * to check in the string, not in code points.\n     *\n     * @param codePoints the array of Unicode code points\n     * @param index the index of the character to check\n     * @return true if character at {@code index} is whitespace\n     */\n    public static boolean isCodePointWhitespace(int[] codePoints, int index) {\n        //  We only need to check the first member of a surrogate pair to verify that\n        //  it is not whitespace.\n        final char character = Character.toChars(codePoints[index])[0];\n        return Character.isWhitespace(character);\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Finds a resource with a given name in the Checkstyle resource bundle.\n     * This method is intended only for internal use in Checkstyle tests for\n     * easy mocking to gain 100% coverage.\n     *\n     * @param name name of the desired resource\n     * @return URI of the resource\n     */\n    public static URL getCheckstyleResource(String name) {\n        return CommonUtil.class.getResource(name);\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Gets a resource from the classpath.\n     *\n     * @param filename name of file\n     * @return URI of file in classpath\n     * @throws CheckstyleException on failure\n     */\n    public static URI getResourceFromClassPath(String filename) throws CheckstyleException {\n        final URL configUrl;\n        if (filename.charAt(0) == '/') {\n            configUrl = getCheckstyleResource(filename);\n        }\n        else {\n            configUrl = ClassLoader.getSystemResource(filename);\n        }\n\n        if (configUrl == null) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename);\n        }\n\n        final URI uri;\n        try {\n            uri = configUrl.toURI();\n        }\n        catch (final URISyntaxException ex) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename, ex);\n        }\n\n        return uri;\n    }\n/**\n     * Finds a resource with a given name in the Checkstyle resource bundle.\n     * This method is intended only for internal use in Checkstyle tests for\n     * easy mocking to gain 100% coverage.\n     *\n     * @param name name of the desired resource\n     * @return URI of the resource\n     */\n    public static URL getCheckstyleResource(String name) {\n        return CommonUtil.class.getResource(name);\n    }", "diffSourceCode": "   440:     /**\n   441:      * Gets a resource from the classpath.\n   442:      *\n   443:      * @param filename name of file\n   444:      * @return URI of file in classpath\n   445:      * @throws CheckstyleException on failure\n   446:      */\n   447:     public static URI getResourceFromClassPath(String filename) throws CheckstyleException {\n   448:         final URL configUrl;\n   449:         if (filename.charAt(0) == '/') {\n-  450:             configUrl = CommonUtil.class.getResource(filename);\n+  450:             configUrl = getCheckstyleResource(filename);\n   451:         }\n   452:         else {\n   453:             configUrl = ClassLoader.getSystemResource(filename);\n   454:         }\n   455: \n   456:         if (configUrl == null) {\n   457:             throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename);\n   458:         }\n   459: \n   460:         final URI uri;\n   461:         try {\n   462:             uri = configUrl.toURI();\n   463:         }\n   464:         catch (final URISyntaxException ex) {\n   465:             throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename, ex);\n   466:         }\n   467: \n   468:         return uri;\n   469:     }\n   471:     /**\n-  472:      * Puts part of line, which matches regexp into given template\n-  473:      * on positions $n where 'n' is number of matched part in line.\n-  474:      *\n-  475:      * @param template the string to expand.\n-  476:      * @param lineToPlaceInTemplate contains expression which should be placed into string.\n-  477:      * @param regexp expression to find in comment.\n-  478:      * @return the string, based on template filled with given lines\n-  479:      */\n-  480:     public static String fillTemplateWithStringsByRegexp(\n-  481:         String template, String lineToPlaceInTemplate, Pattern regexp) {\n+  472:      * Finds a resource with a given name in the Checkstyle resource bundle.\n+  473:      * This method is intended only for internal use in Checkstyle tests for\n+  474:      * easy mocking to gain 100% coverage.\n+  475:      *\n+  476:      * @param name name of the desired resource\n+  477:      * @return URI of the resource\n+  478:      */\n+  479:     public static URL getCheckstyleResource(String name) {\n+  480:         return CommonUtil.class.getResource(name);\n+  481:     }\n", "uniqueId": "8129a4f69cf30d059ed7b34b4dca4b8118690526_440_469_471_481_440_469", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 47}, "BRANCH": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 10}, "COMPLEXITY": {"missed": 0, "covered": 3}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\n/**\n * Resolves the specified filename containing 'http', 'https', 'ftp',\n * and 'file' protocols (or any RFC 2396 compliant URL) to a URI.\n *\n * @param filename name of the file\n * @return resolved file URI or null if URL is malformed or non-existent\n */\npublic static URI getWebOrFileProtocolUri(String filename) {\n    URI uri;\n    try {\n        final URL url = new URL(filename);\n        uri = url.toURI();\n    }\n    catch (URISyntaxException | MalformedURLException ignored) {\n        uri = null;\n    }\n    return uri;\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Gets a resource from the classpath.\n     *\n     * @param filename name of file\n     * @return URI of file in classpath\n     * @throws CheckstyleException on failure\n     */\n    public static URI getResourceFromClassPath(String filename) throws CheckstyleException {\n        final URL configUrl;\n        if (filename.charAt(0) == '/') {\n            configUrl = CommonUtil.class.getResource(filename);\n        }\n        else {\n            configUrl = ClassLoader.getSystemResource(filename);\n        }\n\n        if (configUrl == null) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename);\n        }\n\n        final URI uri;\n        try {\n            uri = configUrl.toURI();\n        }\n        catch (final URISyntaxException ex) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename, ex);\n        }\n\n        return uri;\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.utils;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Contains utility methods.\n *\n */\npublic final class CommonUtil {\n\n    /** Default tab width for column reporting. */\n    public static final int DEFAULT_TAB_WIDTH = 8;\n\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final int[] EMPTY_INT_ARRAY = new int[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n    /** Pseudo URL protocol for loading from the class path. */\n    public static final String CLASSPATH_URL_PROTOCOL = \"classpath:\";\n\n    /** Prefix for the exception when unable to find resource. */\n    private static final String UNABLE_TO_FIND_EXCEPTION_PREFIX = \"Unable to find: \";\n\n    /** Stop instances being created. **/\n    private CommonUtil() {\n    }\n\n    /**\n     * Helper method to create a regular expression.\n     *\n     * @param pattern\n     *            the pattern to match\n     * @return a created regexp object\n     * @throws IllegalArgumentException\n     *             if unable to create Pattern object.\n     **/\n    public static Pattern createPattern(String pattern) {\n        return createPattern(pattern, 0);\n    }\n\n    /**\n     * Helper method to create a regular expression with a specific flags.\n     *\n     * @param pattern\n     *            the pattern to match\n     * @param flags\n     *            the flags to set\n     * @return a created regexp object\n     * @throws IllegalArgumentException\n     *             if unable to create Pattern object.\n     **/\n    public static Pattern createPattern(String pattern, int flags) {\n        try {\n            return Pattern.compile(pattern, flags);\n        }\n        catch (final PatternSyntaxException ex) {\n            throw new IllegalArgumentException(\n                \"Failed to initialise regular expression \" + pattern, ex);\n        }\n    }\n\n    /**\n     * Returns whether the file extension matches what we are meant to process.\n     *\n     * @param file\n     *            the file to be checked.\n     * @param fileExtensions\n     *            files extensions, empty property in config makes it matches to all.\n     * @return whether there is a match.\n     */\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        boolean result = false;\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            result = true;\n        }\n        else {\n            // normalize extensions so all of them have a leading dot\n            final String[] withDotExtensions = new String[fileExtensions.length];\n            for (int i = 0; i < fileExtensions.length; i++) {\n                final String extension = fileExtensions[i];\n                if (startsWithChar(extension, '.')) {\n                    withDotExtensions[i] = extension;\n                }\n                else {\n                    withDotExtensions[i] = \".\" + extension;\n                }\n            }\n\n            final String fileName = file.getName();\n            for (final String fileExtension : withDotExtensions) {\n                if (fileName.endsWith(fileExtension)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns whether the specified string contains only whitespace up to the specified index.\n     *\n     * @param index\n     *            index to check up to\n     * @param line\n     *            the line to check\n     * @return whether there is only whitespace\n     */\n    public static boolean hasWhitespaceBefore(int index, String line) {\n        boolean result = true;\n        for (int i = 0; i < index; i++) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                result = false;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the length of a string ignoring all trailing whitespace.\n     * It is a pity that there is not a trim() like\n     * method that only removed the trailing whitespace.\n     *\n     * @param line\n     *            the string to process\n     * @return the length of the string ignoring all trailing whitespace\n     **/\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int len = line.length();\n        for (int i = len - 1; i >= 0; i--) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                break;\n            }\n            len--;\n        }\n        return len;\n    }\n\n    /**\n     * Returns the length of a String prefix with tabs expanded.\n     * Each tab is counted as the number of characters is\n     * takes to jump to the next tab stop.\n     *\n     * @param inputString\n     *            the input String\n     * @param toIdx\n     *            index in string (exclusive) where the calculation stops\n     * @param tabWidth\n     *            the distance between tab stop position.\n     * @return the length of string.substring(0, toIdx) with tabs expanded.\n     */\n    public static int lengthExpandedTabs(String inputString,\n            int toIdx,\n            int tabWidth) {\n        int len = 0;\n        for (int idx = 0; idx < toIdx; idx++) {\n            if (inputString.codePointAt(idx) == '\\t') {\n                len = (len / tabWidth + 1) * tabWidth;\n            }\n            else {\n                len++;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * Validates whether passed string is a valid pattern or not.\n     *\n     * @param pattern\n     *            string to validate\n     * @return true if the pattern is valid false otherwise\n     */\n    public static boolean isPatternValid(String pattern) {\n        boolean isValid = true;\n        try {\n            Pattern.compile(pattern);\n        }\n        catch (final PatternSyntaxException ignored) {\n            isValid = false;\n        }\n        return isValid;\n    }\n\n    /**\n     * Returns base class name from qualified name.\n     *\n     * @param type\n     *            the fully qualified name. Cannot be null\n     * @return the base class name from a fully qualified name\n     */\n    public static String baseClassName(String type) {\n        final String className;\n        final int index = type.lastIndexOf('.');\n        if (index == -1) {\n            className = type;\n        }\n        else {\n            className = type.substring(index + 1);\n        }\n        return className;\n    }\n\n    /**\n     * Constructs a normalized relative path between base directory and a given path.\n     *\n     * @param baseDirectory\n     *            the base path to which given path is relativized\n     * @param path\n     *            the path to relativize against base directory\n     * @return the relative normalized path between base directory and\n     *     path or path if base directory is null.\n     */\n    public static String relativizeAndNormalizePath(final String baseDirectory, final String path) {\n        final String resultPath;\n        if (baseDirectory == null) {\n            resultPath = path;\n        }\n        else {\n            final Path pathAbsolute = Paths.get(path).normalize();\n            final Path pathBase = Paths.get(baseDirectory).normalize();\n            resultPath = pathBase.relativize(pathAbsolute).toString();\n        }\n        return resultPath;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     * <p>\n     * It is faster version of {@link String#startsWith(String)} optimized for\n     *  one-character prefixes at the expense of\n     * some readability. Suggested by SimplifyStartsWith PMD rule:\n     * http://pmd.sourceforge.net/pmd-5.3.1/pmd-java/rules/java/optimizations.html#SimplifyStartsWith\n     * </p>\n     *\n     * @param value\n     *            the {@code String} to check\n     * @param prefix\n     *            the prefix to find\n     * @return {@code true} if the {@code char} is a prefix of the given {@code String};\n     *     {@code false} otherwise.\n     */\n    public static boolean startsWithChar(String value, char prefix) {\n        return !value.isEmpty() && value.charAt(0) == prefix;\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     * <p>\n     * It is faster version of {@link String#endsWith(String)} optimized for\n     *  one-character suffixes at the expense of\n     * some readability. Suggested by SimplifyStartsWith PMD rule:\n     * http://pmd.sourceforge.net/pmd-5.3.1/pmd-java/rules/java/optimizations.html#SimplifyStartsWith\n     * </p>\n     *\n     * @param value\n     *            the {@code String} to check\n     * @param suffix\n     *            the suffix to find\n     * @return {@code true} if the {@code char} is a suffix of the given {@code String};\n     *     {@code false} otherwise.\n     */\n    public static boolean endsWithChar(String value, char suffix) {\n        return !value.isEmpty() && value.charAt(value.length() - 1) == suffix;\n    }\n\n    /**\n     * Gets constructor of targetClass.\n     *\n     * @param <T> type of the target class object.\n     * @param targetClass\n     *            from which constructor is returned\n     * @param parameterTypes\n     *            of constructor\n     * @return constructor of targetClass\n     * @throws IllegalStateException if any exception occurs\n     * @see Class#getConstructor(Class[])\n     */\n    public static <T> Constructor<T> getConstructor(Class<T> targetClass,\n                                                    Class<?>... parameterTypes) {\n        try {\n            return targetClass.getConstructor(parameterTypes);\n        }\n        catch (NoSuchMethodException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    /**\n     * Returns new instance of a class.\n     *\n     * @param <T>\n     *            type of constructor\n     * @param constructor\n     *            to invoke\n     * @param parameters\n     *            to pass to constructor\n     * @return new instance of class\n     * @throws IllegalStateException if any exception occurs\n     * @see Constructor#newInstance(Object...)\n     */\n    public static <T> T invokeConstructor(Constructor<T> constructor, Object... parameters) {\n        try {\n            return constructor.newInstance(parameters);\n        }\n        catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    /**\n     * Closes a stream re-throwing IOException as IllegalStateException.\n     *\n     * @param closeable\n     *            Closeable object\n     * @throws IllegalStateException when any IOException occurs\n     */\n    public static void close(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            }\n            catch (IOException ex) {\n                throw new IllegalStateException(\"Cannot close the stream\", ex);\n            }\n        }\n    }\n\n    /**\n     * Resolve the specified filename to a URI.\n     *\n     * @param filename name of the file\n     * @return resolved file URI\n     * @throws CheckstyleException on failure\n     */\n    public static URI getUriByFilename(String filename) throws CheckstyleException {\n        URI uri = getWebOrFileProtocolUri(filename);\n\n        if (uri == null) {\n            uri = getFilepathOrClasspathUri(filename);\n        }\n\n        return uri;\n    }\n\n    /**\n     * Resolves the specified filename containing 'http', 'https', 'ftp',\n     * and 'file' protocols (or any RFC 2396 compliant URL) to a URI.\n     *\n     * @param filename name of the file\n     * @return resolved file URI or null if URL is malformed or non-existent\n     */\n    public static URI getWebOrFileProtocolUri(String filename) {\n        URI uri;\n        try {\n            final URL url = new URL(filename);\n            uri = url.toURI();\n        }\n        catch (URISyntaxException | MalformedURLException ignored) {\n            uri = null;\n        }\n        return uri;\n    }\n\n    /**\n     * Resolves the specified local filename, possibly with 'classpath:'\n     * protocol, to a URI.  First we attempt to create a new file with\n     * given filename, then attempt to load file from class path.\n     *\n     * @param filename name of the file\n     * @return resolved file URI\n     * @throws CheckstyleException on failure\n     */\n    private static URI getFilepathOrClasspathUri(String filename) throws CheckstyleException {\n        final URI uri;\n        final File file = new File(filename);\n\n        if (file.exists()) {\n            uri = file.toURI();\n        }\n        else {\n            final int lastIndexOfClasspathProtocol;\n            if (filename.lastIndexOf(CLASSPATH_URL_PROTOCOL) == 0) {\n                lastIndexOfClasspathProtocol = CLASSPATH_URL_PROTOCOL.length();\n            }\n            else {\n                lastIndexOfClasspathProtocol = 0;\n            }\n            uri = getResourceFromClassPath(filename\n                .substring(lastIndexOfClasspathProtocol));\n        }\n        return uri;\n    }\n\n    /**\n     * Gets a resource from the classpath.\n     *\n     * @param filename name of file\n     * @return URI of file in classpath\n     * @throws CheckstyleException on failure\n     */\n    public static URI getResourceFromClassPath(String filename) throws CheckstyleException {\n        final URL configUrl;\n        if (filename.charAt(0) == '/') {\n            configUrl = CommonUtil.class.getResource(filename);\n        }\n        else {\n            configUrl = ClassLoader.getSystemResource(filename);\n        }\n\n        if (configUrl == null) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename);\n        }\n\n        final URI uri;\n        try {\n            uri = configUrl.toURI();\n        }\n        catch (final URISyntaxException ex) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename, ex);\n        }\n\n        return uri;\n    }\n\n    /**\n     * Puts part of line, which matches regexp into given template\n     * on positions $n where 'n' is number of matched part in line.\n     *\n     * @param template the string to expand.\n     * @param lineToPlaceInTemplate contains expression which should be placed into string.\n     * @param regexp expression to find in comment.\n     * @return the string, based on template filled with given lines\n     */\n    public static String fillTemplateWithStringsByRegexp(\n        String template, String lineToPlaceInTemplate, Pattern regexp) {\n        final Matcher matcher = regexp.matcher(lineToPlaceInTemplate);\n        String result = template;\n        if (matcher.find()) {\n            for (int i = 0; i <= matcher.groupCount(); i++) {\n                // $n expands comment match like in Pattern.subst().\n                result = result.replaceAll(\"\\\\$\" + i, matcher.group(i));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns file name without extension.\n     * We do not use the method from Guava library to reduce Checkstyle's dependencies\n     * on external libraries.\n     *\n     * @param fullFilename file name with extension.\n     * @return file name without extension.\n     */\n    public static String getFileNameWithoutExtension(String fullFilename) {\n        final String fileName = new File(fullFilename).getName();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String fileNameWithoutExtension;\n        if (dotIndex == -1) {\n            fileNameWithoutExtension = fileName;\n        }\n        else {\n            fileNameWithoutExtension = fileName.substring(0, dotIndex);\n        }\n        return fileNameWithoutExtension;\n    }\n\n    /**\n     * Returns file extension for the given file name\n     * or empty string if file does not have an extension.\n     * We do not use the method from Guava library to reduce Checkstyle's dependencies\n     * on external libraries.\n     *\n     * @param fileNameWithExtension file name with extension.\n     * @return file extension for the given file name\n     *         or empty string if file does not have an extension.\n     */\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n    }\n\n    /**\n     * Checks whether the given string is a valid identifier.\n     *\n     * @param str A string to check.\n     * @return true when the given string contains valid identifier.\n     */\n    public static boolean isIdentifier(String str) {\n        boolean isIdentifier = !str.isEmpty();\n\n        for (int i = 0; isIdentifier && i < str.length(); i++) {\n            if (i == 0) {\n                isIdentifier = Character.isJavaIdentifierStart(str.charAt(0));\n            }\n            else {\n                isIdentifier = Character.isJavaIdentifierPart(str.charAt(i));\n            }\n        }\n\n        return isIdentifier;\n    }\n\n    /**\n     * Checks whether the given string is a valid name.\n     *\n     * @param str A string to check.\n     * @return true when the given string contains valid name.\n     */\n    public static boolean isName(String str) {\n        boolean isName = !str.isEmpty();\n\n        final String[] identifiers = str.split(\"\\\\.\", -1);\n        for (int i = 0; isName && i < identifiers.length; i++) {\n            isName = isIdentifier(identifiers[i]);\n        }\n\n        return isName;\n    }\n\n    /**\n     * Checks if the value arg is blank by either being null,\n     * empty, or contains only whitespace characters.\n     *\n     * @param value A string to check.\n     * @return true if the arg is blank.\n     */\n    public static boolean isBlank(String value) {\n        return Objects.isNull(value)\n                || indexOfNonWhitespace(value) >= value.length();\n    }\n\n    /**\n     * Method to find the index of the first non-whitespace character in a string.\n     *\n     * @param value the string to find the first index of a non-whitespace character for.\n     * @return the index of the first non-whitespace character.\n     */\n    public static int indexOfNonWhitespace(String value) {\n        final int length = value.length();\n        int left = 0;\n        while (left < length) {\n            final int codePointAt = value.codePointAt(left);\n            if (!Character.isWhitespace(codePointAt)) {\n                break;\n            }\n            left += Character.charCount(codePointAt);\n        }\n        return left;\n    }\n\n    /**\n     * Checks whether the string contains an integer value.\n     *\n     * @param str a string to check\n     * @return true if the given string is an integer, false otherwise.\n     */\n    public static boolean isInt(String str) {\n        boolean isInt;\n        if (str == null) {\n            isInt = false;\n        }\n        else {\n            try {\n                Integer.parseInt(str);\n                isInt = true;\n            }\n            catch (NumberFormatException ignored) {\n                isInt = false;\n            }\n        }\n        return isInt;\n    }\n\n    /**\n     * Converts the Unicode code point at index {@code index} to it's UTF-16\n     * representation, then checks if the character is whitespace. Note that the given\n     * index {@code index} should correspond to the location of the character\n     * to check in the string, not in code points.\n     *\n     * @param codePoints the array of Unicode code points\n     * @param index the index of the character to check\n     * @return true if character at {@code index} is whitespace\n     */\n    public static boolean isCodePointWhitespace(int[] codePoints, int index) {\n        //  We only need to check the first member of a surrogate pair to verify that\n        //  it is not whitespace.\n        final char character = Character.toChars(codePoints[index])[0];\n        return Character.isWhitespace(character);\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate visitParameters(parametersAst DetailAST) : void extracted from private visitMethodParameters(ast DetailAST) : void in class com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "startLine": 256, "endLine": 274, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "startLine": 226, "endLine": 233, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "startLine": 249, "endLine": 267, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        DetailAST parameterDefAST =\n            ast.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "isPureRefactoring": true, "commitId": "ebfc50d227b7514505007aa111d6bf0e7e09f926", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck#visitMethodParameters", "classSignatureBefore": "public final class ParameterAssignmentCheck extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck#visitMethodParameters"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck"], "classSignatureBeforeSet": ["public final class ParameterAssignmentCheck extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All the mappings are matched! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n\n/**\n * <p>\n * Disallows assignment of parameters.\n * </p>\n * <p>\n * Rationale:\n * Parameter assignment is often considered poor\n * programming practice. Forcing developers to declare\n * parameters as final is often onerous. Having a check\n * ensure that parameters are never assigned would give\n * the best of both worlds.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;ParameterAssignment&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * class MyClass {\n *   int methodOne(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     parameter -= 2;  // violation\n *     return parameter;\n *   }\n *\n *   int methodTwo(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     int local = parameter;\n *     local -= 2;  // OK\n *     return local;\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code parameter.assignment}\n * </li>\n * </ul>\n *\n * @since 3.2\n */\n@FileStatefulCheck\npublic final class ParameterAssignmentCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"parameter.assignment\";\n\n    /** Stack of methods' parameters. */\n    private final Deque<Set<String>> parameterNamesStack = new ArrayDeque<>();\n    /** Current set of parameters. */\n    private Set<String> parameterNames;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN,\n            TokenTypes.INC,\n            TokenTypes.POST_INC,\n            TokenTypes.DEC,\n            TokenTypes.POST_DEC,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        // clear data\n        parameterNamesStack.clear();\n        parameterNames = Collections.emptySet();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                visitMethodDef(ast);\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n                visitAssign(ast);\n                break;\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                visitIncDec(ast);\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                leaveMethodDef();\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                // Do nothing\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    /**\n     * Checks if this is assignments of parameter.\n     *\n     * @param ast assignment to check.\n     */\n    private void visitAssign(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Checks if this is increment/decrement of parameter.\n     *\n     * @param ast dec/inc to check.\n     */\n    private void visitIncDec(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Check if ident is parameter.\n     *\n     * @param ast ident to check.\n     */\n    private void checkIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param ast a method to process.\n     */\n    private void visitMethodDef(DetailAST ast) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        visitMethodParameters(ast.findFirstToken(TokenTypes.PARAMETERS));\n    }\n\n    /** Restores old set of parameters. */\n    private void leaveMethodDef() {\n        parameterNames = parameterNamesStack.pop();\n    }\n\n    /**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        DetailAST parameterDefAST =\n            ast.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * <p>\n * Disallows assignment of parameters.\n * </p>\n * <p>\n * Rationale:\n * Parameter assignment is often considered poor\n * programming practice. Forcing developers to declare\n * parameters as final is often onerous. Having a check\n * ensure that parameters are never assigned would give\n * the best of both worlds.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;ParameterAssignment&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * class MyClass {\n *   int methodOne(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     parameter -= 2;  // violation\n *     return parameter;\n *   }\n *\n *   int methodTwo(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     int local = parameter;\n *     local -= 2;  // OK\n *     return local;\n *   }\n *\n *   IntPredicate obj = a -&gt; ++a == 12; // violation\n *   IntBinaryOperator obj2 = (int a, int b) -&gt; {\n *       a++;     // violation\n *       b += 12; // violation\n *       return a + b;\n *   };\n *   IntPredicate obj3 = a -&gt; {\n *       int b = a; // ok\n *       return ++b == 12;\n *   };\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code parameter.assignment}\n * </li>\n * </ul>\n *\n * @since 3.2\n */\n@FileStatefulCheck\npublic final class ParameterAssignmentCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"parameter.assignment\";\n\n    /** Stack of methods' parameters. */\n    private final Deque<Set<String>> parameterNamesStack = new ArrayDeque<>();\n    /** Current set of parameters. */\n    private Set<String> parameterNames;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN,\n            TokenTypes.INC,\n            TokenTypes.POST_INC,\n            TokenTypes.DEC,\n            TokenTypes.POST_DEC,\n            TokenTypes.LAMBDA,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        // clear data\n        parameterNamesStack.clear();\n        parameterNames = Collections.emptySet();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final int type = ast.getType();\n        if (TokenUtil.isOfType(type, TokenTypes.CTOR_DEF, TokenTypes.METHOD_DEF)) {\n            visitMethodDef(ast);\n        }\n        else if (type == TokenTypes.LAMBDA) {\n            if (ast.getParent().getType() != TokenTypes.SWITCH_RULE) {\n                visitLambda(ast);\n            }\n        }\n        else {\n            checkNestedIdent(ast);\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        final int type = ast.getType();\n        if (TokenUtil.isOfType(type, TokenTypes.CTOR_DEF, TokenTypes.METHOD_DEF)\n                || type == TokenTypes.LAMBDA\n                && ast.getParent().getType() != TokenTypes.SWITCH_RULE) {\n            parameterNames = parameterNamesStack.pop();\n        }\n    }\n\n    /**\n     * Check if nested ident is parameter.\n     *\n     * @param ast parent of node of ident\n     */\n    private void checkNestedIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param ast a method to process.\n     */\n    private void visitMethodDef(DetailAST ast) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        visitMethodParameters(ast.findFirstToken(TokenTypes.PARAMETERS));\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param lambdaAst node of type {@link TokenTypes#LAMBDA}.\n     */\n    private void visitLambda(DetailAST lambdaAst) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        DetailAST parameterAst = lambdaAst.findFirstToken(TokenTypes.PARAMETERS);\n        if (parameterAst == null) {\n            parameterAst = lambdaAst.getFirstChild();\n        }\n        visitLambdaParameters(parameterAst);\n    }\n\n    /**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        visitParameters(ast);\n    }\n\n    /**\n     * Creates new parameter set for given lambda expression.\n     *\n     * @param ast a lambda expression parameter to process\n     */\n    private void visitLambdaParameters(DetailAST ast) {\n        if (ast.getType() == TokenTypes.IDENT) {\n            parameterNames.add(ast.getText());\n        }\n        else {\n            visitParameters(ast);\n        }\n    }\n\n    /**\n     * Visits parameter list and adds parameter names to the set.\n     *\n     * @param parametersAst ast node of type {@link TokenTypes#PARAMETERS}.\n     */\n    private void visitParameters(DetailAST parametersAst) {\n        DetailAST parameterDefAST =\n            parametersAst.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Visits parameter list and adds parameter names to the set.\n     *\n     * @param parametersAst ast node of type {@link TokenTypes#PARAMETERS}.\n     */\n    private void visitParameters(DetailAST parametersAst) {\n        DetailAST parameterDefAST =\n            parametersAst.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        visitParameters(ast);\n    }\n/**\n     * Visits parameter list and adds parameter names to the set.\n     *\n     * @param parametersAst ast node of type {@link TokenTypes#PARAMETERS}.\n     */\n    private void visitParameters(DetailAST parametersAst) {\n        DetailAST parameterDefAST =\n            parametersAst.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }", "diffSourceCode": "-  226:      *\n-  227:      * @param ast ident to check.\n-  228:      */\n-  229:     private void checkIdent(DetailAST ast) {\n-  230:         final DetailAST identAST = ast.getFirstChild();\n-  231: \n-  232:         if (identAST != null\n-  233:             && identAST.getType() == TokenTypes.IDENT\n-  249:     }\n-  250: \n-  251:     /** Restores old set of parameters. */\n-  252:     private void leaveMethodDef() {\n-  253:         parameterNames = parameterNamesStack.pop();\n-  254:     }\n-  255: \n-  256:     /**\n-  257:      * Creates new parameter set for given method.\n-  258:      *\n-  259:      * @param ast a method for process.\n-  260:      */\n-  261:     private void visitMethodParameters(DetailAST ast) {\n-  262:         DetailAST parameterDefAST =\n-  263:             ast.findFirstToken(TokenTypes.PARAMETER_DEF);\n-  264: \n-  265:         while (parameterDefAST != null) {\n-  266:             if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n-  267:                     && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n-  268:                 final DetailAST param =\n-  269:                     parameterDefAST.findFirstToken(TokenTypes.IDENT);\n-  270:                 parameterNames.add(param.getText());\n-  271:             }\n-  272:             parameterDefAST = parameterDefAST.getNextSibling();\n-  273:         }\n-  274:     }\n+  226:     /**\n+  227:      * Creates new parameter set for given method.\n+  228:      *\n+  229:      * @param ast a method for process.\n+  230:      */\n+  231:     private void visitMethodParameters(DetailAST ast) {\n+  232:         visitParameters(ast);\n+  233:     }\n+  249:     /**\n+  250:      * Visits parameter list and adds parameter names to the set.\n+  251:      *\n+  252:      * @param parametersAst ast node of type {@link TokenTypes#PARAMETERS}.\n+  253:      */\n+  254:     private void visitParameters(DetailAST parametersAst) {\n+  255:         DetailAST parameterDefAST =\n+  256:             parametersAst.findFirstToken(TokenTypes.PARAMETER_DEF);\n+  257: \n+  258:         while (parameterDefAST != null) {\n+  259:             if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n+  260:                     && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n+  261:                 final DetailAST param =\n+  262:                     parameterDefAST.findFirstToken(TokenTypes.IDENT);\n+  263:                 parameterNames.add(param.getText());\n+  264:             }\n+  265:             parameterDefAST = parameterDefAST.getNextSibling();\n+  266:         }\n+  267:     }\n+  268: \n+  269: }\n", "uniqueId": "ebfc50d227b7514505007aa111d6bf0e7e09f926_256_274_249_267_226_233", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 28}, "BRANCH": {"missed": 0, "covered": 6}, "LINE": {"missed": 0, "covered": 10}, "COMPLEXITY": {"missed": 0, "covered": 4}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\n/**\n * Checks if this is assignments of parameter.\n *\n * @param ast assignment to check.\n */\nprivate void visitAssign(DetailAST ast) {\n    checkIdent(ast);\n}\n\n/**\n * Checks if this is increment/decrement of parameter.\n *\n * @param ast dec/inc to check.\n */\nprivate void visitIncDec(DetailAST ast) {\n    checkIdent(ast);\n}\n\n/**\n * Check if ident is parameter.\n *\n * @param ast ident to check.\n */\nprivate void checkIdent(DetailAST ast) {\n    final DetailAST identAST = ast.getFirstChild();\n\n    if (identAST != null\n        && identAST.getType() == TokenTypes.IDENT\n        && parameterNames.contains(identAST.getText())) {\n        log(ast, MSG_KEY, identAST.getText());\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        DetailAST parameterDefAST =\n            ast.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n\n/**\n * <p>\n * Disallows assignment of parameters.\n * </p>\n * <p>\n * Rationale:\n * Parameter assignment is often considered poor\n * programming practice. Forcing developers to declare\n * parameters as final is often onerous. Having a check\n * ensure that parameters are never assigned would give\n * the best of both worlds.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;ParameterAssignment&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * class MyClass {\n *   int methodOne(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     parameter -= 2;  // violation\n *     return parameter;\n *   }\n *\n *   int methodTwo(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     int local = parameter;\n *     local -= 2;  // OK\n *     return local;\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code parameter.assignment}\n * </li>\n * </ul>\n *\n * @since 3.2\n */\n@FileStatefulCheck\npublic final class ParameterAssignmentCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"parameter.assignment\";\n\n    /** Stack of methods' parameters. */\n    private final Deque<Set<String>> parameterNamesStack = new ArrayDeque<>();\n    /** Current set of parameters. */\n    private Set<String> parameterNames;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN,\n            TokenTypes.INC,\n            TokenTypes.POST_INC,\n            TokenTypes.DEC,\n            TokenTypes.POST_DEC,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        // clear data\n        parameterNamesStack.clear();\n        parameterNames = Collections.emptySet();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                visitMethodDef(ast);\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n                visitAssign(ast);\n                break;\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                visitIncDec(ast);\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                leaveMethodDef();\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                // Do nothing\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    /**\n     * Checks if this is assignments of parameter.\n     *\n     * @param ast assignment to check.\n     */\n    private void visitAssign(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Checks if this is increment/decrement of parameter.\n     *\n     * @param ast dec/inc to check.\n     */\n    private void visitIncDec(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Check if ident is parameter.\n     *\n     * @param ast ident to check.\n     */\n    private void checkIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param ast a method to process.\n     */\n    private void visitMethodDef(DetailAST ast) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        visitMethodParameters(ast.findFirstToken(TokenTypes.PARAMETERS));\n    }\n\n    /** Restores old set of parameters. */\n    private void leaveMethodDef() {\n        parameterNames = parameterNamesStack.pop();\n    }\n\n    /**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        DetailAST parameterDefAST =\n            ast.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Inline Method", "description": "Inline Method\tprivate checkIdent(ast DetailAST) : void inlined to private checkNestedIdent(ast DetailAST) : void in class com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "startLine": 215, "endLine": 222, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "startLine": 183, "endLine": 196, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "startLine": 224, "endLine": 237, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Check if ident is parameter.\n     *\n     * @param ast ident to check.\n     */\n    private void checkIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "isPureRefactoring": true, "commitId": "ebfc50d227b7514505007aa111d6bf0e7e09f926", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck#checkIdent", "classSignatureBefore": "public final class ParameterAssignmentCheck extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck#checkIdent"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck"], "classSignatureBeforeSet": ["public final class ParameterAssignmentCheck extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n\n/**\n * <p>\n * Disallows assignment of parameters.\n * </p>\n * <p>\n * Rationale:\n * Parameter assignment is often considered poor\n * programming practice. Forcing developers to declare\n * parameters as final is often onerous. Having a check\n * ensure that parameters are never assigned would give\n * the best of both worlds.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;ParameterAssignment&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * class MyClass {\n *   int methodOne(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     parameter -= 2;  // violation\n *     return parameter;\n *   }\n *\n *   int methodTwo(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     int local = parameter;\n *     local -= 2;  // OK\n *     return local;\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code parameter.assignment}\n * </li>\n * </ul>\n *\n * @since 3.2\n */\n@FileStatefulCheck\npublic final class ParameterAssignmentCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"parameter.assignment\";\n\n    /** Stack of methods' parameters. */\n    private final Deque<Set<String>> parameterNamesStack = new ArrayDeque<>();\n    /** Current set of parameters. */\n    private Set<String> parameterNames;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN,\n            TokenTypes.INC,\n            TokenTypes.POST_INC,\n            TokenTypes.DEC,\n            TokenTypes.POST_DEC,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        // clear data\n        parameterNamesStack.clear();\n        parameterNames = Collections.emptySet();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                visitMethodDef(ast);\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n                visitAssign(ast);\n                break;\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                visitIncDec(ast);\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                leaveMethodDef();\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                // Do nothing\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    /**\n     * Checks if this is assignments of parameter.\n     *\n     * @param ast assignment to check.\n     */\n    private void visitAssign(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Checks if this is increment/decrement of parameter.\n     *\n     * @param ast dec/inc to check.\n     */\n    private void visitIncDec(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Check if ident is parameter.\n     *\n     * @param ast ident to check.\n     */\n    private void checkIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param ast a method to process.\n     */\n    private void visitMethodDef(DetailAST ast) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        visitMethodParameters(ast.findFirstToken(TokenTypes.PARAMETERS));\n    }\n\n    /** Restores old set of parameters. */\n    private void leaveMethodDef() {\n        parameterNames = parameterNamesStack.pop();\n    }\n\n    /**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        DetailAST parameterDefAST =\n            ast.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * <p>\n * Disallows assignment of parameters.\n * </p>\n * <p>\n * Rationale:\n * Parameter assignment is often considered poor\n * programming practice. Forcing developers to declare\n * parameters as final is often onerous. Having a check\n * ensure that parameters are never assigned would give\n * the best of both worlds.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;ParameterAssignment&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * class MyClass {\n *   int methodOne(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     parameter -= 2;  // violation\n *     return parameter;\n *   }\n *\n *   int methodTwo(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     int local = parameter;\n *     local -= 2;  // OK\n *     return local;\n *   }\n *\n *   IntPredicate obj = a -&gt; ++a == 12; // violation\n *   IntBinaryOperator obj2 = (int a, int b) -&gt; {\n *       a++;     // violation\n *       b += 12; // violation\n *       return a + b;\n *   };\n *   IntPredicate obj3 = a -&gt; {\n *       int b = a; // ok\n *       return ++b == 12;\n *   };\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code parameter.assignment}\n * </li>\n * </ul>\n *\n * @since 3.2\n */\n@FileStatefulCheck\npublic final class ParameterAssignmentCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"parameter.assignment\";\n\n    /** Stack of methods' parameters. */\n    private final Deque<Set<String>> parameterNamesStack = new ArrayDeque<>();\n    /** Current set of parameters. */\n    private Set<String> parameterNames;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN,\n            TokenTypes.INC,\n            TokenTypes.POST_INC,\n            TokenTypes.DEC,\n            TokenTypes.POST_DEC,\n            TokenTypes.LAMBDA,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        // clear data\n        parameterNamesStack.clear();\n        parameterNames = Collections.emptySet();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final int type = ast.getType();\n        if (TokenUtil.isOfType(type, TokenTypes.CTOR_DEF, TokenTypes.METHOD_DEF)) {\n            visitMethodDef(ast);\n        }\n        else if (type == TokenTypes.LAMBDA) {\n            if (ast.getParent().getType() != TokenTypes.SWITCH_RULE) {\n                visitLambda(ast);\n            }\n        }\n        else {\n            checkNestedIdent(ast);\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        final int type = ast.getType();\n        if (TokenUtil.isOfType(type, TokenTypes.CTOR_DEF, TokenTypes.METHOD_DEF)\n                || type == TokenTypes.LAMBDA\n                && ast.getParent().getType() != TokenTypes.SWITCH_RULE) {\n            parameterNames = parameterNamesStack.pop();\n        }\n    }\n\n    /**\n     * Check if nested ident is parameter.\n     *\n     * @param ast parent of node of ident\n     */\n    private void checkNestedIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param ast a method to process.\n     */\n    private void visitMethodDef(DetailAST ast) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        visitMethodParameters(ast.findFirstToken(TokenTypes.PARAMETERS));\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param lambdaAst node of type {@link TokenTypes#LAMBDA}.\n     */\n    private void visitLambda(DetailAST lambdaAst) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        DetailAST parameterAst = lambdaAst.findFirstToken(TokenTypes.PARAMETERS);\n        if (parameterAst == null) {\n            parameterAst = lambdaAst.getFirstChild();\n        }\n        visitLambdaParameters(parameterAst);\n    }\n\n    /**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        visitParameters(ast);\n    }\n\n    /**\n     * Creates new parameter set for given lambda expression.\n     *\n     * @param ast a lambda expression parameter to process\n     */\n    private void visitLambdaParameters(DetailAST ast) {\n        if (ast.getType() == TokenTypes.IDENT) {\n            parameterNames.add(ast.getText());\n        }\n        else {\n            visitParameters(ast);\n        }\n    }\n\n    /**\n     * Visits parameter list and adds parameter names to the set.\n     *\n     * @param parametersAst ast node of type {@link TokenTypes#PARAMETERS}.\n     */\n    private void visitParameters(DetailAST parametersAst) {\n        DetailAST parameterDefAST =\n            parametersAst.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Check if nested ident is parameter.\n     *\n     * @param ast parent of node of ident\n     */\n    private void checkNestedIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }", "diffSourceCode": "-  183:             case TokenTypes.ASSIGN:\n-  184:             case TokenTypes.PLUS_ASSIGN:\n-  185:             case TokenTypes.MINUS_ASSIGN:\n-  186:             case TokenTypes.STAR_ASSIGN:\n-  187:             case TokenTypes.DIV_ASSIGN:\n-  188:             case TokenTypes.MOD_ASSIGN:\n-  189:             case TokenTypes.SR_ASSIGN:\n-  190:             case TokenTypes.BSR_ASSIGN:\n-  191:             case TokenTypes.SL_ASSIGN:\n-  192:             case TokenTypes.BAND_ASSIGN:\n-  193:             case TokenTypes.BXOR_ASSIGN:\n-  194:             case TokenTypes.BOR_ASSIGN:\n-  195:             case TokenTypes.INC:\n-  196:             case TokenTypes.POST_INC:\n-  215:     /**\n-  216:      * Checks if this is increment/decrement of parameter.\n-  217:      *\n-  218:      * @param ast dec/inc to check.\n-  219:      */\n-  220:     private void visitIncDec(DetailAST ast) {\n-  221:         checkIdent(ast);\n-  222:     }\n-  224:     /**\n-  225:      * Check if ident is parameter.\n-  226:      *\n-  227:      * @param ast ident to check.\n-  228:      */\n-  229:     private void checkIdent(DetailAST ast) {\n-  230:         final DetailAST identAST = ast.getFirstChild();\n-  231: \n-  232:         if (identAST != null\n-  233:             && identAST.getType() == TokenTypes.IDENT\n-  234:             && parameterNames.contains(identAST.getText())) {\n-  235:             log(ast, MSG_KEY, identAST.getText());\n-  236:         }\n-  237:     }\n+  183:     /**\n+  184:      * Check if nested ident is parameter.\n+  185:      *\n+  186:      * @param ast parent of node of ident\n+  187:      */\n+  188:     private void checkNestedIdent(DetailAST ast) {\n+  189:         final DetailAST identAST = ast.getFirstChild();\n+  190: \n+  191:         if (identAST != null\n+  192:             && identAST.getType() == TokenTypes.IDENT\n+  193:             && parameterNames.contains(identAST.getText())) {\n+  194:             log(ast, MSG_KEY, identAST.getText());\n+  195:         }\n+  196:     }\n+  215:     private void visitLambda(DetailAST lambdaAst) {\n+  216:         parameterNamesStack.push(parameterNames);\n+  217:         parameterNames = new HashSet<>();\n+  218: \n+  219:         DetailAST parameterAst = lambdaAst.findFirstToken(TokenTypes.PARAMETERS);\n+  220:         if (parameterAst == null) {\n+  221:             parameterAst = lambdaAst.getFirstChild();\n+  222:         }\n+  224:     }\n+  225: \n+  226:     /**\n+  227:      * Creates new parameter set for given method.\n+  228:      *\n+  229:      * @param ast a method for process.\n+  230:      */\n+  231:     private void visitMethodParameters(DetailAST ast) {\n+  232:         visitParameters(ast);\n+  233:     }\n+  234: \n+  235:     /**\n+  236:      * Creates new parameter set for given lambda expression.\n+  237:      *\n", "uniqueId": "ebfc50d227b7514505007aa111d6bf0e7e09f926_215_222__183_196_224_237", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 27}, "BRANCH": {"missed": 0, "covered": 6}, "LINE": {"missed": 0, "covered": 6}, "COMPLEXITY": {"missed": 0, "covered": 4}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\n/**\n * Check if ident is parameter.\n *\n * @param ast ident to check.\n */\nprivate void checkIdent(DetailAST ast) {\n    final DetailAST identAST = ast.getFirstChild();\n\n    if (identAST != null\n        && identAST.getType() == TokenTypes.IDENT\n        && parameterNames.contains(identAST.getText())) {\n        log(ast, MSG_KEY, identAST.getText());\n    }\n}\n\n/**\n * Checks if this is assignments of parameter.\n *\n * @param ast assignment to check.\n */\nprivate void visitAssign(DetailAST ast) {\n    final DetailAST identAST = ast.getFirstChild();\n\n    if (identAST != null\n        && identAST.getType() == TokenTypes.IDENT\n        && parameterNames.contains(identAST.getText())) {\n        log(ast, MSG_KEY, identAST.getText());\n    }\n}\n\n/**\n * Checks if this is increment/decrement of parameter.\n *\n * @param ast dec/inc to check.\n */\nprivate void visitIncDec(DetailAST ast) {\n    final DetailAST identAST = ast.getFirstChild();\n\n    if (identAST != null\n        && identAST.getType() == TokenTypes.IDENT\n        && parameterNames.contains(identAST.getText())) {\n        log(ast, MSG_KEY, identAST.getText());\n    }\n}\n\n/**\n * Creates new set of parameters and store old one in stack.\n *\n * @param ast a method to process.\n */\nprivate void visitMethodDef(DetailAST ast) {\n    parameterNamesStack.push(parameterNames);\n    parameterNames = new HashSet<>();\n\n    DetailAST parametersAST = ast.findFirstToken(TokenTypes.PARAMETERS);\n    DetailAST parameterDefAST = parametersAST.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n    while (parameterDefAST != null) {\n        if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n            final DetailAST param = parameterDefAST.findFirstToken(TokenTypes.IDENT);\n            parameterNames.add(param.getText());\n        }\n        parameterDefAST = parameterDefAST.getNextSibling();\n    }\n}\n\n/** Restores old set of parameters. */\nprivate void leaveMethodDef() {\n    parameterNames = parameterNamesStack.pop();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Check if ident is parameter.\n     *\n     * @param ast ident to check.\n     */\n    private void checkIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n\n/**\n * <p>\n * Disallows assignment of parameters.\n * </p>\n * <p>\n * Rationale:\n * Parameter assignment is often considered poor\n * programming practice. Forcing developers to declare\n * parameters as final is often onerous. Having a check\n * ensure that parameters are never assigned would give\n * the best of both worlds.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;ParameterAssignment&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * class MyClass {\n *   int methodOne(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     parameter -= 2;  // violation\n *     return parameter;\n *   }\n *\n *   int methodTwo(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     int local = parameter;\n *     local -= 2;  // OK\n *     return local;\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code parameter.assignment}\n * </li>\n * </ul>\n *\n * @since 3.2\n */\n@FileStatefulCheck\npublic final class ParameterAssignmentCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"parameter.assignment\";\n\n    /** Stack of methods' parameters. */\n    private final Deque<Set<String>> parameterNamesStack = new ArrayDeque<>();\n    /** Current set of parameters. */\n    private Set<String> parameterNames;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN,\n            TokenTypes.INC,\n            TokenTypes.POST_INC,\n            TokenTypes.DEC,\n            TokenTypes.POST_DEC,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        // clear data\n        parameterNamesStack.clear();\n        parameterNames = Collections.emptySet();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                visitMethodDef(ast);\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n                visitAssign(ast);\n                break;\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                visitIncDec(ast);\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                leaveMethodDef();\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                // Do nothing\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    /**\n     * Checks if this is assignments of parameter.\n     *\n     * @param ast assignment to check.\n     */\n    private void visitAssign(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Checks if this is increment/decrement of parameter.\n     *\n     * @param ast dec/inc to check.\n     */\n    private void visitIncDec(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Check if ident is parameter.\n     *\n     * @param ast ident to check.\n     */\n    private void checkIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param ast a method to process.\n     */\n    private void visitMethodDef(DetailAST ast) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        visitMethodParameters(ast.findFirstToken(TokenTypes.PARAMETERS));\n    }\n\n    /** Restores old set of parameters. */\n    private void leaveMethodDef() {\n        parameterNames = parameterNamesStack.pop();\n    }\n\n    /**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        DetailAST parameterDefAST =\n            ast.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\n}\n\nRefactoring Operation:\nInline Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\nrefactored_class_code\n##########################\n\n\n"}, {"type": "Inline Method", "description": "Inline Method\tprivate leaveMethodDef() : void inlined to public leaveToken(ast DetailAST) : void in class com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "startLine": 176, "endLine": 204, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "startLine": 173, "endLine": 181, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "startLine": 251, "endLine": 254, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/** Restores old set of parameters. */\n    private void leaveMethodDef() {\n        parameterNames = parameterNamesStack.pop();\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "isPureRefactoring": true, "commitId": "ebfc50d227b7514505007aa111d6bf0e7e09f926", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck#leaveMethodDef", "classSignatureBefore": "public final class ParameterAssignmentCheck extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck#leaveMethodDef"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.coding.ParameterAssignmentCheck"], "classSignatureBeforeSet": ["public final class ParameterAssignmentCheck extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n\n/**\n * <p>\n * Disallows assignment of parameters.\n * </p>\n * <p>\n * Rationale:\n * Parameter assignment is often considered poor\n * programming practice. Forcing developers to declare\n * parameters as final is often onerous. Having a check\n * ensure that parameters are never assigned would give\n * the best of both worlds.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;ParameterAssignment&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * class MyClass {\n *   int methodOne(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     parameter -= 2;  // violation\n *     return parameter;\n *   }\n *\n *   int methodTwo(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     int local = parameter;\n *     local -= 2;  // OK\n *     return local;\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code parameter.assignment}\n * </li>\n * </ul>\n *\n * @since 3.2\n */\n@FileStatefulCheck\npublic final class ParameterAssignmentCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"parameter.assignment\";\n\n    /** Stack of methods' parameters. */\n    private final Deque<Set<String>> parameterNamesStack = new ArrayDeque<>();\n    /** Current set of parameters. */\n    private Set<String> parameterNames;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN,\n            TokenTypes.INC,\n            TokenTypes.POST_INC,\n            TokenTypes.DEC,\n            TokenTypes.POST_DEC,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        // clear data\n        parameterNamesStack.clear();\n        parameterNames = Collections.emptySet();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                visitMethodDef(ast);\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n                visitAssign(ast);\n                break;\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                visitIncDec(ast);\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                leaveMethodDef();\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                // Do nothing\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    /**\n     * Checks if this is assignments of parameter.\n     *\n     * @param ast assignment to check.\n     */\n    private void visitAssign(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Checks if this is increment/decrement of parameter.\n     *\n     * @param ast dec/inc to check.\n     */\n    private void visitIncDec(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Check if ident is parameter.\n     *\n     * @param ast ident to check.\n     */\n    private void checkIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param ast a method to process.\n     */\n    private void visitMethodDef(DetailAST ast) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        visitMethodParameters(ast.findFirstToken(TokenTypes.PARAMETERS));\n    }\n\n    /** Restores old set of parameters. */\n    private void leaveMethodDef() {\n        parameterNames = parameterNamesStack.pop();\n    }\n\n    /**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        DetailAST parameterDefAST =\n            ast.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * <p>\n * Disallows assignment of parameters.\n * </p>\n * <p>\n * Rationale:\n * Parameter assignment is often considered poor\n * programming practice. Forcing developers to declare\n * parameters as final is often onerous. Having a check\n * ensure that parameters are never assigned would give\n * the best of both worlds.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;ParameterAssignment&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * class MyClass {\n *   int methodOne(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     parameter -= 2;  // violation\n *     return parameter;\n *   }\n *\n *   int methodTwo(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     int local = parameter;\n *     local -= 2;  // OK\n *     return local;\n *   }\n *\n *   IntPredicate obj = a -&gt; ++a == 12; // violation\n *   IntBinaryOperator obj2 = (int a, int b) -&gt; {\n *       a++;     // violation\n *       b += 12; // violation\n *       return a + b;\n *   };\n *   IntPredicate obj3 = a -&gt; {\n *       int b = a; // ok\n *       return ++b == 12;\n *   };\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code parameter.assignment}\n * </li>\n * </ul>\n *\n * @since 3.2\n */\n@FileStatefulCheck\npublic final class ParameterAssignmentCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"parameter.assignment\";\n\n    /** Stack of methods' parameters. */\n    private final Deque<Set<String>> parameterNamesStack = new ArrayDeque<>();\n    /** Current set of parameters. */\n    private Set<String> parameterNames;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN,\n            TokenTypes.INC,\n            TokenTypes.POST_INC,\n            TokenTypes.DEC,\n            TokenTypes.POST_DEC,\n            TokenTypes.LAMBDA,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        // clear data\n        parameterNamesStack.clear();\n        parameterNames = Collections.emptySet();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final int type = ast.getType();\n        if (TokenUtil.isOfType(type, TokenTypes.CTOR_DEF, TokenTypes.METHOD_DEF)) {\n            visitMethodDef(ast);\n        }\n        else if (type == TokenTypes.LAMBDA) {\n            if (ast.getParent().getType() != TokenTypes.SWITCH_RULE) {\n                visitLambda(ast);\n            }\n        }\n        else {\n            checkNestedIdent(ast);\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        final int type = ast.getType();\n        if (TokenUtil.isOfType(type, TokenTypes.CTOR_DEF, TokenTypes.METHOD_DEF)\n                || type == TokenTypes.LAMBDA\n                && ast.getParent().getType() != TokenTypes.SWITCH_RULE) {\n            parameterNames = parameterNamesStack.pop();\n        }\n    }\n\n    /**\n     * Check if nested ident is parameter.\n     *\n     * @param ast parent of node of ident\n     */\n    private void checkNestedIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param ast a method to process.\n     */\n    private void visitMethodDef(DetailAST ast) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        visitMethodParameters(ast.findFirstToken(TokenTypes.PARAMETERS));\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param lambdaAst node of type {@link TokenTypes#LAMBDA}.\n     */\n    private void visitLambda(DetailAST lambdaAst) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        DetailAST parameterAst = lambdaAst.findFirstToken(TokenTypes.PARAMETERS);\n        if (parameterAst == null) {\n            parameterAst = lambdaAst.getFirstChild();\n        }\n        visitLambdaParameters(parameterAst);\n    }\n\n    /**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        visitParameters(ast);\n    }\n\n    /**\n     * Creates new parameter set for given lambda expression.\n     *\n     * @param ast a lambda expression parameter to process\n     */\n    private void visitLambdaParameters(DetailAST ast) {\n        if (ast.getType() == TokenTypes.IDENT) {\n            parameterNames.add(ast.getText());\n        }\n        else {\n            visitParameters(ast);\n        }\n    }\n\n    /**\n     * Visits parameter list and adds parameter names to the set.\n     *\n     * @param parametersAst ast node of type {@link TokenTypes#PARAMETERS}.\n     */\n    private void visitParameters(DetailAST parametersAst) {\n        DetailAST parameterDefAST =\n            parametersAst.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Override\n    public void leaveToken(DetailAST ast) {\n        final int type = ast.getType();\n        if (TokenUtil.isOfType(type, TokenTypes.CTOR_DEF, TokenTypes.METHOD_DEF)\n                || type == TokenTypes.LAMBDA\n                && ast.getParent().getType() != TokenTypes.SWITCH_RULE) {\n            parameterNames = parameterNamesStack.pop();\n        }\n    }", "diffSourceCode": "-  173:         }\n-  174:     }\n-  175: \n-  176:     @Override\n-  177:     public void leaveToken(DetailAST ast) {\n-  178:         switch (ast.getType()) {\n-  179:             case TokenTypes.CTOR_DEF:\n-  180:             case TokenTypes.METHOD_DEF:\n-  181:                 leaveMethodDef();\n-  182:                 break;\n-  183:             case TokenTypes.ASSIGN:\n-  184:             case TokenTypes.PLUS_ASSIGN:\n-  185:             case TokenTypes.MINUS_ASSIGN:\n-  186:             case TokenTypes.STAR_ASSIGN:\n-  187:             case TokenTypes.DIV_ASSIGN:\n-  188:             case TokenTypes.MOD_ASSIGN:\n-  189:             case TokenTypes.SR_ASSIGN:\n-  190:             case TokenTypes.BSR_ASSIGN:\n-  191:             case TokenTypes.SL_ASSIGN:\n-  192:             case TokenTypes.BAND_ASSIGN:\n-  193:             case TokenTypes.BXOR_ASSIGN:\n-  194:             case TokenTypes.BOR_ASSIGN:\n-  195:             case TokenTypes.INC:\n-  196:             case TokenTypes.POST_INC:\n-  197:             case TokenTypes.DEC:\n-  198:             case TokenTypes.POST_DEC:\n-  199:                 // Do nothing\n-  200:                 break;\n-  201:             default:\n-  202:                 throw new IllegalStateException(ast.toString());\n-  203:         }\n-  204:     }\n-  251:     /** Restores old set of parameters. */\n-  252:     private void leaveMethodDef() {\n-  253:         parameterNames = parameterNamesStack.pop();\n-  254:     }\n+  173:     @Override\n+  174:     public void leaveToken(DetailAST ast) {\n+  175:         final int type = ast.getType();\n+  176:         if (TokenUtil.isOfType(type, TokenTypes.CTOR_DEF, TokenTypes.METHOD_DEF)\n+  177:                 || type == TokenTypes.LAMBDA\n+  178:                 && ast.getParent().getType() != TokenTypes.SWITCH_RULE) {\n+  179:             parameterNames = parameterNamesStack.pop();\n+  180:         }\n+  181:     }\n+  182: \n+  183:     /**\n+  184:      * Check if nested ident is parameter.\n+  185:      *\n+  186:      * @param ast parent of node of ident\n+  187:      */\n+  188:     private void checkNestedIdent(DetailAST ast) {\n+  189:         final DetailAST identAST = ast.getFirstChild();\n+  190: \n+  191:         if (identAST != null\n+  192:             && identAST.getType() == TokenTypes.IDENT\n+  193:             && parameterNames.contains(identAST.getText())) {\n+  194:             log(ast, MSG_KEY, identAST.getText());\n+  195:         }\n+  196:     }\n+  197: \n+  198:     /**\n+  199:      * Creates new set of parameters and store old one in stack.\n+  200:      *\n+  201:      * @param ast a method to process.\n+  202:      */\n+  203:     private void visitMethodDef(DetailAST ast) {\n+  204:         parameterNamesStack.push(parameterNames);\n+  251:      *\n+  252:      * @param parametersAst ast node of type {@link TokenTypes#PARAMETERS}.\n+  253:      */\n+  254:     private void visitParameters(DetailAST parametersAst) {\n", "uniqueId": "ebfc50d227b7514505007aa111d6bf0e7e09f926_176_204__173_181_251_254", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 7}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "##########################\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n\n/**\n * <p>\n * Disallows assignment of parameters.\n * </p>\n * <p>\n * Rationale:\n * Parameter assignment is often considered poor\n * programming practice. Forcing developers to declare\n * parameters as final is often onerous. Having a check\n * ensure that parameters are never assigned would give\n * the best of both worlds.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;ParameterAssignment&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * class MyClass {\n *   int methodOne(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     parameter -= 2;  // violation\n *     return parameter;\n *   }\n *\n *   int methodTwo(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     int local = parameter;\n *     local -= 2;  // OK\n *     return local;\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code parameter.assignment}\n * </li>\n * </ul>\n *\n * @since 3.2\n */\n@FileStatefulCheck\npublic final class ParameterAssignmentCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"parameter.assignment\";\n\n    /** Stack of methods' parameters. */\n    private final Deque<Set<String>> parameterNamesStack = new ArrayDeque<>();\n    /** Current set of parameters. */\n    private Set<String> parameterNames;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN,\n            TokenTypes.INC,\n            TokenTypes.POST_INC,\n            TokenTypes.DEC,\n            TokenTypes.POST_DEC,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        // clear data\n        parameterNamesStack.clear();\n        parameterNames = Collections.emptySet();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                parameterNamesStack.push(parameterNames);\n                parameterNames = new HashSet<>();\n                visitMethodParameters(ast.findFirstToken(TokenTypes.PARAMETERS));\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                checkIdent(ast);\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.CTOR_DEF || ast.getType() == TokenTypes.METHOD_DEF) {\n            parameterNames = parameterNamesStack.pop();\n        }\n    }\n\n    /**\n     * Checks if this is assignments of parameter.\n     *\n     * @param ast assignment to check.\n     */\n    private void checkIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\n    /**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        DetailAST parameterDefAST = ast.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param = parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/** Restores old set of parameters. */\n    private void leaveMethodDef() {\n        parameterNames = parameterNamesStack.pop();\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.coding;\n\nimport java.util.ArrayDeque;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\n\n/**\n * <p>\n * Disallows assignment of parameters.\n * </p>\n * <p>\n * Rationale:\n * Parameter assignment is often considered poor\n * programming practice. Forcing developers to declare\n * parameters as final is often onerous. Having a check\n * ensure that parameters are never assigned would give\n * the best of both worlds.\n * </p>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;ParameterAssignment&quot;/&gt;\n * </pre>\n * <p>\n * Example:\n * </p>\n * <pre>\n * class MyClass {\n *   int methodOne(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     parameter -= 2;  // violation\n *     return parameter;\n *   }\n *\n *   int methodTwo(int parameter) {\n *     if (parameter &lt;= 0 ) {\n *       throw new IllegalArgumentException(\"A positive value is expected\");\n *     }\n *     int local = parameter;\n *     local -= 2;  // OK\n *     return local;\n *   }\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code parameter.assignment}\n * </li>\n * </ul>\n *\n * @since 3.2\n */\n@FileStatefulCheck\npublic final class ParameterAssignmentCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"parameter.assignment\";\n\n    /** Stack of methods' parameters. */\n    private final Deque<Set<String>> parameterNamesStack = new ArrayDeque<>();\n    /** Current set of parameters. */\n    private Set<String> parameterNames;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.CTOR_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.ASSIGN,\n            TokenTypes.PLUS_ASSIGN,\n            TokenTypes.MINUS_ASSIGN,\n            TokenTypes.STAR_ASSIGN,\n            TokenTypes.DIV_ASSIGN,\n            TokenTypes.MOD_ASSIGN,\n            TokenTypes.SR_ASSIGN,\n            TokenTypes.BSR_ASSIGN,\n            TokenTypes.SL_ASSIGN,\n            TokenTypes.BAND_ASSIGN,\n            TokenTypes.BXOR_ASSIGN,\n            TokenTypes.BOR_ASSIGN,\n            TokenTypes.INC,\n            TokenTypes.POST_INC,\n            TokenTypes.DEC,\n            TokenTypes.POST_DEC,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        // clear data\n        parameterNamesStack.clear();\n        parameterNames = Collections.emptySet();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                visitMethodDef(ast);\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n                visitAssign(ast);\n                break;\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                visitIncDec(ast);\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.CTOR_DEF:\n            case TokenTypes.METHOD_DEF:\n                leaveMethodDef();\n                break;\n            case TokenTypes.ASSIGN:\n            case TokenTypes.PLUS_ASSIGN:\n            case TokenTypes.MINUS_ASSIGN:\n            case TokenTypes.STAR_ASSIGN:\n            case TokenTypes.DIV_ASSIGN:\n            case TokenTypes.MOD_ASSIGN:\n            case TokenTypes.SR_ASSIGN:\n            case TokenTypes.BSR_ASSIGN:\n            case TokenTypes.SL_ASSIGN:\n            case TokenTypes.BAND_ASSIGN:\n            case TokenTypes.BXOR_ASSIGN:\n            case TokenTypes.BOR_ASSIGN:\n            case TokenTypes.INC:\n            case TokenTypes.POST_INC:\n            case TokenTypes.DEC:\n            case TokenTypes.POST_DEC:\n                // Do nothing\n                break;\n            default:\n                throw new IllegalStateException(ast.toString());\n        }\n    }\n\n    /**\n     * Checks if this is assignments of parameter.\n     *\n     * @param ast assignment to check.\n     */\n    private void visitAssign(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Checks if this is increment/decrement of parameter.\n     *\n     * @param ast dec/inc to check.\n     */\n    private void visitIncDec(DetailAST ast) {\n        checkIdent(ast);\n    }\n\n    /**\n     * Check if ident is parameter.\n     *\n     * @param ast ident to check.\n     */\n    private void checkIdent(DetailAST ast) {\n        final DetailAST identAST = ast.getFirstChild();\n\n        if (identAST != null\n            && identAST.getType() == TokenTypes.IDENT\n            && parameterNames.contains(identAST.getText())) {\n            log(ast, MSG_KEY, identAST.getText());\n        }\n    }\n\n    /**\n     * Creates new set of parameters and store old one in stack.\n     *\n     * @param ast a method to process.\n     */\n    private void visitMethodDef(DetailAST ast) {\n        parameterNamesStack.push(parameterNames);\n        parameterNames = new HashSet<>();\n\n        visitMethodParameters(ast.findFirstToken(TokenTypes.PARAMETERS));\n    }\n\n    /** Restores old set of parameters. */\n    private void leaveMethodDef() {\n        parameterNames = parameterNamesStack.pop();\n    }\n\n    /**\n     * Creates new parameter set for given method.\n     *\n     * @param ast a method for process.\n     */\n    private void visitMethodParameters(DetailAST ast) {\n        DetailAST parameterDefAST =\n            ast.findFirstToken(TokenTypes.PARAMETER_DEF);\n\n        while (parameterDefAST != null) {\n            if (parameterDefAST.getType() == TokenTypes.PARAMETER_DEF\n                    && !CheckUtil.isReceiverParameter(parameterDefAST)) {\n                final DetailAST param =\n                    parameterDefAST.findFirstToken(TokenTypes.IDENT);\n                parameterNames.add(param.getText());\n            }\n            parameterDefAST = parameterDefAST.getNextSibling();\n        }\n    }\n\n}\n\nRefactoring Operation:\nInline Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\nrefactored_class_code\n##########################\n\n\n"}, {"type": "Move And Rename Method", "description": "Move And Rename Method\tprivate isWhitespace(codePoints int[], index int) : boolean from class com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck to public isCodePointWhitespace(codePoints int[], index int) : boolean from class com.puppycrawl.tools.checkstyle.utils.CommonUtil", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCheck.java", "startLine": 232, "endLine": 247, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java", "startLine": 629, "endLine": 644, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Converts the Unicode code point at index {@code index} to it's UTF-16\n     * representation, then checks if the character is whitespace. Note that the given\n     * index {@code index} should correspond to the location of the character\n     * to check in the string, not in code points.\n     *\n     * @param codePoints the array of Unicode code points\n     * @param index the index of the character to check\n     * @return true if character at {@code index} is whitespace\n     */\n    private static boolean isWhitespace(int[] codePoints, int index) {\n        //  We only need to check the first member of a surrogate pair to verify that\n        //  it is not whitespace.\n        final char character = Character.toChars(codePoints[index])[0];\n        return Character.isWhitespace(character);\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCheck.java", "isPureRefactoring": true, "commitId": "7a9913aa64f911e41eae958b757e73a5d2f93205", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.whitespace", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck#isWhitespace", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck#isWhitespace\n methodBody: private static boolean isWhitespace(int[] codePoints, int index) {\nfinal char character=Character.toChars(codePoints[index])[0];\nreturn Character.isWhitespace(character);\n}", "classSignatureBefore": "public class NoWhitespaceBeforeCheck\n    extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck#isWhitespace"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck"], "classSignatureBeforeSet": ["public class NoWhitespaceBeforeCheck\n    extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.whitespace;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * <p>\n * Checks that there is no whitespace before a token.\n * More specifically, it checks that it is not preceded with whitespace,\n * or (if linebreaks are allowed) all characters on the line before are\n * whitespace. To allow linebreaks before a token, set property\n * {@code allowLineBreaks} to {@code true}. No check occurs before semi-colons in empty\n * for loop initializers or conditions.\n * </p>\n * <ul>\n * <li>\n * Property {@code allowLineBreaks} - Control whether whitespace is allowed\n * if the token is at a linebreak.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code tokens} - tokens to check\n * Type is {@code java.lang.String[]}.\n * Validation type is {@code tokenSet}.\n * Default value is:\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#COMMA\">\n * COMMA</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#SEMI\">\n * SEMI</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#POST_INC\">\n * POST_INC</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#POST_DEC\">\n * POST_DEC</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ELLIPSIS\">\n * ELLIPSIS</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LABELED_STAT\">\n * LABELED_STAT</a>.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;NoWhitespaceBefore&quot;/&gt;\n * </pre>\n * <p>Example:</p>\n * <pre>\n * int foo;\n * foo ++; // violation, whitespace before '++' is not allowed\n * foo++; // OK\n * for (int i = 0 ; i &lt; 5; i++) {}  // violation\n *            // ^ whitespace before ';' is not allowed\n * for (int i = 0; i &lt; 5; i++) {} // OK\n * int[][] array = { { 1, 2 }\n *                 , { 3, 4 } }; // violation, whitespace before ',' is not allowed\n * int[][] array2 = { { 1, 2 },\n *                    { 3, 4 } }; // OK\n * Lists.charactersOf(\"foo\").listIterator()\n *        .forEachRemaining(System.out::print)\n *        ; // violation, whitespace before ';' is not allowed\n *   {\n *     label1 : // violation, whitespace before ':' is not allowed\n *     for (int i = 0; i &lt; 10; i++) {}\n *   }\n *\n *   {\n *     label2: // OK\n *     while (true) {}\n *   }\n * </pre>\n * <p>To configure the check to allow linebreaks before default tokens:</p>\n * <pre>\n * &lt;module name=&quot;NoWhitespaceBefore&quot;&gt;\n *   &lt;property name=&quot;allowLineBreaks&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>Example:</p>\n * <pre>\n * int[][] array = { { 1, 2 }\n *                 , { 3, 4 } }; // OK, linebreak is allowed before ','\n * int[][] array2 = { { 1, 2 },\n *                    { 3, 4 } }; // OK, ideal code\n * void ellipsisExample(String ...params) {}; // violation, whitespace before '...' is not allowed\n * void ellipsisExample2(String\n *                         ...params) {}; //OK, linebreak is allowed before '...'\n * Lists.charactersOf(\"foo\")\n *        .listIterator()\n *        .forEachRemaining(System.out::print); // OK\n * </pre>\n * <p>\n *     To Configure the check to restrict the use of whitespace before METHOD_REF and DOT tokens:\n * </p>\n * <pre>\n * &lt;module name=&quot;NoWhitespaceBefore&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;METHOD_REF&quot;/&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;DOT&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>Example:</p>\n * <pre>\n * Lists.charactersOf(\"foo\").listIterator()\n *        .forEachRemaining(System.out::print); // violation, whitespace before '.' is not allowed\n * Lists.charactersOf(\"foo\").listIterator().forEachRemaining(System.out ::print); // violation,\n *                           // whitespace before '::' is not allowed  ^\n * Lists.charactersOf(\"foo\").listIterator().forEachRemaining(System.out::print); // OK\n * </pre>\n * <p>\n *     To configure the check to allow linebreak before METHOD_REF and DOT tokens:\n * </p>\n * <pre>\n * &lt;module name=&quot;NoWhitespaceBefore&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;METHOD_REF&quot;/&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;DOT&quot;/&gt;\n *   &lt;property name=&quot;allowLineBreaks&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>Example:</p>\n * <pre>\n * Lists .charactersOf(\"foo\") //violation, whitespace before '.' is not allowed\n *         .listIterator()\n *         .forEachRemaining(System.out ::print); // violation,\n *                                  // ^ whitespace before '::' is not allowed\n * Lists.charactersOf(\"foo\")\n *        .listIterator()\n *        .forEachRemaining(System.out::print); // OK\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code ws.preceded}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@StatelessCheck\npublic class NoWhitespaceBeforeCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"ws.preceded\";\n\n    /** Control whether whitespace is allowed if the token is at a linebreak. */\n    private boolean allowLineBreaks;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.COMMA,\n            TokenTypes.SEMI,\n            TokenTypes.POST_INC,\n            TokenTypes.POST_DEC,\n            TokenTypes.ELLIPSIS,\n            TokenTypes.LABELED_STAT,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.COMMA,\n            TokenTypes.SEMI,\n            TokenTypes.POST_INC,\n            TokenTypes.POST_DEC,\n            TokenTypes.DOT,\n            TokenTypes.GENERIC_START,\n            TokenTypes.GENERIC_END,\n            TokenTypes.ELLIPSIS,\n            TokenTypes.LABELED_STAT,\n            TokenTypes.METHOD_REF,\n        };\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return CommonUtil.EMPTY_INT_ARRAY;\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final String line = getLine(ast.getLineNo() - 1);\n        final int before = ast.getColumnNo() - 1;\n        final int[] codePoints = line.codePoints().toArray();\n\n        if ((before == -1 || isWhitespace(codePoints, before))\n                && !isInEmptyForInitializerOrCondition(ast)) {\n            boolean flag = !allowLineBreaks;\n            // verify all characters before '.' are whitespace\n            for (int i = 0; i <= before - 1; i++) {\n                if (!isWhitespace(codePoints, i)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) {\n                log(ast, MSG_KEY, ast.getText());\n            }\n        }\n    }\n\n    /**\n     * Converts the Unicode code point at index {@code index} to it's UTF-16\n     * representation, then checks if the character is whitespace. Note that the given\n     * index {@code index} should correspond to the location of the character\n     * to check in the string, not in code points.\n     *\n     * @param codePoints the array of Unicode code points\n     * @param index the index of the character to check\n     * @return true if character at {@code index} is whitespace\n     */\n    private static boolean isWhitespace(int[] codePoints, int index) {\n        //  We only need to check the first member of a surrogate pair to verify that\n        //  it is not whitespace.\n        final char character = Character.toChars(codePoints[index])[0];\n        return Character.isWhitespace(character);\n    }\n\n    /**\n     * Checks that semicolon is in empty for initializer or condition.\n     *\n     * @param semicolonAst DetailAST of semicolon.\n     * @return true if semicolon is in empty for initializer or condition.\n     */\n    private static boolean isInEmptyForInitializerOrCondition(DetailAST semicolonAst) {\n        boolean result = false;\n        final DetailAST sibling = semicolonAst.getPreviousSibling();\n        if (sibling != null\n                && (sibling.getType() == TokenTypes.FOR_INIT\n                        || sibling.getType() == TokenTypes.FOR_CONDITION)\n                && !sibling.hasChildren()) {\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * Setter to control whether whitespace is allowed if the token is at a linebreak.\n     *\n     * @param allowLineBreaks whether whitespace should be\n     *     flagged at line breaks.\n     */\n    public void setAllowLineBreaks(boolean allowLineBreaks) {\n        this.allowLineBreaks = allowLineBreaks;\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.utils;\n\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.regex.PatternSyntaxException;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\n/**\n * Contains utility methods.\n *\n */\npublic final class CommonUtil {\n\n    /** Default tab width for column reporting. */\n    public static final int DEFAULT_TAB_WIDTH = 8;\n\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final String[] EMPTY_STRING_ARRAY = new String[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final int[] EMPTY_INT_ARRAY = new int[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n    /** Copied from org.apache.commons.lang3.ArrayUtils. */\n    public static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n    /** Pseudo URL protocol for loading from the class path. */\n    public static final String CLASSPATH_URL_PROTOCOL = \"classpath:\";\n\n    /** Prefix for the exception when unable to find resource. */\n    private static final String UNABLE_TO_FIND_EXCEPTION_PREFIX = \"Unable to find: \";\n\n    /** Stop instances being created. **/\n    private CommonUtil() {\n    }\n\n    /**\n     * Helper method to create a regular expression.\n     *\n     * @param pattern\n     *            the pattern to match\n     * @return a created regexp object\n     * @throws IllegalArgumentException\n     *             if unable to create Pattern object.\n     **/\n    public static Pattern createPattern(String pattern) {\n        return createPattern(pattern, 0);\n    }\n\n    /**\n     * Helper method to create a regular expression with a specific flags.\n     *\n     * @param pattern\n     *            the pattern to match\n     * @param flags\n     *            the flags to set\n     * @return a created regexp object\n     * @throws IllegalArgumentException\n     *             if unable to create Pattern object.\n     **/\n    public static Pattern createPattern(String pattern, int flags) {\n        try {\n            return Pattern.compile(pattern, flags);\n        }\n        catch (final PatternSyntaxException ex) {\n            throw new IllegalArgumentException(\n                \"Failed to initialise regular expression \" + pattern, ex);\n        }\n    }\n\n    /**\n     * Returns whether the file extension matches what we are meant to process.\n     *\n     * @param file\n     *            the file to be checked.\n     * @param fileExtensions\n     *            files extensions, empty property in config makes it matches to all.\n     * @return whether there is a match.\n     */\n    public static boolean matchesFileExtension(File file, String... fileExtensions) {\n        boolean result = false;\n        if (fileExtensions == null || fileExtensions.length == 0) {\n            result = true;\n        }\n        else {\n            // normalize extensions so all of them have a leading dot\n            final String[] withDotExtensions = new String[fileExtensions.length];\n            for (int i = 0; i < fileExtensions.length; i++) {\n                final String extension = fileExtensions[i];\n                if (startsWithChar(extension, '.')) {\n                    withDotExtensions[i] = extension;\n                }\n                else {\n                    withDotExtensions[i] = \".\" + extension;\n                }\n            }\n\n            final String fileName = file.getName();\n            for (final String fileExtension : withDotExtensions) {\n                if (fileName.endsWith(fileExtension)) {\n                    result = true;\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns whether the specified string contains only whitespace up to the specified index.\n     *\n     * @param index\n     *            index to check up to\n     * @param line\n     *            the line to check\n     * @return whether there is only whitespace\n     */\n    public static boolean hasWhitespaceBefore(int index, String line) {\n        boolean result = true;\n        for (int i = 0; i < index; i++) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                result = false;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns the length of a string ignoring all trailing whitespace.\n     * It is a pity that there is not a trim() like\n     * method that only removed the trailing whitespace.\n     *\n     * @param line\n     *            the string to process\n     * @return the length of the string ignoring all trailing whitespace\n     **/\n    public static int lengthMinusTrailingWhitespace(String line) {\n        int len = line.length();\n        for (int i = len - 1; i >= 0; i--) {\n            if (!Character.isWhitespace(line.charAt(i))) {\n                break;\n            }\n            len--;\n        }\n        return len;\n    }\n\n    /**\n     * Returns the length of a String prefix with tabs expanded.\n     * Each tab is counted as the number of characters is\n     * takes to jump to the next tab stop.\n     *\n     * @param inputString\n     *            the input String\n     * @param toIdx\n     *            index in string (exclusive) where the calculation stops\n     * @param tabWidth\n     *            the distance between tab stop position.\n     * @return the length of string.substring(0, toIdx) with tabs expanded.\n     */\n    public static int lengthExpandedTabs(String inputString,\n            int toIdx,\n            int tabWidth) {\n        int len = 0;\n        for (int idx = 0; idx < toIdx; idx++) {\n            if (inputString.codePointAt(idx) == '\\t') {\n                len = (len / tabWidth + 1) * tabWidth;\n            }\n            else {\n                len++;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * Validates whether passed string is a valid pattern or not.\n     *\n     * @param pattern\n     *            string to validate\n     * @return true if the pattern is valid false otherwise\n     */\n    public static boolean isPatternValid(String pattern) {\n        boolean isValid = true;\n        try {\n            Pattern.compile(pattern);\n        }\n        catch (final PatternSyntaxException ignored) {\n            isValid = false;\n        }\n        return isValid;\n    }\n\n    /**\n     * Returns base class name from qualified name.\n     *\n     * @param type\n     *            the fully qualified name. Cannot be null\n     * @return the base class name from a fully qualified name\n     */\n    public static String baseClassName(String type) {\n        final String className;\n        final int index = type.lastIndexOf('.');\n        if (index == -1) {\n            className = type;\n        }\n        else {\n            className = type.substring(index + 1);\n        }\n        return className;\n    }\n\n    /**\n     * Constructs a normalized relative path between base directory and a given path.\n     *\n     * @param baseDirectory\n     *            the base path to which given path is relativized\n     * @param path\n     *            the path to relativize against base directory\n     * @return the relative normalized path between base directory and\n     *     path or path if base directory is null.\n     */\n    public static String relativizeAndNormalizePath(final String baseDirectory, final String path) {\n        final String resultPath;\n        if (baseDirectory == null) {\n            resultPath = path;\n        }\n        else {\n            final Path pathAbsolute = Paths.get(path).normalize();\n            final Path pathBase = Paths.get(baseDirectory).normalize();\n            resultPath = pathBase.relativize(pathAbsolute).toString();\n        }\n        return resultPath;\n    }\n\n    /**\n     * Tests if this string starts with the specified prefix.\n     * <p>\n     * It is faster version of {@link String#startsWith(String)} optimized for\n     *  one-character prefixes at the expense of\n     * some readability. Suggested by SimplifyStartsWith PMD rule:\n     * http://pmd.sourceforge.net/pmd-5.3.1/pmd-java/rules/java/optimizations.html#SimplifyStartsWith\n     * </p>\n     *\n     * @param value\n     *            the {@code String} to check\n     * @param prefix\n     *            the prefix to find\n     * @return {@code true} if the {@code char} is a prefix of the given {@code String};\n     *     {@code false} otherwise.\n     */\n    public static boolean startsWithChar(String value, char prefix) {\n        return !value.isEmpty() && value.charAt(0) == prefix;\n    }\n\n    /**\n     * Tests if this string ends with the specified suffix.\n     * <p>\n     * It is faster version of {@link String#endsWith(String)} optimized for\n     *  one-character suffixes at the expense of\n     * some readability. Suggested by SimplifyStartsWith PMD rule:\n     * http://pmd.sourceforge.net/pmd-5.3.1/pmd-java/rules/java/optimizations.html#SimplifyStartsWith\n     * </p>\n     *\n     * @param value\n     *            the {@code String} to check\n     * @param suffix\n     *            the suffix to find\n     * @return {@code true} if the {@code char} is a suffix of the given {@code String};\n     *     {@code false} otherwise.\n     */\n    public static boolean endsWithChar(String value, char suffix) {\n        return !value.isEmpty() && value.charAt(value.length() - 1) == suffix;\n    }\n\n    /**\n     * Gets constructor of targetClass.\n     *\n     * @param <T> type of the target class object.\n     * @param targetClass\n     *            from which constructor is returned\n     * @param parameterTypes\n     *            of constructor\n     * @return constructor of targetClass\n     * @throws IllegalStateException if any exception occurs\n     * @see Class#getConstructor(Class[])\n     */\n    public static <T> Constructor<T> getConstructor(Class<T> targetClass,\n                                                    Class<?>... parameterTypes) {\n        try {\n            return targetClass.getConstructor(parameterTypes);\n        }\n        catch (NoSuchMethodException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    /**\n     * Returns new instance of a class.\n     *\n     * @param <T>\n     *            type of constructor\n     * @param constructor\n     *            to invoke\n     * @param parameters\n     *            to pass to constructor\n     * @return new instance of class\n     * @throws IllegalStateException if any exception occurs\n     * @see Constructor#newInstance(Object...)\n     */\n    public static <T> T invokeConstructor(Constructor<T> constructor, Object... parameters) {\n        try {\n            return constructor.newInstance(parameters);\n        }\n        catch (InstantiationException | IllegalAccessException | InvocationTargetException ex) {\n            throw new IllegalStateException(ex);\n        }\n    }\n\n    /**\n     * Closes a stream re-throwing IOException as IllegalStateException.\n     *\n     * @param closeable\n     *            Closeable object\n     * @throws IllegalStateException when any IOException occurs\n     */\n    public static void close(Closeable closeable) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            }\n            catch (IOException ex) {\n                throw new IllegalStateException(\"Cannot close the stream\", ex);\n            }\n        }\n    }\n\n    /**\n     * Resolve the specified filename to a URI.\n     *\n     * @param filename name of the file\n     * @return resolved file URI\n     * @throws CheckstyleException on failure\n     */\n    public static URI getUriByFilename(String filename) throws CheckstyleException {\n        URI uri = getWebOrFileProtocolUri(filename);\n\n        if (uri == null) {\n            uri = getFilepathOrClasspathUri(filename);\n        }\n\n        return uri;\n    }\n\n    /**\n     * Resolves the specified filename containing 'http', 'https', 'ftp',\n     * and 'file' protocols (or any RFC 2396 compliant URL) to a URI.\n     *\n     * @param filename name of the file\n     * @return resolved file URI or null if URL is malformed or non-existent\n     */\n    public static URI getWebOrFileProtocolUri(String filename) {\n        URI uri;\n        try {\n            final URL url = new URL(filename);\n            uri = url.toURI();\n        }\n        catch (URISyntaxException | MalformedURLException ignored) {\n            uri = null;\n        }\n        return uri;\n    }\n\n    /**\n     * Resolves the specified local filename, possibly with 'classpath:'\n     * protocol, to a URI.  First we attempt to create a new file with\n     * given filename, then attempt to load file from class path.\n     *\n     * @param filename name of the file\n     * @return resolved file URI\n     * @throws CheckstyleException on failure\n     */\n    private static URI getFilepathOrClasspathUri(String filename) throws CheckstyleException {\n        final URI uri;\n        final File file = new File(filename);\n\n        if (file.exists()) {\n            uri = file.toURI();\n        }\n        else {\n            final int lastIndexOfClasspathProtocol;\n            if (filename.lastIndexOf(CLASSPATH_URL_PROTOCOL) == 0) {\n                lastIndexOfClasspathProtocol = CLASSPATH_URL_PROTOCOL.length();\n            }\n            else {\n                lastIndexOfClasspathProtocol = 0;\n            }\n            uri = getResourceFromClassPath(filename\n                .substring(lastIndexOfClasspathProtocol));\n        }\n        return uri;\n    }\n\n    /**\n     * Gets a resource from the classpath.\n     *\n     * @param filename name of file\n     * @return URI of file in classpath\n     * @throws CheckstyleException on failure\n     */\n    public static URI getResourceFromClassPath(String filename) throws CheckstyleException {\n        final URL configUrl;\n        if (filename.charAt(0) == '/') {\n            configUrl = CommonUtil.class.getResource(filename);\n        }\n        else {\n            configUrl = ClassLoader.getSystemResource(filename);\n        }\n\n        if (configUrl == null) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename);\n        }\n\n        final URI uri;\n        try {\n            uri = configUrl.toURI();\n        }\n        catch (final URISyntaxException ex) {\n            throw new CheckstyleException(UNABLE_TO_FIND_EXCEPTION_PREFIX + filename, ex);\n        }\n\n        return uri;\n    }\n\n    /**\n     * Puts part of line, which matches regexp into given template\n     * on positions $n where 'n' is number of matched part in line.\n     *\n     * @param template the string to expand.\n     * @param lineToPlaceInTemplate contains expression which should be placed into string.\n     * @param regexp expression to find in comment.\n     * @return the string, based on template filled with given lines\n     */\n    public static String fillTemplateWithStringsByRegexp(\n        String template, String lineToPlaceInTemplate, Pattern regexp) {\n        final Matcher matcher = regexp.matcher(lineToPlaceInTemplate);\n        String result = template;\n        if (matcher.find()) {\n            for (int i = 0; i <= matcher.groupCount(); i++) {\n                // $n expands comment match like in Pattern.subst().\n                result = result.replaceAll(\"\\\\$\" + i, matcher.group(i));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns file name without extension.\n     * We do not use the method from Guava library to reduce Checkstyle's dependencies\n     * on external libraries.\n     *\n     * @param fullFilename file name with extension.\n     * @return file name without extension.\n     */\n    public static String getFileNameWithoutExtension(String fullFilename) {\n        final String fileName = new File(fullFilename).getName();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String fileNameWithoutExtension;\n        if (dotIndex == -1) {\n            fileNameWithoutExtension = fileName;\n        }\n        else {\n            fileNameWithoutExtension = fileName.substring(0, dotIndex);\n        }\n        return fileNameWithoutExtension;\n    }\n\n    /**\n     * Returns file extension for the given file name\n     * or empty string if file does not have an extension.\n     * We do not use the method from Guava library to reduce Checkstyle's dependencies\n     * on external libraries.\n     *\n     * @param fileNameWithExtension file name with extension.\n     * @return file extension for the given file name\n     *         or empty string if file does not have an extension.\n     */\n    public static String getFileExtension(String fileNameWithExtension) {\n        final String fileName = Paths.get(fileNameWithExtension).toString();\n        final int dotIndex = fileName.lastIndexOf('.');\n        final String extension;\n        if (dotIndex == -1) {\n            extension = \"\";\n        }\n        else {\n            extension = fileName.substring(dotIndex + 1);\n        }\n        return extension;\n    }\n\n    /**\n     * Checks whether the given string is a valid identifier.\n     *\n     * @param str A string to check.\n     * @return true when the given string contains valid identifier.\n     */\n    public static boolean isIdentifier(String str) {\n        boolean isIdentifier = !str.isEmpty();\n\n        for (int i = 0; isIdentifier && i < str.length(); i++) {\n            if (i == 0) {\n                isIdentifier = Character.isJavaIdentifierStart(str.charAt(0));\n            }\n            else {\n                isIdentifier = Character.isJavaIdentifierPart(str.charAt(i));\n            }\n        }\n\n        return isIdentifier;\n    }\n\n    /**\n     * Checks whether the given string is a valid name.\n     *\n     * @param str A string to check.\n     * @return true when the given string contains valid name.\n     */\n    public static boolean isName(String str) {\n        boolean isName = !str.isEmpty();\n\n        final String[] identifiers = str.split(\"\\\\.\", -1);\n        for (int i = 0; isName && i < identifiers.length; i++) {\n            isName = isIdentifier(identifiers[i]);\n        }\n\n        return isName;\n    }\n\n    /**\n     * Checks if the value arg is blank by either being null,\n     * empty, or contains only whitespace characters.\n     *\n     * @param value A string to check.\n     * @return true if the arg is blank.\n     */\n    public static boolean isBlank(String value) {\n        return Objects.isNull(value)\n                || indexOfNonWhitespace(value) >= value.length();\n    }\n\n    /**\n     * Method to find the index of the first non-whitespace character in a string.\n     *\n     * @param value the string to find the first index of a non-whitespace character for.\n     * @return the index of the first non-whitespace character.\n     */\n    public static int indexOfNonWhitespace(String value) {\n        final int length = value.length();\n        int left = 0;\n        while (left < length) {\n            final int codePointAt = value.codePointAt(left);\n            if (!Character.isWhitespace(codePointAt)) {\n                break;\n            }\n            left += Character.charCount(codePointAt);\n        }\n        return left;\n    }\n\n    /**\n     * Checks whether the string contains an integer value.\n     *\n     * @param str a string to check\n     * @return true if the given string is an integer, false otherwise.\n     */\n    public static boolean isInt(String str) {\n        boolean isInt;\n        if (str == null) {\n            isInt = false;\n        }\n        else {\n            try {\n                Integer.parseInt(str);\n                isInt = true;\n            }\n            catch (NumberFormatException ignored) {\n                isInt = false;\n            }\n        }\n        return isInt;\n    }\n\n    /**\n     * Converts the Unicode code point at index {@code index} to it's UTF-16\n     * representation, then checks if the character is whitespace. Note that the given\n     * index {@code index} should correspond to the location of the character\n     * to check in the string, not in code points.\n     *\n     * @param codePoints the array of Unicode code points\n     * @param index the index of the character to check\n     * @return true if character at {@code index} is whitespace\n     */\n    public static boolean isCodePointWhitespace(int[] codePoints, int index) {\n        //  We only need to check the first member of a surrogate pair to verify that\n        //  it is not whitespace.\n        final char character = Character.toChars(codePoints[index])[0];\n        return Character.isWhitespace(character);\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.checks.whitespace.NoWhitespaceBeforeCheck#isWhitespace\n methodBody: private static boolean isWhitespace(int[] codePoints, int index) {\nfinal char character=Character.toChars(codePoints[index])[0];\nreturn Character.isWhitespace(character);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Converts the Unicode code point at index {@code index} to it's UTF-16\n     * representation, then checks if the character is whitespace. Note that the given\n     * index {@code index} should correspond to the location of the character\n     * to check in the string, not in code points.\n     *\n     * @param codePoints the array of Unicode code points\n     * @param index the index of the character to check\n     * @return true if character at {@code index} is whitespace\n     */\n    public static boolean isCodePointWhitespace(int[] codePoints, int index) {\n        //  We only need to check the first member of a surrogate pair to verify that\n        //  it is not whitespace.\n        final char character = Character.toChars(codePoints[index])[0];\n        return Character.isWhitespace(character);\n    }", "diffSourceCode": "-  232:     /**\n-  233:      * Converts the Unicode code point at index {@code index} to it's UTF-16\n-  234:      * representation, then checks if the character is whitespace. Note that the given\n-  235:      * index {@code index} should correspond to the location of the character\n-  236:      * to check in the string, not in code points.\n-  237:      *\n-  238:      * @param codePoints the array of Unicode code points\n-  239:      * @param index the index of the character to check\n-  240:      * @return true if character at {@code index} is whitespace\n-  241:      */\n-  242:     private static boolean isWhitespace(int[] codePoints, int index) {\n-  243:         //  We only need to check the first member of a surrogate pair to verify that\n-  244:         //  it is not whitespace.\n-  245:         final char character = Character.toChars(codePoints[index])[0];\n-  246:         return Character.isWhitespace(character);\n+  232:      *\n+  233:      * @param type\n+  234:      *            the fully qualified name. Cannot be null\n+  235:      * @return the base class name from a fully qualified name\n+  236:      */\n+  237:     public static String baseClassName(String type) {\n+  238:         final String className;\n+  239:         final int index = type.lastIndexOf('.');\n+  240:         if (index == -1) {\n+  241:             className = type;\n+  242:         }\n+  243:         else {\n+  244:             className = type.substring(index + 1);\n+  245:         }\n+  246:         return className;\n   247:     }\n+  629:     /**\n+  630:      * Converts the Unicode code point at index {@code index} to it's UTF-16\n+  631:      * representation, then checks if the character is whitespace. Note that the given\n+  632:      * index {@code index} should correspond to the location of the character\n+  633:      * to check in the string, not in code points.\n+  634:      *\n+  635:      * @param codePoints the array of Unicode code points\n+  636:      * @param index the index of the character to check\n+  637:      * @return true if character at {@code index} is whitespace\n+  638:      */\n+  639:     public static boolean isCodePointWhitespace(int[] codePoints, int index) {\n+  640:         //  We only need to check the first member of a surrogate pair to verify that\n+  641:         //  it is not whitespace.\n+  642:         final char character = Character.toChars(codePoints[index])[0];\n+  643:         return Character.isWhitespace(character);\n+  644:     }\n", "uniqueId": "7a9913aa64f911e41eae958b757e73a5d2f93205_232_247__629_644", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 10}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nsrc/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/AbstractParenPadCheck.java\n##########################\n/**\n * Converts the Unicode code point at index {@code index} to it's UTF-16\n * representation, then checks if the character is whitespace. Note that the given\n * index {@code index} should correspond to the location of the character\n * to check in the string, not in code points.\n *\n * @param codePoints the array of Unicode code points\n * @param index the index of the character to check\n * @return true if character at {@code index} is whitespace\n */\npublic static boolean isWhitespace(int[] codePoints, int index) {\n    //  We only need to check the first member of a surrogate pair to verify that\n    //  it is not whitespace.\n    final char character = Character.toChars(codePoints[index])[0];\n    return Character.isWhitespace(character);\n}\n##########################\n    private static boolean isWhitespace(int[] codePoints, int index) {\n        return AbstractParenPadCheck.isWhitespace(codePoints, index);\n    }\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Converts the Unicode code point at index {@code index} to it's UTF-16\n     * representation, then checks if the character is whitespace. Note that the given\n     * index {@code index} should correspond to the location of the character\n     * to check in the string, not in code points.\n     *\n     * @param codePoints the array of Unicode code points\n     * @param index the index of the character to check\n     * @return true if character at {@code index} is whitespace\n     */\n    private static boolean isWhitespace(int[] codePoints, int index) {\n        //  We only need to check the first member of a surrogate pair to verify that\n        //  it is not whitespace.\n        final char character = Character.toChars(codePoints[index])[0];\n        return Character.isWhitespace(character);\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.whitespace;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * <p>\n * Checks that there is no whitespace before a token.\n * More specifically, it checks that it is not preceded with whitespace,\n * or (if linebreaks are allowed) all characters on the line before are\n * whitespace. To allow linebreaks before a token, set property\n * {@code allowLineBreaks} to {@code true}. No check occurs before semi-colons in empty\n * for loop initializers or conditions.\n * </p>\n * <ul>\n * <li>\n * Property {@code allowLineBreaks} - Control whether whitespace is allowed\n * if the token is at a linebreak.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code tokens} - tokens to check\n * Type is {@code java.lang.String[]}.\n * Validation type is {@code tokenSet}.\n * Default value is:\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#COMMA\">\n * COMMA</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#SEMI\">\n * SEMI</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#POST_INC\">\n * POST_INC</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#POST_DEC\">\n * POST_DEC</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#ELLIPSIS\">\n * ELLIPSIS</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LABELED_STAT\">\n * LABELED_STAT</a>.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=&quot;NoWhitespaceBefore&quot;/&gt;\n * </pre>\n * <p>Example:</p>\n * <pre>\n * int foo;\n * foo ++; // violation, whitespace before '++' is not allowed\n * foo++; // OK\n * for (int i = 0 ; i &lt; 5; i++) {}  // violation\n *            // ^ whitespace before ';' is not allowed\n * for (int i = 0; i &lt; 5; i++) {} // OK\n * int[][] array = { { 1, 2 }\n *                 , { 3, 4 } }; // violation, whitespace before ',' is not allowed\n * int[][] array2 = { { 1, 2 },\n *                    { 3, 4 } }; // OK\n * Lists.charactersOf(\"foo\").listIterator()\n *        .forEachRemaining(System.out::print)\n *        ; // violation, whitespace before ';' is not allowed\n *   {\n *     label1 : // violation, whitespace before ':' is not allowed\n *     for (int i = 0; i &lt; 10; i++) {}\n *   }\n *\n *   {\n *     label2: // OK\n *     while (true) {}\n *   }\n * </pre>\n * <p>To configure the check to allow linebreaks before default tokens:</p>\n * <pre>\n * &lt;module name=&quot;NoWhitespaceBefore&quot;&gt;\n *   &lt;property name=&quot;allowLineBreaks&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>Example:</p>\n * <pre>\n * int[][] array = { { 1, 2 }\n *                 , { 3, 4 } }; // OK, linebreak is allowed before ','\n * int[][] array2 = { { 1, 2 },\n *                    { 3, 4 } }; // OK, ideal code\n * void ellipsisExample(String ...params) {}; // violation, whitespace before '...' is not allowed\n * void ellipsisExample2(String\n *                         ...params) {}; //OK, linebreak is allowed before '...'\n * Lists.charactersOf(\"foo\")\n *        .listIterator()\n *        .forEachRemaining(System.out::print); // OK\n * </pre>\n * <p>\n *     To Configure the check to restrict the use of whitespace before METHOD_REF and DOT tokens:\n * </p>\n * <pre>\n * &lt;module name=&quot;NoWhitespaceBefore&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;METHOD_REF&quot;/&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;DOT&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>Example:</p>\n * <pre>\n * Lists.charactersOf(\"foo\").listIterator()\n *        .forEachRemaining(System.out::print); // violation, whitespace before '.' is not allowed\n * Lists.charactersOf(\"foo\").listIterator().forEachRemaining(System.out ::print); // violation,\n *                           // whitespace before '::' is not allowed  ^\n * Lists.charactersOf(\"foo\").listIterator().forEachRemaining(System.out::print); // OK\n * </pre>\n * <p>\n *     To configure the check to allow linebreak before METHOD_REF and DOT tokens:\n * </p>\n * <pre>\n * &lt;module name=&quot;NoWhitespaceBefore&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;METHOD_REF&quot;/&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;DOT&quot;/&gt;\n *   &lt;property name=&quot;allowLineBreaks&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>Example:</p>\n * <pre>\n * Lists .charactersOf(\"foo\") //violation, whitespace before '.' is not allowed\n *         .listIterator()\n *         .forEachRemaining(System.out ::print); // violation,\n *                                  // ^ whitespace before '::' is not allowed\n * Lists.charactersOf(\"foo\")\n *        .listIterator()\n *        .forEachRemaining(System.out::print); // OK\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code ws.preceded}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@StatelessCheck\npublic class NoWhitespaceBeforeCheck\n    extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"ws.preceded\";\n\n    /** Control whether whitespace is allowed if the token is at a linebreak. */\n    private boolean allowLineBreaks;\n\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.COMMA,\n            TokenTypes.SEMI,\n            TokenTypes.POST_INC,\n            TokenTypes.POST_DEC,\n            TokenTypes.ELLIPSIS,\n            TokenTypes.LABELED_STAT,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.COMMA,\n            TokenTypes.SEMI,\n            TokenTypes.POST_INC,\n            TokenTypes.POST_DEC,\n            TokenTypes.DOT,\n            TokenTypes.GENERIC_START,\n            TokenTypes.GENERIC_END,\n            TokenTypes.ELLIPSIS,\n            TokenTypes.LABELED_STAT,\n            TokenTypes.METHOD_REF,\n        };\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return CommonUtil.EMPTY_INT_ARRAY;\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final String line = getLine(ast.getLineNo() - 1);\n        final int before = ast.getColumnNo() - 1;\n        final int[] codePoints = line.codePoints().toArray();\n\n        if ((before == -1 || isWhitespace(codePoints, before))\n                && !isInEmptyForInitializerOrCondition(ast)) {\n            boolean flag = !allowLineBreaks;\n            // verify all characters before '.' are whitespace\n            for (int i = 0; i <= before - 1; i++) {\n                if (!isWhitespace(codePoints, i)) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (flag) {\n                log(ast, MSG_KEY, ast.getText());\n            }\n        }\n    }\n\n    /**\n     * Converts the Unicode code point at index {@code index} to it's UTF-16\n     * representation, then checks if the character is whitespace. Note that the given\n     * index {@code index} should correspond to the location of the character\n     * to check in the string, not in code points.\n     *\n     * @param codePoints the array of Unicode code points\n     * @param index the index of the character to check\n     * @return true if character at {@code index} is whitespace\n     */\n    private static boolean isWhitespace(int[] codePoints, int index) {\n        //  We only need to check the first member of a surrogate pair to verify that\n        //  it is not whitespace.\n        final char character = Character.toChars(codePoints[index])[0];\n        return Character.isWhitespace(character);\n    }\n\n    /**\n     * Checks that semicolon is in empty for initializer or condition.\n     *\n     * @param semicolonAst DetailAST of semicolon.\n     * @return true if semicolon is in empty for initializer or condition.\n     */\n    private static boolean isInEmptyForInitializerOrCondition(DetailAST semicolonAst) {\n        boolean result = false;\n        final DetailAST sibling = semicolonAst.getPreviousSibling();\n        if (sibling != null\n                && (sibling.getType() == TokenTypes.FOR_INIT\n                        || sibling.getType() == TokenTypes.FOR_CONDITION)\n                && !sibling.hasChildren()) {\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * Setter to control whether whitespace is allowed if the token is at a linebreak.\n     *\n     * @param allowLineBreaks whether whitespace should be\n     *     flagged at line breaks.\n     */\n    public void setAllowLineBreaks(boolean allowLineBreaks) {\n        this.allowLineBreaks = allowLineBreaks;\n    }\n\n}\n\nRefactoring Operation:\nMove And Rename Method\n\nProject Structure:\n['src/main/java/com/puppycrawl/tools/checkstyle/AstTreeStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/AuditEventDefaultFormatter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/AuditEventFormatter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Checker.java', 'src/main/java/com/puppycrawl/tools/checkstyle/CheckstyleParserErrorStrategy.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultContext.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Definitions.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DetailAstImpl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DetailNodeTreeStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/FileStatefulCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/GlobalStatefulCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavaAstVisitor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavaParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavadocPropertiesGenerator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Main.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ModuleFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PackageNamesLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertiesExpander.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertyResolver.java', 'src/main/java/com/puppycrawl/tools/checkstyle/SarifLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/StatelessCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/SuppressionsStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ThreadModeSettings.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalkerAuditEvent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalkerFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XMLLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XmlLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAstFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAuditListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ant/CheckstyleAntTask.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ant/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractFileSetCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractViolationReporter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AuditEvent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AuditListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AutomaticBean.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilterSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/CheckstyleException.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Comment.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Configurable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Configuration.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Context.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Contextualizable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/DetailNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/ExternalResourceHolder.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileContents.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileSetCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Filter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FilterSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FullIdent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/JavadocTokenTypes.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/LineColumn.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/MessageDispatcher.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/RootModule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Scope.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/SeverityLevel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/SeverityLevelCounter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/TextBlock.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/TokenTypes.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Violation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/ArrayTypeStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/FinalParametersCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/LineSeparatorOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/NoCodeInFileCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/OrderedPropertiesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/OuterTypeFilenameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TodoCommentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UniquePropertiesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UpperEllCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationOnSameLineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingDeprecatedCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingOverrideCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/PackageAnnotationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/AvoidNestedBlocksCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/BlockOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyBlockCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AbstractSuperCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ArrayTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidDoubleBraceInitializationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidInlineConditionalsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidNoArgumentSuperConstructorCallCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/CovariantEqualsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DefaultComesLastCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EmptyStatementCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsHashCodeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ExplicitInitializationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/HiddenFieldCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalCatchCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenTextCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MagicNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MatchXpathCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingCtorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingSwitchDefaultCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ModifiedControlVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleVariableDeclarationsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedForDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedIfDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedTryDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoArrayTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoCloneCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoEnumTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoFinalizerCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/PackageDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ReturnCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanExpressionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanReturnCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/StringLiteralEqualityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperCloneCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperFinalizeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterOuterTypeDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterTypeMemberDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInEnumerationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInTryWithResourcesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/HideUtilityClassConstructorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/InnerTypeLastCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/InterfaceIsTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/OneTopLevelClassCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/ThrowsCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/HeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AbstractImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AbstractImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AccessResult.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStarImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStaticImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ClassImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/FileImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/IllegalImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/MismatchStrategy.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/RedundantImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AbstractExpressionHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AnnotationArrayInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ArrayInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/BlockParentHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CaseHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CatchHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/DetailAstSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/DoWhileHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ElseHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/FinallyHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ForHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IfHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ImportHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentLevel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndexHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LabelHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LambdaHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MemberDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodCallHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/NewHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ObjectBlockHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/PackageDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/PrimordialHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SlistHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/StaticInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SwitchHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SwitchRuleHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SynchronizedHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/TryHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/WhileHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/YieldHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AtclauseOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/HtmlTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocPositionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocBlockTagLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMissingLeadingAsteriskCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMissingWhitespaceAfterAsteriskCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocNodeImpl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocPackageCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocParagraphCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagContinuationIndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagInfo.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTags.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocMethodCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocPackageCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/NonEmptyAtclauseDescriptionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/RequireEmptyLineBeforeBlockTagGroupCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SingleLineJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/WriteTagCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/BlockTagUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/InlineTagUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/TagInfo.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassDataAbstractionCouplingCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassFanOutComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/CyclomaticComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/JavaNCSSCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ClassMemberImpliedModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/InterfaceMemberImpliedModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ModifierOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbbreviationAsWordInNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractAccessControlNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AccessModifierOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/CatchParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ClassTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ConstantNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/IllegalIdentifierNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/InterfaceTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LambdaParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalFinalVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MemberNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/PackageNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/PatternVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/RecordComponentNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/RecordTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/StaticVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/TypeNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/CommentSuppressor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/DetectorOptions.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/MatchSuppressor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/MultilineDetector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/NeverSuppress.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpMultilineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpOnFilenameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineJavaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/SinglelineDetector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/AnonInnerLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/ExecutableStatementCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/FileLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/LambdaBodyLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/LineLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/OuterTypeNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/ParameterNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/RecordComponentNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/AbstractParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForInitializerPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForIteratorPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/FileTabCharacterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/MethodParamPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoLineWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCaseDefaultColonCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/OperatorWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/PadOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SeparatorWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SingleSpaceSeparatorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/TypecastParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAfterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WrapOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filefilters/BeforeExecutionExclusionFileFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filefilters/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/CsvFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntMatchFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntRangeFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SeverityMatchFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWarningsFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithPlainTextCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionSingleFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathSingleFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionsLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/XpathFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/CommentListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/CrAwareLexerSimulator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/BaseCellEditor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/CodeSelector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/CodeSelectorPresentation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ListToTreeSelectionModelWrapper.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/Main.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/MainFrame.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/MainFrameModel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTableModel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTablePresentation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTableCellRenderer.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTableModelAdapter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/MetadataGenerationException.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModuleDetails.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModulePropertyDetails.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModuleType.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaReader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaWriter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/AnnotationUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/BlockCommentPosition.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ChainedPropertyUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/FilterUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ModuleReflectionUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ParserUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ScopeUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/TokenUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/XpathUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/AbstractNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/AttributeNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/ElementNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/RootNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/XpathQueryGenerator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/package-info.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move and rename method operation to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate setViolations(inputConfigBuilder TestInputConfiguration.Builder, lines List<String>, useFilteredViolations boolean, lineNo int) : void extracted from private setViolations(inputConfigBuilder TestInputConfiguration.Builder, lines List<String>, useFilteredViolations boolean) : void in class com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java", "startLine": 257, "endLine": 307, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java", "startLine": 257, "endLine": 262, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java", "startLine": 264, "endLine": 322, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines, boolean useFilteredViolations) {\n        for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n            final Matcher violationMatcher =\n                    VIOLATION_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationAboveMatcher =\n                    VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationBelowMatcher =\n                    VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsMatcher =\n                    MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsAboveMatcher =\n                    MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsBelowMatcher =\n                    MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n            if (violationMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n            }\n            else if (violationAboveMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n            }\n            else if (violationBelowMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n            }\n            else if (multipleViolationsMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsAboveMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsBelowMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n                                lineNo + 2)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (useFilteredViolations) {\n                setFilteredViolation(inputConfigBuilder, lineNo + 1, lines.get(lineNo));\n            }\n        }\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java", "isPureRefactoring": true, "commitId": "defd358fbe0123c2dd4c72fbf9960cc5178fbf8b", "packageNameBefore": "com.puppycrawl.tools.checkstyle.bdd", "classNameBefore": "com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser", "methodNameBefore": "com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#setViolations", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#setFilteredViolation\n methodBody: private static void setFilteredViolation(TestInputConfiguration.Builder inputConfigBuilder,\n                                             int lineNo, String line) {\nfinal Matcher violationMatcher=FILTERED_VIOLATION_PATTERN.matcher(line);\nfinal Matcher violationAboveMatcher=FILTERED_VIOLATION_ABOVE_PATTERN.matcher(line);\nfinal Matcher violationBelowMatcher=FILTERED_VIOLATION_BELOW_PATTERN.matcher(line);\nif(violationMatcher.matches()){inputConfigBuilder.addFilteredViolation(lineNo,violationMatcher.group(1));\n}if(violationAboveMatcher.matches()){inputConfigBuilder.addFilteredViolation(lineNo - 1,violationAboveMatcher.group(1));\n}if(violationBelowMatcher.matches()){inputConfigBuilder.addFilteredViolation(lineNo + 1,violationBelowMatcher.group(1));\n}}", "classSignatureBefore": "public final class InlineConfigParser ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#setViolations"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser"], "classSignatureBeforeSet": ["public final class InlineConfigParser "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.bdd;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\npublic final class InlineConfigParser {\n\n    /** A pattern matching the symbol: \"\\\" or \"/\". */\n    private static final Pattern SLASH_PATTERN = Pattern.compile(\"[\\\\\\\\/]\");\n\n    /** A pattern to find the string: \"// violation\". */\n    private static final Pattern VIOLATION_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation above\". */\n    private static final Pattern VIOLATION_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation above(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation below\". */\n    private static final Pattern VIOLATION_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation below(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// X violations\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations$\");\n\n    /** A pattern to find the string: \"// X violations above\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations above$\");\n\n    /** A pattern to find the string: \"// X violations below\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations below$\");\n\n    /** A pattern to find the string: \"// filtered violation\". */\n    private static final Pattern FILTERED_VIOLATION_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// filtered violation above\". */\n    private static final Pattern FILTERED_VIOLATION_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation above(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// filtered violation below\". */\n    private static final Pattern FILTERED_VIOLATION_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation below(?:\\\\W+'(.*)')?$\");\n\n    /** The String \"(null)\". */\n    private static final String NULL_STRING = \"(null)\";\n\n    /** Stop instances being created. **/\n    private InlineConfigParser() {\n    }\n\n    public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n        return parse(inputFilePath, false);\n    }\n\n    /**\n     * Parses the input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @param setFilteredViolations flag to set filtered violations.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    private static TestInputConfiguration parse(String inputFilePath,\n                                                boolean setFilteredViolations) throws Exception {\n        final TestInputConfiguration.Builder testInputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        try {\n            final Path filePath = Paths.get(inputFilePath);\n            final List<String> lines = readFile(filePath);\n            setModules(testInputConfigBuilder, inputFilePath, lines);\n            setViolations(testInputConfigBuilder, lines, setFilteredViolations);\n        }\n        catch (Exception ex) {\n            throw new CheckstyleException(\"Config comment not specified properly in \"\n                    + inputFilePath, ex);\n        }\n        return testInputConfigBuilder.build();\n    }\n\n    public static TestInputConfiguration parseWithFilteredViolations(String inputFilePath)\n            throws Exception {\n        return parse(inputFilePath, true);\n    }\n\n    private static void setModules(TestInputConfiguration.Builder testInputConfigBuilder,\n                                   String inputFilePath, List<String> lines)\n            throws Exception {\n        if (!lines.get(0).startsWith(\"/*\")) {\n            throw new CheckstyleException(\"Config not specified on top.\"\n                + \"Please see other inputs for examples of what is required.\");\n        }\n        int lineNo = 1;\n        do {\n            final ModuleInputConfiguration.Builder moduleInputConfigBuilder =\n                    new ModuleInputConfiguration.Builder();\n            setModuleName(moduleInputConfigBuilder, inputFilePath, lines.get(lineNo));\n            setProperties(moduleInputConfigBuilder, inputFilePath, lines, lineNo + 1);\n            testInputConfigBuilder.addChildModule(moduleInputConfigBuilder.build());\n            do {\n                lineNo++;\n            } while (lines.get(lineNo).isEmpty() || !lines.get(lineNo - 1).isEmpty());\n        } while (!lines.get(lineNo).startsWith(\"*/\"));\n    }\n\n    private static String getFullyQualifiedClassName(String filePath, String moduleName)\n            throws CheckstyleException {\n        String fullyQualifiedClassName;\n        if (moduleName.startsWith(\"com.\")) {\n            fullyQualifiedClassName = moduleName;\n        }\n        else {\n            final String path = SLASH_PATTERN.matcher(filePath).replaceAll(\"\\\\.\");\n            final int endIndex = path.lastIndexOf(moduleName.toLowerCase(Locale.ROOT));\n            if (endIndex == -1) {\n                throw new CheckstyleException(\"Unable to resolve module name: \" + moduleName\n                + \". Please check for spelling errors or specify fully qualified class name.\");\n            }\n            final int beginIndex = path.indexOf(\"com.puppycrawl\");\n            fullyQualifiedClassName = path.substring(beginIndex, endIndex) + moduleName;\n            if (!fullyQualifiedClassName.endsWith(\"Filter\")) {\n                fullyQualifiedClassName += \"Check\";\n            }\n        }\n        return fullyQualifiedClassName;\n    }\n\n    private static String getFilePath(String fileName, String inputFilePath) {\n        final int lastSlashIndex = Math.max(inputFilePath.lastIndexOf('\\\\'),\n                inputFilePath.lastIndexOf('/'));\n        final String root = inputFilePath.substring(0, lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getResourcePath(String fileName, String inputFilePath) {\n        final String filePath = getUriPath(fileName, inputFilePath);\n        final int lastSlashIndex = filePath.lastIndexOf('/');\n        final String root = filePath.substring(filePath.indexOf(\"puppycrawl\") - 5,\n                lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getUriPath(String fileName, String inputFilePath) {\n        return new File(getFilePath(fileName, inputFilePath)).toURI().toString();\n    }\n\n    private static String getResolvedPath(String fileValue, String inputFilePath) {\n        final String resolvedFilePath;\n        if (fileValue.startsWith(\"(resource)\")) {\n            resolvedFilePath =\n                    getResourcePath(fileValue.substring(fileValue.indexOf(')') + 1),\n                            inputFilePath);\n        }\n        else if (fileValue.startsWith(\"(uri)\")) {\n            resolvedFilePath =\n                    getUriPath(fileValue.substring(fileValue.indexOf(')') + 1), inputFilePath);\n        }\n        else {\n            resolvedFilePath = getFilePath(fileValue, inputFilePath);\n        }\n        return resolvedFilePath;\n    }\n\n    private static List<String> readFile(Path filePath) throws CheckstyleException {\n        try {\n            return Files.readAllLines(filePath);\n        }\n        catch (IOException ex) {\n            throw new CheckstyleException(\"Failed to read \" + filePath, ex);\n        }\n    }\n\n    private static void setModuleName(ModuleInputConfiguration.Builder moduleInputConfigBuilder,\n                                      String filePath, String moduleName)\n            throws CheckstyleException {\n        final String fullyQualifiedClassName = getFullyQualifiedClassName(filePath, moduleName);\n        moduleInputConfigBuilder.setModuleName(fullyQualifiedClassName);\n    }\n\n    private static void setProperties(ModuleInputConfiguration.Builder inputConfigBuilder,\n                                      String inputFilePath,\n                                      List<String> lines,\n                                      int beginLineNo)\n                    throws IOException {\n        final StringBuilder stringBuilder = new StringBuilder(128);\n        int lineNo = beginLineNo;\n        for (String line = lines.get(lineNo); !line.isEmpty() && !\"*/\".equals(line);\n                ++lineNo, line = lines.get(lineNo)) {\n            stringBuilder.append(line).append('\\n');\n        }\n        final Properties properties = new Properties();\n        properties.load(new StringReader(stringBuilder.toString()));\n        for (final Map.Entry<Object, Object> entry : properties.entrySet()) {\n            final String key = entry.getKey().toString();\n            final String value = entry.getValue().toString();\n            if (key.startsWith(\"message.\")) {\n                inputConfigBuilder.addModuleMessage(key.substring(8), value);\n            }\n            else if (value.startsWith(\"(file)\")) {\n                final String fileName = value.substring(value.indexOf(')') + 1);\n                final String filePath = getResolvedPath(fileName, inputFilePath);\n                inputConfigBuilder.addNonDefaultProperty(key, filePath);\n            }\n            else if (value.startsWith(\"(default)\")) {\n                final String defaultValue = value.substring(value.indexOf(')') + 1);\n                if (NULL_STRING.equals(defaultValue)) {\n                    inputConfigBuilder.addDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addDefaultProperty(key, defaultValue);\n                }\n            }\n            else {\n                if (NULL_STRING.equals(value)) {\n                    inputConfigBuilder.addNonDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addNonDefaultProperty(key, value);\n                }\n            }\n        }\n    }\n\n    private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines, boolean useFilteredViolations) {\n        for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n            final Matcher violationMatcher =\n                    VIOLATION_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationAboveMatcher =\n                    VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationBelowMatcher =\n                    VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsMatcher =\n                    MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsAboveMatcher =\n                    MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsBelowMatcher =\n                    MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n            if (violationMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n            }\n            else if (violationAboveMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n            }\n            else if (violationBelowMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n            }\n            else if (multipleViolationsMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsAboveMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsBelowMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n                                lineNo + 2)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (useFilteredViolations) {\n                setFilteredViolation(inputConfigBuilder, lineNo + 1, lines.get(lineNo));\n            }\n        }\n    }\n\n    private static void setFilteredViolation(TestInputConfiguration.Builder inputConfigBuilder,\n                                             int lineNo, String line) {\n        final Matcher violationMatcher =\n                FILTERED_VIOLATION_PATTERN.matcher(line);\n        final Matcher violationAboveMatcher =\n                FILTERED_VIOLATION_ABOVE_PATTERN.matcher(line);\n        final Matcher violationBelowMatcher =\n                FILTERED_VIOLATION_BELOW_PATTERN.matcher(line);\n        if (violationMatcher.matches()) {\n            inputConfigBuilder.addFilteredViolation(lineNo, violationMatcher.group(1));\n        }\n        else if (violationAboveMatcher.matches()) {\n            inputConfigBuilder.addFilteredViolation(lineNo - 1, violationAboveMatcher.group(1));\n        }\n        else if (violationBelowMatcher.matches()) {\n            inputConfigBuilder.addFilteredViolation(lineNo + 1, violationBelowMatcher.group(1));\n        }\n    }\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.bdd;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\npublic final class InlineConfigParser {\n\n    /** A pattern matching the symbol: \"\\\" or \"/\". */\n    private static final Pattern SLASH_PATTERN = Pattern.compile(\"[\\\\\\\\/]\");\n\n    /** A pattern to find the string: \"// violation\". */\n    private static final Pattern VIOLATION_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation above\". */\n    private static final Pattern VIOLATION_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation above(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation below\". */\n    private static final Pattern VIOLATION_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation below(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// X violations\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations$\");\n\n    /** A pattern to find the string: \"// X violations above\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations above$\");\n\n    /** A pattern to find the string: \"// X violations below\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations below$\");\n\n    /** A pattern to find the string: \"// filtered violation\". */\n    private static final Pattern FILTERED_VIOLATION_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// filtered violation above\". */\n    private static final Pattern FILTERED_VIOLATION_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation above(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// filtered violation below\". */\n    private static final Pattern FILTERED_VIOLATION_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation below(?:\\\\W+'(.*)')?$\");\n\n    /** The String \"(null)\". */\n    private static final String NULL_STRING = \"(null)\";\n\n    /** Stop instances being created. **/\n    private InlineConfigParser() {\n    }\n\n    public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n        return parse(inputFilePath, false);\n    }\n\n    /**\n     * Parses the input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @param setFilteredViolations flag to set filtered violations.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    private static TestInputConfiguration parse(String inputFilePath,\n                                                boolean setFilteredViolations) throws Exception {\n        final TestInputConfiguration.Builder testInputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        try {\n            final Path filePath = Paths.get(inputFilePath);\n            final List<String> lines = readFile(filePath);\n            setModules(testInputConfigBuilder, inputFilePath, lines);\n            setViolations(testInputConfigBuilder, lines, setFilteredViolations);\n        }\n        catch (Exception ex) {\n            throw new CheckstyleException(\"Config comment not specified properly in \"\n                    + inputFilePath, ex);\n        }\n        return testInputConfigBuilder.build();\n    }\n\n    public static TestInputConfiguration parseWithFilteredViolations(String inputFilePath)\n            throws Exception {\n        return parse(inputFilePath, true);\n    }\n\n    private static void setModules(TestInputConfiguration.Builder testInputConfigBuilder,\n                                   String inputFilePath, List<String> lines)\n            throws Exception {\n        if (!lines.get(0).startsWith(\"/*\")) {\n            throw new CheckstyleException(\"Config not specified on top.\"\n                + \"Please see other inputs for examples of what is required.\");\n        }\n        int lineNo = 1;\n        do {\n            final ModuleInputConfiguration.Builder moduleInputConfigBuilder =\n                    new ModuleInputConfiguration.Builder();\n            setModuleName(moduleInputConfigBuilder, inputFilePath, lines.get(lineNo));\n            setProperties(moduleInputConfigBuilder, inputFilePath, lines, lineNo + 1);\n            testInputConfigBuilder.addChildModule(moduleInputConfigBuilder.build());\n            do {\n                lineNo++;\n            } while (lines.get(lineNo).isEmpty() || !lines.get(lineNo - 1).isEmpty());\n        } while (!lines.get(lineNo).startsWith(\"*/\"));\n    }\n\n    private static String getFullyQualifiedClassName(String filePath, String moduleName)\n            throws CheckstyleException {\n        String fullyQualifiedClassName;\n        if (moduleName.startsWith(\"com.\")) {\n            fullyQualifiedClassName = moduleName;\n        }\n        else {\n            final String path = SLASH_PATTERN.matcher(filePath).replaceAll(\"\\\\.\");\n            final int endIndex = path.lastIndexOf(moduleName.toLowerCase(Locale.ROOT));\n            if (endIndex == -1) {\n                throw new CheckstyleException(\"Unable to resolve module name: \" + moduleName\n                + \". Please check for spelling errors or specify fully qualified class name.\");\n            }\n            final int beginIndex = path.indexOf(\"com.puppycrawl\");\n            fullyQualifiedClassName = path.substring(beginIndex, endIndex) + moduleName;\n            if (!fullyQualifiedClassName.endsWith(\"Filter\")) {\n                fullyQualifiedClassName += \"Check\";\n            }\n        }\n        return fullyQualifiedClassName;\n    }\n\n    private static String getFilePath(String fileName, String inputFilePath) {\n        final int lastSlashIndex = Math.max(inputFilePath.lastIndexOf('\\\\'),\n                inputFilePath.lastIndexOf('/'));\n        final String root = inputFilePath.substring(0, lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getResourcePath(String fileName, String inputFilePath) {\n        final String filePath = getUriPath(fileName, inputFilePath);\n        final int lastSlashIndex = filePath.lastIndexOf('/');\n        final String root = filePath.substring(filePath.indexOf(\"puppycrawl\") - 5,\n                lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getUriPath(String fileName, String inputFilePath) {\n        return new File(getFilePath(fileName, inputFilePath)).toURI().toString();\n    }\n\n    private static String getResolvedPath(String fileValue, String inputFilePath) {\n        final String resolvedFilePath;\n        if (fileValue.startsWith(\"(resource)\")) {\n            resolvedFilePath =\n                    getResourcePath(fileValue.substring(fileValue.indexOf(')') + 1),\n                            inputFilePath);\n        }\n        else if (fileValue.startsWith(\"(uri)\")) {\n            resolvedFilePath =\n                    getUriPath(fileValue.substring(fileValue.indexOf(')') + 1), inputFilePath);\n        }\n        else {\n            resolvedFilePath = getFilePath(fileValue, inputFilePath);\n        }\n        return resolvedFilePath;\n    }\n\n    private static List<String> readFile(Path filePath) throws CheckstyleException {\n        try {\n            return Files.readAllLines(filePath);\n        }\n        catch (IOException ex) {\n            throw new CheckstyleException(\"Failed to read \" + filePath, ex);\n        }\n    }\n\n    private static void setModuleName(ModuleInputConfiguration.Builder moduleInputConfigBuilder,\n                                      String filePath, String moduleName)\n            throws CheckstyleException {\n        final String fullyQualifiedClassName = getFullyQualifiedClassName(filePath, moduleName);\n        moduleInputConfigBuilder.setModuleName(fullyQualifiedClassName);\n    }\n\n    private static void setProperties(ModuleInputConfiguration.Builder inputConfigBuilder,\n                                      String inputFilePath,\n                                      List<String> lines,\n                                      int beginLineNo)\n                    throws IOException {\n        final StringBuilder stringBuilder = new StringBuilder(128);\n        int lineNo = beginLineNo;\n        for (String line = lines.get(lineNo); !line.isEmpty() && !\"*/\".equals(line);\n                ++lineNo, line = lines.get(lineNo)) {\n            stringBuilder.append(line).append('\\n');\n        }\n        final Properties properties = new Properties();\n        properties.load(new StringReader(stringBuilder.toString()));\n        for (final Map.Entry<Object, Object> entry : properties.entrySet()) {\n            final String key = entry.getKey().toString();\n            final String value = entry.getValue().toString();\n            if (key.startsWith(\"message.\")) {\n                inputConfigBuilder.addModuleMessage(key.substring(8), value);\n            }\n            else if (value.startsWith(\"(file)\")) {\n                final String fileName = value.substring(value.indexOf(')') + 1);\n                final String filePath = getResolvedPath(fileName, inputFilePath);\n                inputConfigBuilder.addNonDefaultProperty(key, filePath);\n            }\n            else if (value.startsWith(\"(default)\")) {\n                final String defaultValue = value.substring(value.indexOf(')') + 1);\n                if (NULL_STRING.equals(defaultValue)) {\n                    inputConfigBuilder.addDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addDefaultProperty(key, defaultValue);\n                }\n            }\n            else {\n                if (NULL_STRING.equals(value)) {\n                    inputConfigBuilder.addNonDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addNonDefaultProperty(key, value);\n                }\n            }\n        }\n    }\n\n    private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines, boolean useFilteredViolations) {\n        for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n            setViolations(inputConfigBuilder, lines, useFilteredViolations, lineNo);\n        }\n    }\n\n    /**\n     * Sets the violations.\n     *\n     * @param inputConfigBuilder the input file path.\n     * @param lines all the lines in the file.\n     * @param useFilteredViolations flag to set filtered violations.\n     * @param lineNo current line.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines, boolean useFilteredViolations,\n                                      int lineNo) {\n        final Matcher violationMatcher =\n                VIOLATION_PATTERN.matcher(lines.get(lineNo));\n        final Matcher violationAboveMatcher =\n                VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n        final Matcher violationBelowMatcher =\n                VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsMatcher =\n                MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsAboveMatcher =\n                MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsBelowMatcher =\n                MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n        if (violationMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n        }\n        else if (violationAboveMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n        }\n        else if (violationBelowMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n        }\n        else if (multipleViolationsMatcher.matches()) {\n            Collections\n                    .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n                    .forEach(actualLineNumber -> {\n                        inputConfigBuilder.addViolation(actualLineNumber, null);\n                    });\n        }\n        else if (multipleViolationsAboveMatcher.matches()) {\n            Collections\n                    .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n                    .forEach(actualLineNumber -> {\n                        inputConfigBuilder.addViolation(actualLineNumber, null);\n                    });\n        }\n        else if (multipleViolationsBelowMatcher.matches()) {\n            Collections\n                    .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n                            lineNo + 2)\n                    .forEach(actualLineNumber -> {\n                        inputConfigBuilder.addViolation(actualLineNumber, null);\n                    });\n        }\n        else if (useFilteredViolations) {\n            setFilteredViolation(inputConfigBuilder, lineNo + 1, lines.get(lineNo));\n        }\n    }\n\n    private static void setFilteredViolation(TestInputConfiguration.Builder inputConfigBuilder,\n                                             int lineNo, String line) {\n        final Matcher violationMatcher =\n                FILTERED_VIOLATION_PATTERN.matcher(line);\n        final Matcher violationAboveMatcher =\n                FILTERED_VIOLATION_ABOVE_PATTERN.matcher(line);\n        final Matcher violationBelowMatcher =\n                FILTERED_VIOLATION_BELOW_PATTERN.matcher(line);\n        if (violationMatcher.matches()) {\n            inputConfigBuilder.addFilteredViolation(lineNo, violationMatcher.group(1));\n        }\n        else if (violationAboveMatcher.matches()) {\n            inputConfigBuilder.addFilteredViolation(lineNo - 1, violationAboveMatcher.group(1));\n        }\n        else if (violationBelowMatcher.matches()) {\n            inputConfigBuilder.addFilteredViolation(lineNo + 1, violationBelowMatcher.group(1));\n        }\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Sets the violations.\n     *\n     * @param inputConfigBuilder the input file path.\n     * @param lines all the lines in the file.\n     * @param useFilteredViolations flag to set filtered violations.\n     * @param lineNo current line.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines, boolean useFilteredViolations,\n                                      int lineNo) {\n        final Matcher violationMatcher =\n                VIOLATION_PATTERN.matcher(lines.get(lineNo));\n        final Matcher violationAboveMatcher =\n                VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n        final Matcher violationBelowMatcher =\n                VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsMatcher =\n                MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsAboveMatcher =\n                MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsBelowMatcher =\n                MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n        if (violationMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n        }\n        else if (violationAboveMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n        }\n        else if (violationBelowMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n        }\n        else if (multipleViolationsMatcher.matches()) {\n            Collections\n                    .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n                    .forEach(actualLineNumber -> {\n                        inputConfigBuilder.addViolation(actualLineNumber, null);\n                    });\n        }\n        else if (multipleViolationsAboveMatcher.matches()) {\n            Collections\n                    .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n                    .forEach(actualLineNumber -> {\n                        inputConfigBuilder.addViolation(actualLineNumber, null);\n                    });\n        }\n        else if (multipleViolationsBelowMatcher.matches()) {\n            Collections\n                    .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n                            lineNo + 2)\n                    .forEach(actualLineNumber -> {\n                        inputConfigBuilder.addViolation(actualLineNumber, null);\n                    });\n        }\n        else if (useFilteredViolations) {\n            setFilteredViolation(inputConfigBuilder, lineNo + 1, lines.get(lineNo));\n        }\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#setFilteredViolation\n methodBody: private static void setFilteredViolation(TestInputConfiguration.Builder inputConfigBuilder,\n                                             int lineNo, String line) {\nfinal Matcher violationMatcher=FILTERED_VIOLATION_PATTERN.matcher(line);\nfinal Matcher violationAboveMatcher=FILTERED_VIOLATION_ABOVE_PATTERN.matcher(line);\nfinal Matcher violationBelowMatcher=FILTERED_VIOLATION_BELOW_PATTERN.matcher(line);\nif(violationMatcher.matches()){inputConfigBuilder.addFilteredViolation(lineNo,violationMatcher.group(1));\n}if(violationAboveMatcher.matches()){inputConfigBuilder.addFilteredViolation(lineNo - 1,violationAboveMatcher.group(1));\n}if(violationBelowMatcher.matches()){inputConfigBuilder.addFilteredViolation(lineNo + 1,violationBelowMatcher.group(1));\n}}"], "sourceCodeAfterRefactoring": "private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines, boolean useFilteredViolations) {\n        for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n            setViolations(inputConfigBuilder, lines, useFilteredViolations, lineNo);\n        }\n    }\n/**\n     * Sets the violations.\n     *\n     * @param inputConfigBuilder the input file path.\n     * @param lines all the lines in the file.\n     * @param useFilteredViolations flag to set filtered violations.\n     * @param lineNo current line.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines, boolean useFilteredViolations,\n                                      int lineNo) {\n        final Matcher violationMatcher =\n                VIOLATION_PATTERN.matcher(lines.get(lineNo));\n        final Matcher violationAboveMatcher =\n                VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n        final Matcher violationBelowMatcher =\n                VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsMatcher =\n                MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsAboveMatcher =\n                MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsBelowMatcher =\n                MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n        if (violationMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n        }\n        else if (violationAboveMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n        }\n        else if (violationBelowMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n        }\n        else if (multipleViolationsMatcher.matches()) {\n            Collections\n                    .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n                    .forEach(actualLineNumber -> {\n                        inputConfigBuilder.addViolation(actualLineNumber, null);\n                    });\n        }\n        else if (multipleViolationsAboveMatcher.matches()) {\n            Collections\n                    .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n                    .forEach(actualLineNumber -> {\n                        inputConfigBuilder.addViolation(actualLineNumber, null);\n                    });\n        }\n        else if (multipleViolationsBelowMatcher.matches()) {\n            Collections\n                    .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n                            lineNo + 2)\n                    .forEach(actualLineNumber -> {\n                        inputConfigBuilder.addViolation(actualLineNumber, null);\n                    });\n        }\n        else if (useFilteredViolations) {\n            setFilteredViolation(inputConfigBuilder, lineNo + 1, lines.get(lineNo));\n        }\n    }", "diffSourceCode": "   257:     private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n   258:                                       List<String> lines, boolean useFilteredViolations) {\n   259:         for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n-  260:             final Matcher violationMatcher =\n-  261:                     VIOLATION_PATTERN.matcher(lines.get(lineNo));\n-  262:             final Matcher violationAboveMatcher =\n-  263:                     VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n-  264:             final Matcher violationBelowMatcher =\n-  265:                     VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n-  266:             final Matcher multipleViolationsMatcher =\n-  267:                     MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n-  268:             final Matcher multipleViolationsAboveMatcher =\n-  269:                     MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n-  270:             final Matcher multipleViolationsBelowMatcher =\n-  271:                     MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n-  272:             if (violationMatcher.matches()) {\n-  273:                 inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n-  274:             }\n-  275:             else if (violationAboveMatcher.matches()) {\n-  276:                 inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n-  277:             }\n-  278:             else if (violationBelowMatcher.matches()) {\n-  279:                 inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n-  280:             }\n-  281:             else if (multipleViolationsMatcher.matches()) {\n-  282:                 Collections\n-  283:                         .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n-  284:                         .forEach(actualLineNumber -> {\n-  285:                             inputConfigBuilder.addViolation(actualLineNumber, null);\n-  286:                         });\n-  287:             }\n-  288:             else if (multipleViolationsAboveMatcher.matches()) {\n-  289:                 Collections\n-  290:                         .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n-  291:                         .forEach(actualLineNumber -> {\n-  292:                             inputConfigBuilder.addViolation(actualLineNumber, null);\n-  293:                         });\n-  294:             }\n-  295:             else if (multipleViolationsBelowMatcher.matches()) {\n-  296:                 Collections\n-  297:                         .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n-  298:                                 lineNo + 2)\n-  299:                         .forEach(actualLineNumber -> {\n-  300:                             inputConfigBuilder.addViolation(actualLineNumber, null);\n-  301:                         });\n-  302:             }\n-  303:             else if (useFilteredViolations) {\n-  304:                 setFilteredViolation(inputConfigBuilder, lineNo + 1, lines.get(lineNo));\n-  305:             }\n-  306:         }\n-  307:     }\n-  308: \n-  309:     private static void setFilteredViolation(TestInputConfiguration.Builder inputConfigBuilder,\n-  310:                                              int lineNo, String line) {\n-  311:         final Matcher violationMatcher =\n-  312:                 FILTERED_VIOLATION_PATTERN.matcher(line);\n-  313:         final Matcher violationAboveMatcher =\n-  314:                 FILTERED_VIOLATION_ABOVE_PATTERN.matcher(line);\n-  315:         final Matcher violationBelowMatcher =\n-  316:                 FILTERED_VIOLATION_BELOW_PATTERN.matcher(line);\n-  317:         if (violationMatcher.matches()) {\n-  318:             inputConfigBuilder.addFilteredViolation(lineNo, violationMatcher.group(1));\n-  319:         }\n-  320:         else if (violationAboveMatcher.matches()) {\n-  321:             inputConfigBuilder.addFilteredViolation(lineNo - 1, violationAboveMatcher.group(1));\n-  322:         }\n+  260:             setViolations(inputConfigBuilder, lines, useFilteredViolations, lineNo);\n+  261:         }\n+  262:     }\n+  263: \n+  264:     /**\n+  265:      * Sets the violations.\n+  266:      *\n+  267:      * @param inputConfigBuilder the input file path.\n+  268:      * @param lines all the lines in the file.\n+  269:      * @param useFilteredViolations flag to set filtered violations.\n+  270:      * @param lineNo current line.\n+  271:      * @noinspection IfStatementWithTooManyBranches\n+  272:      */\n+  273:     private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n+  274:                                       List<String> lines, boolean useFilteredViolations,\n+  275:                                       int lineNo) {\n+  276:         final Matcher violationMatcher =\n+  277:                 VIOLATION_PATTERN.matcher(lines.get(lineNo));\n+  278:         final Matcher violationAboveMatcher =\n+  279:                 VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n+  280:         final Matcher violationBelowMatcher =\n+  281:                 VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n+  282:         final Matcher multipleViolationsMatcher =\n+  283:                 MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n+  284:         final Matcher multipleViolationsAboveMatcher =\n+  285:                 MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n+  286:         final Matcher multipleViolationsBelowMatcher =\n+  287:                 MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n+  288:         if (violationMatcher.matches()) {\n+  289:             inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n+  290:         }\n+  291:         else if (violationAboveMatcher.matches()) {\n+  292:             inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n+  293:         }\n+  294:         else if (violationBelowMatcher.matches()) {\n+  295:             inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n+  296:         }\n+  297:         else if (multipleViolationsMatcher.matches()) {\n+  298:             Collections\n+  299:                     .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n+  300:                     .forEach(actualLineNumber -> {\n+  301:                         inputConfigBuilder.addViolation(actualLineNumber, null);\n+  302:                     });\n+  303:         }\n+  304:         else if (multipleViolationsAboveMatcher.matches()) {\n+  305:             Collections\n+  306:                     .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n+  307:                     .forEach(actualLineNumber -> {\n+  308:                         inputConfigBuilder.addViolation(actualLineNumber, null);\n+  309:                     });\n+  310:         }\n+  311:         else if (multipleViolationsBelowMatcher.matches()) {\n+  312:             Collections\n+  313:                     .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n+  314:                             lineNo + 2)\n+  315:                     .forEach(actualLineNumber -> {\n+  316:                         inputConfigBuilder.addViolation(actualLineNumber, null);\n+  317:                     });\n+  318:         }\n+  319:         else if (useFilteredViolations) {\n+  320:             setFilteredViolation(inputConfigBuilder, lineNo + 1, lines.get(lineNo));\n+  321:         }\n+  322:     }\n", "uniqueId": "defd358fbe0123c2dd4c72fbf9960cc5178fbf8b_257_307_264_322_257_262", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "##########################\nprivate static void processViolation(TestInputConfiguration.Builder inputConfigBuilder, int lineNo, Matcher matcher, String group) {\n    if (matcher.matches()) {\n        inputConfigBuilder.addViolation(lineNo, group);\n    }\n}\n\nprivate static void processMultipleViolations(TestInputConfiguration.Builder inputConfigBuilder, int lineNo, Matcher matcher, int offset) {\n    if (matcher.matches()) {\n        Collections\n                .nCopies(Integer.parseInt(matcher.group(1)), lineNo + offset)\n                .forEach(actualLineNumber -> {\n                    inputConfigBuilder.addViolation(actualLineNumber, null);\n                });\n    }\n}\n\nprivate static void setFilteredViolation(TestInputConfiguration.Builder inputConfigBuilder, int lineNo, Matcher violationMatcher, Matcher violationAboveMatcher, Matcher violationBelowMatcher) {\n    if (violationMatcher.matches()) {\n        inputConfigBuilder.addFilteredViolation(lineNo, violationMatcher.group(1));\n    } else if (violationAboveMatcher.matches()) {\n        inputConfigBuilder.addFilteredViolation(lineNo - 1, violationAboveMatcher.group(1));\n    } else if (violationBelowMatcher.matches()) {\n        inputConfigBuilder.addFilteredViolation(lineNo + 1, violationBelowMatcher.group(1));\n    }\n}\n\nprivate static void setViolations(TestInputConfiguration.Builder inputConfigBuilder, List<String> lines, boolean useFilteredViolations) {\n    for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n        final Matcher violationMatcher = VIOLATION_PATTERN.matcher(lines.get(lineNo));\n        final Matcher violationAboveMatcher = VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n        final Matcher violationBelowMatcher = VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsMatcher = MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsAboveMatcher = MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n        final Matcher multipleViolationsBelowMatcher = MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n\n        processViolation(inputConfigBuilder, lineNo + 1, violationMatcher, violationMatcher.group(1));\n        processViolation(inputConfigBuilder, lineNo, violationAboveMatcher, violationAboveMatcher.group(1));\n        processViolation(inputConfigBuilder, lineNo + 2, violationBelowMatcher, violationBelowMatcher.group(1));\n        processMultipleViolations(inputConfigBuilder, lineNo + 1, multipleViolationsMatcher, 0);\n        processMultipleViolations(inputConfigBuilder, lineNo, multipleViolationsAboveMatcher, -1);\n        processMultipleViolations(inputConfigBuilder, lineNo + 2, multipleViolationsBelowMatcher, 1);\n\n        if (useFilteredViolations) {\n            final Matcher filteredViolationMatcher = FILTERED_VIOLATION_PATTERN.matcher(lines.get(lineNo));\n            final Matcher filteredViolationAboveMatcher = FILTERED_VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher filteredViolationBelowMatcher = FILTERED_VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n            setFilteredViolation(inputConfigBuilder, lineNo, filteredViolationMatcher, filteredViolationAboveMatcher, filteredViolationBelowMatcher);\n        }\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\nprivate static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines, boolean useFilteredViolations) {\n        for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n            final Matcher violationMatcher =\n                    VIOLATION_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationAboveMatcher =\n                    VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationBelowMatcher =\n                    VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsMatcher =\n                    MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsAboveMatcher =\n                    MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsBelowMatcher =\n                    MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n            if (violationMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n            }\n            else if (violationAboveMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n            }\n            else if (violationBelowMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n            }\n            else if (multipleViolationsMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsAboveMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsBelowMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n                                lineNo + 2)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (useFilteredViolations) {\n                setFilteredViolation(inputConfigBuilder, lineNo + 1, lines.get(lineNo));\n            }\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.bdd;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\npublic final class InlineConfigParser {\n\n    /** A pattern matching the symbol: \"\\\" or \"/\". */\n    private static final Pattern SLASH_PATTERN = Pattern.compile(\"[\\\\\\\\/]\");\n\n    /** A pattern to find the string: \"// violation\". */\n    private static final Pattern VIOLATION_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation above\". */\n    private static final Pattern VIOLATION_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation above(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation below\". */\n    private static final Pattern VIOLATION_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation below(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// X violations\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations$\");\n\n    /** A pattern to find the string: \"// X violations above\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations above$\");\n\n    /** A pattern to find the string: \"// X violations below\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations below$\");\n\n    /** A pattern to find the string: \"// filtered violation\". */\n    private static final Pattern FILTERED_VIOLATION_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// filtered violation above\". */\n    private static final Pattern FILTERED_VIOLATION_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation above(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// filtered violation below\". */\n    private static final Pattern FILTERED_VIOLATION_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation below(?:\\\\W+'(.*)')?$\");\n\n    /** The String \"(null)\". */\n    private static final String NULL_STRING = \"(null)\";\n\n    /** Stop instances being created. **/\n    private InlineConfigParser() {\n    }\n\n    public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n        return parse(inputFilePath, false);\n    }\n\n    /**\n     * Parses the input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @param setFilteredViolations flag to set filtered violations.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    private static TestInputConfiguration parse(String inputFilePath,\n                                                boolean setFilteredViolations) throws Exception {\n        final TestInputConfiguration.Builder testInputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        try {\n            final Path filePath = Paths.get(inputFilePath);\n            final List<String> lines = readFile(filePath);\n            setModules(testInputConfigBuilder, inputFilePath, lines);\n            setViolations(testInputConfigBuilder, lines, setFilteredViolations);\n        }\n        catch (Exception ex) {\n            throw new CheckstyleException(\"Config comment not specified properly in \"\n                    + inputFilePath, ex);\n        }\n        return testInputConfigBuilder.build();\n    }\n\n    public static TestInputConfiguration parseWithFilteredViolations(String inputFilePath)\n            throws Exception {\n        return parse(inputFilePath, true);\n    }\n\n    private static void setModules(TestInputConfiguration.Builder testInputConfigBuilder,\n                                   String inputFilePath, List<String> lines)\n            throws Exception {\n        if (!lines.get(0).startsWith(\"/*\")) {\n            throw new CheckstyleException(\"Config not specified on top.\"\n                + \"Please see other inputs for examples of what is required.\");\n        }\n        int lineNo = 1;\n        do {\n            final ModuleInputConfiguration.Builder moduleInputConfigBuilder =\n                    new ModuleInputConfiguration.Builder();\n            setModuleName(moduleInputConfigBuilder, inputFilePath, lines.get(lineNo));\n            setProperties(moduleInputConfigBuilder, inputFilePath, lines, lineNo + 1);\n            testInputConfigBuilder.addChildModule(moduleInputConfigBuilder.build());\n            do {\n                lineNo++;\n            } while (lines.get(lineNo).isEmpty() || !lines.get(lineNo - 1).isEmpty());\n        } while (!lines.get(lineNo).startsWith(\"*/\"));\n    }\n\n    private static String getFullyQualifiedClassName(String filePath, String moduleName)\n            throws CheckstyleException {\n        String fullyQualifiedClassName;\n        if (moduleName.startsWith(\"com.\")) {\n            fullyQualifiedClassName = moduleName;\n        }\n        else {\n            final String path = SLASH_PATTERN.matcher(filePath).replaceAll(\"\\\\.\");\n            final int endIndex = path.lastIndexOf(moduleName.toLowerCase(Locale.ROOT));\n            if (endIndex == -1) {\n                throw new CheckstyleException(\"Unable to resolve module name: \" + moduleName\n                + \". Please check for spelling errors or specify fully qualified class name.\");\n            }\n            final int beginIndex = path.indexOf(\"com.puppycrawl\");\n            fullyQualifiedClassName = path.substring(beginIndex, endIndex) + moduleName;\n            if (!fullyQualifiedClassName.endsWith(\"Filter\")) {\n                fullyQualifiedClassName += \"Check\";\n            }\n        }\n        return fullyQualifiedClassName;\n    }\n\n    private static String getFilePath(String fileName, String inputFilePath) {\n        final int lastSlashIndex = Math.max(inputFilePath.lastIndexOf('\\\\'),\n                inputFilePath.lastIndexOf('/'));\n        final String root = inputFilePath.substring(0, lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getResourcePath(String fileName, String inputFilePath) {\n        final String filePath = getUriPath(fileName, inputFilePath);\n        final int lastSlashIndex = filePath.lastIndexOf('/');\n        final String root = filePath.substring(filePath.indexOf(\"puppycrawl\") - 5,\n                lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getUriPath(String fileName, String inputFilePath) {\n        return new File(getFilePath(fileName, inputFilePath)).toURI().toString();\n    }\n\n    private static String getResolvedPath(String fileValue, String inputFilePath) {\n        final String resolvedFilePath;\n        if (fileValue.startsWith(\"(resource)\")) {\n            resolvedFilePath =\n                    getResourcePath(fileValue.substring(fileValue.indexOf(')') + 1),\n                            inputFilePath);\n        }\n        else if (fileValue.startsWith(\"(uri)\")) {\n            resolvedFilePath =\n                    getUriPath(fileValue.substring(fileValue.indexOf(')') + 1), inputFilePath);\n        }\n        else {\n            resolvedFilePath = getFilePath(fileValue, inputFilePath);\n        }\n        return resolvedFilePath;\n    }\n\n    private static List<String> readFile(Path filePath) throws CheckstyleException {\n        try {\n            return Files.readAllLines(filePath);\n        }\n        catch (IOException ex) {\n            throw new CheckstyleException(\"Failed to read \" + filePath, ex);\n        }\n    }\n\n    private static void setModuleName(ModuleInputConfiguration.Builder moduleInputConfigBuilder,\n                                      String filePath, String moduleName)\n            throws CheckstyleException {\n        final String fullyQualifiedClassName = getFullyQualifiedClassName(filePath, moduleName);\n        moduleInputConfigBuilder.setModuleName(fullyQualifiedClassName);\n    }\n\n    private static void setProperties(ModuleInputConfiguration.Builder inputConfigBuilder,\n                                      String inputFilePath,\n                                      List<String> lines,\n                                      int beginLineNo)\n                    throws IOException {\n        final StringBuilder stringBuilder = new StringBuilder(128);\n        int lineNo = beginLineNo;\n        for (String line = lines.get(lineNo); !line.isEmpty() && !\"*/\".equals(line);\n                ++lineNo, line = lines.get(lineNo)) {\n            stringBuilder.append(line).append('\\n');\n        }\n        final Properties properties = new Properties();\n        properties.load(new StringReader(stringBuilder.toString()));\n        for (final Map.Entry<Object, Object> entry : properties.entrySet()) {\n            final String key = entry.getKey().toString();\n            final String value = entry.getValue().toString();\n            if (key.startsWith(\"message.\")) {\n                inputConfigBuilder.addModuleMessage(key.substring(8), value);\n            }\n            else if (value.startsWith(\"(file)\")) {\n                final String fileName = value.substring(value.indexOf(')') + 1);\n                final String filePath = getResolvedPath(fileName, inputFilePath);\n                inputConfigBuilder.addNonDefaultProperty(key, filePath);\n            }\n            else if (value.startsWith(\"(default)\")) {\n                final String defaultValue = value.substring(value.indexOf(')') + 1);\n                if (NULL_STRING.equals(defaultValue)) {\n                    inputConfigBuilder.addDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addDefaultProperty(key, defaultValue);\n                }\n            }\n            else {\n                if (NULL_STRING.equals(value)) {\n                    inputConfigBuilder.addNonDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addNonDefaultProperty(key, value);\n                }\n            }\n        }\n    }\n\n    private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines, boolean useFilteredViolations) {\n        for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n            final Matcher violationMatcher =\n                    VIOLATION_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationAboveMatcher =\n                    VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationBelowMatcher =\n                    VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsMatcher =\n                    MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsAboveMatcher =\n                    MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsBelowMatcher =\n                    MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n            if (violationMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n            }\n            else if (violationAboveMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n            }\n            else if (violationBelowMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n            }\n            else if (multipleViolationsMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsAboveMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsBelowMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n                                lineNo + 2)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (useFilteredViolations) {\n                setFilteredViolation(inputConfigBuilder, lineNo + 1, lines.get(lineNo));\n            }\n        }\n    }\n\n    private static void setFilteredViolation(TestInputConfiguration.Builder inputConfigBuilder,\n                                             int lineNo, String line) {\n        final Matcher violationMatcher =\n                FILTERED_VIOLATION_PATTERN.matcher(line);\n        final Matcher violationAboveMatcher =\n                FILTERED_VIOLATION_ABOVE_PATTERN.matcher(line);\n        final Matcher violationBelowMatcher =\n                FILTERED_VIOLATION_BELOW_PATTERN.matcher(line);\n        if (violationMatcher.matches()) {\n            inputConfigBuilder.addFilteredViolation(lineNo, violationMatcher.group(1));\n        }\n        else if (violationAboveMatcher.matches()) {\n            inputConfigBuilder.addFilteredViolation(lineNo - 1, violationAboveMatcher.group(1));\n        }\n        else if (violationBelowMatcher.matches()) {\n            inputConfigBuilder.addFilteredViolation(lineNo + 1, violationBelowMatcher.group(1));\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tprivate exit(code int) : void extracted from public main(args String...) : void in class com.puppycrawl.tools.checkstyle.Main & moved to class com.puppycrawl.tools.checkstyle.Main.ExitHelper", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java", "startLine": 99, "endLine": 155, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java", "startLine": 99, "endLine": 153, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java", "startLine": 876, "endLine": 886, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Loops over the files specified checking them for errors. The exit code\n     * is the number of errors found in all the files.\n     *\n     * @param args the command line arguments.\n     * @throws IOException if there is a problem with files access\n     * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace, CallToSystemExit\n     **/\n    public static void main(String... args) throws IOException {\n\n        final CliOptions cliOptions = new CliOptions();\n        final CommandLine commandLine = new CommandLine(cliOptions);\n        commandLine.setUsageHelpWidth(CliOptions.HELP_WIDTH);\n        commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n\n        // provide proper exit code based on results.\n        int exitStatus = 0;\n        int errorCounter = 0;\n        try {\n            final ParseResult parseResult = commandLine.parseArgs(args);\n            if (parseResult.isVersionHelpRequested()) {\n                System.out.println(getVersionString());\n            }\n            else if (parseResult.isUsageHelpRequested()) {\n                commandLine.usage(System.out);\n            }\n            else {\n                exitStatus = execute(parseResult, cliOptions);\n                errorCounter = exitStatus;\n            }\n        }\n        catch (ParameterException ex) {\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n            System.err.println(ex.getMessage());\n            System.err.println(\"Usage: checkstyle [OPTIONS]... FILES...\");\n            System.err.println(\"Try 'checkstyle --help' for more information.\");\n        }\n        catch (CheckstyleException ex) {\n            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n            errorCounter = 1;\n            ex.printStackTrace();\n        }\n        finally {\n            // return exit code base on validation of Checker\n            if (errorCounter > 0) {\n                final Violation errorCounterViolation = new Violation(1,\n                        Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n                        new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n                // print error count statistic to error output stream,\n                // output stream might be used by validation report content\n                System.err.println(errorCounterViolation.getViolation());\n            }\n            if (exitStatus != 0) {\n                System.exit(exitStatus);\n            }\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java", "isPureRefactoring": true, "commitId": "664227cd5bf9c649847461d8055a7ee573f483e5", "packageNameBefore": "com.puppycrawl.tools.checkstyle", "classNameBefore": "com.puppycrawl.tools.checkstyle.Main", "methodNameBefore": "com.puppycrawl.tools.checkstyle.Main#main", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.Main#getVersionString\n methodBody: private static String getVersionString() {\nreturn \"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion();\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.Main#execute\n methodBody: private static int execute(ParseResult parseResult, CliOptions options)\n            throws IOException, CheckstyleException {\nfinal int exitStatus;\nfinal List<File> filesToProcess=getFilesToProcess(options);\nfinal List<String> messages=options.validateCli(parseResult,filesToProcess);\nfinal boolean hasMessages=!messages.isEmpty();\nif(hasMessages){messages.forEach(System.out::println);\nexitStatus=EXIT_WITH_INVALID_USER_INPUT_CODE;\n}{exitStatus=runCli(options,filesToProcess);\n}return exitStatus;\n}", "classSignatureBefore": "public final class Main ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.Main#main"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.Main"], "classSignatureBeforeSet": ["public final class Main "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All the mappings are matched! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Filter;\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport com.puppycrawl.tools.checkstyle.api.AuditEvent;\nimport com.puppycrawl.tools.checkstyle.api.AuditListener;\nimport com.puppycrawl.tools.checkstyle.api.AutomaticBean;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.RootModule;\nimport com.puppycrawl.tools.checkstyle.api.Violation;\nimport com.puppycrawl.tools.checkstyle.utils.ChainedPropertyUtil;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.XpathUtil;\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Option;\nimport picocli.CommandLine.ParameterException;\nimport picocli.CommandLine.Parameters;\nimport picocli.CommandLine.ParseResult;\n\n/**\n * Wrapper command line program for the Checker.\n */\npublic final class Main {\n\n    /**\n     * A key pointing to the error counter\n     * message in the \"messages.properties\" file.\n     */\n    public static final String ERROR_COUNTER = \"Main.errorCounter\";\n    /**\n     * A key pointing to the load properties exception\n     * message in the \"messages.properties\" file.\n     */\n    public static final String LOAD_PROPERTIES_EXCEPTION = \"Main.loadProperties\";\n    /**\n     * A key pointing to the create listener exception\n     * message in the \"messages.properties\" file.\n     */\n    public static final String CREATE_LISTENER_EXCEPTION = \"Main.createListener\";\n\n    /** Logger for Main. */\n    private static final Log LOG = LogFactory.getLog(Main.class);\n\n    /** Exit code returned when user specified invalid command line arguments. */\n    private static final int EXIT_WITH_INVALID_USER_INPUT_CODE = -1;\n\n    /** Exit code returned when execution finishes with {@link CheckstyleException}. */\n    private static final int EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE = -2;\n\n    /**\n     * Client code should not create instances of this class, but use\n     * {@link #main(String[])} method instead.\n     */\n    private Main() {\n    }\n\n    /**\n     * Loops over the files specified checking them for errors. The exit code\n     * is the number of errors found in all the files.\n     *\n     * @param args the command line arguments.\n     * @throws IOException if there is a problem with files access\n     * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace, CallToSystemExit\n     **/\n    public static void main(String... args) throws IOException {\n\n        final CliOptions cliOptions = new CliOptions();\n        final CommandLine commandLine = new CommandLine(cliOptions);\n        commandLine.setUsageHelpWidth(CliOptions.HELP_WIDTH);\n        commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n\n        // provide proper exit code based on results.\n        int exitStatus = 0;\n        int errorCounter = 0;\n        try {\n            final ParseResult parseResult = commandLine.parseArgs(args);\n            if (parseResult.isVersionHelpRequested()) {\n                System.out.println(getVersionString());\n            }\n            else if (parseResult.isUsageHelpRequested()) {\n                commandLine.usage(System.out);\n            }\n            else {\n                exitStatus = execute(parseResult, cliOptions);\n                errorCounter = exitStatus;\n            }\n        }\n        catch (ParameterException ex) {\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n            System.err.println(ex.getMessage());\n            System.err.println(\"Usage: checkstyle [OPTIONS]... FILES...\");\n            System.err.println(\"Try 'checkstyle --help' for more information.\");\n        }\n        catch (CheckstyleException ex) {\n            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n            errorCounter = 1;\n            ex.printStackTrace();\n        }\n        finally {\n            // return exit code base on validation of Checker\n            if (errorCounter > 0) {\n                final Violation errorCounterViolation = new Violation(1,\n                        Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n                        new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n                // print error count statistic to error output stream,\n                // output stream might be used by validation report content\n                System.err.println(errorCounterViolation.getViolation());\n            }\n            if (exitStatus != 0) {\n                System.exit(exitStatus);\n            }\n        }\n    }\n\n    /**\n     * Returns the version string printed when the user requests version help (--version or -V).\n     *\n     * @return a version string based on the package implementation version\n     */\n    private static String getVersionString() {\n        return \"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion();\n    }\n\n    /**\n     * Validates the user input and returns {@value #EXIT_WITH_INVALID_USER_INPUT_CODE} if\n     * invalid, otherwise executes CheckStyle and returns the number of violations.\n     *\n     * @param parseResult generic access to options and parameters found on the command line\n     * @param options encapsulates options and parameters specified on the command line\n     * @return number of violations\n     * @throws IOException if a file could not be read.\n     * @throws CheckstyleException if something happens processing the files.\n     * @noinspection UseOfSystemOutOrSystemErr\n     */\n    private static int execute(ParseResult parseResult, CliOptions options)\n            throws IOException, CheckstyleException {\n\n        final int exitStatus;\n\n        // return error if something is wrong in arguments\n        final List<File> filesToProcess = getFilesToProcess(options);\n        final List<String> messages = options.validateCli(parseResult, filesToProcess);\n        final boolean hasMessages = !messages.isEmpty();\n        if (hasMessages) {\n            messages.forEach(System.out::println);\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n        }\n        else {\n            exitStatus = runCli(options, filesToProcess);\n        }\n        return exitStatus;\n    }\n\n    /**\n     * Determines the files to process.\n     *\n     * @param options the user-specified options\n     * @return list of files to process\n     */\n    private static List<File> getFilesToProcess(CliOptions options) {\n        final List<Pattern> patternsToExclude = options.getExclusions();\n\n        final List<File> result = new LinkedList<>();\n        for (File file : options.files) {\n            result.addAll(listFiles(file, patternsToExclude));\n        }\n        return result;\n    }\n\n    /**\n     * Traverses a specified node looking for files to check. Found files are added to\n     * a specified list. Subdirectories are also traversed.\n     *\n     * @param node\n     *        the node to process\n     * @param patternsToExclude The list of patterns to exclude from searching or being added as\n     *        files.\n     * @return found files\n     */\n    private static List<File> listFiles(File node, List<Pattern> patternsToExclude) {\n        // could be replaced with org.apache.commons.io.FileUtils.list() method\n        // if only we add commons-io library\n        final List<File> result = new LinkedList<>();\n\n        if (node.canRead() && !isPathExcluded(node.getAbsolutePath(), patternsToExclude)) {\n            if (node.isDirectory()) {\n                final File[] files = node.listFiles();\n                // listFiles() can return null, so we need to check it\n                if (files != null) {\n                    for (File element : files) {\n                        result.addAll(listFiles(element, patternsToExclude));\n                    }\n                }\n            }\n            else if (node.isFile()) {\n                result.add(node);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Checks if a directory/file {@code path} should be excluded based on if it matches one of the\n     * patterns supplied.\n     *\n     * @param path The path of the directory/file to check\n     * @param patternsToExclude The list of patterns to exclude from searching or being added as\n     *        files.\n     * @return True if the directory/file matches one of the patterns.\n     */\n    private static boolean isPathExcluded(String path, List<Pattern> patternsToExclude) {\n        boolean result = false;\n\n        for (Pattern pattern : patternsToExclude) {\n            if (pattern.matcher(path).find()) {\n                result = true;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Do execution of CheckStyle based on Command line options.\n     *\n     * @param options user-specified options\n     * @param filesToProcess the list of files whose style to check\n     * @return number of violations\n     * @throws IOException if a file could not be read.\n     * @throws CheckstyleException if something happens processing the files.\n     * @noinspection UseOfSystemOutOrSystemErr\n     */\n    private static int runCli(CliOptions options, List<File> filesToProcess)\n            throws IOException, CheckstyleException {\n        int result = 0;\n        final boolean hasSuppressionLineColumnNumber = options.suppressionLineColumnNumber != null;\n\n        // create config helper object\n        if (options.printAst) {\n            // print AST\n            final File file = filesToProcess.get(0);\n            final String stringAst = AstTreeStringPrinter.printFileAst(file,\n                    JavaParser.Options.WITHOUT_COMMENTS);\n            System.out.print(stringAst);\n        }\n        else if (Objects.nonNull(options.xpath)) {\n            final String branch = XpathUtil.printXpathBranch(options.xpath, filesToProcess.get(0));\n            System.out.print(branch);\n        }\n        else if (options.printAstWithComments) {\n            final File file = filesToProcess.get(0);\n            final String stringAst = AstTreeStringPrinter.printFileAst(file,\n                    JavaParser.Options.WITH_COMMENTS);\n            System.out.print(stringAst);\n        }\n        else if (options.printJavadocTree) {\n            final File file = filesToProcess.get(0);\n            final String stringAst = DetailNodeTreeStringPrinter.printFileAst(file);\n            System.out.print(stringAst);\n        }\n        else if (options.printTreeWithJavadoc) {\n            final File file = filesToProcess.get(0);\n            final String stringAst = AstTreeStringPrinter.printJavaAndJavadocTree(file);\n            System.out.print(stringAst);\n        }\n        else if (hasSuppressionLineColumnNumber) {\n            final File file = filesToProcess.get(0);\n            final String stringSuppressions =\n                    SuppressionsStringPrinter.printSuppressions(file,\n                            options.suppressionLineColumnNumber, options.tabWidth);\n            System.out.print(stringSuppressions);\n        }\n        else {\n            if (options.debug) {\n                final Logger parentLogger = Logger.getLogger(Main.class.getName()).getParent();\n                final ConsoleHandler handler = new ConsoleHandler();\n                handler.setLevel(Level.FINEST);\n                handler.setFilter(new OnlyCheckstyleLoggersFilter());\n                parentLogger.addHandler(handler);\n                parentLogger.setLevel(Level.FINEST);\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Checkstyle debug logging enabled\");\n                LOG.debug(\"Running Checkstyle with version: \"\n                        + Main.class.getPackage().getImplementationVersion());\n            }\n\n            // run Checker\n            result = runCheckstyle(options, filesToProcess);\n        }\n\n        return result;\n    }\n\n    /**\n     * Executes required Checkstyle actions based on passed parameters.\n     *\n     * @param options user-specified options\n     * @param filesToProcess the list of files whose style to check\n     * @return number of violations of ERROR level\n     * @throws IOException\n     *         when output file could not be found\n     * @throws CheckstyleException\n     *         when properties file could not be loaded\n     */\n    private static int runCheckstyle(CliOptions options, List<File> filesToProcess)\n            throws CheckstyleException, IOException {\n        // setup the properties\n        final Properties props;\n\n        if (options.propertiesFile == null) {\n            props = System.getProperties();\n        }\n        else {\n            props = loadProperties(options.propertiesFile);\n        }\n\n        // create a configuration\n        final ThreadModeSettings multiThreadModeSettings =\n                new ThreadModeSettings(CliOptions.CHECKER_THREADS_NUMBER,\n                        CliOptions.TREE_WALKER_THREADS_NUMBER);\n\n        final ConfigurationLoader.IgnoredModulesOptions ignoredModulesOptions;\n        if (options.executeIgnoredModules) {\n            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.EXECUTE;\n        }\n        else {\n            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.OMIT;\n        }\n\n        final Configuration config = ConfigurationLoader.loadConfiguration(\n                options.configurationFile, new PropertiesExpander(props),\n                ignoredModulesOptions, multiThreadModeSettings);\n\n        // create RootModule object and run it\n        final int errorCounter;\n        final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n        final RootModule rootModule = getRootModule(config.getName(), moduleClassLoader);\n\n        try {\n            final AuditListener listener;\n            if (options.generateXpathSuppressionsFile) {\n                // create filter to print generated xpath suppressions file\n                final Configuration treeWalkerConfig = getTreeWalkerConfig(config);\n                if (treeWalkerConfig != null) {\n                    final DefaultConfiguration moduleConfig =\n                            new DefaultConfiguration(\n                                    XpathFileGeneratorAstFilter.class.getName());\n                    moduleConfig.addProperty(CliOptions.ATTRIB_TAB_WIDTH_NAME,\n                            String.valueOf(options.tabWidth));\n                    ((DefaultConfiguration) treeWalkerConfig).addChild(moduleConfig);\n                }\n\n                listener = new XpathFileGeneratorAuditListener(getOutputStream(options.outputPath),\n                        getOutputStreamOptions(options.outputPath));\n            }\n            else {\n                listener = createListener(options.format, options.outputPath);\n            }\n\n            rootModule.setModuleClassLoader(moduleClassLoader);\n            rootModule.configure(config);\n            rootModule.addListener(listener);\n\n            // run RootModule\n            errorCounter = rootModule.process(filesToProcess);\n        }\n        finally {\n            rootModule.destroy();\n        }\n\n        return errorCounter;\n    }\n\n    /**\n     * Loads properties from a File.\n     *\n     * @param file\n     *        the properties file\n     * @return the properties in file\n     * @throws CheckstyleException\n     *         when could not load properties file\n     */\n    private static Properties loadProperties(File file)\n            throws CheckstyleException {\n        final Properties properties = new Properties();\n\n        try (InputStream stream = Files.newInputStream(file.toPath())) {\n            properties.load(stream);\n        }\n        catch (final IOException ex) {\n            final Violation loadPropertiesExceptionMessage = new Violation(1,\n                    Definitions.CHECKSTYLE_BUNDLE, LOAD_PROPERTIES_EXCEPTION,\n                    new String[] {file.getAbsolutePath()}, null, Main.class, null);\n            throw new CheckstyleException(loadPropertiesExceptionMessage.getViolation(), ex);\n        }\n\n        return ChainedPropertyUtil.getResolvedProperties(properties);\n    }\n\n    /**\n     * Creates a new instance of the root module that will control and run\n     * Checkstyle.\n     *\n     * @param name The name of the module. This will either be a short name that\n     *        will have to be found or the complete package name.\n     * @param moduleClassLoader Class loader used to load the root module.\n     * @return The new instance of the root module.\n     * @throws CheckstyleException if no module can be instantiated from name\n     */\n    private static RootModule getRootModule(String name, ClassLoader moduleClassLoader)\n            throws CheckstyleException {\n        final ModuleFactory factory = new PackageObjectFactory(\n                Checker.class.getPackage().getName(), moduleClassLoader);\n\n        return (RootModule) factory.createModule(name);\n    }\n\n    /**\n     * Returns {@code TreeWalker} module configuration.\n     *\n     * @param config The configuration object.\n     * @return The {@code TreeWalker} module configuration.\n     */\n    private static Configuration getTreeWalkerConfig(Configuration config) {\n        Configuration result = null;\n\n        final Configuration[] children = config.getChildren();\n        for (Configuration child : children) {\n            if (\"TreeWalker\".equals(child.getName())) {\n                result = child;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * This method creates in AuditListener an open stream for validation data, it must be\n     * closed by {@link RootModule} (default implementation is {@link Checker}) by calling\n     * {@link AuditListener#auditFinished(AuditEvent)}.\n     *\n     * @param format format of the audit listener\n     * @param outputLocation the location of output\n     * @return a fresh new {@code AuditListener}\n     * @exception IOException when provided output location is not found\n     */\n    private static AuditListener createListener(OutputFormat format, Path outputLocation)\n            throws IOException {\n        final OutputStream out = getOutputStream(outputLocation);\n        final AutomaticBean.OutputStreamOptions closeOutputStreamOption =\n                getOutputStreamOptions(outputLocation);\n        return format.createListener(out, closeOutputStreamOption);\n    }\n\n    /**\n     * Create output stream or return System.out\n     *\n     * @param outputPath output location\n     * @return output stream\n     * @throws IOException might happen\n     * @noinspection UseOfSystemOutOrSystemErr\n     */\n    @SuppressWarnings(\"resource\")\n    private static OutputStream getOutputStream(Path outputPath) throws IOException {\n        final OutputStream result;\n        if (outputPath == null) {\n            result = System.out;\n        }\n        else {\n            result = Files.newOutputStream(outputPath);\n        }\n        return result;\n    }\n\n    /**\n     * Create {@link AutomaticBean.OutputStreamOptions} for the given location.\n     *\n     * @param outputPath output location\n     * @return output stream options\n     */\n    private static AutomaticBean.OutputStreamOptions getOutputStreamOptions(Path outputPath) {\n        final AutomaticBean.OutputStreamOptions result;\n        if (outputPath == null) {\n            result = AutomaticBean.OutputStreamOptions.NONE;\n        }\n        else {\n            result = AutomaticBean.OutputStreamOptions.CLOSE;\n        }\n        return result;\n    }\n\n    /**\n     * Enumeration over the possible output formats.\n     *\n     * @noinspection PackageVisibleInnerClass\n     */\n    // Package-visible for tests.\n    enum OutputFormat {\n        /** XML output format. */\n        XML,\n        /** SARIF output format. */\n        SARIF,\n        /** Plain output format. */\n        PLAIN;\n\n        /**\n         * Returns a new AuditListener for this OutputFormat.\n         *\n         * @param out the output stream\n         * @param options the output stream options\n         * @return a new AuditListener for this OutputFormat\n         * @throws IOException if there is any IO exception during logger initialization\n         */\n        public AuditListener createListener(\n            OutputStream out,\n            AutomaticBean.OutputStreamOptions options) throws IOException {\n            final AuditListener result;\n            if (this == XML) {\n                result = new XMLLogger(out, options);\n            }\n            else if (this == SARIF) {\n                result = new SarifLogger(out, options);\n            }\n            else {\n                result = new DefaultLogger(out, options);\n            }\n            return result;\n        }\n\n        /**\n         * Returns the name in lowercase.\n         *\n         * @return the enum name in lowercase\n         */\n        @Override\n        public String toString() {\n            return name().toLowerCase(Locale.ROOT);\n        }\n    }\n\n    /** Log Filter used in debug mode. */\n    private static final class OnlyCheckstyleLoggersFilter implements Filter {\n        /** Name of the package used to filter on. */\n        private final String packageName = Main.class.getPackage().getName();\n\n        /**\n         * Returns whether the specified logRecord should be logged.\n         *\n         * @param logRecord the logRecord to log\n         * @return true if the logger name is in the package of this class or a subpackage\n         */\n        @Override\n        public boolean isLoggable(LogRecord logRecord) {\n            return logRecord.getLoggerName().startsWith(packageName);\n        }\n    }\n\n    /**\n     * Command line options.\n     *\n     * @noinspection unused, FieldMayBeFinal, CanBeFinal,\n     *              MismatchedQueryAndUpdateOfCollection, LocalCanBeFinal\n     */\n    @Command(name = \"checkstyle\", description = \"Checkstyle verifies that the specified \"\n            + \"source code files adhere to the specified rules. By default violations are \"\n            + \"reported to standard out in plain format. Checkstyle requires a configuration \"\n            + \"XML file that configures the checks to apply.\",\n            mixinStandardHelpOptions = true)\n    private static class CliOptions {\n\n        /** Width of CLI help option. */\n        private static final int HELP_WIDTH = 100;\n\n        /** The default number of threads to use for checker and the tree walker. */\n        private static final int DEFAULT_THREAD_COUNT = 1;\n\n        /** Name for the moduleConfig attribute 'tabWidth'. */\n        private static final String ATTRIB_TAB_WIDTH_NAME = \"tabWidth\";\n\n        /** Default output format. */\n        private static final OutputFormat DEFAULT_OUTPUT_FORMAT = OutputFormat.PLAIN;\n\n        /** Option name for output format. */\n        private static final String OUTPUT_FORMAT_OPTION = \"-f\";\n\n        /**\n         * The checker threads number.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         * This option has been skipped for CLI options intentionally.\n         *\n         * @noinspection CanBeFinal\n         */\n        private static final int CHECKER_THREADS_NUMBER = DEFAULT_THREAD_COUNT;\n\n        /**\n         * The tree walker threads number.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         * This option has been skipped for CLI options intentionally.\n         *\n         * @noinspection CanBeFinal\n         */\n        private static final int TREE_WALKER_THREADS_NUMBER = DEFAULT_THREAD_COUNT;\n\n        /** List of file to validate. */\n        @Parameters(arity = \"1..*\", description = \"One or more source files to verify\")\n        private List<File> files;\n\n        /** Config file location. */\n        @Option(names = \"-c\", description = \"Specifies the location of the file that defines\"\n                + \" the configuration modules. The location can either be a filesystem location\"\n                + \", or a name passed to the ClassLoader.getResource() method.\")\n        private String configurationFile;\n\n        /** Output file location. */\n        @Option(names = \"-o\", description = \"Sets the output file. Defaults to stdout.\")\n        private Path outputPath;\n\n        /** Properties file location. */\n        @Option(names = \"-p\", description = \"Sets the property files to load.\")\n        private File propertiesFile;\n\n        /** LineNo and columnNo for the suppression. */\n        @Option(names = \"-s\",\n                description = \"Prints xpath suppressions at the file's line and column position. \"\n                        + \"Argument is the line and column number (separated by a : ) in the file \"\n                        + \"that the suppression should be generated for. The option cannot be used \"\n                        + \"with other options and requires exactly one file to run on to be \"\n                        + \"specified. ATTENTION: generated result will have few queries, joined \"\n                        + \"by pipe(|). Together they will match all AST nodes on \"\n                        + \"specified line and column. You need to choose only one and recheck \"\n                        + \"that it works. Usage of all of them is also ok, but might result in \"\n                        + \"undesirable matching and suppress other issues.\")\n        private String suppressionLineColumnNumber;\n\n        /**\n         * Tab character length.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = {\"-w\", \"--tabWidth\"},\n                description = \"Sets the length of the tab character. \"\n                + \"Used only with -s option. Default value is ${DEFAULT-VALUE}.\")\n        private int tabWidth = CommonUtil.DEFAULT_TAB_WIDTH;\n\n        /** Switch whether to generate suppressions file or not. */\n        @Option(names = {\"-g\", \"--generate-xpath-suppression\"},\n                description = \"Generates to output a suppression xml to use to suppress all \"\n                        + \"violations from user's config. Instead of printing every violation, \"\n                        + \"all violations will be catched and single suppressions xml file will \"\n                        + \"be printed out. Used only with -c option. Output \"\n                        + \"location can be specified with -o option.\")\n        private boolean generateXpathSuppressionsFile;\n\n        /**\n         * Output format.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = \"-f\",\n                description = \"Specifies the output format. Valid values: \"\n                + \"${COMPLETION-CANDIDATES} for XMLLogger, SarifLogger, \"\n                + \"and DefaultLogger respectively. Defaults to ${DEFAULT-VALUE}.\")\n        private OutputFormat format = DEFAULT_OUTPUT_FORMAT;\n\n        /** Option that controls whether to print the AST of the file. */\n        @Option(names = {\"-t\", \"--tree\"},\n                description = \"Prints Abstract Syntax Tree(AST) of the checked file. The option \"\n                        + \"cannot be used other options and requires exactly one file to run on \"\n                        + \"to be specified.\")\n        private boolean printAst;\n\n        /** Option that controls whether to print the AST of the file including comments. */\n        @Option(names = {\"-T\", \"--treeWithComments\"},\n                description = \"Prints Abstract Syntax Tree(AST) with comment nodes \"\n                        + \"of the checked file. The option cannot be used with other options \"\n                        + \"and requires exactly one file to run on to be specified.\")\n        private boolean printAstWithComments;\n\n        /** Option that controls whether to print the parse tree of the javadoc comment. */\n        @Option(names = {\"-j\", \"--javadocTree\"},\n                description = \"Prints Parse Tree of the Javadoc comment. \"\n                        + \"The file have to contain only Javadoc comment content without \"\n                        + \"including '/**' and '*/' at the beginning and at the end respectively. \"\n                        + \"The option cannot be used other options and requires exactly one file \"\n                        + \"to run on to be specified.\")\n        private boolean printJavadocTree;\n\n        /** Option that controls whether to print the full AST of the file. */\n        @Option(names = {\"-J\", \"--treeWithJavadoc\"},\n                description = \"Prints Abstract Syntax Tree(AST) with Javadoc nodes \"\n                        + \"and comment nodes of the checked file. Attention that line number and \"\n                        + \"columns will not be the same as it is a file due to the fact that each \"\n                        + \"javadoc comment is parsed separately from java file. The option cannot \"\n                        + \"be used with other options and requires exactly one file to run on to \"\n                        + \"be specified.\")\n        private boolean printTreeWithJavadoc;\n\n        /** Option that controls whether to print debug info. */\n        @Option(names = {\"-d\", \"--debug\"},\n                description = \"Prints all debug logging of CheckStyle utility.\")\n        private boolean debug;\n\n        /**\n         * Option that allows users to specify a list of paths to exclude.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = {\"-e\", \"--exclude\"},\n                description = \"Directory/file to exclude from CheckStyle. The path can be the \"\n                        + \"full, absolute path, or relative to the current path. Multiple \"\n                        + \"excludes are allowed.\")\n        private List<File> exclude = new ArrayList<>();\n\n        /**\n         * Option that allows users to specify a regex of paths to exclude.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = {\"-x\", \"--exclude-regexp\"},\n                description = \"Directory/file pattern to exclude from CheckStyle. Multiple \"\n                        + \"excludes are allowed.\")\n        private List<Pattern> excludeRegex = new ArrayList<>();\n\n        /** Switch whether to execute ignored modules or not. */\n        @Option(names = {\"-E\", \"--executeIgnoredModules\"},\n                description = \"Allows ignored modules to be run.\")\n        private boolean executeIgnoredModules;\n\n        /** Show AST branches that match xpath. */\n        @Option(names = {\"-b\", \"--branch-matching-xpath\"},\n            description = \"Shows Abstract Syntax Tree(AST) branches that match given XPath query.\")\n        private String xpath;\n\n        /**\n         * Gets the list of exclusions provided through the command line arguments.\n         *\n         * @return List of exclusion patterns.\n         */\n        private List<Pattern> getExclusions() {\n            final List<Pattern> result = exclude.stream()\n                    .map(File::getAbsolutePath)\n                    .map(Pattern::quote)\n                    .map(pattern -> Pattern.compile(\"^\" + pattern + \"$\"))\n                    .collect(Collectors.toCollection(ArrayList::new));\n            result.addAll(excludeRegex);\n            return result;\n        }\n\n        /**\n         * Validates the user-specified command line options.\n         *\n         * @param parseResult used to verify if the format option was specified on the command line\n         * @param filesToProcess the list of files whose style to check\n         * @return list of violations\n         */\n        // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation\n        private List<String> validateCli(ParseResult parseResult, List<File> filesToProcess) {\n            final List<String> result = new ArrayList<>();\n            final boolean hasConfigurationFile = configurationFile != null;\n            final boolean hasSuppressionLineColumnNumber = suppressionLineColumnNumber != null;\n\n            if (filesToProcess.isEmpty()) {\n                result.add(\"Files to process must be specified, found 0.\");\n            }\n            // ensure there is no conflicting options\n            else if (printAst || printAstWithComments || printJavadocTree || printTreeWithJavadoc\n                || xpath != null) {\n                if (suppressionLineColumnNumber != null || configurationFile != null\n                        || propertiesFile != null || outputPath != null\n                        || parseResult.hasMatchedOption(OUTPUT_FORMAT_OPTION)) {\n                    result.add(\"Option '-t' cannot be used with other options.\");\n                }\n                else if (filesToProcess.size() > 1) {\n                    result.add(\"Printing AST is allowed for only one file.\");\n                }\n            }\n            else if (hasSuppressionLineColumnNumber) {\n                if (configurationFile != null || propertiesFile != null\n                        || outputPath != null\n                        || parseResult.hasMatchedOption(OUTPUT_FORMAT_OPTION)) {\n                    result.add(\"Option '-s' cannot be used with other options.\");\n                }\n                else if (filesToProcess.size() > 1) {\n                    result.add(\"Printing xpath suppressions is allowed for only one file.\");\n                }\n            }\n            else if (hasConfigurationFile) {\n                try {\n                    // test location only\n                    CommonUtil.getUriByFilename(configurationFile);\n                }\n                catch (CheckstyleException ignored) {\n                    final String msg = \"Could not find config XML file '%s'.\";\n                    result.add(String.format(Locale.ROOT, msg, configurationFile));\n                }\n                result.addAll(validateOptionalCliParametersIfConfigDefined());\n            }\n            else {\n                result.add(\"Must specify a config XML file.\");\n            }\n\n            return result;\n        }\n\n        /**\n         * Validates optional command line parameters that might be used with config file.\n         *\n         * @return list of violations\n         */\n        private List<String> validateOptionalCliParametersIfConfigDefined() {\n            final List<String> result = new ArrayList<>();\n            if (propertiesFile != null && !propertiesFile.exists()) {\n                result.add(String.format(Locale.ROOT,\n                        \"Could not find file '%s'.\", propertiesFile));\n            }\n            return result;\n        }\n    }\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/Main.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Filter;\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport com.puppycrawl.tools.checkstyle.api.AuditEvent;\nimport com.puppycrawl.tools.checkstyle.api.AuditListener;\nimport com.puppycrawl.tools.checkstyle.api.AutomaticBean;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.RootModule;\nimport com.puppycrawl.tools.checkstyle.api.Violation;\nimport com.puppycrawl.tools.checkstyle.utils.ChainedPropertyUtil;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.XpathUtil;\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Option;\nimport picocli.CommandLine.ParameterException;\nimport picocli.CommandLine.Parameters;\nimport picocli.CommandLine.ParseResult;\n\n/**\n * Wrapper command line program for the Checker.\n */\npublic final class Main {\n\n    /**\n     * A key pointing to the error counter\n     * message in the \"messages.properties\" file.\n     */\n    public static final String ERROR_COUNTER = \"Main.errorCounter\";\n    /**\n     * A key pointing to the load properties exception\n     * message in the \"messages.properties\" file.\n     */\n    public static final String LOAD_PROPERTIES_EXCEPTION = \"Main.loadProperties\";\n    /**\n     * A key pointing to the create listener exception\n     * message in the \"messages.properties\" file.\n     */\n    public static final String CREATE_LISTENER_EXCEPTION = \"Main.createListener\";\n\n    /** Logger for Main. */\n    private static final Log LOG = LogFactory.getLog(Main.class);\n\n    /** Exit code returned when user specified invalid command line arguments. */\n    private static final int EXIT_WITH_INVALID_USER_INPUT_CODE = -1;\n\n    /** Exit code returned when execution finishes with {@link CheckstyleException}. */\n    private static final int EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE = -2;\n\n    /**\n     * Client code should not create instances of this class, but use\n     * {@link #main(String[])} method instead.\n     */\n    private Main() {\n    }\n\n    /**\n     * Loops over the files specified checking them for errors. The exit code\n     * is the number of errors found in all the files.\n     *\n     * @param args the command line arguments.\n     * @throws IOException if there is a problem with files access\n     * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace\n     **/\n    public static void main(String... args) throws IOException {\n\n        final CliOptions cliOptions = new CliOptions();\n        final CommandLine commandLine = new CommandLine(cliOptions);\n        commandLine.setUsageHelpWidth(CliOptions.HELP_WIDTH);\n        commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n\n        // provide proper exit code based on results.\n        int exitStatus = 0;\n        int errorCounter = 0;\n        try {\n            final ParseResult parseResult = commandLine.parseArgs(args);\n            if (parseResult.isVersionHelpRequested()) {\n                System.out.println(getVersionString());\n            }\n            else if (parseResult.isUsageHelpRequested()) {\n                commandLine.usage(System.out);\n            }\n            else {\n                exitStatus = execute(parseResult, cliOptions);\n                errorCounter = exitStatus;\n            }\n        }\n        catch (ParameterException ex) {\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n            System.err.println(ex.getMessage());\n            System.err.println(\"Usage: checkstyle [OPTIONS]... FILES...\");\n            System.err.println(\"Try 'checkstyle --help' for more information.\");\n        }\n        catch (CheckstyleException ex) {\n            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n            errorCounter = 1;\n            ex.printStackTrace();\n        }\n        finally {\n            // return exit code base on validation of Checker\n            if (errorCounter > 0) {\n                final Violation errorCounterViolation = new Violation(1,\n                        Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n                        new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n                // print error count statistic to error output stream,\n                // output stream might be used by validation report content\n                System.err.println(errorCounterViolation.getViolation());\n            }\n        }\n        ExitHelper.exit(exitStatus);\n    }\n\n    /**\n     * Returns the version string printed when the user requests version help (--version or -V).\n     *\n     * @return a version string based on the package implementation version\n     */\n    private static String getVersionString() {\n        return \"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion();\n    }\n\n    /**\n     * Validates the user input and returns {@value #EXIT_WITH_INVALID_USER_INPUT_CODE} if\n     * invalid, otherwise executes CheckStyle and returns the number of violations.\n     *\n     * @param parseResult generic access to options and parameters found on the command line\n     * @param options encapsulates options and parameters specified on the command line\n     * @return number of violations\n     * @throws IOException if a file could not be read.\n     * @throws CheckstyleException if something happens processing the files.\n     * @noinspection UseOfSystemOutOrSystemErr\n     */\n    private static int execute(ParseResult parseResult, CliOptions options)\n            throws IOException, CheckstyleException {\n\n        final int exitStatus;\n\n        // return error if something is wrong in arguments\n        final List<File> filesToProcess = getFilesToProcess(options);\n        final List<String> messages = options.validateCli(parseResult, filesToProcess);\n        final boolean hasMessages = !messages.isEmpty();\n        if (hasMessages) {\n            messages.forEach(System.out::println);\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n        }\n        else {\n            exitStatus = runCli(options, filesToProcess);\n        }\n        return exitStatus;\n    }\n\n    /**\n     * Determines the files to process.\n     *\n     * @param options the user-specified options\n     * @return list of files to process\n     */\n    private static List<File> getFilesToProcess(CliOptions options) {\n        final List<Pattern> patternsToExclude = options.getExclusions();\n\n        final List<File> result = new LinkedList<>();\n        for (File file : options.files) {\n            result.addAll(listFiles(file, patternsToExclude));\n        }\n        return result;\n    }\n\n    /**\n     * Traverses a specified node looking for files to check. Found files are added to\n     * a specified list. Subdirectories are also traversed.\n     *\n     * @param node\n     *        the node to process\n     * @param patternsToExclude The list of patterns to exclude from searching or being added as\n     *        files.\n     * @return found files\n     */\n    private static List<File> listFiles(File node, List<Pattern> patternsToExclude) {\n        // could be replaced with org.apache.commons.io.FileUtils.list() method\n        // if only we add commons-io library\n        final List<File> result = new LinkedList<>();\n\n        if (node.canRead() && !isPathExcluded(node.getAbsolutePath(), patternsToExclude)) {\n            if (node.isDirectory()) {\n                final File[] files = node.listFiles();\n                // listFiles() can return null, so we need to check it\n                if (files != null) {\n                    for (File element : files) {\n                        result.addAll(listFiles(element, patternsToExclude));\n                    }\n                }\n            }\n            else if (node.isFile()) {\n                result.add(node);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Checks if a directory/file {@code path} should be excluded based on if it matches one of the\n     * patterns supplied.\n     *\n     * @param path The path of the directory/file to check\n     * @param patternsToExclude The list of patterns to exclude from searching or being added as\n     *        files.\n     * @return True if the directory/file matches one of the patterns.\n     */\n    private static boolean isPathExcluded(String path, List<Pattern> patternsToExclude) {\n        boolean result = false;\n\n        for (Pattern pattern : patternsToExclude) {\n            if (pattern.matcher(path).find()) {\n                result = true;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Do execution of CheckStyle based on Command line options.\n     *\n     * @param options user-specified options\n     * @param filesToProcess the list of files whose style to check\n     * @return number of violations\n     * @throws IOException if a file could not be read.\n     * @throws CheckstyleException if something happens processing the files.\n     * @noinspection UseOfSystemOutOrSystemErr\n     */\n    private static int runCli(CliOptions options, List<File> filesToProcess)\n            throws IOException, CheckstyleException {\n        int result = 0;\n        final boolean hasSuppressionLineColumnNumber = options.suppressionLineColumnNumber != null;\n\n        // create config helper object\n        if (options.printAst) {\n            // print AST\n            final File file = filesToProcess.get(0);\n            final String stringAst = AstTreeStringPrinter.printFileAst(file,\n                    JavaParser.Options.WITHOUT_COMMENTS);\n            System.out.print(stringAst);\n        }\n        else if (Objects.nonNull(options.xpath)) {\n            final String branch = XpathUtil.printXpathBranch(options.xpath, filesToProcess.get(0));\n            System.out.print(branch);\n        }\n        else if (options.printAstWithComments) {\n            final File file = filesToProcess.get(0);\n            final String stringAst = AstTreeStringPrinter.printFileAst(file,\n                    JavaParser.Options.WITH_COMMENTS);\n            System.out.print(stringAst);\n        }\n        else if (options.printJavadocTree) {\n            final File file = filesToProcess.get(0);\n            final String stringAst = DetailNodeTreeStringPrinter.printFileAst(file);\n            System.out.print(stringAst);\n        }\n        else if (options.printTreeWithJavadoc) {\n            final File file = filesToProcess.get(0);\n            final String stringAst = AstTreeStringPrinter.printJavaAndJavadocTree(file);\n            System.out.print(stringAst);\n        }\n        else if (hasSuppressionLineColumnNumber) {\n            final File file = filesToProcess.get(0);\n            final String stringSuppressions =\n                    SuppressionsStringPrinter.printSuppressions(file,\n                            options.suppressionLineColumnNumber, options.tabWidth);\n            System.out.print(stringSuppressions);\n        }\n        else {\n            if (options.debug) {\n                final Logger parentLogger = Logger.getLogger(Main.class.getName()).getParent();\n                final ConsoleHandler handler = new ConsoleHandler();\n                handler.setLevel(Level.FINEST);\n                handler.setFilter(new OnlyCheckstyleLoggersFilter());\n                parentLogger.addHandler(handler);\n                parentLogger.setLevel(Level.FINEST);\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Checkstyle debug logging enabled\");\n                LOG.debug(\"Running Checkstyle with version: \"\n                        + Main.class.getPackage().getImplementationVersion());\n            }\n\n            // run Checker\n            result = runCheckstyle(options, filesToProcess);\n        }\n\n        return result;\n    }\n\n    /**\n     * Executes required Checkstyle actions based on passed parameters.\n     *\n     * @param options user-specified options\n     * @param filesToProcess the list of files whose style to check\n     * @return number of violations of ERROR level\n     * @throws IOException\n     *         when output file could not be found\n     * @throws CheckstyleException\n     *         when properties file could not be loaded\n     */\n    private static int runCheckstyle(CliOptions options, List<File> filesToProcess)\n            throws CheckstyleException, IOException {\n        // setup the properties\n        final Properties props;\n\n        if (options.propertiesFile == null) {\n            props = System.getProperties();\n        }\n        else {\n            props = loadProperties(options.propertiesFile);\n        }\n\n        // create a configuration\n        final ThreadModeSettings multiThreadModeSettings =\n                new ThreadModeSettings(CliOptions.CHECKER_THREADS_NUMBER,\n                        CliOptions.TREE_WALKER_THREADS_NUMBER);\n\n        final ConfigurationLoader.IgnoredModulesOptions ignoredModulesOptions;\n        if (options.executeIgnoredModules) {\n            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.EXECUTE;\n        }\n        else {\n            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.OMIT;\n        }\n\n        final Configuration config = ConfigurationLoader.loadConfiguration(\n                options.configurationFile, new PropertiesExpander(props),\n                ignoredModulesOptions, multiThreadModeSettings);\n\n        // create RootModule object and run it\n        final int errorCounter;\n        final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n        final RootModule rootModule = getRootModule(config.getName(), moduleClassLoader);\n\n        try {\n            final AuditListener listener;\n            if (options.generateXpathSuppressionsFile) {\n                // create filter to print generated xpath suppressions file\n                final Configuration treeWalkerConfig = getTreeWalkerConfig(config);\n                if (treeWalkerConfig != null) {\n                    final DefaultConfiguration moduleConfig =\n                            new DefaultConfiguration(\n                                    XpathFileGeneratorAstFilter.class.getName());\n                    moduleConfig.addProperty(CliOptions.ATTRIB_TAB_WIDTH_NAME,\n                            String.valueOf(options.tabWidth));\n                    ((DefaultConfiguration) treeWalkerConfig).addChild(moduleConfig);\n                }\n\n                listener = new XpathFileGeneratorAuditListener(getOutputStream(options.outputPath),\n                        getOutputStreamOptions(options.outputPath));\n            }\n            else {\n                listener = createListener(options.format, options.outputPath);\n            }\n\n            rootModule.setModuleClassLoader(moduleClassLoader);\n            rootModule.configure(config);\n            rootModule.addListener(listener);\n\n            // run RootModule\n            errorCounter = rootModule.process(filesToProcess);\n        }\n        finally {\n            rootModule.destroy();\n        }\n\n        return errorCounter;\n    }\n\n    /**\n     * Loads properties from a File.\n     *\n     * @param file\n     *        the properties file\n     * @return the properties in file\n     * @throws CheckstyleException\n     *         when could not load properties file\n     */\n    private static Properties loadProperties(File file)\n            throws CheckstyleException {\n        final Properties properties = new Properties();\n\n        try (InputStream stream = Files.newInputStream(file.toPath())) {\n            properties.load(stream);\n        }\n        catch (final IOException ex) {\n            final Violation loadPropertiesExceptionMessage = new Violation(1,\n                    Definitions.CHECKSTYLE_BUNDLE, LOAD_PROPERTIES_EXCEPTION,\n                    new String[] {file.getAbsolutePath()}, null, Main.class, null);\n            throw new CheckstyleException(loadPropertiesExceptionMessage.getViolation(), ex);\n        }\n\n        return ChainedPropertyUtil.getResolvedProperties(properties);\n    }\n\n    /**\n     * Creates a new instance of the root module that will control and run\n     * Checkstyle.\n     *\n     * @param name The name of the module. This will either be a short name that\n     *        will have to be found or the complete package name.\n     * @param moduleClassLoader Class loader used to load the root module.\n     * @return The new instance of the root module.\n     * @throws CheckstyleException if no module can be instantiated from name\n     */\n    private static RootModule getRootModule(String name, ClassLoader moduleClassLoader)\n            throws CheckstyleException {\n        final ModuleFactory factory = new PackageObjectFactory(\n                Checker.class.getPackage().getName(), moduleClassLoader);\n\n        return (RootModule) factory.createModule(name);\n    }\n\n    /**\n     * Returns {@code TreeWalker} module configuration.\n     *\n     * @param config The configuration object.\n     * @return The {@code TreeWalker} module configuration.\n     */\n    private static Configuration getTreeWalkerConfig(Configuration config) {\n        Configuration result = null;\n\n        final Configuration[] children = config.getChildren();\n        for (Configuration child : children) {\n            if (\"TreeWalker\".equals(child.getName())) {\n                result = child;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * This method creates in AuditListener an open stream for validation data, it must be\n     * closed by {@link RootModule} (default implementation is {@link Checker}) by calling\n     * {@link AuditListener#auditFinished(AuditEvent)}.\n     *\n     * @param format format of the audit listener\n     * @param outputLocation the location of output\n     * @return a fresh new {@code AuditListener}\n     * @exception IOException when provided output location is not found\n     */\n    private static AuditListener createListener(OutputFormat format, Path outputLocation)\n            throws IOException {\n        final OutputStream out = getOutputStream(outputLocation);\n        final AutomaticBean.OutputStreamOptions closeOutputStreamOption =\n                getOutputStreamOptions(outputLocation);\n        return format.createListener(out, closeOutputStreamOption);\n    }\n\n    /**\n     * Create output stream or return System.out\n     *\n     * @param outputPath output location\n     * @return output stream\n     * @throws IOException might happen\n     * @noinspection UseOfSystemOutOrSystemErr\n     */\n    @SuppressWarnings(\"resource\")\n    private static OutputStream getOutputStream(Path outputPath) throws IOException {\n        final OutputStream result;\n        if (outputPath == null) {\n            result = System.out;\n        }\n        else {\n            result = Files.newOutputStream(outputPath);\n        }\n        return result;\n    }\n\n    /**\n     * Create {@link AutomaticBean.OutputStreamOptions} for the given location.\n     *\n     * @param outputPath output location\n     * @return output stream options\n     */\n    private static AutomaticBean.OutputStreamOptions getOutputStreamOptions(Path outputPath) {\n        final AutomaticBean.OutputStreamOptions result;\n        if (outputPath == null) {\n            result = AutomaticBean.OutputStreamOptions.NONE;\n        }\n        else {\n            result = AutomaticBean.OutputStreamOptions.CLOSE;\n        }\n        return result;\n    }\n\n    /**\n     * Enumeration over the possible output formats.\n     *\n     * @noinspection PackageVisibleInnerClass\n     */\n    // Package-visible for tests.\n    enum OutputFormat {\n        /** XML output format. */\n        XML,\n        /** SARIF output format. */\n        SARIF,\n        /** Plain output format. */\n        PLAIN;\n\n        /**\n         * Returns a new AuditListener for this OutputFormat.\n         *\n         * @param out the output stream\n         * @param options the output stream options\n         * @return a new AuditListener for this OutputFormat\n         * @throws IOException if there is any IO exception during logger initialization\n         */\n        public AuditListener createListener(\n            OutputStream out,\n            AutomaticBean.OutputStreamOptions options) throws IOException {\n            final AuditListener result;\n            if (this == XML) {\n                result = new XMLLogger(out, options);\n            }\n            else if (this == SARIF) {\n                result = new SarifLogger(out, options);\n            }\n            else {\n                result = new DefaultLogger(out, options);\n            }\n            return result;\n        }\n\n        /**\n         * Returns the name in lowercase.\n         *\n         * @return the enum name in lowercase\n         */\n        @Override\n        public String toString() {\n            return name().toLowerCase(Locale.ROOT);\n        }\n    }\n\n    /** Log Filter used in debug mode. */\n    private static final class OnlyCheckstyleLoggersFilter implements Filter {\n        /** Name of the package used to filter on. */\n        private final String packageName = Main.class.getPackage().getName();\n\n        /**\n         * Returns whether the specified logRecord should be logged.\n         *\n         * @param logRecord the logRecord to log\n         * @return true if the logger name is in the package of this class or a subpackage\n         */\n        @Override\n        public boolean isLoggable(LogRecord logRecord) {\n            return logRecord.getLoggerName().startsWith(packageName);\n        }\n    }\n\n    /**\n     * Command line options.\n     *\n     * @noinspection unused, FieldMayBeFinal, CanBeFinal,\n     *              MismatchedQueryAndUpdateOfCollection, LocalCanBeFinal\n     */\n    @Command(name = \"checkstyle\", description = \"Checkstyle verifies that the specified \"\n            + \"source code files adhere to the specified rules. By default violations are \"\n            + \"reported to standard out in plain format. Checkstyle requires a configuration \"\n            + \"XML file that configures the checks to apply.\",\n            mixinStandardHelpOptions = true)\n    private static class CliOptions {\n\n        /** Width of CLI help option. */\n        private static final int HELP_WIDTH = 100;\n\n        /** The default number of threads to use for checker and the tree walker. */\n        private static final int DEFAULT_THREAD_COUNT = 1;\n\n        /** Name for the moduleConfig attribute 'tabWidth'. */\n        private static final String ATTRIB_TAB_WIDTH_NAME = \"tabWidth\";\n\n        /** Default output format. */\n        private static final OutputFormat DEFAULT_OUTPUT_FORMAT = OutputFormat.PLAIN;\n\n        /** Option name for output format. */\n        private static final String OUTPUT_FORMAT_OPTION = \"-f\";\n\n        /**\n         * The checker threads number.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         * This option has been skipped for CLI options intentionally.\n         *\n         * @noinspection CanBeFinal\n         */\n        private static final int CHECKER_THREADS_NUMBER = DEFAULT_THREAD_COUNT;\n\n        /**\n         * The tree walker threads number.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         * This option has been skipped for CLI options intentionally.\n         *\n         * @noinspection CanBeFinal\n         */\n        private static final int TREE_WALKER_THREADS_NUMBER = DEFAULT_THREAD_COUNT;\n\n        /** List of file to validate. */\n        @Parameters(arity = \"1..*\", description = \"One or more source files to verify\")\n        private List<File> files;\n\n        /** Config file location. */\n        @Option(names = \"-c\", description = \"Specifies the location of the file that defines\"\n                + \" the configuration modules. The location can either be a filesystem location\"\n                + \", or a name passed to the ClassLoader.getResource() method.\")\n        private String configurationFile;\n\n        /** Output file location. */\n        @Option(names = \"-o\", description = \"Sets the output file. Defaults to stdout.\")\n        private Path outputPath;\n\n        /** Properties file location. */\n        @Option(names = \"-p\", description = \"Sets the property files to load.\")\n        private File propertiesFile;\n\n        /** LineNo and columnNo for the suppression. */\n        @Option(names = \"-s\",\n                description = \"Prints xpath suppressions at the file's line and column position. \"\n                        + \"Argument is the line and column number (separated by a : ) in the file \"\n                        + \"that the suppression should be generated for. The option cannot be used \"\n                        + \"with other options and requires exactly one file to run on to be \"\n                        + \"specified. ATTENTION: generated result will have few queries, joined \"\n                        + \"by pipe(|). Together they will match all AST nodes on \"\n                        + \"specified line and column. You need to choose only one and recheck \"\n                        + \"that it works. Usage of all of them is also ok, but might result in \"\n                        + \"undesirable matching and suppress other issues.\")\n        private String suppressionLineColumnNumber;\n\n        /**\n         * Tab character length.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = {\"-w\", \"--tabWidth\"},\n                description = \"Sets the length of the tab character. \"\n                + \"Used only with -s option. Default value is ${DEFAULT-VALUE}.\")\n        private int tabWidth = CommonUtil.DEFAULT_TAB_WIDTH;\n\n        /** Switch whether to generate suppressions file or not. */\n        @Option(names = {\"-g\", \"--generate-xpath-suppression\"},\n                description = \"Generates to output a suppression xml to use to suppress all \"\n                        + \"violations from user's config. Instead of printing every violation, \"\n                        + \"all violations will be catched and single suppressions xml file will \"\n                        + \"be printed out. Used only with -c option. Output \"\n                        + \"location can be specified with -o option.\")\n        private boolean generateXpathSuppressionsFile;\n\n        /**\n         * Output format.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = \"-f\",\n                description = \"Specifies the output format. Valid values: \"\n                + \"${COMPLETION-CANDIDATES} for XMLLogger, SarifLogger, \"\n                + \"and DefaultLogger respectively. Defaults to ${DEFAULT-VALUE}.\")\n        private OutputFormat format = DEFAULT_OUTPUT_FORMAT;\n\n        /** Option that controls whether to print the AST of the file. */\n        @Option(names = {\"-t\", \"--tree\"},\n                description = \"Prints Abstract Syntax Tree(AST) of the checked file. The option \"\n                        + \"cannot be used other options and requires exactly one file to run on \"\n                        + \"to be specified.\")\n        private boolean printAst;\n\n        /** Option that controls whether to print the AST of the file including comments. */\n        @Option(names = {\"-T\", \"--treeWithComments\"},\n                description = \"Prints Abstract Syntax Tree(AST) with comment nodes \"\n                        + \"of the checked file. The option cannot be used with other options \"\n                        + \"and requires exactly one file to run on to be specified.\")\n        private boolean printAstWithComments;\n\n        /** Option that controls whether to print the parse tree of the javadoc comment. */\n        @Option(names = {\"-j\", \"--javadocTree\"},\n                description = \"Prints Parse Tree of the Javadoc comment. \"\n                        + \"The file have to contain only Javadoc comment content without \"\n                        + \"including '/**' and '*/' at the beginning and at the end respectively. \"\n                        + \"The option cannot be used other options and requires exactly one file \"\n                        + \"to run on to be specified.\")\n        private boolean printJavadocTree;\n\n        /** Option that controls whether to print the full AST of the file. */\n        @Option(names = {\"-J\", \"--treeWithJavadoc\"},\n                description = \"Prints Abstract Syntax Tree(AST) with Javadoc nodes \"\n                        + \"and comment nodes of the checked file. Attention that line number and \"\n                        + \"columns will not be the same as it is a file due to the fact that each \"\n                        + \"javadoc comment is parsed separately from java file. The option cannot \"\n                        + \"be used with other options and requires exactly one file to run on to \"\n                        + \"be specified.\")\n        private boolean printTreeWithJavadoc;\n\n        /** Option that controls whether to print debug info. */\n        @Option(names = {\"-d\", \"--debug\"},\n                description = \"Prints all debug logging of CheckStyle utility.\")\n        private boolean debug;\n\n        /**\n         * Option that allows users to specify a list of paths to exclude.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = {\"-e\", \"--exclude\"},\n                description = \"Directory/file to exclude from CheckStyle. The path can be the \"\n                        + \"full, absolute path, or relative to the current path. Multiple \"\n                        + \"excludes are allowed.\")\n        private List<File> exclude = new ArrayList<>();\n\n        /**\n         * Option that allows users to specify a regex of paths to exclude.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = {\"-x\", \"--exclude-regexp\"},\n                description = \"Directory/file pattern to exclude from CheckStyle. Multiple \"\n                        + \"excludes are allowed.\")\n        private List<Pattern> excludeRegex = new ArrayList<>();\n\n        /** Switch whether to execute ignored modules or not. */\n        @Option(names = {\"-E\", \"--executeIgnoredModules\"},\n                description = \"Allows ignored modules to be run.\")\n        private boolean executeIgnoredModules;\n\n        /** Show AST branches that match xpath. */\n        @Option(names = {\"-b\", \"--branch-matching-xpath\"},\n            description = \"Shows Abstract Syntax Tree(AST) branches that match given XPath query.\")\n        private String xpath;\n\n        /**\n         * Gets the list of exclusions provided through the command line arguments.\n         *\n         * @return List of exclusion patterns.\n         */\n        private List<Pattern> getExclusions() {\n            final List<Pattern> result = exclude.stream()\n                    .map(File::getAbsolutePath)\n                    .map(Pattern::quote)\n                    .map(pattern -> Pattern.compile(\"^\" + pattern + \"$\"))\n                    .collect(Collectors.toCollection(ArrayList::new));\n            result.addAll(excludeRegex);\n            return result;\n        }\n\n        /**\n         * Validates the user-specified command line options.\n         *\n         * @param parseResult used to verify if the format option was specified on the command line\n         * @param filesToProcess the list of files whose style to check\n         * @return list of violations\n         */\n        // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation\n        private List<String> validateCli(ParseResult parseResult, List<File> filesToProcess) {\n            final List<String> result = new ArrayList<>();\n            final boolean hasConfigurationFile = configurationFile != null;\n            final boolean hasSuppressionLineColumnNumber = suppressionLineColumnNumber != null;\n\n            if (filesToProcess.isEmpty()) {\n                result.add(\"Files to process must be specified, found 0.\");\n            }\n            // ensure there is no conflicting options\n            else if (printAst || printAstWithComments || printJavadocTree || printTreeWithJavadoc\n                || xpath != null) {\n                if (suppressionLineColumnNumber != null || configurationFile != null\n                        || propertiesFile != null || outputPath != null\n                        || parseResult.hasMatchedOption(OUTPUT_FORMAT_OPTION)) {\n                    result.add(\"Option '-t' cannot be used with other options.\");\n                }\n                else if (filesToProcess.size() > 1) {\n                    result.add(\"Printing AST is allowed for only one file.\");\n                }\n            }\n            else if (hasSuppressionLineColumnNumber) {\n                if (configurationFile != null || propertiesFile != null\n                        || outputPath != null\n                        || parseResult.hasMatchedOption(OUTPUT_FORMAT_OPTION)) {\n                    result.add(\"Option '-s' cannot be used with other options.\");\n                }\n                else if (filesToProcess.size() > 1) {\n                    result.add(\"Printing xpath suppressions is allowed for only one file.\");\n                }\n            }\n            else if (hasConfigurationFile) {\n                try {\n                    // test location only\n                    CommonUtil.getUriByFilename(configurationFile);\n                }\n                catch (CheckstyleException ignored) {\n                    final String msg = \"Could not find config XML file '%s'.\";\n                    result.add(String.format(Locale.ROOT, msg, configurationFile));\n                }\n                result.addAll(validateOptionalCliParametersIfConfigDefined());\n            }\n            else {\n                result.add(\"Must specify a config XML file.\");\n            }\n\n            return result;\n        }\n\n        /**\n         * Validates optional command line parameters that might be used with config file.\n         *\n         * @return list of violations\n         */\n        private List<String> validateOptionalCliParametersIfConfigDefined() {\n            final List<String> result = new ArrayList<>();\n            if (propertiesFile != null && !propertiesFile.exists()) {\n                result.add(String.format(Locale.ROOT,\n                        \"Could not find file '%s'.\", propertiesFile));\n            }\n            return result;\n        }\n    }\n\n    /**\n     * This class is needed for a workaround for the Jacoco limitations. A call to\n     * {@link System#exit(int)} will never be shown as covered.\n     * Since it is not possible to exclude a certain method from the Jacoco coverage,\n     * the entire class is excluded.\n     * Method 'exit' must contain IF condition, see details at\n     * https://github.com/checkstyle/checkstyle/pull/10951\n     */\n    private static class ExitHelper {\n\n        /**\n         * Terminates the program.\n         *\n         * @param code the return code\n         * @noinspection CallToSystemExit\n         */\n        private static void exit(int code) {\n            if (code != 0) {\n                System.exit(code);\n            }\n        }\n\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n         * Terminates the program.\n         *\n         * @param code the return code\n         * @noinspection CallToSystemExit\n         */\n        private static void exit(int code) {\n            if (code != 0) {\n                System.exit(code);\n            }\n        }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.Main#getVersionString\n methodBody: private static String getVersionString() {\nreturn \"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion();\n}", "methodSignature: com.puppycrawl.tools.checkstyle.Main#execute\n methodBody: private static int execute(ParseResult parseResult, CliOptions options)\n            throws IOException, CheckstyleException {\nfinal int exitStatus;\nfinal List<File> filesToProcess=getFilesToProcess(options);\nfinal List<String> messages=options.validateCli(parseResult,filesToProcess);\nfinal boolean hasMessages=!messages.isEmpty();\nif(hasMessages){messages.forEach(System.out::println);\nexitStatus=EXIT_WITH_INVALID_USER_INPUT_CODE;\n}{exitStatus=runCli(options,filesToProcess);\n}return exitStatus;\n}"], "sourceCodeAfterRefactoring": "/**\n     * Loops over the files specified checking them for errors. The exit code\n     * is the number of errors found in all the files.\n     *\n     * @param args the command line arguments.\n     * @throws IOException if there is a problem with files access\n     * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace\n     **/\n    public static void main(String... args) throws IOException {\n\n        final CliOptions cliOptions = new CliOptions();\n        final CommandLine commandLine = new CommandLine(cliOptions);\n        commandLine.setUsageHelpWidth(CliOptions.HELP_WIDTH);\n        commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n\n        // provide proper exit code based on results.\n        int exitStatus = 0;\n        int errorCounter = 0;\n        try {\n            final ParseResult parseResult = commandLine.parseArgs(args);\n            if (parseResult.isVersionHelpRequested()) {\n                System.out.println(getVersionString());\n            }\n            else if (parseResult.isUsageHelpRequested()) {\n                commandLine.usage(System.out);\n            }\n            else {\n                exitStatus = execute(parseResult, cliOptions);\n                errorCounter = exitStatus;\n            }\n        }\n        catch (ParameterException ex) {\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n            System.err.println(ex.getMessage());\n            System.err.println(\"Usage: checkstyle [OPTIONS]... FILES...\");\n            System.err.println(\"Try 'checkstyle --help' for more information.\");\n        }\n        catch (CheckstyleException ex) {\n            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n            errorCounter = 1;\n            ex.printStackTrace();\n        }\n        finally {\n            // return exit code base on validation of Checker\n            if (errorCounter > 0) {\n                final Violation errorCounterViolation = new Violation(1,\n                        Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n                        new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n                // print error count statistic to error output stream,\n                // output stream might be used by validation report content\n                System.err.println(errorCounterViolation.getViolation());\n            }\n        }\n        ExitHelper.exit(exitStatus);\n    }\n/**\n         * Terminates the program.\n         *\n         * @param code the return code\n         * @noinspection CallToSystemExit\n         */\n        private static void exit(int code) {\n            if (code != 0) {\n                System.exit(code);\n            }\n        }", "diffSourceCode": "    99:     /**\n   100:      * Loops over the files specified checking them for errors. The exit code\n   101:      * is the number of errors found in all the files.\n   102:      *\n   103:      * @param args the command line arguments.\n   104:      * @throws IOException if there is a problem with files access\n-  105:      * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace, CallToSystemExit\n+  105:      * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace\n   106:      **/\n   107:     public static void main(String... args) throws IOException {\n   108: \n   109:         final CliOptions cliOptions = new CliOptions();\n   110:         final CommandLine commandLine = new CommandLine(cliOptions);\n   111:         commandLine.setUsageHelpWidth(CliOptions.HELP_WIDTH);\n   112:         commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n   113: \n   114:         // provide proper exit code based on results.\n   115:         int exitStatus = 0;\n   116:         int errorCounter = 0;\n   117:         try {\n   118:             final ParseResult parseResult = commandLine.parseArgs(args);\n   119:             if (parseResult.isVersionHelpRequested()) {\n   120:                 System.out.println(getVersionString());\n   121:             }\n   122:             else if (parseResult.isUsageHelpRequested()) {\n   123:                 commandLine.usage(System.out);\n   124:             }\n   125:             else {\n   126:                 exitStatus = execute(parseResult, cliOptions);\n   127:                 errorCounter = exitStatus;\n   128:             }\n   129:         }\n   130:         catch (ParameterException ex) {\n   131:             exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n   132:             System.err.println(ex.getMessage());\n   133:             System.err.println(\"Usage: checkstyle [OPTIONS]... FILES...\");\n   134:             System.err.println(\"Try 'checkstyle --help' for more information.\");\n   135:         }\n   136:         catch (CheckstyleException ex) {\n   137:             exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n   138:             errorCounter = 1;\n   139:             ex.printStackTrace();\n   140:         }\n   141:         finally {\n   142:             // return exit code base on validation of Checker\n   143:             if (errorCounter > 0) {\n   144:                 final Violation errorCounterViolation = new Violation(1,\n   145:                         Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n   146:                         new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n   147:                 // print error count statistic to error output stream,\n   148:                 // output stream might be used by validation report content\n   149:                 System.err.println(errorCounterViolation.getViolation());\n   150:             }\n-  151:             if (exitStatus != 0) {\n-  152:                 System.exit(exitStatus);\n-  153:             }\n-  154:         }\n-  155:     }\n+  151:         }\n+  152:         ExitHelper.exit(exitStatus);\n+  153:     }\n+  154: \n+  155:     /**\n+  876:         /**\n+  877:          * Terminates the program.\n+  878:          *\n+  879:          * @param code the return code\n+  880:          * @noinspection CallToSystemExit\n+  881:          */\n+  882:         private static void exit(int code) {\n+  883:             if (code != 0) {\n+  884:                 System.exit(code);\n+  885:             }\n+  886:         }\n", "uniqueId": "664227cd5bf9c649847461d8055a7ee573f483e5_99_155_876_886_99_153", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 94}, "BRANCH": {"missed": 0, "covered": 8}, "LINE": {"missed": 0, "covered": 29}, "COMPLEXITY": {"missed": 0, "covered": 5}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nsrc/main/java/com/puppycrawl/tools/checkstyle/AstTreeStringPrinter.java\n##########################\n/**\n * Prints the Abstract Syntax Tree (AST) of a file without comments.\n *\n * @param file the file to print the AST for\n * @return the string representation of the AST\n */\npublic static String printFileAst(File file) {\n    // implementation here\n}\n##########################\n// Refactored method in Main.java using the moved class\n\n/**\n * Prints the Abstract Syntax Tree (AST) of the specified file.\n *\n * @param file the file to print the AST for\n * @return the string representation of the AST\n */\nprivate static String printAst(File file) {\n    return AstTreeStringPrinter.printFileAst(file);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Loops over the files specified checking them for errors. The exit code\n     * is the number of errors found in all the files.\n     *\n     * @param args the command line arguments.\n     * @throws IOException if there is a problem with files access\n     * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace, CallToSystemExit\n     **/\n    public static void main(String... args) throws IOException {\n\n        final CliOptions cliOptions = new CliOptions();\n        final CommandLine commandLine = new CommandLine(cliOptions);\n        commandLine.setUsageHelpWidth(CliOptions.HELP_WIDTH);\n        commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n\n        // provide proper exit code based on results.\n        int exitStatus = 0;\n        int errorCounter = 0;\n        try {\n            final ParseResult parseResult = commandLine.parseArgs(args);\n            if (parseResult.isVersionHelpRequested()) {\n                System.out.println(getVersionString());\n            }\n            else if (parseResult.isUsageHelpRequested()) {\n                commandLine.usage(System.out);\n            }\n            else {\n                exitStatus = execute(parseResult, cliOptions);\n                errorCounter = exitStatus;\n            }\n        }\n        catch (ParameterException ex) {\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n            System.err.println(ex.getMessage());\n            System.err.println(\"Usage: checkstyle [OPTIONS]... FILES...\");\n            System.err.println(\"Try 'checkstyle --help' for more information.\");\n        }\n        catch (CheckstyleException ex) {\n            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n            errorCounter = 1;\n            ex.printStackTrace();\n        }\n        finally {\n            // return exit code base on validation of Checker\n            if (errorCounter > 0) {\n                final Violation errorCounterViolation = new Violation(1,\n                        Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n                        new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n                // print error count statistic to error output stream,\n                // output stream might be used by validation report content\n                System.err.println(errorCounterViolation.getViolation());\n            }\n            if (exitStatus != 0) {\n                System.exit(exitStatus);\n            }\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.logging.ConsoleHandler;\nimport java.util.logging.Filter;\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport com.puppycrawl.tools.checkstyle.api.AuditEvent;\nimport com.puppycrawl.tools.checkstyle.api.AuditListener;\nimport com.puppycrawl.tools.checkstyle.api.AutomaticBean;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.RootModule;\nimport com.puppycrawl.tools.checkstyle.api.Violation;\nimport com.puppycrawl.tools.checkstyle.utils.ChainedPropertyUtil;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.XpathUtil;\nimport picocli.CommandLine;\nimport picocli.CommandLine.Command;\nimport picocli.CommandLine.Option;\nimport picocli.CommandLine.ParameterException;\nimport picocli.CommandLine.Parameters;\nimport picocli.CommandLine.ParseResult;\n\n/**\n * Wrapper command line program for the Checker.\n */\npublic final class Main {\n\n    /**\n     * A key pointing to the error counter\n     * message in the \"messages.properties\" file.\n     */\n    public static final String ERROR_COUNTER = \"Main.errorCounter\";\n    /**\n     * A key pointing to the load properties exception\n     * message in the \"messages.properties\" file.\n     */\n    public static final String LOAD_PROPERTIES_EXCEPTION = \"Main.loadProperties\";\n    /**\n     * A key pointing to the create listener exception\n     * message in the \"messages.properties\" file.\n     */\n    public static final String CREATE_LISTENER_EXCEPTION = \"Main.createListener\";\n\n    /** Logger for Main. */\n    private static final Log LOG = LogFactory.getLog(Main.class);\n\n    /** Exit code returned when user specified invalid command line arguments. */\n    private static final int EXIT_WITH_INVALID_USER_INPUT_CODE = -1;\n\n    /** Exit code returned when execution finishes with {@link CheckstyleException}. */\n    private static final int EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE = -2;\n\n    /**\n     * Client code should not create instances of this class, but use\n     * {@link #main(String[])} method instead.\n     */\n    private Main() {\n    }\n\n    /**\n     * Loops over the files specified checking them for errors. The exit code\n     * is the number of errors found in all the files.\n     *\n     * @param args the command line arguments.\n     * @throws IOException if there is a problem with files access\n     * @noinspection UseOfSystemOutOrSystemErr, CallToPrintStackTrace, CallToSystemExit\n     **/\n    public static void main(String... args) throws IOException {\n\n        final CliOptions cliOptions = new CliOptions();\n        final CommandLine commandLine = new CommandLine(cliOptions);\n        commandLine.setUsageHelpWidth(CliOptions.HELP_WIDTH);\n        commandLine.setCaseInsensitiveEnumValuesAllowed(true);\n\n        // provide proper exit code based on results.\n        int exitStatus = 0;\n        int errorCounter = 0;\n        try {\n            final ParseResult parseResult = commandLine.parseArgs(args);\n            if (parseResult.isVersionHelpRequested()) {\n                System.out.println(getVersionString());\n            }\n            else if (parseResult.isUsageHelpRequested()) {\n                commandLine.usage(System.out);\n            }\n            else {\n                exitStatus = execute(parseResult, cliOptions);\n                errorCounter = exitStatus;\n            }\n        }\n        catch (ParameterException ex) {\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n            System.err.println(ex.getMessage());\n            System.err.println(\"Usage: checkstyle [OPTIONS]... FILES...\");\n            System.err.println(\"Try 'checkstyle --help' for more information.\");\n        }\n        catch (CheckstyleException ex) {\n            exitStatus = EXIT_WITH_CHECKSTYLE_EXCEPTION_CODE;\n            errorCounter = 1;\n            ex.printStackTrace();\n        }\n        finally {\n            // return exit code base on validation of Checker\n            if (errorCounter > 0) {\n                final Violation errorCounterViolation = new Violation(1,\n                        Definitions.CHECKSTYLE_BUNDLE, ERROR_COUNTER,\n                        new String[] {String.valueOf(errorCounter)}, null, Main.class, null);\n                // print error count statistic to error output stream,\n                // output stream might be used by validation report content\n                System.err.println(errorCounterViolation.getViolation());\n            }\n            if (exitStatus != 0) {\n                System.exit(exitStatus);\n            }\n        }\n    }\n\n    /**\n     * Returns the version string printed when the user requests version help (--version or -V).\n     *\n     * @return a version string based on the package implementation version\n     */\n    private static String getVersionString() {\n        return \"Checkstyle version: \" + Main.class.getPackage().getImplementationVersion();\n    }\n\n    /**\n     * Validates the user input and returns {@value #EXIT_WITH_INVALID_USER_INPUT_CODE} if\n     * invalid, otherwise executes CheckStyle and returns the number of violations.\n     *\n     * @param parseResult generic access to options and parameters found on the command line\n     * @param options encapsulates options and parameters specified on the command line\n     * @return number of violations\n     * @throws IOException if a file could not be read.\n     * @throws CheckstyleException if something happens processing the files.\n     * @noinspection UseOfSystemOutOrSystemErr\n     */\n    private static int execute(ParseResult parseResult, CliOptions options)\n            throws IOException, CheckstyleException {\n\n        final int exitStatus;\n\n        // return error if something is wrong in arguments\n        final List<File> filesToProcess = getFilesToProcess(options);\n        final List<String> messages = options.validateCli(parseResult, filesToProcess);\n        final boolean hasMessages = !messages.isEmpty();\n        if (hasMessages) {\n            messages.forEach(System.out::println);\n            exitStatus = EXIT_WITH_INVALID_USER_INPUT_CODE;\n        }\n        else {\n            exitStatus = runCli(options, filesToProcess);\n        }\n        return exitStatus;\n    }\n\n    /**\n     * Determines the files to process.\n     *\n     * @param options the user-specified options\n     * @return list of files to process\n     */\n    private static List<File> getFilesToProcess(CliOptions options) {\n        final List<Pattern> patternsToExclude = options.getExclusions();\n\n        final List<File> result = new LinkedList<>();\n        for (File file : options.files) {\n            result.addAll(listFiles(file, patternsToExclude));\n        }\n        return result;\n    }\n\n    /**\n     * Traverses a specified node looking for files to check. Found files are added to\n     * a specified list. Subdirectories are also traversed.\n     *\n     * @param node\n     *        the node to process\n     * @param patternsToExclude The list of patterns to exclude from searching or being added as\n     *        files.\n     * @return found files\n     */\n    private static List<File> listFiles(File node, List<Pattern> patternsToExclude) {\n        // could be replaced with org.apache.commons.io.FileUtils.list() method\n        // if only we add commons-io library\n        final List<File> result = new LinkedList<>();\n\n        if (node.canRead() && !isPathExcluded(node.getAbsolutePath(), patternsToExclude)) {\n            if (node.isDirectory()) {\n                final File[] files = node.listFiles();\n                // listFiles() can return null, so we need to check it\n                if (files != null) {\n                    for (File element : files) {\n                        result.addAll(listFiles(element, patternsToExclude));\n                    }\n                }\n            }\n            else if (node.isFile()) {\n                result.add(node);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Checks if a directory/file {@code path} should be excluded based on if it matches one of the\n     * patterns supplied.\n     *\n     * @param path The path of the directory/file to check\n     * @param patternsToExclude The list of patterns to exclude from searching or being added as\n     *        files.\n     * @return True if the directory/file matches one of the patterns.\n     */\n    private static boolean isPathExcluded(String path, List<Pattern> patternsToExclude) {\n        boolean result = false;\n\n        for (Pattern pattern : patternsToExclude) {\n            if (pattern.matcher(path).find()) {\n                result = true;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Do execution of CheckStyle based on Command line options.\n     *\n     * @param options user-specified options\n     * @param filesToProcess the list of files whose style to check\n     * @return number of violations\n     * @throws IOException if a file could not be read.\n     * @throws CheckstyleException if something happens processing the files.\n     * @noinspection UseOfSystemOutOrSystemErr\n     */\n    private static int runCli(CliOptions options, List<File> filesToProcess)\n            throws IOException, CheckstyleException {\n        int result = 0;\n        final boolean hasSuppressionLineColumnNumber = options.suppressionLineColumnNumber != null;\n\n        // create config helper object\n        if (options.printAst) {\n            // print AST\n            final File file = filesToProcess.get(0);\n            final String stringAst = AstTreeStringPrinter.printFileAst(file,\n                    JavaParser.Options.WITHOUT_COMMENTS);\n            System.out.print(stringAst);\n        }\n        else if (Objects.nonNull(options.xpath)) {\n            final String branch = XpathUtil.printXpathBranch(options.xpath, filesToProcess.get(0));\n            System.out.print(branch);\n        }\n        else if (options.printAstWithComments) {\n            final File file = filesToProcess.get(0);\n            final String stringAst = AstTreeStringPrinter.printFileAst(file,\n                    JavaParser.Options.WITH_COMMENTS);\n            System.out.print(stringAst);\n        }\n        else if (options.printJavadocTree) {\n            final File file = filesToProcess.get(0);\n            final String stringAst = DetailNodeTreeStringPrinter.printFileAst(file);\n            System.out.print(stringAst);\n        }\n        else if (options.printTreeWithJavadoc) {\n            final File file = filesToProcess.get(0);\n            final String stringAst = AstTreeStringPrinter.printJavaAndJavadocTree(file);\n            System.out.print(stringAst);\n        }\n        else if (hasSuppressionLineColumnNumber) {\n            final File file = filesToProcess.get(0);\n            final String stringSuppressions =\n                    SuppressionsStringPrinter.printSuppressions(file,\n                            options.suppressionLineColumnNumber, options.tabWidth);\n            System.out.print(stringSuppressions);\n        }\n        else {\n            if (options.debug) {\n                final Logger parentLogger = Logger.getLogger(Main.class.getName()).getParent();\n                final ConsoleHandler handler = new ConsoleHandler();\n                handler.setLevel(Level.FINEST);\n                handler.setFilter(new OnlyCheckstyleLoggersFilter());\n                parentLogger.addHandler(handler);\n                parentLogger.setLevel(Level.FINEST);\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Checkstyle debug logging enabled\");\n                LOG.debug(\"Running Checkstyle with version: \"\n                        + Main.class.getPackage().getImplementationVersion());\n            }\n\n            // run Checker\n            result = runCheckstyle(options, filesToProcess);\n        }\n\n        return result;\n    }\n\n    /**\n     * Executes required Checkstyle actions based on passed parameters.\n     *\n     * @param options user-specified options\n     * @param filesToProcess the list of files whose style to check\n     * @return number of violations of ERROR level\n     * @throws IOException\n     *         when output file could not be found\n     * @throws CheckstyleException\n     *         when properties file could not be loaded\n     */\n    private static int runCheckstyle(CliOptions options, List<File> filesToProcess)\n            throws CheckstyleException, IOException {\n        // setup the properties\n        final Properties props;\n\n        if (options.propertiesFile == null) {\n            props = System.getProperties();\n        }\n        else {\n            props = loadProperties(options.propertiesFile);\n        }\n\n        // create a configuration\n        final ThreadModeSettings multiThreadModeSettings =\n                new ThreadModeSettings(CliOptions.CHECKER_THREADS_NUMBER,\n                        CliOptions.TREE_WALKER_THREADS_NUMBER);\n\n        final ConfigurationLoader.IgnoredModulesOptions ignoredModulesOptions;\n        if (options.executeIgnoredModules) {\n            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.EXECUTE;\n        }\n        else {\n            ignoredModulesOptions = ConfigurationLoader.IgnoredModulesOptions.OMIT;\n        }\n\n        final Configuration config = ConfigurationLoader.loadConfiguration(\n                options.configurationFile, new PropertiesExpander(props),\n                ignoredModulesOptions, multiThreadModeSettings);\n\n        // create RootModule object and run it\n        final int errorCounter;\n        final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n        final RootModule rootModule = getRootModule(config.getName(), moduleClassLoader);\n\n        try {\n            final AuditListener listener;\n            if (options.generateXpathSuppressionsFile) {\n                // create filter to print generated xpath suppressions file\n                final Configuration treeWalkerConfig = getTreeWalkerConfig(config);\n                if (treeWalkerConfig != null) {\n                    final DefaultConfiguration moduleConfig =\n                            new DefaultConfiguration(\n                                    XpathFileGeneratorAstFilter.class.getName());\n                    moduleConfig.addProperty(CliOptions.ATTRIB_TAB_WIDTH_NAME,\n                            String.valueOf(options.tabWidth));\n                    ((DefaultConfiguration) treeWalkerConfig).addChild(moduleConfig);\n                }\n\n                listener = new XpathFileGeneratorAuditListener(getOutputStream(options.outputPath),\n                        getOutputStreamOptions(options.outputPath));\n            }\n            else {\n                listener = createListener(options.format, options.outputPath);\n            }\n\n            rootModule.setModuleClassLoader(moduleClassLoader);\n            rootModule.configure(config);\n            rootModule.addListener(listener);\n\n            // run RootModule\n            errorCounter = rootModule.process(filesToProcess);\n        }\n        finally {\n            rootModule.destroy();\n        }\n\n        return errorCounter;\n    }\n\n    /**\n     * Loads properties from a File.\n     *\n     * @param file\n     *        the properties file\n     * @return the properties in file\n     * @throws CheckstyleException\n     *         when could not load properties file\n     */\n    private static Properties loadProperties(File file)\n            throws CheckstyleException {\n        final Properties properties = new Properties();\n\n        try (InputStream stream = Files.newInputStream(file.toPath())) {\n            properties.load(stream);\n        }\n        catch (final IOException ex) {\n            final Violation loadPropertiesExceptionMessage = new Violation(1,\n                    Definitions.CHECKSTYLE_BUNDLE, LOAD_PROPERTIES_EXCEPTION,\n                    new String[] {file.getAbsolutePath()}, null, Main.class, null);\n            throw new CheckstyleException(loadPropertiesExceptionMessage.getViolation(), ex);\n        }\n\n        return ChainedPropertyUtil.getResolvedProperties(properties);\n    }\n\n    /**\n     * Creates a new instance of the root module that will control and run\n     * Checkstyle.\n     *\n     * @param name The name of the module. This will either be a short name that\n     *        will have to be found or the complete package name.\n     * @param moduleClassLoader Class loader used to load the root module.\n     * @return The new instance of the root module.\n     * @throws CheckstyleException if no module can be instantiated from name\n     */\n    private static RootModule getRootModule(String name, ClassLoader moduleClassLoader)\n            throws CheckstyleException {\n        final ModuleFactory factory = new PackageObjectFactory(\n                Checker.class.getPackage().getName(), moduleClassLoader);\n\n        return (RootModule) factory.createModule(name);\n    }\n\n    /**\n     * Returns {@code TreeWalker} module configuration.\n     *\n     * @param config The configuration object.\n     * @return The {@code TreeWalker} module configuration.\n     */\n    private static Configuration getTreeWalkerConfig(Configuration config) {\n        Configuration result = null;\n\n        final Configuration[] children = config.getChildren();\n        for (Configuration child : children) {\n            if (\"TreeWalker\".equals(child.getName())) {\n                result = child;\n                break;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * This method creates in AuditListener an open stream for validation data, it must be\n     * closed by {@link RootModule} (default implementation is {@link Checker}) by calling\n     * {@link AuditListener#auditFinished(AuditEvent)}.\n     *\n     * @param format format of the audit listener\n     * @param outputLocation the location of output\n     * @return a fresh new {@code AuditListener}\n     * @exception IOException when provided output location is not found\n     */\n    private static AuditListener createListener(OutputFormat format, Path outputLocation)\n            throws IOException {\n        final OutputStream out = getOutputStream(outputLocation);\n        final AutomaticBean.OutputStreamOptions closeOutputStreamOption =\n                getOutputStreamOptions(outputLocation);\n        return format.createListener(out, closeOutputStreamOption);\n    }\n\n    /**\n     * Create output stream or return System.out\n     *\n     * @param outputPath output location\n     * @return output stream\n     * @throws IOException might happen\n     * @noinspection UseOfSystemOutOrSystemErr\n     */\n    @SuppressWarnings(\"resource\")\n    private static OutputStream getOutputStream(Path outputPath) throws IOException {\n        final OutputStream result;\n        if (outputPath == null) {\n            result = System.out;\n        }\n        else {\n            result = Files.newOutputStream(outputPath);\n        }\n        return result;\n    }\n\n    /**\n     * Create {@link AutomaticBean.OutputStreamOptions} for the given location.\n     *\n     * @param outputPath output location\n     * @return output stream options\n     */\n    private static AutomaticBean.OutputStreamOptions getOutputStreamOptions(Path outputPath) {\n        final AutomaticBean.OutputStreamOptions result;\n        if (outputPath == null) {\n            result = AutomaticBean.OutputStreamOptions.NONE;\n        }\n        else {\n            result = AutomaticBean.OutputStreamOptions.CLOSE;\n        }\n        return result;\n    }\n\n    /**\n     * Enumeration over the possible output formats.\n     *\n     * @noinspection PackageVisibleInnerClass\n     */\n    // Package-visible for tests.\n    enum OutputFormat {\n        /** XML output format. */\n        XML,\n        /** SARIF output format. */\n        SARIF,\n        /** Plain output format. */\n        PLAIN;\n\n        /**\n         * Returns a new AuditListener for this OutputFormat.\n         *\n         * @param out the output stream\n         * @param options the output stream options\n         * @return a new AuditListener for this OutputFormat\n         * @throws IOException if there is any IO exception during logger initialization\n         */\n        public AuditListener createListener(\n            OutputStream out,\n            AutomaticBean.OutputStreamOptions options) throws IOException {\n            final AuditListener result;\n            if (this == XML) {\n                result = new XMLLogger(out, options);\n            }\n            else if (this == SARIF) {\n                result = new SarifLogger(out, options);\n            }\n            else {\n                result = new DefaultLogger(out, options);\n            }\n            return result;\n        }\n\n        /**\n         * Returns the name in lowercase.\n         *\n         * @return the enum name in lowercase\n         */\n        @Override\n        public String toString() {\n            return name().toLowerCase(Locale.ROOT);\n        }\n    }\n\n    /** Log Filter used in debug mode. */\n    private static final class OnlyCheckstyleLoggersFilter implements Filter {\n        /** Name of the package used to filter on. */\n        private final String packageName = Main.class.getPackage().getName();\n\n        /**\n         * Returns whether the specified logRecord should be logged.\n         *\n         * @param logRecord the logRecord to log\n         * @return true if the logger name is in the package of this class or a subpackage\n         */\n        @Override\n        public boolean isLoggable(LogRecord logRecord) {\n            return logRecord.getLoggerName().startsWith(packageName);\n        }\n    }\n\n    /**\n     * Command line options.\n     *\n     * @noinspection unused, FieldMayBeFinal, CanBeFinal,\n     *              MismatchedQueryAndUpdateOfCollection, LocalCanBeFinal\n     */\n    @Command(name = \"checkstyle\", description = \"Checkstyle verifies that the specified \"\n            + \"source code files adhere to the specified rules. By default violations are \"\n            + \"reported to standard out in plain format. Checkstyle requires a configuration \"\n            + \"XML file that configures the checks to apply.\",\n            mixinStandardHelpOptions = true)\n    private static class CliOptions {\n\n        /** Width of CLI help option. */\n        private static final int HELP_WIDTH = 100;\n\n        /** The default number of threads to use for checker and the tree walker. */\n        private static final int DEFAULT_THREAD_COUNT = 1;\n\n        /** Name for the moduleConfig attribute 'tabWidth'. */\n        private static final String ATTRIB_TAB_WIDTH_NAME = \"tabWidth\";\n\n        /** Default output format. */\n        private static final OutputFormat DEFAULT_OUTPUT_FORMAT = OutputFormat.PLAIN;\n\n        /** Option name for output format. */\n        private static final String OUTPUT_FORMAT_OPTION = \"-f\";\n\n        /**\n         * The checker threads number.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         * This option has been skipped for CLI options intentionally.\n         *\n         * @noinspection CanBeFinal\n         */\n        private static final int CHECKER_THREADS_NUMBER = DEFAULT_THREAD_COUNT;\n\n        /**\n         * The tree walker threads number.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         * This option has been skipped for CLI options intentionally.\n         *\n         * @noinspection CanBeFinal\n         */\n        private static final int TREE_WALKER_THREADS_NUMBER = DEFAULT_THREAD_COUNT;\n\n        /** List of file to validate. */\n        @Parameters(arity = \"1..*\", description = \"One or more source files to verify\")\n        private List<File> files;\n\n        /** Config file location. */\n        @Option(names = \"-c\", description = \"Specifies the location of the file that defines\"\n                + \" the configuration modules. The location can either be a filesystem location\"\n                + \", or a name passed to the ClassLoader.getResource() method.\")\n        private String configurationFile;\n\n        /** Output file location. */\n        @Option(names = \"-o\", description = \"Sets the output file. Defaults to stdout.\")\n        private Path outputPath;\n\n        /** Properties file location. */\n        @Option(names = \"-p\", description = \"Sets the property files to load.\")\n        private File propertiesFile;\n\n        /** LineNo and columnNo for the suppression. */\n        @Option(names = \"-s\",\n                description = \"Prints xpath suppressions at the file's line and column position. \"\n                        + \"Argument is the line and column number (separated by a : ) in the file \"\n                        + \"that the suppression should be generated for. The option cannot be used \"\n                        + \"with other options and requires exactly one file to run on to be \"\n                        + \"specified. ATTENTION: generated result will have few queries, joined \"\n                        + \"by pipe(|). Together they will match all AST nodes on \"\n                        + \"specified line and column. You need to choose only one and recheck \"\n                        + \"that it works. Usage of all of them is also ok, but might result in \"\n                        + \"undesirable matching and suppress other issues.\")\n        private String suppressionLineColumnNumber;\n\n        /**\n         * Tab character length.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = {\"-w\", \"--tabWidth\"},\n                description = \"Sets the length of the tab character. \"\n                + \"Used only with -s option. Default value is ${DEFAULT-VALUE}.\")\n        private int tabWidth = CommonUtil.DEFAULT_TAB_WIDTH;\n\n        /** Switch whether to generate suppressions file or not. */\n        @Option(names = {\"-g\", \"--generate-xpath-suppression\"},\n                description = \"Generates to output a suppression xml to use to suppress all \"\n                        + \"violations from user's config. Instead of printing every violation, \"\n                        + \"all violations will be catched and single suppressions xml file will \"\n                        + \"be printed out. Used only with -c option. Output \"\n                        + \"location can be specified with -o option.\")\n        private boolean generateXpathSuppressionsFile;\n\n        /**\n         * Output format.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = \"-f\",\n                description = \"Specifies the output format. Valid values: \"\n                + \"${COMPLETION-CANDIDATES} for XMLLogger, SarifLogger, \"\n                + \"and DefaultLogger respectively. Defaults to ${DEFAULT-VALUE}.\")\n        private OutputFormat format = DEFAULT_OUTPUT_FORMAT;\n\n        /** Option that controls whether to print the AST of the file. */\n        @Option(names = {\"-t\", \"--tree\"},\n                description = \"Prints Abstract Syntax Tree(AST) of the checked file. The option \"\n                        + \"cannot be used other options and requires exactly one file to run on \"\n                        + \"to be specified.\")\n        private boolean printAst;\n\n        /** Option that controls whether to print the AST of the file including comments. */\n        @Option(names = {\"-T\", \"--treeWithComments\"},\n                description = \"Prints Abstract Syntax Tree(AST) with comment nodes \"\n                        + \"of the checked file. The option cannot be used with other options \"\n                        + \"and requires exactly one file to run on to be specified.\")\n        private boolean printAstWithComments;\n\n        /** Option that controls whether to print the parse tree of the javadoc comment. */\n        @Option(names = {\"-j\", \"--javadocTree\"},\n                description = \"Prints Parse Tree of the Javadoc comment. \"\n                        + \"The file have to contain only Javadoc comment content without \"\n                        + \"including '/**' and '*/' at the beginning and at the end respectively. \"\n                        + \"The option cannot be used other options and requires exactly one file \"\n                        + \"to run on to be specified.\")\n        private boolean printJavadocTree;\n\n        /** Option that controls whether to print the full AST of the file. */\n        @Option(names = {\"-J\", \"--treeWithJavadoc\"},\n                description = \"Prints Abstract Syntax Tree(AST) with Javadoc nodes \"\n                        + \"and comment nodes of the checked file. Attention that line number and \"\n                        + \"columns will not be the same as it is a file due to the fact that each \"\n                        + \"javadoc comment is parsed separately from java file. The option cannot \"\n                        + \"be used with other options and requires exactly one file to run on to \"\n                        + \"be specified.\")\n        private boolean printTreeWithJavadoc;\n\n        /** Option that controls whether to print debug info. */\n        @Option(names = {\"-d\", \"--debug\"},\n                description = \"Prints all debug logging of CheckStyle utility.\")\n        private boolean debug;\n\n        /**\n         * Option that allows users to specify a list of paths to exclude.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = {\"-e\", \"--exclude\"},\n                description = \"Directory/file to exclude from CheckStyle. The path can be the \"\n                        + \"full, absolute path, or relative to the current path. Multiple \"\n                        + \"excludes are allowed.\")\n        private List<File> exclude = new ArrayList<>();\n\n        /**\n         * Option that allows users to specify a regex of paths to exclude.\n         * Suppression: CanBeFinal - we use picocli and it use  reflection to manage such fields\n         *\n         * @noinspection CanBeFinal\n         */\n        @Option(names = {\"-x\", \"--exclude-regexp\"},\n                description = \"Directory/file pattern to exclude from CheckStyle. Multiple \"\n                        + \"excludes are allowed.\")\n        private List<Pattern> excludeRegex = new ArrayList<>();\n\n        /** Switch whether to execute ignored modules or not. */\n        @Option(names = {\"-E\", \"--executeIgnoredModules\"},\n                description = \"Allows ignored modules to be run.\")\n        private boolean executeIgnoredModules;\n\n        /** Show AST branches that match xpath. */\n        @Option(names = {\"-b\", \"--branch-matching-xpath\"},\n            description = \"Shows Abstract Syntax Tree(AST) branches that match given XPath query.\")\n        private String xpath;\n\n        /**\n         * Gets the list of exclusions provided through the command line arguments.\n         *\n         * @return List of exclusion patterns.\n         */\n        private List<Pattern> getExclusions() {\n            final List<Pattern> result = exclude.stream()\n                    .map(File::getAbsolutePath)\n                    .map(Pattern::quote)\n                    .map(pattern -> Pattern.compile(\"^\" + pattern + \"$\"))\n                    .collect(Collectors.toCollection(ArrayList::new));\n            result.addAll(excludeRegex);\n            return result;\n        }\n\n        /**\n         * Validates the user-specified command line options.\n         *\n         * @param parseResult used to verify if the format option was specified on the command line\n         * @param filesToProcess the list of files whose style to check\n         * @return list of violations\n         */\n        // -@cs[CyclomaticComplexity] Breaking apart will damage encapsulation\n        private List<String> validateCli(ParseResult parseResult, List<File> filesToProcess) {\n            final List<String> result = new ArrayList<>();\n            final boolean hasConfigurationFile = configurationFile != null;\n            final boolean hasSuppressionLineColumnNumber = suppressionLineColumnNumber != null;\n\n            if (filesToProcess.isEmpty()) {\n                result.add(\"Files to process must be specified, found 0.\");\n            }\n            // ensure there is no conflicting options\n            else if (printAst || printAstWithComments || printJavadocTree || printTreeWithJavadoc\n                || xpath != null) {\n                if (suppressionLineColumnNumber != null || configurationFile != null\n                        || propertiesFile != null || outputPath != null\n                        || parseResult.hasMatchedOption(OUTPUT_FORMAT_OPTION)) {\n                    result.add(\"Option '-t' cannot be used with other options.\");\n                }\n                else if (filesToProcess.size() > 1) {\n                    result.add(\"Printing AST is allowed for only one file.\");\n                }\n            }\n            else if (hasSuppressionLineColumnNumber) {\n                if (configurationFile != null || propertiesFile != null\n                        || outputPath != null\n                        || parseResult.hasMatchedOption(OUTPUT_FORMAT_OPTION)) {\n                    result.add(\"Option '-s' cannot be used with other options.\");\n                }\n                else if (filesToProcess.size() > 1) {\n                    result.add(\"Printing xpath suppressions is allowed for only one file.\");\n                }\n            }\n            else if (hasConfigurationFile) {\n                try {\n                    // test location only\n                    CommonUtil.getUriByFilename(configurationFile);\n                }\n                catch (CheckstyleException ignored) {\n                    final String msg = \"Could not find config XML file '%s'.\";\n                    result.add(String.format(Locale.ROOT, msg, configurationFile));\n                }\n                result.addAll(validateOptionalCliParametersIfConfigDefined());\n            }\n            else {\n                result.add(\"Must specify a config XML file.\");\n            }\n\n            return result;\n        }\n\n        /**\n         * Validates optional command line parameters that might be used with config file.\n         *\n         * @return list of violations\n         */\n        private List<String> validateOptionalCliParametersIfConfigDefined() {\n            final List<String> result = new ArrayList<>();\n            if (propertiesFile != null && !propertiesFile.exists()) {\n                result.add(String.format(Locale.ROOT,\n                        \"Could not find file '%s'.\", propertiesFile));\n            }\n            return result;\n        }\n    }\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['src/main/java/com/puppycrawl/tools/checkstyle/AstTreeStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/AuditEventDefaultFormatter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/AuditEventFormatter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Checker.java', 'src/main/java/com/puppycrawl/tools/checkstyle/CheckstyleParserErrorStrategy.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultContext.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Definitions.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DetailAstImpl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DetailNodeTreeStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/FileStatefulCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/GlobalStatefulCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavaAstVisitor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavaParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavadocPropertiesGenerator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Main.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ModuleFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PackageNamesLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertiesExpander.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertyResolver.java', 'src/main/java/com/puppycrawl/tools/checkstyle/SarifLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/StatelessCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/SuppressionsStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ThreadModeSettings.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalkerAuditEvent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalkerFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XMLLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XmlLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAstFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAuditListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ant/CheckstyleAntTask.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ant/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractFileSetCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractViolationReporter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AuditEvent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AuditListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AutomaticBean.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilterSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/CheckstyleException.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Comment.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Configurable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Configuration.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Context.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Contextualizable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/DetailNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/ExternalResourceHolder.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileContents.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileSetCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Filter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FilterSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FullIdent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/JavadocTokenTypes.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/LineColumn.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/MessageDispatcher.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/RootModule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Scope.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/SeverityLevel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/SeverityLevelCounter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/TextBlock.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/TokenTypes.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Violation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/ArrayTypeStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/FinalParametersCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/LineSeparatorOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/NoCodeInFileCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/OrderedPropertiesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/OuterTypeFilenameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TodoCommentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UniquePropertiesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UpperEllCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationOnSameLineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingDeprecatedCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingOverrideCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/PackageAnnotationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/AvoidNestedBlocksCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/BlockOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyBlockCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AbstractSuperCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ArrayTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidDoubleBraceInitializationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidInlineConditionalsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidNoArgumentSuperConstructorCallCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/CovariantEqualsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DefaultComesLastCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EmptyStatementCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsHashCodeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ExplicitInitializationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/HiddenFieldCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalCatchCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenTextCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MagicNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MatchXpathCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingCtorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingSwitchDefaultCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ModifiedControlVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleVariableDeclarationsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedForDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedIfDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedTryDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoArrayTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoCloneCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoEnumTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoFinalizerCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/PackageDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ReturnCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanExpressionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanReturnCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/StringLiteralEqualityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperCloneCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperFinalizeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterOuterTypeDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterTypeMemberDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInEnumerationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInTryWithResourcesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/HideUtilityClassConstructorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/InnerTypeLastCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/InterfaceIsTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/OneTopLevelClassCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/ThrowsCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/HeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AbstractImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AbstractImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AccessResult.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStarImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStaticImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ClassImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/FileImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/IllegalImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/MismatchStrategy.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/RedundantImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AbstractExpressionHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AnnotationArrayInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ArrayInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/BlockParentHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CaseHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CatchHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/DetailAstSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/DoWhileHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ElseHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/FinallyHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ForHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IfHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ImportHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentLevel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndexHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LabelHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LambdaHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MemberDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodCallHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/NewHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ObjectBlockHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/PackageDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/PrimordialHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SlistHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/StaticInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SwitchHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SwitchRuleHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SynchronizedHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/TryHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/WhileHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/YieldHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AtclauseOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/HtmlTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocPositionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocBlockTagLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMissingLeadingAsteriskCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMissingWhitespaceAfterAsteriskCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocNodeImpl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocPackageCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocParagraphCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagContinuationIndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagInfo.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTags.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocMethodCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocPackageCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/NonEmptyAtclauseDescriptionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/RequireEmptyLineBeforeBlockTagGroupCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SingleLineJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/WriteTagCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/BlockTagUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/InlineTagUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/TagInfo.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassDataAbstractionCouplingCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassFanOutComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/CyclomaticComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/JavaNCSSCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ClassMemberImpliedModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/InterfaceMemberImpliedModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ModifierOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbbreviationAsWordInNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractAccessControlNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AccessModifierOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/CatchParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ClassTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ConstantNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/IllegalIdentifierNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/InterfaceTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LambdaParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalFinalVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MemberNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/PackageNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/PatternVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/RecordComponentNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/RecordTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/StaticVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/TypeNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/CommentSuppressor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/DetectorOptions.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/MatchSuppressor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/MultilineDetector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/NeverSuppress.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpMultilineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpOnFilenameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineJavaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/SinglelineDetector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/AnonInnerLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/ExecutableStatementCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/FileLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/LambdaBodyLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/LineLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/OuterTypeNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/ParameterNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/RecordComponentNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/AbstractParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForInitializerPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForIteratorPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/FileTabCharacterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/MethodParamPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoLineWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCaseDefaultColonCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/OperatorWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/PadOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SeparatorWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SingleSpaceSeparatorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/TypecastParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAfterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WrapOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filefilters/BeforeExecutionExclusionFileFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filefilters/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/CsvFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntMatchFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntRangeFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SeverityMatchFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWarningsFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithPlainTextCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionSingleFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathSingleFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionsLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/XpathFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/CommentListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/CrAwareLexerSimulator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/BaseCellEditor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/CodeSelector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/CodeSelectorPresentation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ListToTreeSelectionModelWrapper.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/Main.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/MainFrame.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/MainFrameModel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTableModel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTablePresentation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTableCellRenderer.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTableModelAdapter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/MetadataGenerationException.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModuleDetails.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModulePropertyDetails.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModuleType.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaReader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaWriter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/AnnotationUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/BlockCommentPosition.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ChainedPropertyUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/FilterUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ModuleReflectionUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ParserUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ScopeUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/TokenUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/XpathUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/AbstractNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/AttributeNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/ElementNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/RootNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/XpathQueryGenerator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/package-info.java']\n\nFile Path Before Refactoring:\nsrc/main/java/com/puppycrawl/tools/checkstyle/Main.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate isKnownPropertyType(propertyType Class<?>) : boolean extracted from private getModulePropertyExpectedTypeName(sectionName String, fieldClass Class<?>, instance Object, propertyName String) : String in class com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1077, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1019, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 1150, "endLine": 1162, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "isPureRefactoring": true, "commitId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7", "packageNameBefore": "com.puppycrawl.tools.checkstyle.internal", "classNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "methodNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}", "classSignatureBefore": "public class XdocsPagesTest ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest"], "classSignatureBeforeSet": ["public class XdocsPagesTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n", "description": "One of the overlapping cases - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks whether property is a dynamic custom expression.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return true if it is a dynamic custom expression.\n     */\n    private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n        return isSuppressionFilter(sectionName)\n                && (\"checkFormat\".equals(propertyName)\n                || \"messageFormat\".equals(propertyName)\n                || \"idFormat\".equals(propertyName)\n                || \"influenceFormat\".equals(propertyName))\n                || isRegexpCheck(sectionName)\n                && \"format\".equals(propertyName);\n    }\n\n    /**\n     * Checks Whether the section is a type of suppression filter.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if it is a type of suppression filter.\n     */\n    private static boolean isSuppressionFilter(String sectionName) {\n        return \"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n    }\n\n    /**\n     * Checks whether the section is a RegexpCheck.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if the section is a RegexpCheck.\n     */\n    private static boolean isRegexpCheck(String sectionName) {\n        return \"RegexpMultiline\".equals(sectionName)\n                || \"RegexpSingleline\".equals(sectionName)\n                || \"RegexpSinglelineJava\".equals(sectionName);\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Int[] class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n        String result = \"int[]\";\n        if (isPropertyTokenType(sectionName, propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForString(String sectionName, String propertyName) {\n        String result = \"String\";\n\n        if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n            result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n        }\n        else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n            result += \" (either the empty string or a lowercase ISO 639 code)\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String[] class.\n     *\n     * @param propertyName the property name to work with.\n     * @param instanceName the simple name of class instance to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForStringArray(\n            String propertyName, String instanceName) {\n        String result = \"String[]\";\n        if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                && \"ignoreOccurrenceContext\".equals(propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPattern(String checkProperty) {\n        String result = \"Pattern\";\n        if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n            result = \"Regular Expression\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern[] class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPatternArray(String checkProperty) {\n        String result = \"Pattern[]\";\n        if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n            result = \"Regular Expressions\";\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether given property is a known property type.\n     *\n     * @param propertyType the bean property's type.\n     * @return true if given property type matches with one of the known property type.\n     */\n    private static boolean isKnownPropertyType(Class<?> propertyType) {\n        return propertyType == int.class\n                || propertyType == boolean.class\n                || propertyType == double[].class\n                || propertyType == URI.class\n                || propertyType == AccessModifierOption[].class;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Checks whether given property is a known property type.\n     *\n     * @param propertyType the bean property's type.\n     * @return true if given property type matches with one of the known property type.\n     */\n    private static boolean isKnownPropertyType(Class<?> propertyType) {\n        return propertyType == int.class\n                || propertyType == boolean.class\n                || propertyType == double[].class\n                || propertyType == URI.class\n                || propertyType == AccessModifierOption[].class;\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n/**\n     * Checks whether given property is a known property type.\n     *\n     * @param propertyType the bean property's type.\n     * @return true if given property type matches with one of the known property type.\n     */\n    private static boolean isKnownPropertyType(Class<?> propertyType) {\n        return propertyType == int.class\n                || propertyType == boolean.class\n                || propertyType == double[].class\n                || propertyType == URI.class\n                || propertyType == AccessModifierOption[].class;\n    }", "diffSourceCode": "   962:     /**\n   963:      * Get's the name of the bean property's type for the class.\n   964:      *\n   965:      * @param sectionName The name of the section/module being worked on.\n   966:      * @param fieldClass The bean property's type.\n   967:      * @param instance The class instance to work with.\n   968:      * @param propertyName The property name to work with.\n   969:      * @return String form of property's type.\n-  970:      * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n+  970:      * @noinspection IfStatementWithTooManyBranches\n   971:      */\n   972:     private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n   973:             Object instance, String propertyName) {\n   974:         final String instanceName = instance.getClass().getSimpleName();\n   975:         String result = null;\n   976:         final String checkProperty = sectionName + \":\" + propertyName;\n-  977:         if ((\"SuppressionCommentFilter\".equals(sectionName)\n-  978:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n-  979:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n-  980:                     && (\"checkFormat\".equals(propertyName)\n-  981:                         || \"messageFormat\".equals(propertyName)\n-  982:                         || \"idFormat\".equals(propertyName)\n-  983:                         || \"influenceFormat\".equals(propertyName))\n-  984:                 || (\"RegexpMultiline\".equals(sectionName)\n-  985:                     || \"RegexpSingleline\".equals(sectionName)\n-  986:                     || \"RegexpSinglelineJava\".equals(sectionName))\n-  987:                     && \"format\".equals(propertyName)) {\n-  988:             // dynamic custom expression\n-  989:             result = \"Regular Expression\";\n+  977:         if (isDynamicCustomExpression(sectionName, propertyName)) {\n+  978:             // dynamic custom expression\n+  979:             result = \"Regular Expression\";\n+  980:         }\n+  981:         else if (fieldClass == int[].class) {\n+  982:             result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n+  983:         }\n+  984:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n+  985:             result = getPropertyTypeNameForString(sectionName, propertyName);\n+  986: \n+  987:         }\n+  988:         else if (fieldClass == String[].class) {\n+  989:             result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n   990:         }\n-  991:         else if (fieldClass == boolean.class) {\n-  992:             result = \"boolean\";\n+  991:         else if (fieldClass == Pattern.class) {\n+  992:             result = getPropertyTypeNameForPattern(checkProperty);\n   993:         }\n-  994:         else if (fieldClass == int.class) {\n-  995:             result = \"int\";\n+  994:         else if (fieldClass == Pattern[].class) {\n+  995:             result = getPropertyTypeNameForPatternArray(checkProperty);\n   996:         }\n-  997:         else if (fieldClass == int[].class) {\n-  998:             if (isPropertyTokenType(sectionName, propertyName)) {\n-  999:                 result = \"subset of tokens TokenTypes\";\n- 1000:             }\n- 1001:             else {\n- 1002:                 result = \"int[]\";\n- 1003:             }\n- 1004:         }\n- 1005:         else if (fieldClass == double[].class) {\n- 1006:             result = \"double[]\";\n- 1007:         }\n- 1008:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n- 1009:             result = \"String\";\n- 1010: \n- 1011:             if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n- 1012:                 result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n- 1013:             }\n- 1014:             else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n- 1015:                 result += \" (either the empty string or a lowercase ISO 639 code)\";\n- 1016:             }\n- 1017:         }\n- 1018:         else if (fieldClass == String[].class) {\n- 1019:             if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n- 1020:                     || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n- 1021:                     || \"MultipleStringLiteralsCheck\".equals(instanceName)\n- 1022:                             && \"ignoreOccurrenceContext\".equals(propertyName)) {\n- 1023:                 result = \"subset of tokens TokenTypes\";\n- 1024:             }\n- 1025:             else {\n- 1026:                 result = \"String[]\";\n- 1027:             }\n- 1028:         }\n- 1029:         else if (fieldClass == URI.class) {\n- 1030:             result = \"URI\";\n- 1031:         }\n- 1032:         else if (fieldClass == Pattern.class) {\n- 1033:             if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n- 1034:                 || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n- 1035:                 || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n- 1036:                 || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n- 1037:                 || \"IllegalTokenText:format\".equals(checkProperty)) {\n- 1038:                 result = \"Regular Expression\";\n- 1039:             }\n- 1040:             else {\n- 1041:                 result = \"Pattern\";\n- 1042:             }\n- 1043:         }\n- 1044:         else if (fieldClass == Pattern[].class) {\n- 1045:             if (\"ImportOrder:groups\".equals(checkProperty)\n- 1046:                 || \"ImportOrder:staticGroups\".equals(checkProperty)\n- 1047:                 || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n- 1048:                 || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n- 1049:                 result = \"Regular Expressions\";\n- 1050:             }\n- 1051:             else {\n- 1052:                 result = \"Pattern[]\";\n- 1053:             }\n- 1054:         }\n- 1055:         else if (fieldClass == Scope.class) {\n- 1056:             result = \"Scope\";\n- 1057:         }\n- 1058:         else if (fieldClass == AccessModifierOption[].class) {\n- 1059:             result = \"AccessModifierOption[]\";\n- 1060:         }\n- 1061:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n- 1062:             result = \"File\";\n- 1063:         }\n- 1064:         else if (fieldClass.isEnum()) {\n- 1065:             result = fieldClass.getSimpleName();\n- 1066:         }\n- 1067:         else {\n- 1068:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n- 1069:         }\n- 1070: \n- 1071:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n- 1072:             result = result + \" in a format of comma separated attribute=value entries. The \"\n- 1073:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n- 1074:         }\n- 1075: \n- 1076:         return result;\n- 1077:     }\n- 1150:                                 }\n- 1151:                                 else {\n- 1152:                                     sb.append(\", \");\n- 1153:                                 }\n- 1154: \n- 1155:                                 sb.append(TokenUtil.getTokenName(i));\n- 1156:                             }\n- 1157:                         }\n- 1158: \n- 1159:                         result = sb.toString();\n- 1160:                     }\n- 1161:                     else {\n- 1162:                         final StringBuilder sb = new StringBuilder(20);\n+  997:         else if (fieldClass == Scope.class) {\n+  998:             result = \"Scope\";\n+  999:         }\n+ 1000:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n+ 1001:             result = \"File\";\n+ 1002:         }\n+ 1003:         else if (fieldClass.isEnum()) {\n+ 1004:             result = fieldClass.getSimpleName();\n+ 1005:         }\n+ 1006:         else if (isKnownPropertyType(fieldClass)) {\n+ 1007:             result = fieldClass.getSimpleName();\n+ 1008:         }\n+ 1009:         else {\n+ 1010:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n+ 1011:         }\n+ 1012: \n+ 1013:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n+ 1014:             result = result + \" in a format of comma separated attribute=value entries. The \"\n+ 1015:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n+ 1016:         }\n+ 1017: \n+ 1018:         return result;\n+ 1019:     }\n+ 1020: \n+ 1021:     /**\n+ 1022:      * Checks whether property is a dynamic custom expression.\n+ 1023:      *\n+ 1024:      * @param sectionName the name of the section/module being worked on.\n+ 1025:      * @param propertyName the property name to work with.\n+ 1026:      * @return true if it is a dynamic custom expression.\n+ 1027:      */\n+ 1028:     private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n+ 1029:         return isSuppressionFilter(sectionName)\n+ 1030:                 && (\"checkFormat\".equals(propertyName)\n+ 1031:                 || \"messageFormat\".equals(propertyName)\n+ 1032:                 || \"idFormat\".equals(propertyName)\n+ 1033:                 || \"influenceFormat\".equals(propertyName))\n+ 1034:                 || isRegexpCheck(sectionName)\n+ 1035:                 && \"format\".equals(propertyName);\n+ 1036:     }\n+ 1037: \n+ 1038:     /**\n+ 1039:      * Checks Whether the section is a type of suppression filter.\n+ 1040:      *\n+ 1041:      * @param sectionName the name of the section/module being worked on.\n+ 1042:      * @return true if it is a type of suppression filter.\n+ 1043:      */\n+ 1044:     private static boolean isSuppressionFilter(String sectionName) {\n+ 1045:         return \"SuppressionCommentFilter\".equals(sectionName)\n+ 1046:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n+ 1047:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n+ 1048:     }\n+ 1049: \n+ 1050:     /**\n+ 1051:      * Checks whether the section is a RegexpCheck.\n+ 1052:      *\n+ 1053:      * @param sectionName the name of the section/module being worked on.\n+ 1054:      * @return true if the section is a RegexpCheck.\n+ 1055:      */\n+ 1056:     private static boolean isRegexpCheck(String sectionName) {\n+ 1057:         return \"RegexpMultiline\".equals(sectionName)\n+ 1058:                 || \"RegexpSingleline\".equals(sectionName)\n+ 1059:                 || \"RegexpSinglelineJava\".equals(sectionName);\n+ 1060:     }\n+ 1061: \n+ 1062:     /**\n+ 1063:      * Get's the name of the bean property's type for the Int[] class.\n+ 1064:      *\n+ 1065:      * @param sectionName the name of the section/module being worked on.\n+ 1066:      * @param propertyName the property name to work with.\n+ 1067:      * @return String form of property's type.\n+ 1068:      */\n+ 1069:     private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n+ 1070:         String result = \"int[]\";\n+ 1071:         if (isPropertyTokenType(sectionName, propertyName)) {\n+ 1072:             result = \"subset of tokens TokenTypes\";\n+ 1073:         }\n+ 1074:         return result;\n+ 1075:     }\n+ 1076: \n+ 1077:     /**\n+ 1150:     /**\n+ 1151:      * Checks whether given property is a known property type.\n+ 1152:      *\n+ 1153:      * @param propertyType the bean property's type.\n+ 1154:      * @return true if given property type matches with one of the known property type.\n+ 1155:      */\n+ 1156:     private static boolean isKnownPropertyType(Class<?> propertyType) {\n+ 1157:         return propertyType == int.class\n+ 1158:                 || propertyType == boolean.class\n+ 1159:                 || propertyType == double[].class\n+ 1160:                 || propertyType == URI.class\n+ 1161:                 || propertyType == AccessModifierOption[].class;\n+ 1162:     }\n", "uniqueId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7_962_1077_1150_1162_962_1019", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nrefactored_method_code\n##########################\n/**\n * Validates the order of rule names and ensures they are in ascending order.\n *\n * @param fileName The name of the file being processed.\n * @param lastRuleName The name of the last rule processed.\n * @param lastRuleNumberParts The parts of the last rule number processed.\n * @param ruleName The name of the current rule being processed.\n * @return The parts of the current rule number being processed.\n */\nprivate String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                       String[] lastRuleNumberParts, String ruleName) {\n    final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n    if (lastRuleName != null) {\n        final int ruleNumberPartsAmount = ruleNumberParts.length;\n        final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n        final String outOfOrderReason = fileName + \" rule '\" + ruleName + \"' is out of order compared to '\" + lastRuleName + \"'\";\n        boolean lastRuleNumberPartWasEqual = false;\n        int partIndex;\n        for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n            if (lastRuleNumberPartsAmount <= partIndex) {\n                // equal up to here and last rule has less parts, thus order is correct, stop comparing\n                break;\n            }\n\n            final String ruleNumberPart = ruleNumberParts[partIndex];\n            final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n            final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                    ruleNumberPart.chars(),\n                    lastRuleNumberPart.chars()\n            ).allMatch(Character::isDigit);\n\n            if (ruleNumberPartsAreNumeric) {\n                final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                assertThat(outOfOrderReason,\n                        numericRuleNumberPart < numericLastRuleNumberPart,\n                        describedAs(\"'%0' should not be less than '%1'\",\n                                is(false),\n                                numericRuleNumberPart, numericLastRuleNumberPart));\n            } else {\n                assertThat(outOfOrderReason,\n                        ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                        describedAs(\"'%0' should not be less than '%1'\",\n                                is(false),\n                                ruleNumberPart, lastRuleNumberPart));\n            }\n            lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n            if (!lastRuleNumberPartWasEqual) {\n                // number part is not equal but properly ordered, thus order is correct, stop comparing\n                break;\n            }\n        }\n        if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n            if (lastRuleNumberPartsAmount == partIndex) {\n                fail(fileName + \" rule '\" + ruleName + \"' and rule '\" + lastRuleName + \"' have the same rule number\");\n            } else {\n                fail(outOfOrderReason);\n            }\n        }\n    }\n\n    return ruleNumberParts;\n}\n```", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getPropertyTypeNameForPatternArray(checkProperty String) : String extracted from private getModulePropertyExpectedTypeName(sectionName String, fieldClass Class<?>, instance Object, propertyName String) : String in class com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1077, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1019, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 1133, "endLine": 1148, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "isPureRefactoring": true, "commitId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7", "packageNameBefore": "com.puppycrawl.tools.checkstyle.internal", "classNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "methodNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}", "classSignatureBefore": "public class XdocsPagesTest ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest"], "classSignatureBeforeSet": ["public class XdocsPagesTest "], "purityCheckResultList": [{"isPure": true, "purityComment": " Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks whether property is a dynamic custom expression.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return true if it is a dynamic custom expression.\n     */\n    private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n        return isSuppressionFilter(sectionName)\n                && (\"checkFormat\".equals(propertyName)\n                || \"messageFormat\".equals(propertyName)\n                || \"idFormat\".equals(propertyName)\n                || \"influenceFormat\".equals(propertyName))\n                || isRegexpCheck(sectionName)\n                && \"format\".equals(propertyName);\n    }\n\n    /**\n     * Checks Whether the section is a type of suppression filter.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if it is a type of suppression filter.\n     */\n    private static boolean isSuppressionFilter(String sectionName) {\n        return \"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n    }\n\n    /**\n     * Checks whether the section is a RegexpCheck.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if the section is a RegexpCheck.\n     */\n    private static boolean isRegexpCheck(String sectionName) {\n        return \"RegexpMultiline\".equals(sectionName)\n                || \"RegexpSingleline\".equals(sectionName)\n                || \"RegexpSinglelineJava\".equals(sectionName);\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Int[] class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n        String result = \"int[]\";\n        if (isPropertyTokenType(sectionName, propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForString(String sectionName, String propertyName) {\n        String result = \"String\";\n\n        if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n            result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n        }\n        else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n            result += \" (either the empty string or a lowercase ISO 639 code)\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String[] class.\n     *\n     * @param propertyName the property name to work with.\n     * @param instanceName the simple name of class instance to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForStringArray(\n            String propertyName, String instanceName) {\n        String result = \"String[]\";\n        if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                && \"ignoreOccurrenceContext\".equals(propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPattern(String checkProperty) {\n        String result = \"Pattern\";\n        if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n            result = \"Regular Expression\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern[] class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPatternArray(String checkProperty) {\n        String result = \"Pattern[]\";\n        if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n            result = \"Regular Expressions\";\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether given property is a known property type.\n     *\n     * @param propertyType the bean property's type.\n     * @return true if given property type matches with one of the known property type.\n     */\n    private static boolean isKnownPropertyType(Class<?> propertyType) {\n        return propertyType == int.class\n                || propertyType == boolean.class\n                || propertyType == double[].class\n                || propertyType == URI.class\n                || propertyType == AccessModifierOption[].class;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Get's the name of the bean property's type for the Pattern[] class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPatternArray(String checkProperty) {\n        String result = \"Pattern[]\";\n        if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n            result = \"Regular Expressions\";\n        }\n        return result;\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n/**\n     * Get's the name of the bean property's type for the Pattern[] class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPatternArray(String checkProperty) {\n        String result = \"Pattern[]\";\n        if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n            result = \"Regular Expressions\";\n        }\n        return result;\n    }", "diffSourceCode": "   962:     /**\n   963:      * Get's the name of the bean property's type for the class.\n   964:      *\n   965:      * @param sectionName The name of the section/module being worked on.\n   966:      * @param fieldClass The bean property's type.\n   967:      * @param instance The class instance to work with.\n   968:      * @param propertyName The property name to work with.\n   969:      * @return String form of property's type.\n-  970:      * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n+  970:      * @noinspection IfStatementWithTooManyBranches\n   971:      */\n   972:     private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n   973:             Object instance, String propertyName) {\n   974:         final String instanceName = instance.getClass().getSimpleName();\n   975:         String result = null;\n   976:         final String checkProperty = sectionName + \":\" + propertyName;\n-  977:         if ((\"SuppressionCommentFilter\".equals(sectionName)\n-  978:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n-  979:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n-  980:                     && (\"checkFormat\".equals(propertyName)\n-  981:                         || \"messageFormat\".equals(propertyName)\n-  982:                         || \"idFormat\".equals(propertyName)\n-  983:                         || \"influenceFormat\".equals(propertyName))\n-  984:                 || (\"RegexpMultiline\".equals(sectionName)\n-  985:                     || \"RegexpSingleline\".equals(sectionName)\n-  986:                     || \"RegexpSinglelineJava\".equals(sectionName))\n-  987:                     && \"format\".equals(propertyName)) {\n-  988:             // dynamic custom expression\n-  989:             result = \"Regular Expression\";\n+  977:         if (isDynamicCustomExpression(sectionName, propertyName)) {\n+  978:             // dynamic custom expression\n+  979:             result = \"Regular Expression\";\n+  980:         }\n+  981:         else if (fieldClass == int[].class) {\n+  982:             result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n+  983:         }\n+  984:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n+  985:             result = getPropertyTypeNameForString(sectionName, propertyName);\n+  986: \n+  987:         }\n+  988:         else if (fieldClass == String[].class) {\n+  989:             result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n   990:         }\n-  991:         else if (fieldClass == boolean.class) {\n-  992:             result = \"boolean\";\n+  991:         else if (fieldClass == Pattern.class) {\n+  992:             result = getPropertyTypeNameForPattern(checkProperty);\n   993:         }\n-  994:         else if (fieldClass == int.class) {\n-  995:             result = \"int\";\n+  994:         else if (fieldClass == Pattern[].class) {\n+  995:             result = getPropertyTypeNameForPatternArray(checkProperty);\n   996:         }\n-  997:         else if (fieldClass == int[].class) {\n-  998:             if (isPropertyTokenType(sectionName, propertyName)) {\n-  999:                 result = \"subset of tokens TokenTypes\";\n- 1000:             }\n- 1001:             else {\n- 1002:                 result = \"int[]\";\n- 1003:             }\n- 1004:         }\n- 1005:         else if (fieldClass == double[].class) {\n- 1006:             result = \"double[]\";\n- 1007:         }\n- 1008:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n- 1009:             result = \"String\";\n- 1010: \n- 1011:             if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n- 1012:                 result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n- 1013:             }\n- 1014:             else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n- 1015:                 result += \" (either the empty string or a lowercase ISO 639 code)\";\n- 1016:             }\n- 1017:         }\n- 1018:         else if (fieldClass == String[].class) {\n- 1019:             if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n- 1020:                     || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n- 1021:                     || \"MultipleStringLiteralsCheck\".equals(instanceName)\n- 1022:                             && \"ignoreOccurrenceContext\".equals(propertyName)) {\n- 1023:                 result = \"subset of tokens TokenTypes\";\n- 1024:             }\n- 1025:             else {\n- 1026:                 result = \"String[]\";\n- 1027:             }\n- 1028:         }\n- 1029:         else if (fieldClass == URI.class) {\n- 1030:             result = \"URI\";\n- 1031:         }\n- 1032:         else if (fieldClass == Pattern.class) {\n- 1033:             if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n- 1034:                 || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n- 1035:                 || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n- 1036:                 || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n- 1037:                 || \"IllegalTokenText:format\".equals(checkProperty)) {\n- 1038:                 result = \"Regular Expression\";\n- 1039:             }\n- 1040:             else {\n- 1041:                 result = \"Pattern\";\n- 1042:             }\n- 1043:         }\n- 1044:         else if (fieldClass == Pattern[].class) {\n- 1045:             if (\"ImportOrder:groups\".equals(checkProperty)\n- 1046:                 || \"ImportOrder:staticGroups\".equals(checkProperty)\n- 1047:                 || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n- 1048:                 || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n- 1049:                 result = \"Regular Expressions\";\n- 1050:             }\n- 1051:             else {\n- 1052:                 result = \"Pattern[]\";\n- 1053:             }\n- 1054:         }\n- 1055:         else if (fieldClass == Scope.class) {\n- 1056:             result = \"Scope\";\n- 1057:         }\n- 1058:         else if (fieldClass == AccessModifierOption[].class) {\n- 1059:             result = \"AccessModifierOption[]\";\n- 1060:         }\n- 1061:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n- 1062:             result = \"File\";\n- 1063:         }\n- 1064:         else if (fieldClass.isEnum()) {\n- 1065:             result = fieldClass.getSimpleName();\n- 1066:         }\n- 1067:         else {\n- 1068:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n- 1069:         }\n- 1070: \n- 1071:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n- 1072:             result = result + \" in a format of comma separated attribute=value entries. The \"\n- 1073:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n- 1074:         }\n- 1075: \n- 1076:         return result;\n- 1077:     }\n- 1133:                         index++;\n- 1134:                     }\n- 1135: \n- 1136:                     value = newArray;\n- 1137:                 }\n- 1138: \n- 1139:                 if (isPropertyTokenType(sectionName, propertyName)) {\n- 1140:                     boolean first = true;\n- 1141: \n- 1142:                     if (value instanceof BitSet) {\n- 1143:                         final BitSet list = (BitSet) value;\n- 1144:                         final StringBuilder sb = new StringBuilder(20);\n- 1145: \n- 1146:                         for (int i = 0; i < list.size(); i++) {\n- 1147:                             if (list.get(i)) {\n- 1148:                                 if (first) {\n+  997:         else if (fieldClass == Scope.class) {\n+  998:             result = \"Scope\";\n+  999:         }\n+ 1000:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n+ 1001:             result = \"File\";\n+ 1002:         }\n+ 1003:         else if (fieldClass.isEnum()) {\n+ 1004:             result = fieldClass.getSimpleName();\n+ 1005:         }\n+ 1006:         else if (isKnownPropertyType(fieldClass)) {\n+ 1007:             result = fieldClass.getSimpleName();\n+ 1008:         }\n+ 1009:         else {\n+ 1010:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n+ 1011:         }\n+ 1012: \n+ 1013:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n+ 1014:             result = result + \" in a format of comma separated attribute=value entries. The \"\n+ 1015:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n+ 1016:         }\n+ 1017: \n+ 1018:         return result;\n+ 1019:     }\n+ 1020: \n+ 1021:     /**\n+ 1022:      * Checks whether property is a dynamic custom expression.\n+ 1023:      *\n+ 1024:      * @param sectionName the name of the section/module being worked on.\n+ 1025:      * @param propertyName the property name to work with.\n+ 1026:      * @return true if it is a dynamic custom expression.\n+ 1027:      */\n+ 1028:     private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n+ 1029:         return isSuppressionFilter(sectionName)\n+ 1030:                 && (\"checkFormat\".equals(propertyName)\n+ 1031:                 || \"messageFormat\".equals(propertyName)\n+ 1032:                 || \"idFormat\".equals(propertyName)\n+ 1033:                 || \"influenceFormat\".equals(propertyName))\n+ 1034:                 || isRegexpCheck(sectionName)\n+ 1035:                 && \"format\".equals(propertyName);\n+ 1036:     }\n+ 1037: \n+ 1038:     /**\n+ 1039:      * Checks Whether the section is a type of suppression filter.\n+ 1040:      *\n+ 1041:      * @param sectionName the name of the section/module being worked on.\n+ 1042:      * @return true if it is a type of suppression filter.\n+ 1043:      */\n+ 1044:     private static boolean isSuppressionFilter(String sectionName) {\n+ 1045:         return \"SuppressionCommentFilter\".equals(sectionName)\n+ 1046:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n+ 1047:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n+ 1048:     }\n+ 1049: \n+ 1050:     /**\n+ 1051:      * Checks whether the section is a RegexpCheck.\n+ 1052:      *\n+ 1053:      * @param sectionName the name of the section/module being worked on.\n+ 1054:      * @return true if the section is a RegexpCheck.\n+ 1055:      */\n+ 1056:     private static boolean isRegexpCheck(String sectionName) {\n+ 1057:         return \"RegexpMultiline\".equals(sectionName)\n+ 1058:                 || \"RegexpSingleline\".equals(sectionName)\n+ 1059:                 || \"RegexpSinglelineJava\".equals(sectionName);\n+ 1060:     }\n+ 1061: \n+ 1062:     /**\n+ 1063:      * Get's the name of the bean property's type for the Int[] class.\n+ 1064:      *\n+ 1065:      * @param sectionName the name of the section/module being worked on.\n+ 1066:      * @param propertyName the property name to work with.\n+ 1067:      * @return String form of property's type.\n+ 1068:      */\n+ 1069:     private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n+ 1070:         String result = \"int[]\";\n+ 1071:         if (isPropertyTokenType(sectionName, propertyName)) {\n+ 1072:             result = \"subset of tokens TokenTypes\";\n+ 1073:         }\n+ 1074:         return result;\n+ 1075:     }\n+ 1076: \n+ 1077:     /**\n+ 1133:     /**\n+ 1134:      * Get's the name of the bean property's type for the Pattern[] class.\n+ 1135:      *\n+ 1136:      * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n+ 1137:      * @return String form of property's type.\n+ 1138:      */\n+ 1139:     private static String getPropertyTypeNameForPatternArray(String checkProperty) {\n+ 1140:         String result = \"Pattern[]\";\n+ 1141:         if (\"ImportOrder:groups\".equals(checkProperty)\n+ 1142:                 || \"ImportOrder:staticGroups\".equals(checkProperty)\n+ 1143:                 || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n+ 1144:                 || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n+ 1145:             result = \"Regular Expressions\";\n+ 1146:         }\n+ 1147:         return result;\n+ 1148:     }\n", "uniqueId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7_962_1077_1133_1148_962_1019", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nrefactored_method_code\n##########################\n/**\n * Validates the order of rule names and ensures they are in ascending order.\n *\n * @param fileName The name of the file being processed.\n * @param lastRuleName The name of the last rule processed.\n * @param lastRuleNumberParts The parts of the last rule number processed.\n * @param ruleName The name of the current rule being processed.\n * @return The parts of the current rule number being processed.\n */\nprivate String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                       String[] lastRuleNumberParts, String ruleName) {\n    final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n    if (lastRuleName != null) {\n        final int ruleNumberPartsAmount = ruleNumberParts.length;\n        final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n        final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                + \"' is out of order compared to '\" + lastRuleName + \"'\";\n        boolean lastRuleNumberPartWasEqual = false;\n        int partIndex;\n        for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n            if (lastRuleNumberPartsAmount <= partIndex) {\n                // equal up to here and last rule has less parts,\n                // thus order is correct, stop comparing\n                break;\n            }\n\n            final String ruleNumberPart = ruleNumberParts[partIndex];\n            final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n            final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                    ruleNumberPart.chars(),\n                    lastRuleNumberPart.chars()\n            ).allMatch(Character::isDigit);\n\n            if (ruleNumberPartsAreNumeric) {\n                final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                assertThat(outOfOrderReason,\n                        numericRuleNumberPart < numericLastRuleNumberPart,\n                        describedAs(\"'%0' should not be less than '%1'\",\n                                is(false),\n                                numericRuleNumberPart, numericLastRuleNumberPart));\n            } else {\n                assertThat(outOfOrderReason,\n                        ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                        describedAs(\"'%0' should not be less than '%1'\",\n                                is(false),\n                                ruleNumberPart, lastRuleNumberPart));\n            }\n            lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n            if (!lastRuleNumberPartWasEqual) {\n                // number part is not equal but properly ordered,\n                // thus order is correct, stop comparing\n                break;\n            }\n        }\n        if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n            if (lastRuleNumberPartsAmount == partIndex) {\n                fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                        + lastRuleName + \"' have the same rule number\");\n            } else {\n                fail(outOfOrderReason);\n            }\n        }\n    }\n\n    return ruleNumberParts;\n}\n```", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getPropertyTypeNameForPattern(checkProperty String) : String extracted from private getModulePropertyExpectedTypeName(sectionName String, fieldClass Class<?>, instance Object, propertyName String) : String in class com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1077, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1019, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 1115, "endLine": 1131, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "isPureRefactoring": true, "commitId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7", "packageNameBefore": "com.puppycrawl.tools.checkstyle.internal", "classNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "methodNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}", "classSignatureBefore": "public class XdocsPagesTest ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest"], "classSignatureBeforeSet": ["public class XdocsPagesTest "], "purityCheckResultList": [{"isPure": true, "purityComment": " Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks whether property is a dynamic custom expression.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return true if it is a dynamic custom expression.\n     */\n    private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n        return isSuppressionFilter(sectionName)\n                && (\"checkFormat\".equals(propertyName)\n                || \"messageFormat\".equals(propertyName)\n                || \"idFormat\".equals(propertyName)\n                || \"influenceFormat\".equals(propertyName))\n                || isRegexpCheck(sectionName)\n                && \"format\".equals(propertyName);\n    }\n\n    /**\n     * Checks Whether the section is a type of suppression filter.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if it is a type of suppression filter.\n     */\n    private static boolean isSuppressionFilter(String sectionName) {\n        return \"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n    }\n\n    /**\n     * Checks whether the section is a RegexpCheck.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if the section is a RegexpCheck.\n     */\n    private static boolean isRegexpCheck(String sectionName) {\n        return \"RegexpMultiline\".equals(sectionName)\n                || \"RegexpSingleline\".equals(sectionName)\n                || \"RegexpSinglelineJava\".equals(sectionName);\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Int[] class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n        String result = \"int[]\";\n        if (isPropertyTokenType(sectionName, propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForString(String sectionName, String propertyName) {\n        String result = \"String\";\n\n        if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n            result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n        }\n        else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n            result += \" (either the empty string or a lowercase ISO 639 code)\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String[] class.\n     *\n     * @param propertyName the property name to work with.\n     * @param instanceName the simple name of class instance to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForStringArray(\n            String propertyName, String instanceName) {\n        String result = \"String[]\";\n        if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                && \"ignoreOccurrenceContext\".equals(propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPattern(String checkProperty) {\n        String result = \"Pattern\";\n        if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n            result = \"Regular Expression\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern[] class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPatternArray(String checkProperty) {\n        String result = \"Pattern[]\";\n        if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n            result = \"Regular Expressions\";\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether given property is a known property type.\n     *\n     * @param propertyType the bean property's type.\n     * @return true if given property type matches with one of the known property type.\n     */\n    private static boolean isKnownPropertyType(Class<?> propertyType) {\n        return propertyType == int.class\n                || propertyType == boolean.class\n                || propertyType == double[].class\n                || propertyType == URI.class\n                || propertyType == AccessModifierOption[].class;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Get's the name of the bean property's type for the Pattern class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPattern(String checkProperty) {\n        String result = \"Pattern\";\n        if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n            result = \"Regular Expression\";\n        }\n        return result;\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n/**\n     * Get's the name of the bean property's type for the Pattern class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPattern(String checkProperty) {\n        String result = \"Pattern\";\n        if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n            result = \"Regular Expression\";\n        }\n        return result;\n    }", "diffSourceCode": "   962:     /**\n   963:      * Get's the name of the bean property's type for the class.\n   964:      *\n   965:      * @param sectionName The name of the section/module being worked on.\n   966:      * @param fieldClass The bean property's type.\n   967:      * @param instance The class instance to work with.\n   968:      * @param propertyName The property name to work with.\n   969:      * @return String form of property's type.\n-  970:      * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n+  970:      * @noinspection IfStatementWithTooManyBranches\n   971:      */\n   972:     private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n   973:             Object instance, String propertyName) {\n   974:         final String instanceName = instance.getClass().getSimpleName();\n   975:         String result = null;\n   976:         final String checkProperty = sectionName + \":\" + propertyName;\n-  977:         if ((\"SuppressionCommentFilter\".equals(sectionName)\n-  978:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n-  979:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n-  980:                     && (\"checkFormat\".equals(propertyName)\n-  981:                         || \"messageFormat\".equals(propertyName)\n-  982:                         || \"idFormat\".equals(propertyName)\n-  983:                         || \"influenceFormat\".equals(propertyName))\n-  984:                 || (\"RegexpMultiline\".equals(sectionName)\n-  985:                     || \"RegexpSingleline\".equals(sectionName)\n-  986:                     || \"RegexpSinglelineJava\".equals(sectionName))\n-  987:                     && \"format\".equals(propertyName)) {\n-  988:             // dynamic custom expression\n-  989:             result = \"Regular Expression\";\n+  977:         if (isDynamicCustomExpression(sectionName, propertyName)) {\n+  978:             // dynamic custom expression\n+  979:             result = \"Regular Expression\";\n+  980:         }\n+  981:         else if (fieldClass == int[].class) {\n+  982:             result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n+  983:         }\n+  984:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n+  985:             result = getPropertyTypeNameForString(sectionName, propertyName);\n+  986: \n+  987:         }\n+  988:         else if (fieldClass == String[].class) {\n+  989:             result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n   990:         }\n-  991:         else if (fieldClass == boolean.class) {\n-  992:             result = \"boolean\";\n+  991:         else if (fieldClass == Pattern.class) {\n+  992:             result = getPropertyTypeNameForPattern(checkProperty);\n   993:         }\n-  994:         else if (fieldClass == int.class) {\n-  995:             result = \"int\";\n+  994:         else if (fieldClass == Pattern[].class) {\n+  995:             result = getPropertyTypeNameForPatternArray(checkProperty);\n   996:         }\n-  997:         else if (fieldClass == int[].class) {\n-  998:             if (isPropertyTokenType(sectionName, propertyName)) {\n-  999:                 result = \"subset of tokens TokenTypes\";\n- 1000:             }\n- 1001:             else {\n- 1002:                 result = \"int[]\";\n- 1003:             }\n- 1004:         }\n- 1005:         else if (fieldClass == double[].class) {\n- 1006:             result = \"double[]\";\n- 1007:         }\n- 1008:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n- 1009:             result = \"String\";\n- 1010: \n- 1011:             if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n- 1012:                 result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n- 1013:             }\n- 1014:             else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n- 1015:                 result += \" (either the empty string or a lowercase ISO 639 code)\";\n- 1016:             }\n- 1017:         }\n- 1018:         else if (fieldClass == String[].class) {\n- 1019:             if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n- 1020:                     || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n- 1021:                     || \"MultipleStringLiteralsCheck\".equals(instanceName)\n- 1022:                             && \"ignoreOccurrenceContext\".equals(propertyName)) {\n- 1023:                 result = \"subset of tokens TokenTypes\";\n- 1024:             }\n- 1025:             else {\n- 1026:                 result = \"String[]\";\n- 1027:             }\n- 1028:         }\n- 1029:         else if (fieldClass == URI.class) {\n- 1030:             result = \"URI\";\n- 1031:         }\n- 1032:         else if (fieldClass == Pattern.class) {\n- 1033:             if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n- 1034:                 || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n- 1035:                 || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n- 1036:                 || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n- 1037:                 || \"IllegalTokenText:format\".equals(checkProperty)) {\n- 1038:                 result = \"Regular Expression\";\n- 1039:             }\n- 1040:             else {\n- 1041:                 result = \"Pattern\";\n- 1042:             }\n- 1043:         }\n- 1044:         else if (fieldClass == Pattern[].class) {\n- 1045:             if (\"ImportOrder:groups\".equals(checkProperty)\n- 1046:                 || \"ImportOrder:staticGroups\".equals(checkProperty)\n- 1047:                 || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n- 1048:                 || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n- 1049:                 result = \"Regular Expressions\";\n- 1050:             }\n- 1051:             else {\n- 1052:                 result = \"Pattern[]\";\n- 1053:             }\n- 1054:         }\n- 1055:         else if (fieldClass == Scope.class) {\n- 1056:             result = \"Scope\";\n- 1057:         }\n- 1058:         else if (fieldClass == AccessModifierOption[].class) {\n- 1059:             result = \"AccessModifierOption[]\";\n- 1060:         }\n- 1061:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n- 1062:             result = \"File\";\n- 1063:         }\n- 1064:         else if (fieldClass.isEnum()) {\n- 1065:             result = fieldClass.getSimpleName();\n- 1066:         }\n- 1067:         else {\n- 1068:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n- 1069:         }\n- 1070: \n- 1071:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n- 1072:             result = result + \" in a format of comma separated attribute=value entries. The \"\n- 1073:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n- 1074:         }\n- 1075: \n- 1076:         return result;\n- 1077:     }\n- 1115:             }\n- 1116:             else if (fieldClass == int.class) {\n- 1117:                 if (value.equals(Integer.MAX_VALUE)) {\n- 1118:                     result = \"2147483647\";\n- 1119:                 }\n- 1120:                 else {\n- 1121:                     result = value.toString();\n- 1122:                 }\n- 1123:             }\n- 1124:             else if (fieldClass == int[].class) {\n- 1125:                 if (value instanceof Collection) {\n- 1126:                     final Collection<?> collection = (Collection<?>) value;\n- 1127:                     final int[] newArray = new int[collection.size()];\n- 1128:                     final Iterator<?> iterator = collection.iterator();\n- 1129:                     int index = 0;\n- 1130: \n- 1131:                     while (iterator.hasNext()) {\n+  997:         else if (fieldClass == Scope.class) {\n+  998:             result = \"Scope\";\n+  999:         }\n+ 1000:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n+ 1001:             result = \"File\";\n+ 1002:         }\n+ 1003:         else if (fieldClass.isEnum()) {\n+ 1004:             result = fieldClass.getSimpleName();\n+ 1005:         }\n+ 1006:         else if (isKnownPropertyType(fieldClass)) {\n+ 1007:             result = fieldClass.getSimpleName();\n+ 1008:         }\n+ 1009:         else {\n+ 1010:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n+ 1011:         }\n+ 1012: \n+ 1013:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n+ 1014:             result = result + \" in a format of comma separated attribute=value entries. The \"\n+ 1015:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n+ 1016:         }\n+ 1017: \n+ 1018:         return result;\n+ 1019:     }\n+ 1020: \n+ 1021:     /**\n+ 1022:      * Checks whether property is a dynamic custom expression.\n+ 1023:      *\n+ 1024:      * @param sectionName the name of the section/module being worked on.\n+ 1025:      * @param propertyName the property name to work with.\n+ 1026:      * @return true if it is a dynamic custom expression.\n+ 1027:      */\n+ 1028:     private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n+ 1029:         return isSuppressionFilter(sectionName)\n+ 1030:                 && (\"checkFormat\".equals(propertyName)\n+ 1031:                 || \"messageFormat\".equals(propertyName)\n+ 1032:                 || \"idFormat\".equals(propertyName)\n+ 1033:                 || \"influenceFormat\".equals(propertyName))\n+ 1034:                 || isRegexpCheck(sectionName)\n+ 1035:                 && \"format\".equals(propertyName);\n+ 1036:     }\n+ 1037: \n+ 1038:     /**\n+ 1039:      * Checks Whether the section is a type of suppression filter.\n+ 1040:      *\n+ 1041:      * @param sectionName the name of the section/module being worked on.\n+ 1042:      * @return true if it is a type of suppression filter.\n+ 1043:      */\n+ 1044:     private static boolean isSuppressionFilter(String sectionName) {\n+ 1045:         return \"SuppressionCommentFilter\".equals(sectionName)\n+ 1046:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n+ 1047:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n+ 1048:     }\n+ 1049: \n+ 1050:     /**\n+ 1051:      * Checks whether the section is a RegexpCheck.\n+ 1052:      *\n+ 1053:      * @param sectionName the name of the section/module being worked on.\n+ 1054:      * @return true if the section is a RegexpCheck.\n+ 1055:      */\n+ 1056:     private static boolean isRegexpCheck(String sectionName) {\n+ 1057:         return \"RegexpMultiline\".equals(sectionName)\n+ 1058:                 || \"RegexpSingleline\".equals(sectionName)\n+ 1059:                 || \"RegexpSinglelineJava\".equals(sectionName);\n+ 1060:     }\n+ 1061: \n+ 1062:     /**\n+ 1063:      * Get's the name of the bean property's type for the Int[] class.\n+ 1064:      *\n+ 1065:      * @param sectionName the name of the section/module being worked on.\n+ 1066:      * @param propertyName the property name to work with.\n+ 1067:      * @return String form of property's type.\n+ 1068:      */\n+ 1069:     private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n+ 1070:         String result = \"int[]\";\n+ 1071:         if (isPropertyTokenType(sectionName, propertyName)) {\n+ 1072:             result = \"subset of tokens TokenTypes\";\n+ 1073:         }\n+ 1074:         return result;\n+ 1075:     }\n+ 1076: \n+ 1077:     /**\n+ 1115:     /**\n+ 1116:      * Get's the name of the bean property's type for the Pattern class.\n+ 1117:      *\n+ 1118:      * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n+ 1119:      * @return String form of property's type.\n+ 1120:      */\n+ 1121:     private static String getPropertyTypeNameForPattern(String checkProperty) {\n+ 1122:         String result = \"Pattern\";\n+ 1123:         if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n+ 1124:                 || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n+ 1125:                 || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n+ 1126:                 || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n+ 1127:                 || \"IllegalTokenText:format\".equals(checkProperty)) {\n+ 1128:             result = \"Regular Expression\";\n+ 1129:         }\n+ 1130:         return result;\n+ 1131:     }\n", "uniqueId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7_962_1077_1115_1131_962_1019", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nrefactored_method_code\n##########################\n\nprivate static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (field", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getPropertyTypeNameForStringArray(propertyName String, instanceName String) : String extracted from private getModulePropertyExpectedTypeName(sectionName String, fieldClass Class<?>, instance Object, propertyName String) : String in class com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1077, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1019, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 1096, "endLine": 1113, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "isPureRefactoring": true, "commitId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7", "packageNameBefore": "com.puppycrawl.tools.checkstyle.internal", "classNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "methodNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}", "classSignatureBefore": "public class XdocsPagesTest ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest"], "classSignatureBeforeSet": ["public class XdocsPagesTest "], "purityCheckResultList": [{"isPure": true, "purityComment": " Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks whether property is a dynamic custom expression.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return true if it is a dynamic custom expression.\n     */\n    private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n        return isSuppressionFilter(sectionName)\n                && (\"checkFormat\".equals(propertyName)\n                || \"messageFormat\".equals(propertyName)\n                || \"idFormat\".equals(propertyName)\n                || \"influenceFormat\".equals(propertyName))\n                || isRegexpCheck(sectionName)\n                && \"format\".equals(propertyName);\n    }\n\n    /**\n     * Checks Whether the section is a type of suppression filter.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if it is a type of suppression filter.\n     */\n    private static boolean isSuppressionFilter(String sectionName) {\n        return \"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n    }\n\n    /**\n     * Checks whether the section is a RegexpCheck.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if the section is a RegexpCheck.\n     */\n    private static boolean isRegexpCheck(String sectionName) {\n        return \"RegexpMultiline\".equals(sectionName)\n                || \"RegexpSingleline\".equals(sectionName)\n                || \"RegexpSinglelineJava\".equals(sectionName);\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Int[] class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n        String result = \"int[]\";\n        if (isPropertyTokenType(sectionName, propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForString(String sectionName, String propertyName) {\n        String result = \"String\";\n\n        if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n            result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n        }\n        else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n            result += \" (either the empty string or a lowercase ISO 639 code)\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String[] class.\n     *\n     * @param propertyName the property name to work with.\n     * @param instanceName the simple name of class instance to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForStringArray(\n            String propertyName, String instanceName) {\n        String result = \"String[]\";\n        if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                && \"ignoreOccurrenceContext\".equals(propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPattern(String checkProperty) {\n        String result = \"Pattern\";\n        if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n            result = \"Regular Expression\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern[] class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPatternArray(String checkProperty) {\n        String result = \"Pattern[]\";\n        if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n            result = \"Regular Expressions\";\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether given property is a known property type.\n     *\n     * @param propertyType the bean property's type.\n     * @return true if given property type matches with one of the known property type.\n     */\n    private static boolean isKnownPropertyType(Class<?> propertyType) {\n        return propertyType == int.class\n                || propertyType == boolean.class\n                || propertyType == double[].class\n                || propertyType == URI.class\n                || propertyType == AccessModifierOption[].class;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Get's the name of the bean property's type for the String[] class.\n     *\n     * @param propertyName the property name to work with.\n     * @param instanceName the simple name of class instance to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForStringArray(\n            String propertyName, String instanceName) {\n        String result = \"String[]\";\n        if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                && \"ignoreOccurrenceContext\".equals(propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n/**\n     * Get's the name of the bean property's type for the String[] class.\n     *\n     * @param propertyName the property name to work with.\n     * @param instanceName the simple name of class instance to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForStringArray(\n            String propertyName, String instanceName) {\n        String result = \"String[]\";\n        if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                && \"ignoreOccurrenceContext\".equals(propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }", "diffSourceCode": "   962:     /**\n   963:      * Get's the name of the bean property's type for the class.\n   964:      *\n   965:      * @param sectionName The name of the section/module being worked on.\n   966:      * @param fieldClass The bean property's type.\n   967:      * @param instance The class instance to work with.\n   968:      * @param propertyName The property name to work with.\n   969:      * @return String form of property's type.\n-  970:      * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n+  970:      * @noinspection IfStatementWithTooManyBranches\n   971:      */\n   972:     private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n   973:             Object instance, String propertyName) {\n   974:         final String instanceName = instance.getClass().getSimpleName();\n   975:         String result = null;\n   976:         final String checkProperty = sectionName + \":\" + propertyName;\n-  977:         if ((\"SuppressionCommentFilter\".equals(sectionName)\n-  978:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n-  979:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n-  980:                     && (\"checkFormat\".equals(propertyName)\n-  981:                         || \"messageFormat\".equals(propertyName)\n-  982:                         || \"idFormat\".equals(propertyName)\n-  983:                         || \"influenceFormat\".equals(propertyName))\n-  984:                 || (\"RegexpMultiline\".equals(sectionName)\n-  985:                     || \"RegexpSingleline\".equals(sectionName)\n-  986:                     || \"RegexpSinglelineJava\".equals(sectionName))\n-  987:                     && \"format\".equals(propertyName)) {\n-  988:             // dynamic custom expression\n-  989:             result = \"Regular Expression\";\n+  977:         if (isDynamicCustomExpression(sectionName, propertyName)) {\n+  978:             // dynamic custom expression\n+  979:             result = \"Regular Expression\";\n+  980:         }\n+  981:         else if (fieldClass == int[].class) {\n+  982:             result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n+  983:         }\n+  984:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n+  985:             result = getPropertyTypeNameForString(sectionName, propertyName);\n+  986: \n+  987:         }\n+  988:         else if (fieldClass == String[].class) {\n+  989:             result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n   990:         }\n-  991:         else if (fieldClass == boolean.class) {\n-  992:             result = \"boolean\";\n+  991:         else if (fieldClass == Pattern.class) {\n+  992:             result = getPropertyTypeNameForPattern(checkProperty);\n   993:         }\n-  994:         else if (fieldClass == int.class) {\n-  995:             result = \"int\";\n+  994:         else if (fieldClass == Pattern[].class) {\n+  995:             result = getPropertyTypeNameForPatternArray(checkProperty);\n   996:         }\n-  997:         else if (fieldClass == int[].class) {\n-  998:             if (isPropertyTokenType(sectionName, propertyName)) {\n-  999:                 result = \"subset of tokens TokenTypes\";\n- 1000:             }\n- 1001:             else {\n- 1002:                 result = \"int[]\";\n- 1003:             }\n- 1004:         }\n- 1005:         else if (fieldClass == double[].class) {\n- 1006:             result = \"double[]\";\n- 1007:         }\n- 1008:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n- 1009:             result = \"String\";\n- 1010: \n- 1011:             if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n- 1012:                 result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n- 1013:             }\n- 1014:             else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n- 1015:                 result += \" (either the empty string or a lowercase ISO 639 code)\";\n- 1016:             }\n- 1017:         }\n- 1018:         else if (fieldClass == String[].class) {\n- 1019:             if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n- 1020:                     || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n- 1021:                     || \"MultipleStringLiteralsCheck\".equals(instanceName)\n- 1022:                             && \"ignoreOccurrenceContext\".equals(propertyName)) {\n- 1023:                 result = \"subset of tokens TokenTypes\";\n- 1024:             }\n- 1025:             else {\n- 1026:                 result = \"String[]\";\n- 1027:             }\n- 1028:         }\n- 1029:         else if (fieldClass == URI.class) {\n- 1030:             result = \"URI\";\n- 1031:         }\n- 1032:         else if (fieldClass == Pattern.class) {\n- 1033:             if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n- 1034:                 || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n- 1035:                 || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n- 1036:                 || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n- 1037:                 || \"IllegalTokenText:format\".equals(checkProperty)) {\n- 1038:                 result = \"Regular Expression\";\n- 1039:             }\n- 1040:             else {\n- 1041:                 result = \"Pattern\";\n- 1042:             }\n- 1043:         }\n- 1044:         else if (fieldClass == Pattern[].class) {\n- 1045:             if (\"ImportOrder:groups\".equals(checkProperty)\n- 1046:                 || \"ImportOrder:staticGroups\".equals(checkProperty)\n- 1047:                 || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n- 1048:                 || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n- 1049:                 result = \"Regular Expressions\";\n- 1050:             }\n- 1051:             else {\n- 1052:                 result = \"Pattern[]\";\n- 1053:             }\n- 1054:         }\n- 1055:         else if (fieldClass == Scope.class) {\n- 1056:             result = \"Scope\";\n- 1057:         }\n- 1058:         else if (fieldClass == AccessModifierOption[].class) {\n- 1059:             result = \"AccessModifierOption[]\";\n- 1060:         }\n- 1061:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n- 1062:             result = \"File\";\n- 1063:         }\n- 1064:         else if (fieldClass.isEnum()) {\n- 1065:             result = fieldClass.getSimpleName();\n- 1066:         }\n- 1067:         else {\n- 1068:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n- 1069:         }\n- 1070: \n- 1071:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n- 1072:             result = result + \" in a format of comma separated attribute=value entries. The \"\n- 1073:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n- 1074:         }\n- 1075: \n- 1076:         return result;\n- 1077:     }\n- 1096: \n- 1097:             // noinspection IfStatementWithTooManyBranches\n- 1098:             if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n- 1099:                 result = \"default locale country for the Java Virtual Machine\";\n- 1100:             }\n- 1101:             else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n- 1102:                 result = \"default locale language for the Java Virtual Machine\";\n- 1103:             }\n- 1104:             else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n- 1105:                 result = \"UTF-8\";\n- 1106:             }\n- 1107:             else if (\"charset\".equals(propertyName)) {\n- 1108:                 result = \"the charset property of the parent Checker module\";\n- 1109:             }\n- 1110:             else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n- 1111:                 result = \"null (no cache file)\";\n- 1112:             }\n- 1113:             else if (fieldClass == boolean.class) {\n+  997:         else if (fieldClass == Scope.class) {\n+  998:             result = \"Scope\";\n+  999:         }\n+ 1000:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n+ 1001:             result = \"File\";\n+ 1002:         }\n+ 1003:         else if (fieldClass.isEnum()) {\n+ 1004:             result = fieldClass.getSimpleName();\n+ 1005:         }\n+ 1006:         else if (isKnownPropertyType(fieldClass)) {\n+ 1007:             result = fieldClass.getSimpleName();\n+ 1008:         }\n+ 1009:         else {\n+ 1010:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n+ 1011:         }\n+ 1012: \n+ 1013:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n+ 1014:             result = result + \" in a format of comma separated attribute=value entries. The \"\n+ 1015:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n+ 1016:         }\n+ 1017: \n+ 1018:         return result;\n+ 1019:     }\n+ 1020: \n+ 1021:     /**\n+ 1022:      * Checks whether property is a dynamic custom expression.\n+ 1023:      *\n+ 1024:      * @param sectionName the name of the section/module being worked on.\n+ 1025:      * @param propertyName the property name to work with.\n+ 1026:      * @return true if it is a dynamic custom expression.\n+ 1027:      */\n+ 1028:     private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n+ 1029:         return isSuppressionFilter(sectionName)\n+ 1030:                 && (\"checkFormat\".equals(propertyName)\n+ 1031:                 || \"messageFormat\".equals(propertyName)\n+ 1032:                 || \"idFormat\".equals(propertyName)\n+ 1033:                 || \"influenceFormat\".equals(propertyName))\n+ 1034:                 || isRegexpCheck(sectionName)\n+ 1035:                 && \"format\".equals(propertyName);\n+ 1036:     }\n+ 1037: \n+ 1038:     /**\n+ 1039:      * Checks Whether the section is a type of suppression filter.\n+ 1040:      *\n+ 1041:      * @param sectionName the name of the section/module being worked on.\n+ 1042:      * @return true if it is a type of suppression filter.\n+ 1043:      */\n+ 1044:     private static boolean isSuppressionFilter(String sectionName) {\n+ 1045:         return \"SuppressionCommentFilter\".equals(sectionName)\n+ 1046:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n+ 1047:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n+ 1048:     }\n+ 1049: \n+ 1050:     /**\n+ 1051:      * Checks whether the section is a RegexpCheck.\n+ 1052:      *\n+ 1053:      * @param sectionName the name of the section/module being worked on.\n+ 1054:      * @return true if the section is a RegexpCheck.\n+ 1055:      */\n+ 1056:     private static boolean isRegexpCheck(String sectionName) {\n+ 1057:         return \"RegexpMultiline\".equals(sectionName)\n+ 1058:                 || \"RegexpSingleline\".equals(sectionName)\n+ 1059:                 || \"RegexpSinglelineJava\".equals(sectionName);\n+ 1060:     }\n+ 1061: \n+ 1062:     /**\n+ 1063:      * Get's the name of the bean property's type for the Int[] class.\n+ 1064:      *\n+ 1065:      * @param sectionName the name of the section/module being worked on.\n+ 1066:      * @param propertyName the property name to work with.\n+ 1067:      * @return String form of property's type.\n+ 1068:      */\n+ 1069:     private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n+ 1070:         String result = \"int[]\";\n+ 1071:         if (isPropertyTokenType(sectionName, propertyName)) {\n+ 1072:             result = \"subset of tokens TokenTypes\";\n+ 1073:         }\n+ 1074:         return result;\n+ 1075:     }\n+ 1076: \n+ 1077:     /**\n+ 1096:     /**\n+ 1097:      * Get's the name of the bean property's type for the String[] class.\n+ 1098:      *\n+ 1099:      * @param propertyName the property name to work with.\n+ 1100:      * @param instanceName the simple name of class instance to work with.\n+ 1101:      * @return String form of property's type.\n+ 1102:      */\n+ 1103:     private static String getPropertyTypeNameForStringArray(\n+ 1104:             String propertyName, String instanceName) {\n+ 1105:         String result = \"String[]\";\n+ 1106:         if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n+ 1107:                 || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n+ 1108:                 || \"MultipleStringLiteralsCheck\".equals(instanceName)\n+ 1109:                 && \"ignoreOccurrenceContext\".equals(propertyName)) {\n+ 1110:             result = \"subset of tokens TokenTypes\";\n+ 1111:         }\n+ 1112:         return result;\n+ 1113:     }\n", "uniqueId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7_962_1077_1096_1113_962_1019", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nrefactored_method_code\n##########################\n\n/**\n * Validates the order of rule names and ensures they are in ascending order.\n *\n * @param fileName The name of the file being processed.\n * @param lastRuleName The name of the last rule processed.\n * @param lastRuleNumberParts The parts of the last rule number processed.\n * @param ruleName The name of the current rule being processed.\n * @return The parts of the current rule number being processed.\n */\nprivate static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                              String[] lastRuleNumberParts, String ruleName) {\n    final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n    if (lastRuleName != null) {\n        final int ruleNumberPartsAmount = ruleNumberParts.length;\n        final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n        final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                + \"' is out of order compared to '\" + lastRuleName + \"'\";\n        boolean lastRuleNumberPartWasEqual = false;\n        int partIndex;\n        for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n            if (lastRuleNumberPartsAmount <= partIndex) {\n                // equal up to here and last rule has less parts,\n                // thus order is correct, stop comparing\n                break;\n            }\n\n            final String ruleNumberPart = ruleNumberParts[partIndex];\n            final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n            final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                    ruleNumberPart.chars(),\n                    lastRuleNumberPart.chars()\n            ).allMatch(Character::isDigit);\n\n            if (ruleNumberPartsAreNumeric) {\n                final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                assertThat(outOfOrderReason,\n                        numericRuleNumberPart < numericLastRuleNumberPart,\n                        describedAs(\"'%0' should not be less than '%1'\",\n                                is(false),\n                                numericRuleNumberPart, numericLastRuleNumberPart));\n            } else {\n                assertThat(outOfOrderReason,\n                        ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                        describedAs(\"'%0' should not be less than '%1'\",\n                                is(false),\n                                ruleNumberPart, lastRuleNumberPart));\n            }\n            lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n            if (!lastRuleNumberPartWasEqual) {\n                // number part is not equal but properly ordered,\n                // thus order is correct, stop comparing\n                break;\n            }\n        }\n        if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n            if (lastRuleNumberPartsAmount == partIndex) {\n                fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                        + lastRuleName + \"' have the same rule number\");\n            } else {\n                fail(outOfOrderReason);\n            }\n        }\n    }\n\n    return ruleNumberParts;\n}\n```", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getPropertyTypeNameForString(sectionName String, propertyName String) : String extracted from private getModulePropertyExpectedTypeName(sectionName String, fieldClass Class<?>, instance Object, propertyName String) : String in class com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1077, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1019, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 1077, "endLine": 1094, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "isPureRefactoring": true, "commitId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7", "packageNameBefore": "com.puppycrawl.tools.checkstyle.internal", "classNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "methodNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}", "classSignatureBefore": "public class XdocsPagesTest ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest"], "classSignatureBeforeSet": ["public class XdocsPagesTest "], "purityCheckResultList": [{"isPure": true, "purityComment": " Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks whether property is a dynamic custom expression.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return true if it is a dynamic custom expression.\n     */\n    private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n        return isSuppressionFilter(sectionName)\n                && (\"checkFormat\".equals(propertyName)\n                || \"messageFormat\".equals(propertyName)\n                || \"idFormat\".equals(propertyName)\n                || \"influenceFormat\".equals(propertyName))\n                || isRegexpCheck(sectionName)\n                && \"format\".equals(propertyName);\n    }\n\n    /**\n     * Checks Whether the section is a type of suppression filter.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if it is a type of suppression filter.\n     */\n    private static boolean isSuppressionFilter(String sectionName) {\n        return \"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n    }\n\n    /**\n     * Checks whether the section is a RegexpCheck.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if the section is a RegexpCheck.\n     */\n    private static boolean isRegexpCheck(String sectionName) {\n        return \"RegexpMultiline\".equals(sectionName)\n                || \"RegexpSingleline\".equals(sectionName)\n                || \"RegexpSinglelineJava\".equals(sectionName);\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Int[] class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n        String result = \"int[]\";\n        if (isPropertyTokenType(sectionName, propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForString(String sectionName, String propertyName) {\n        String result = \"String\";\n\n        if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n            result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n        }\n        else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n            result += \" (either the empty string or a lowercase ISO 639 code)\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String[] class.\n     *\n     * @param propertyName the property name to work with.\n     * @param instanceName the simple name of class instance to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForStringArray(\n            String propertyName, String instanceName) {\n        String result = \"String[]\";\n        if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                && \"ignoreOccurrenceContext\".equals(propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPattern(String checkProperty) {\n        String result = \"Pattern\";\n        if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n            result = \"Regular Expression\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern[] class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPatternArray(String checkProperty) {\n        String result = \"Pattern[]\";\n        if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n            result = \"Regular Expressions\";\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether given property is a known property type.\n     *\n     * @param propertyType the bean property's type.\n     * @return true if given property type matches with one of the known property type.\n     */\n    private static boolean isKnownPropertyType(Class<?> propertyType) {\n        return propertyType == int.class\n                || propertyType == boolean.class\n                || propertyType == double[].class\n                || propertyType == URI.class\n                || propertyType == AccessModifierOption[].class;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Get's the name of the bean property's type for the String class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForString(String sectionName, String propertyName) {\n        String result = \"String\";\n\n        if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n            result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n        }\n        else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n            result += \" (either the empty string or a lowercase ISO 639 code)\";\n        }\n        return result;\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n/**\n     * Get's the name of the bean property's type for the String class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForString(String sectionName, String propertyName) {\n        String result = \"String\";\n\n        if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n            result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n        }\n        else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n            result += \" (either the empty string or a lowercase ISO 639 code)\";\n        }\n        return result;\n    }", "diffSourceCode": "   962:     /**\n   963:      * Get's the name of the bean property's type for the class.\n   964:      *\n   965:      * @param sectionName The name of the section/module being worked on.\n   966:      * @param fieldClass The bean property's type.\n   967:      * @param instance The class instance to work with.\n   968:      * @param propertyName The property name to work with.\n   969:      * @return String form of property's type.\n-  970:      * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n+  970:      * @noinspection IfStatementWithTooManyBranches\n   971:      */\n   972:     private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n   973:             Object instance, String propertyName) {\n   974:         final String instanceName = instance.getClass().getSimpleName();\n   975:         String result = null;\n   976:         final String checkProperty = sectionName + \":\" + propertyName;\n-  977:         if ((\"SuppressionCommentFilter\".equals(sectionName)\n-  978:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n-  979:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n-  980:                     && (\"checkFormat\".equals(propertyName)\n-  981:                         || \"messageFormat\".equals(propertyName)\n-  982:                         || \"idFormat\".equals(propertyName)\n-  983:                         || \"influenceFormat\".equals(propertyName))\n-  984:                 || (\"RegexpMultiline\".equals(sectionName)\n-  985:                     || \"RegexpSingleline\".equals(sectionName)\n-  986:                     || \"RegexpSinglelineJava\".equals(sectionName))\n-  987:                     && \"format\".equals(propertyName)) {\n-  988:             // dynamic custom expression\n-  989:             result = \"Regular Expression\";\n+  977:         if (isDynamicCustomExpression(sectionName, propertyName)) {\n+  978:             // dynamic custom expression\n+  979:             result = \"Regular Expression\";\n+  980:         }\n+  981:         else if (fieldClass == int[].class) {\n+  982:             result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n+  983:         }\n+  984:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n+  985:             result = getPropertyTypeNameForString(sectionName, propertyName);\n+  986: \n+  987:         }\n+  988:         else if (fieldClass == String[].class) {\n+  989:             result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n   990:         }\n-  991:         else if (fieldClass == boolean.class) {\n-  992:             result = \"boolean\";\n+  991:         else if (fieldClass == Pattern.class) {\n+  992:             result = getPropertyTypeNameForPattern(checkProperty);\n   993:         }\n-  994:         else if (fieldClass == int.class) {\n-  995:             result = \"int\";\n+  994:         else if (fieldClass == Pattern[].class) {\n+  995:             result = getPropertyTypeNameForPatternArray(checkProperty);\n   996:         }\n-  997:         else if (fieldClass == int[].class) {\n-  998:             if (isPropertyTokenType(sectionName, propertyName)) {\n-  999:                 result = \"subset of tokens TokenTypes\";\n- 1000:             }\n- 1001:             else {\n- 1002:                 result = \"int[]\";\n- 1003:             }\n- 1004:         }\n- 1005:         else if (fieldClass == double[].class) {\n- 1006:             result = \"double[]\";\n- 1007:         }\n- 1008:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n- 1009:             result = \"String\";\n- 1010: \n- 1011:             if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n- 1012:                 result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n- 1013:             }\n- 1014:             else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n- 1015:                 result += \" (either the empty string or a lowercase ISO 639 code)\";\n- 1016:             }\n- 1017:         }\n- 1018:         else if (fieldClass == String[].class) {\n- 1019:             if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n- 1020:                     || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n- 1021:                     || \"MultipleStringLiteralsCheck\".equals(instanceName)\n- 1022:                             && \"ignoreOccurrenceContext\".equals(propertyName)) {\n- 1023:                 result = \"subset of tokens TokenTypes\";\n- 1024:             }\n- 1025:             else {\n- 1026:                 result = \"String[]\";\n- 1027:             }\n- 1028:         }\n- 1029:         else if (fieldClass == URI.class) {\n- 1030:             result = \"URI\";\n- 1031:         }\n- 1032:         else if (fieldClass == Pattern.class) {\n- 1033:             if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n- 1034:                 || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n- 1035:                 || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n- 1036:                 || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n- 1037:                 || \"IllegalTokenText:format\".equals(checkProperty)) {\n- 1038:                 result = \"Regular Expression\";\n- 1039:             }\n- 1040:             else {\n- 1041:                 result = \"Pattern\";\n- 1042:             }\n- 1043:         }\n- 1044:         else if (fieldClass == Pattern[].class) {\n- 1045:             if (\"ImportOrder:groups\".equals(checkProperty)\n- 1046:                 || \"ImportOrder:staticGroups\".equals(checkProperty)\n- 1047:                 || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n- 1048:                 || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n- 1049:                 result = \"Regular Expressions\";\n- 1050:             }\n- 1051:             else {\n- 1052:                 result = \"Pattern[]\";\n- 1053:             }\n- 1054:         }\n- 1055:         else if (fieldClass == Scope.class) {\n- 1056:             result = \"Scope\";\n- 1057:         }\n- 1058:         else if (fieldClass == AccessModifierOption[].class) {\n- 1059:             result = \"AccessModifierOption[]\";\n- 1060:         }\n- 1061:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n- 1062:             result = \"File\";\n- 1063:         }\n- 1064:         else if (fieldClass.isEnum()) {\n- 1065:             result = fieldClass.getSimpleName();\n- 1066:         }\n- 1067:         else {\n- 1068:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n- 1069:         }\n- 1070: \n- 1071:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n- 1072:             result = result + \" in a format of comma separated attribute=value entries. The \"\n- 1073:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n- 1074:         }\n- 1075: \n- 1076:         return result;\n- 1077:     }\n- 1078: \n- 1079:     /**\n- 1080:      * Get's the name of the bean property's default value for the class.\n- 1081:      *\n- 1082:      * @param sectionName The name of the section/module being worked on.\n- 1083:      * @param propertyName The property name to work with.\n- 1084:      * @param field The bean property's field.\n- 1085:      * @param fieldClass The bean property's type.\n- 1086:      * @param instance The class instance to work with.\n- 1087:      * @return String form of property's default value.\n- 1088:      * @noinspection OverlyNestedMethod\n- 1089:      */\n- 1090:     private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n- 1091:             Field field, Class<?> fieldClass, Object instance) throws Exception {\n- 1092:         String result = null;\n- 1093: \n- 1094:         if (field != null) {\n+  997:         else if (fieldClass == Scope.class) {\n+  998:             result = \"Scope\";\n+  999:         }\n+ 1000:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n+ 1001:             result = \"File\";\n+ 1002:         }\n+ 1003:         else if (fieldClass.isEnum()) {\n+ 1004:             result = fieldClass.getSimpleName();\n+ 1005:         }\n+ 1006:         else if (isKnownPropertyType(fieldClass)) {\n+ 1007:             result = fieldClass.getSimpleName();\n+ 1008:         }\n+ 1009:         else {\n+ 1010:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n+ 1011:         }\n+ 1012: \n+ 1013:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n+ 1014:             result = result + \" in a format of comma separated attribute=value entries. The \"\n+ 1015:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n+ 1016:         }\n+ 1017: \n+ 1018:         return result;\n+ 1019:     }\n+ 1020: \n+ 1021:     /**\n+ 1022:      * Checks whether property is a dynamic custom expression.\n+ 1023:      *\n+ 1024:      * @param sectionName the name of the section/module being worked on.\n+ 1025:      * @param propertyName the property name to work with.\n+ 1026:      * @return true if it is a dynamic custom expression.\n+ 1027:      */\n+ 1028:     private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n+ 1029:         return isSuppressionFilter(sectionName)\n+ 1030:                 && (\"checkFormat\".equals(propertyName)\n+ 1031:                 || \"messageFormat\".equals(propertyName)\n+ 1032:                 || \"idFormat\".equals(propertyName)\n+ 1033:                 || \"influenceFormat\".equals(propertyName))\n+ 1034:                 || isRegexpCheck(sectionName)\n+ 1035:                 && \"format\".equals(propertyName);\n+ 1036:     }\n+ 1037: \n+ 1038:     /**\n+ 1039:      * Checks Whether the section is a type of suppression filter.\n+ 1040:      *\n+ 1041:      * @param sectionName the name of the section/module being worked on.\n+ 1042:      * @return true if it is a type of suppression filter.\n+ 1043:      */\n+ 1044:     private static boolean isSuppressionFilter(String sectionName) {\n+ 1045:         return \"SuppressionCommentFilter\".equals(sectionName)\n+ 1046:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n+ 1047:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n+ 1048:     }\n+ 1049: \n+ 1050:     /**\n+ 1051:      * Checks whether the section is a RegexpCheck.\n+ 1052:      *\n+ 1053:      * @param sectionName the name of the section/module being worked on.\n+ 1054:      * @return true if the section is a RegexpCheck.\n+ 1055:      */\n+ 1056:     private static boolean isRegexpCheck(String sectionName) {\n+ 1057:         return \"RegexpMultiline\".equals(sectionName)\n+ 1058:                 || \"RegexpSingleline\".equals(sectionName)\n+ 1059:                 || \"RegexpSinglelineJava\".equals(sectionName);\n+ 1060:     }\n+ 1061: \n+ 1062:     /**\n+ 1063:      * Get's the name of the bean property's type for the Int[] class.\n+ 1064:      *\n+ 1065:      * @param sectionName the name of the section/module being worked on.\n+ 1066:      * @param propertyName the property name to work with.\n+ 1067:      * @return String form of property's type.\n+ 1068:      */\n+ 1069:     private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n+ 1070:         String result = \"int[]\";\n+ 1071:         if (isPropertyTokenType(sectionName, propertyName)) {\n+ 1072:             result = \"subset of tokens TokenTypes\";\n+ 1073:         }\n+ 1074:         return result;\n+ 1075:     }\n+ 1076: \n+ 1077:     /**\n+ 1078:      * Get's the name of the bean property's type for the String class.\n+ 1079:      *\n+ 1080:      * @param sectionName the name of the section/module being worked on.\n+ 1081:      * @param propertyName the property name to work with.\n+ 1082:      * @return String form of property's type.\n+ 1083:      */\n+ 1084:     private static String getPropertyTypeNameForString(String sectionName, String propertyName) {\n+ 1085:         String result = \"String\";\n+ 1086: \n+ 1087:         if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n+ 1088:             result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n+ 1089:         }\n+ 1090:         else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n+ 1091:             result += \" (either the empty string or a lowercase ISO 639 code)\";\n+ 1092:         }\n+ 1093:         return result;\n+ 1094:     }\n", "uniqueId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7_962_1077_1077_1094_962_1019", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nrefactored_method_code\n##########################\n\nprivate static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (field", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getPropertyTypeNameForIntArray(sectionName String, propertyName String) : String extracted from private getModulePropertyExpectedTypeName(sectionName String, fieldClass Class<?>, instance Object, propertyName String) : String in class com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1077, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 962, "endLine": 1019, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "startLine": 1062, "endLine": 1075, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "isPureRefactoring": true, "commitId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7", "packageNameBefore": "com.puppycrawl.tools.checkstyle.internal", "classNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest", "methodNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}", "classSignatureBefore": "public class XdocsPagesTest ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#getModulePropertyExpectedTypeName"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest"], "classSignatureBeforeSet": ["public class XdocsPagesTest "], "purityCheckResultList": [{"isPure": true, "purityComment": " Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks whether property is a dynamic custom expression.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return true if it is a dynamic custom expression.\n     */\n    private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n        return isSuppressionFilter(sectionName)\n                && (\"checkFormat\".equals(propertyName)\n                || \"messageFormat\".equals(propertyName)\n                || \"idFormat\".equals(propertyName)\n                || \"influenceFormat\".equals(propertyName))\n                || isRegexpCheck(sectionName)\n                && \"format\".equals(propertyName);\n    }\n\n    /**\n     * Checks Whether the section is a type of suppression filter.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if it is a type of suppression filter.\n     */\n    private static boolean isSuppressionFilter(String sectionName) {\n        return \"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n    }\n\n    /**\n     * Checks whether the section is a RegexpCheck.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @return true if the section is a RegexpCheck.\n     */\n    private static boolean isRegexpCheck(String sectionName) {\n        return \"RegexpMultiline\".equals(sectionName)\n                || \"RegexpSingleline\".equals(sectionName)\n                || \"RegexpSinglelineJava\".equals(sectionName);\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Int[] class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n        String result = \"int[]\";\n        if (isPropertyTokenType(sectionName, propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForString(String sectionName, String propertyName) {\n        String result = \"String\";\n\n        if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n            result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n        }\n        else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n            result += \" (either the empty string or a lowercase ISO 639 code)\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the String[] class.\n     *\n     * @param propertyName the property name to work with.\n     * @param instanceName the simple name of class instance to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForStringArray(\n            String propertyName, String instanceName) {\n        String result = \"String[]\";\n        if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                && \"ignoreOccurrenceContext\".equals(propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPattern(String checkProperty) {\n        String result = \"Pattern\";\n        if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n            result = \"Regular Expression\";\n        }\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's type for the Pattern[] class.\n     *\n     * @param checkProperty \"sectionName:propertyName\" of the current check under process.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForPatternArray(String checkProperty) {\n        String result = \"Pattern[]\";\n        if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n            result = \"Regular Expressions\";\n        }\n        return result;\n    }\n\n    /**\n     * Checks whether given property is a known property type.\n     *\n     * @param propertyType the bean property's type.\n     * @return true if given property type matches with one of the known property type.\n     */\n    private static boolean isKnownPropertyType(Class<?> propertyType) {\n        return propertyType == int.class\n                || propertyType == boolean.class\n                || propertyType == double[].class\n                || propertyType == URI.class\n                || propertyType == AccessModifierOption[].class;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Get's the name of the bean property's type for the Int[] class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n        String result = \"int[]\";\n        if (isPropertyTokenType(sectionName, propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsPagesTest#isPropertyTokenType\n methodBody: private static boolean isPropertyTokenType(String sectionName, String propertyName) {\nreturn \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName) || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName) || \"MagicNumber\".equals(sectionName) && \"constantWaiverParentToken\".equals(propertyName) || \"MultipleStringLiterals\".equals(sectionName) && \"ignoreOccurrenceContext\".equals(propertyName) || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if (isDynamicCustomExpression(sectionName, propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == int[].class) {\n            result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = getPropertyTypeNameForString(sectionName, propertyName);\n\n        }\n        else if (fieldClass == String[].class) {\n            result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n        }\n        else if (fieldClass == Pattern.class) {\n            result = getPropertyTypeNameForPattern(checkProperty);\n        }\n        else if (fieldClass == Pattern[].class) {\n            result = getPropertyTypeNameForPatternArray(checkProperty);\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else if (isKnownPropertyType(fieldClass)) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n/**\n     * Get's the name of the bean property's type for the Int[] class.\n     *\n     * @param sectionName the name of the section/module being worked on.\n     * @param propertyName the property name to work with.\n     * @return String form of property's type.\n     */\n    private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n        String result = \"int[]\";\n        if (isPropertyTokenType(sectionName, propertyName)) {\n            result = \"subset of tokens TokenTypes\";\n        }\n        return result;\n    }", "diffSourceCode": "   962:     /**\n   963:      * Get's the name of the bean property's type for the class.\n   964:      *\n   965:      * @param sectionName The name of the section/module being worked on.\n   966:      * @param fieldClass The bean property's type.\n   967:      * @param instance The class instance to work with.\n   968:      * @param propertyName The property name to work with.\n   969:      * @return String form of property's type.\n-  970:      * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n+  970:      * @noinspection IfStatementWithTooManyBranches\n   971:      */\n   972:     private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n   973:             Object instance, String propertyName) {\n   974:         final String instanceName = instance.getClass().getSimpleName();\n   975:         String result = null;\n   976:         final String checkProperty = sectionName + \":\" + propertyName;\n-  977:         if ((\"SuppressionCommentFilter\".equals(sectionName)\n-  978:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n-  979:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n-  980:                     && (\"checkFormat\".equals(propertyName)\n-  981:                         || \"messageFormat\".equals(propertyName)\n-  982:                         || \"idFormat\".equals(propertyName)\n-  983:                         || \"influenceFormat\".equals(propertyName))\n-  984:                 || (\"RegexpMultiline\".equals(sectionName)\n-  985:                     || \"RegexpSingleline\".equals(sectionName)\n-  986:                     || \"RegexpSinglelineJava\".equals(sectionName))\n-  987:                     && \"format\".equals(propertyName)) {\n-  988:             // dynamic custom expression\n-  989:             result = \"Regular Expression\";\n+  977:         if (isDynamicCustomExpression(sectionName, propertyName)) {\n+  978:             // dynamic custom expression\n+  979:             result = \"Regular Expression\";\n+  980:         }\n+  981:         else if (fieldClass == int[].class) {\n+  982:             result = getPropertyTypeNameForIntArray(sectionName, propertyName);\n+  983:         }\n+  984:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n+  985:             result = getPropertyTypeNameForString(sectionName, propertyName);\n+  986: \n+  987:         }\n+  988:         else if (fieldClass == String[].class) {\n+  989:             result = getPropertyTypeNameForStringArray(propertyName, instanceName);\n   990:         }\n-  991:         else if (fieldClass == boolean.class) {\n-  992:             result = \"boolean\";\n+  991:         else if (fieldClass == Pattern.class) {\n+  992:             result = getPropertyTypeNameForPattern(checkProperty);\n   993:         }\n-  994:         else if (fieldClass == int.class) {\n-  995:             result = \"int\";\n+  994:         else if (fieldClass == Pattern[].class) {\n+  995:             result = getPropertyTypeNameForPatternArray(checkProperty);\n   996:         }\n-  997:         else if (fieldClass == int[].class) {\n-  998:             if (isPropertyTokenType(sectionName, propertyName)) {\n-  999:                 result = \"subset of tokens TokenTypes\";\n- 1000:             }\n- 1001:             else {\n- 1002:                 result = \"int[]\";\n- 1003:             }\n- 1004:         }\n- 1005:         else if (fieldClass == double[].class) {\n- 1006:             result = \"double[]\";\n- 1007:         }\n- 1008:         else if (fieldClass == String.class || fieldClass == Charset.class) {\n- 1009:             result = \"String\";\n- 1010: \n- 1011:             if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n- 1012:                 result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n- 1013:             }\n- 1014:             else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n- 1015:                 result += \" (either the empty string or a lowercase ISO 639 code)\";\n- 1016:             }\n- 1017:         }\n- 1018:         else if (fieldClass == String[].class) {\n- 1019:             if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n- 1020:                     || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n- 1021:                     || \"MultipleStringLiteralsCheck\".equals(instanceName)\n- 1022:                             && \"ignoreOccurrenceContext\".equals(propertyName)) {\n- 1023:                 result = \"subset of tokens TokenTypes\";\n- 1024:             }\n- 1025:             else {\n- 1026:                 result = \"String[]\";\n- 1027:             }\n- 1028:         }\n- 1029:         else if (fieldClass == URI.class) {\n- 1030:             result = \"URI\";\n- 1031:         }\n- 1032:         else if (fieldClass == Pattern.class) {\n- 1033:             if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n- 1034:                 || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n- 1035:                 || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n- 1036:                 || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n- 1037:                 || \"IllegalTokenText:format\".equals(checkProperty)) {\n- 1038:                 result = \"Regular Expression\";\n- 1039:             }\n- 1040:             else {\n- 1041:                 result = \"Pattern\";\n- 1042:             }\n- 1043:         }\n- 1044:         else if (fieldClass == Pattern[].class) {\n- 1045:             if (\"ImportOrder:groups\".equals(checkProperty)\n- 1046:                 || \"ImportOrder:staticGroups\".equals(checkProperty)\n- 1047:                 || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n- 1048:                 || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n- 1049:                 result = \"Regular Expressions\";\n- 1050:             }\n- 1051:             else {\n- 1052:                 result = \"Pattern[]\";\n- 1053:             }\n- 1054:         }\n- 1055:         else if (fieldClass == Scope.class) {\n- 1056:             result = \"Scope\";\n- 1057:         }\n- 1058:         else if (fieldClass == AccessModifierOption[].class) {\n- 1059:             result = \"AccessModifierOption[]\";\n- 1060:         }\n- 1061:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n- 1062:             result = \"File\";\n- 1063:         }\n- 1064:         else if (fieldClass.isEnum()) {\n- 1065:             result = fieldClass.getSimpleName();\n- 1066:         }\n- 1067:         else {\n- 1068:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n- 1069:         }\n- 1070: \n- 1071:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n- 1072:             result = result + \" in a format of comma separated attribute=value entries. The \"\n- 1073:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n- 1074:         }\n- 1075: \n- 1076:         return result;\n- 1077:     }\n+  997:         else if (fieldClass == Scope.class) {\n+  998:             result = \"Scope\";\n+  999:         }\n+ 1000:         else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n+ 1001:             result = \"File\";\n+ 1002:         }\n+ 1003:         else if (fieldClass.isEnum()) {\n+ 1004:             result = fieldClass.getSimpleName();\n+ 1005:         }\n+ 1006:         else if (isKnownPropertyType(fieldClass)) {\n+ 1007:             result = fieldClass.getSimpleName();\n+ 1008:         }\n+ 1009:         else {\n+ 1010:             fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n+ 1011:         }\n+ 1012: \n+ 1013:         if (\"SuppressWarningsHolder\".equals(instanceName)) {\n+ 1014:             result = result + \" in a format of comma separated attribute=value entries. The \"\n+ 1015:                     + \"attribute is the fully qualified name of the Check and value is its alias.\";\n+ 1016:         }\n+ 1017: \n+ 1018:         return result;\n+ 1019:     }\n+ 1020: \n+ 1021:     /**\n+ 1022:      * Checks whether property is a dynamic custom expression.\n+ 1023:      *\n+ 1024:      * @param sectionName the name of the section/module being worked on.\n+ 1025:      * @param propertyName the property name to work with.\n+ 1026:      * @return true if it is a dynamic custom expression.\n+ 1027:      */\n+ 1028:     private static boolean isDynamicCustomExpression(String sectionName, String propertyName) {\n+ 1029:         return isSuppressionFilter(sectionName)\n+ 1030:                 && (\"checkFormat\".equals(propertyName)\n+ 1031:                 || \"messageFormat\".equals(propertyName)\n+ 1032:                 || \"idFormat\".equals(propertyName)\n+ 1033:                 || \"influenceFormat\".equals(propertyName))\n+ 1034:                 || isRegexpCheck(sectionName)\n+ 1035:                 && \"format\".equals(propertyName);\n+ 1036:     }\n+ 1037: \n+ 1038:     /**\n+ 1039:      * Checks Whether the section is a type of suppression filter.\n+ 1040:      *\n+ 1041:      * @param sectionName the name of the section/module being worked on.\n+ 1042:      * @return true if it is a type of suppression filter.\n+ 1043:      */\n+ 1044:     private static boolean isSuppressionFilter(String sectionName) {\n+ 1045:         return \"SuppressionCommentFilter\".equals(sectionName)\n+ 1046:                 || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n+ 1047:                 || \"SuppressWithPlainTextCommentFilter\".equals(sectionName);\n+ 1048:     }\n+ 1049: \n+ 1050:     /**\n+ 1051:      * Checks whether the section is a RegexpCheck.\n+ 1052:      *\n+ 1053:      * @param sectionName the name of the section/module being worked on.\n+ 1054:      * @return true if the section is a RegexpCheck.\n+ 1055:      */\n+ 1056:     private static boolean isRegexpCheck(String sectionName) {\n+ 1057:         return \"RegexpMultiline\".equals(sectionName)\n+ 1058:                 || \"RegexpSingleline\".equals(sectionName)\n+ 1059:                 || \"RegexpSinglelineJava\".equals(sectionName);\n+ 1060:     }\n+ 1061: \n+ 1062:     /**\n+ 1063:      * Get's the name of the bean property's type for the Int[] class.\n+ 1064:      *\n+ 1065:      * @param sectionName the name of the section/module being worked on.\n+ 1066:      * @param propertyName the property name to work with.\n+ 1067:      * @return String form of property's type.\n+ 1068:      */\n+ 1069:     private static String getPropertyTypeNameForIntArray(String sectionName, String propertyName) {\n+ 1070:         String result = \"int[]\";\n+ 1071:         if (isPropertyTokenType(sectionName, propertyName)) {\n+ 1072:             result = \"subset of tokens TokenTypes\";\n+ 1073:         }\n+ 1074:         return result;\n+ 1075:     }\n+ 1076: \n+ 1077:     /**\n", "uniqueId": "4d5c877fce566569ecf6ac16b67aeeb6a32be8b7_962_1077_1062_1075_962_1019", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nrefactored_method_code\n##########################\n\nprivate static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (field", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static com.google.common.truth.Truth.assertWithMessage;\nimport static java.lang.Integer.parseInt;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.hamcrest.CoreMatchers.describedAs;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.beanutils.PropertyUtils;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader;\nimport com.puppycrawl.tools.checkstyle.ConfigurationLoader.IgnoredModulesOptions;\nimport com.puppycrawl.tools.checkstyle.ModuleFactory;\nimport com.puppycrawl.tools.checkstyle.PropertiesExpander;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.Scope;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.checks.naming.AccessModifierOption;\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.TestUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\npublic class XdocsPagesTest {\n\n    private static final Path AVAILABLE_CHECKS_PATH = Paths.get(\"src/xdocs/checks.xml\");\n    private static final String LINK_TEMPLATE =\n            \"(?s).*<a href=\\\"config_\\\\w+\\\\.html#%1$s\\\">(\\\\s)*%1$s</a>.*\";\n\n    private static final Pattern VERSION = Pattern.compile(\"\\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final Pattern DESCRIPTION_VERSION = Pattern\n            .compile(\"^Since Checkstyle \\\\d+\\\\.\\\\d+(\\\\.\\\\d+)?\");\n\n    private static final List<String> XML_FILESET_LIST = Arrays.asList(\n            \"TreeWalker\",\n            \"name=\\\"Checker\\\"\",\n            \"name=\\\"Header\\\"\",\n            \"name=\\\"LineLength\\\"\",\n            \"name=\\\"Translation\\\"\",\n            \"name=\\\"SeverityMatchFilter\\\"\",\n            \"name=\\\"SuppressWithPlainTextCommentFilter\\\"\",\n            \"name=\\\"SuppressionFilter\\\"\",\n            \"name=\\\"SuppressionSingleFilter\\\"\",\n            \"name=\\\"SuppressWarningsFilter\\\"\",\n            \"name=\\\"BeforeExecutionExclusionFileFilter\\\"\",\n            \"name=\\\"RegexpHeader\\\"\",\n            \"name=\\\"RegexpOnFilename\\\"\",\n            \"name=\\\"RegexpSingleline\\\"\",\n            \"name=\\\"RegexpMultiline\\\"\",\n            \"name=\\\"JavadocPackage\\\"\",\n            \"name=\\\"NewlineAtEndOfFile\\\"\",\n            \"name=\\\"OrderedProperties\\\"\",\n            \"name=\\\"UniqueProperties\\\"\",\n            \"name=\\\"FileLength\\\"\",\n            \"name=\\\"FileTabCharacter\\\"\"\n    );\n\n    private static final Set<String> CHECK_PROPERTIES = getProperties(AbstractCheck.class);\n    private static final Set<String> JAVADOC_CHECK_PROPERTIES =\n            getProperties(AbstractJavadocCheck.class);\n    private static final Set<String> FILESET_PROPERTIES = getProperties(AbstractFileSetCheck.class);\n\n    private static final List<String> UNDOCUMENTED_PROPERTIES = Arrays.asList(\n            \"Checker.classLoader\",\n            \"Checker.classloader\",\n            \"Checker.moduleClassLoader\",\n            \"Checker.moduleFactory\",\n            \"TreeWalker.classLoader\",\n            \"TreeWalker.moduleFactory\",\n            \"TreeWalker.cacheFile\",\n            \"TreeWalker.upChild\",\n            \"SuppressWithNearbyCommentFilter.fileContents\",\n            \"SuppressionCommentFilter.fileContents\"\n    );\n\n    private static final List<String> PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD = Arrays.asList(\n            // static field (all upper case)\n            \"SuppressWarningsHolder.aliasList\",\n            // loads string into memory similar to file\n            \"Header.header\",\n            \"RegexpHeader.header\",\n            // deprecated fields\n            \"JavadocMethod.minLineCount\",\n            \"JavadocMethod.allowMissingJavadoc\",\n            \"JavadocMethod.allowMissingPropertyJavadoc\",\n            \"JavadocMethod.ignoreMethodNamesRegex\",\n            \"JavadocMethod.logLoadErrors\",\n            \"JavadocMethod.suppressLoadErrors\",\n            \"MissingDeprecated.skipNoJavadoc\"\n    );\n\n    private static final Set<String> SUN_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigSunStyleModules()));\n    // ignore the not yet properly covered modules while testing newly added ones\n    // add proper sections to the coverage report and integration tests\n    // and then remove this list eventually\n    private static final List<String> IGNORED_SUN_MODULES = Arrays.asList(\n            \"ArrayTypeStyle\",\n            \"AvoidNestedBlocks\",\n            \"AvoidStarImport\",\n            \"ConstantName\",\n            \"DesignForExtension\",\n            \"EmptyBlock\",\n            \"EmptyForIteratorPad\",\n            \"EmptyStatement\",\n            \"EqualsHashCode\",\n            \"FileLength\",\n            \"FileTabCharacter\",\n            \"FinalClass\",\n            \"FinalParameters\",\n            \"GenericWhitespace\",\n            \"HiddenField\",\n            \"HideUtilityClassConstructor\",\n            \"IllegalImport\",\n            \"IllegalInstantiation\",\n            \"InnerAssignment\",\n            \"InterfaceIsType\",\n            \"JavadocMethod\",\n            \"JavadocPackage\",\n            \"JavadocStyle\",\n            \"JavadocType\",\n            \"JavadocVariable\",\n            \"LeftCurly\",\n            \"LineLength\",\n            \"LocalFinalVariableName\",\n            \"LocalVariableName\",\n            \"MagicNumber\",\n            \"MemberName\",\n            \"MethodLength\",\n            \"MethodName\",\n            \"MethodParamPad\",\n            \"MissingJavadocMethod\",\n            \"MissingSwitchDefault\",\n            \"ModifierOrder\",\n            \"NeedBraces\",\n            \"NewlineAtEndOfFile\",\n            \"NoWhitespaceAfter\",\n            \"NoWhitespaceBefore\",\n            \"OperatorWrap\",\n            \"PackageName\",\n            \"ParameterName\",\n            \"ParameterNumber\",\n            \"ParenPad\",\n            \"RedundantImport\",\n            \"RedundantModifier\",\n            \"RegexpSingleline\",\n            \"RightCurly\",\n            \"SimplifyBooleanExpression\",\n            \"SimplifyBooleanReturn\",\n            \"StaticVariableName\",\n            \"TodoComment\",\n            \"Translation\",\n            \"TypecastParenPad\",\n            \"TypeName\",\n            \"UnusedImports\",\n            \"UpperEll\",\n            \"VisibilityModifier\",\n            \"WhitespaceAfter\",\n            \"WhitespaceAround\"\n    );\n    private static final Set<String> GOOGLE_MODULES = Collections.unmodifiableSet(\n        new HashSet<>(CheckUtil.getConfigGoogleStyleModules()));\n\n    @Test\n    public void testAllChecksPresentOnAvailableChecksPage() throws Exception {\n        final String availableChecks = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n\n        CheckUtil.getSimpleNames(CheckUtil.getCheckstyleChecks())\n            .stream()\n            .filter(checkName -> !\"JavadocMetadataScraper\".equals(checkName))\n            .forEach(checkName -> {\n                if (!isPresent(availableChecks, checkName)) {\n                    fail(checkName + \" is not correctly listed on Available Checks page\"\n                        + \" - add it to \" + AVAILABLE_CHECKS_PATH);\n                }\n            });\n    }\n\n    private static boolean isPresent(String availableChecks, String checkName) {\n        final String linkPattern = String.format(Locale.ROOT, LINK_TEMPLATE, checkName);\n        return availableChecks.matches(linkPattern);\n    }\n\n    @Test\n    public void testAllChecksPageInSyncWithChecksSummaries() throws Exception {\n        final Pattern endOfSentence = Pattern.compile(\"(.*?\\\\.)\\\\s\", Pattern.DOTALL);\n        final Map<String, String> summaries = readSummaries();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            if (\"config_system_properties.xml\".equals(fileName)\n                    || \"config_filefilters.xml\".equals(fileName)\n                    || \"config_filters.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n                if (!\"Description\".equals(sectionName)) {\n                    continue;\n                }\n\n                final String checkName = XmlUtil.getNameAttributeOfNode(section.getParentNode());\n                final Matcher matcher = endOfSentence.matcher(section.getTextContent());\n                assertWithMessage(\n                    \"The first sentence of the \\\"Description\\\" subsection for the check \"\n                        + checkName + \" in the file \\\"\" + fileName + \"\\\" should end with a period\")\n                    .that(matcher.find());\n                final String firstSentence = XmlUtil.sanitizeXml(matcher.group(1));\n                assertWithMessage(\"The summary for check \" + checkName\n                        + \" in the file \\\"\" + AVAILABLE_CHECKS_PATH + \"\\\"\"\n                        + \" should match the first sentence of the \\\"Description\\\" subsection\"\n                        + \" for this check in the file \\\"\" + fileName + \"\\\"\")\n                    .that(summaries.get(checkName))\n                    .isEqualTo(firstSentence);\n            }\n        }\n    }\n\n    private static Map<String, String> readSummaries() throws Exception {\n        final String fileName = AVAILABLE_CHECKS_PATH.getFileName().toString();\n        final String input = new String(Files.readAllBytes(AVAILABLE_CHECKS_PATH), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList rows = document.getElementsByTagName(\"tr\");\n        final Map<String, String> result = new HashMap<>();\n\n        for (int position = 0; position < rows.getLength(); position++) {\n            final Node row = rows.item(position);\n            final Iterator<Node> cells = XmlUtil.findChildElementsByTag(row, \"td\").iterator();\n            final String name = XmlUtil.sanitizeXml(cells.next().getTextContent());\n            final String summary = XmlUtil.sanitizeXml(cells.next().getTextContent());\n\n            result.put(name, summary);\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllSubSections() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList subSections = document.getElementsByTagName(\"subsection\");\n\n            for (int position = 0; position < subSections.getLength(); position++) {\n                final Node subSection = subSections.item(position);\n                final Node name = subSection.getAttributes().getNamedItem(\"name\");\n\n                assertNotNull(name, \"All sub-sections in '\" + fileName + \"' must have a name\");\n\n                final Node id = subSection.getAttributes().getNamedItem(\"id\");\n\n                assertNotNull(id, \"All sub-sections in '\" + fileName + \"' must have an id\");\n\n                final String sectionName;\n\n                if (\"google_style.xml\".equals(fileName)) {\n                    sectionName = \"Google\";\n                }\n                else if (\"sun_style.xml\".equals(fileName)) {\n                    sectionName = \"Sun\";\n                }\n                else {\n                    sectionName = XmlUtil.getNameAttributeOfNode(subSection.getParentNode());\n                }\n\n                final String nameString = name.getNodeValue();\n                final String idString = id.getNodeValue();\n\n                assertEquals((sectionName + \" \" + nameString).replace(' ', '_'), idString,\n                        fileName + \" sub-section \" + nameString + \" for section \"\n                        + sectionName + \" must match\");\n            }\n        }\n    }\n\n    @Test\n    public void testAllXmlExamples() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final String fileName = path.getFileName().toString();\n\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"source\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final String unserializedSource = sources.item(position).getTextContent()\n                        .replace(\"...\", \"\").trim();\n\n                if (unserializedSource.length() > 1 && (unserializedSource.charAt(0) != '<'\n                        || unserializedSource.charAt(unserializedSource.length() - 1) != '>'\n                        // no dtd testing yet\n                        || unserializedSource.contains(\"<!\"))) {\n                    continue;\n                }\n\n                final String code = buildXml(unserializedSource);\n                // validate only\n                XmlUtil.getRawXml(fileName, code, unserializedSource);\n\n                // can't test ant structure, or old and outdated checks\n                assertTrue(fileName.startsWith(\"anttask\")\n                        || fileName.startsWith(\"releasenotes\")\n                        || isValidCheckstyleXml(fileName, code, unserializedSource),\n                        \"Xml is invalid, old or has outdated structure\");\n            }\n        }\n    }\n\n    private static String buildXml(String unserializedSource) throws IOException {\n        // not all examples come with the full xml structure\n        String code = unserializedSource\n            // don't corrupt our own cachefile\n            .replace(\"target/cachefile\", \"target/cachefile-test\");\n\n        if (!hasFileSetClass(code)) {\n            code = \"<module name=\\\"TreeWalker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.contains(\"name=\\\"Checker\\\"\")) {\n            code = \"<module name=\\\"Checker\\\">\\n\" + code + \"\\n</module>\";\n        }\n        if (!code.startsWith(\"<?xml\")) {\n            final String dtdPath = new File(\n                    \"src/main/resources/com/puppycrawl/tools/checkstyle/configuration_1_3.dtd\")\n                    .getCanonicalPath();\n\n            code = \"<?xml version=\\\"1.0\\\"?>\\n<!DOCTYPE module PUBLIC \"\n                    + \"\\\"-//Checkstyle//DTD Checkstyle Configuration 1.3//EN\\\" \\\"\" + dtdPath\n                    + \"\\\">\\n\" + code;\n        }\n        return code;\n    }\n\n    private static boolean hasFileSetClass(String xml) {\n        boolean found = false;\n\n        for (String find : XML_FILESET_LIST) {\n            if (xml.contains(find)) {\n                found = true;\n                break;\n            }\n        }\n\n        return found;\n    }\n\n    private static boolean isValidCheckstyleXml(String fileName, String code,\n                                                String unserializedSource)\n            throws IOException, CheckstyleException {\n        // can't process non-existent examples, or out of context snippets\n        if (!code.contains(\"com.mycompany\") && !code.contains(\"checkstyle-packages\")\n                && !code.contains(\"MethodLimit\") && !code.contains(\"<suppress \")\n                && !code.contains(\"<suppress-xpath \")\n                && !code.contains(\"<import-control \")\n                && !unserializedSource.startsWith(\"<property \")\n                && !unserializedSource.startsWith(\"<taskdef \")) {\n            // validate checkstyle structure and contents\n            try {\n                final Properties properties = new Properties();\n\n                properties.setProperty(\"checkstyle.header.file\",\n                        new File(\"config/java.header\").getCanonicalPath());\n\n                final PropertiesExpander expander = new PropertiesExpander(properties);\n                final Configuration config = ConfigurationLoader.loadConfiguration(new InputSource(\n                        new StringReader(code)), expander, IgnoredModulesOptions.EXECUTE);\n                final Checker checker = new Checker();\n\n                try {\n                    final ClassLoader moduleClassLoader = Checker.class.getClassLoader();\n                    checker.setModuleClassLoader(moduleClassLoader);\n                    checker.configure(config);\n                }\n                finally {\n                    checker.destroy();\n                }\n            }\n            catch (CheckstyleException ex) {\n                throw new CheckstyleException(fileName + \" has invalid Checkstyle xml (\"\n                        + ex.getMessage() + \"): \" + unserializedSource, ex);\n            }\n        }\n        return true;\n    }\n\n    @Test\n    public void testAllCheckSections() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        for (Path path : XdocUtil.getXdocsConfigFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n\n            if (\"config_system_properties.xml\".equals(fileName)) {\n                continue;\n            }\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n            String lastSectionName = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    assertNull(lastSectionName,\n                            fileName + \" section '\" + sectionName + \"' should be first\");\n                    continue;\n                }\n\n                assertFalse(sectionName.endsWith(\"Check\"),\n                        fileName + \" section '\" + sectionName + \"' shouldn't end with 'Check'\");\n                if (lastSectionName != null) {\n                    assertTrue(sectionName.toLowerCase(Locale.ENGLISH).compareTo(\n                            lastSectionName.toLowerCase(Locale.ENGLISH)) >= 0,\n                            fileName + \" section '\" + sectionName\n                                + \"' is out of order compared to '\" + lastSectionName + \"'\");\n                }\n\n                validateCheckSection(moduleFactory, fileName, sectionName, section);\n\n                lastSectionName = sectionName;\n            }\n        }\n    }\n\n    /**\n     * Test contains asserts in callstack, but idea does not see them.\n     *\n     * @noinspection JUnitTestMethodWithNoAssertions\n     */\n    @Test\n    public void testAllCheckSectionsEx() throws Exception {\n        final ModuleFactory moduleFactory = TestUtil.getPackageObjectFactory();\n\n        final Path path = Paths.get(XdocUtil.DIRECTORY_PATH + \"/config.xml\");\n        final String fileName = path.getFileName().toString();\n\n        final String input = new String(Files.readAllBytes(path), UTF_8);\n        final Document document = XmlUtil.getRawXml(fileName, input, input);\n        final NodeList sources = document.getElementsByTagName(\"section\");\n\n        for (int position = 0; position < sources.getLength(); position++) {\n            final Node section = sources.item(position);\n            final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n            if (!\"Checker\".equals(sectionName) && !\"TreeWalker\".equals(sectionName)) {\n                continue;\n            }\n\n            validateCheckSection(moduleFactory, fileName, sectionName, section);\n        }\n    }\n\n    private static void validateCheckSection(ModuleFactory moduleFactory, String fileName,\n            String sectionName, Node section) throws Exception {\n        final Object instance;\n\n        try {\n            instance = moduleFactory.createModule(sectionName);\n        }\n        catch (CheckstyleException ex) {\n            throw new CheckstyleException(fileName + \" couldn't find class: \" + sectionName, ex);\n        }\n\n        int subSectionPos = 0;\n        for (Node subSection : XmlUtil.getChildrenElements(section)) {\n            if (subSectionPos == 0 && \"p\".equals(subSection.getNodeName())) {\n                validateSinceDescriptionSection(fileName, sectionName, subSection);\n                continue;\n            }\n\n            final String subSectionName = XmlUtil.getNameAttributeOfNode(subSection);\n\n            // can be in different orders, and completely optional\n            if (\"Notes\".equals(subSectionName)\n                    || \"Rule Description\".equals(subSectionName)\n                    || \"Metadata\".equals(subSectionName)) {\n                continue;\n            }\n\n            // optional sections that can be skipped if they have nothing to report\n            if (subSectionPos == 1 && !\"Properties\".equals(subSectionName)) {\n                validatePropertySection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n            if (subSectionPos == 4 && !\"Violation Messages\".equals(subSectionName)) {\n                validateViolationSection(fileName, sectionName, null, instance);\n                subSectionPos++;\n            }\n\n            assertEquals(getSubSectionName(subSectionPos), subSectionName,\n                    fileName + \" section '\" + sectionName + \"' should be in order\");\n\n            switch (subSectionPos) {\n                case 0:\n                    validateDescriptionSection(fileName, sectionName, subSection);\n                    break;\n                case 1:\n                    validatePropertySection(fileName, sectionName, subSection, instance);\n                    break;\n                case 3:\n                    validateUsageExample(fileName, sectionName, subSection);\n                    break;\n                case 4:\n                    validateViolationSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 5:\n                    validatePackageSection(fileName, sectionName, subSection, instance);\n                    break;\n                case 6:\n                    validateParentSection(fileName, sectionName, subSection);\n                    break;\n                case 2:\n                default:\n                    break;\n            }\n\n            subSectionPos++;\n        }\n\n        if (\"Checker\".equals(sectionName)) {\n            assertTrue(subSectionPos >= 6, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Package' sub-section\");\n        }\n        else {\n            assertTrue(subSectionPos >= 7, fileName + \" section '\" + sectionName\n                    + \"' should contain up to 'Parent' sub-section\");\n        }\n    }\n\n    private static void validateSinceDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        assertTrue(DESCRIPTION_VERSION.matcher(subSection.getTextContent().trim()).find(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a valid version at the start of the description like:\\n\"\n                        + DESCRIPTION_VERSION.pattern());\n    }\n\n    private static Object getSubSectionName(int subSectionPos) {\n        final String result;\n\n        switch (subSectionPos) {\n            case 0:\n                result = \"Description\";\n                break;\n            case 1:\n                result = \"Properties\";\n                break;\n            case 2:\n                result = \"Examples\";\n                break;\n            case 3:\n                result = \"Example of Usage\";\n                break;\n            case 4:\n                result = \"Violation Messages\";\n                break;\n            case 5:\n                result = \"Package\";\n                break;\n            case 6:\n                result = \"Parent Module\";\n                break;\n            default:\n                result = null;\n                break;\n        }\n\n        return result;\n    }\n\n    private static void validateDescriptionSection(String fileName, String sectionName,\n            Node subSection) {\n        if (\"config_filters.xml\".equals(fileName) && \"SuppressionXpathFilter\".equals(sectionName)) {\n            validateListOfSuppressionXpathFilterIncompatibleChecks(subSection);\n        }\n    }\n\n    private static void validateListOfSuppressionXpathFilterIncompatibleChecks(Node subSection) {\n        assertWithMessage(\n            \"Incompatible check list should match XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES\")\n            .that(getListById(subSection, \"SuppressionXpathFilter_IncompatibleChecks\"))\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_CHECK_NAMES);\n        final Set<String> suppressionXpathFilterJavadocChecks = getListById(subSection,\n                \"SuppressionXpathFilter_JavadocChecks\");\n        assertWithMessage(\n            \"Javadoc check list should match XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES\")\n            .that(suppressionXpathFilterJavadocChecks)\n            .isEqualTo(XpathRegressionTest.INCOMPATIBLE_JAVADOC_CHECK_NAMES);\n    }\n\n    private static void validatePropertySection(String fileName, String sectionName,\n            Node subSection, Object instance) throws Exception {\n        final Set<String> properties = getProperties(instance.getClass());\n        final Class<?> clss = instance.getClass();\n\n        fixCapturedProperties(sectionName, instance, clss, properties);\n\n        if (subSection != null) {\n            assertFalse(properties.isEmpty(), fileName + \" section '\" + sectionName\n                    + \"' should have no properties to show\");\n\n            final Set<Node> nodes = XmlUtil.getChildrenElements(subSection);\n            assertEquals(1, nodes.size(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' should have one child node\");\n\n            final Node div = nodes.iterator().next();\n            assertEquals(\"div\", div.getNodeName(), fileName + \" section '\" + sectionName\n                        + \"' subsection 'Properties' has unexpected child node\");\n            final String wrapperMessage = fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' wrapping div for table needs the\"\n                    + \" class 'wrapper'\";\n            assertTrue(div.hasAttributes(), wrapperMessage);\n            assertNotNull(div.getAttributes().getNamedItem(\"class\").getNodeValue(), wrapperMessage);\n            assertTrue(div.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),\n                    wrapperMessage);\n\n            final Node table = XmlUtil.getFirstChildElement(div);\n            assertEquals(\"table\", table.getNodeName(), fileName + \" section '\" + sectionName\n                    + \"' subsection 'Properties' has unexpected child node\");\n\n            validatePropertySectionProperties(fileName, sectionName, table, instance,\n                    properties);\n        }\n\n        assertTrue(properties.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should show properties: \" + properties);\n    }\n\n    private static void fixCapturedProperties(String sectionName, Object instance, Class<?> clss,\n            Set<String> properties) {\n        // remove global properties that don't need documentation\n        if (hasParentModule(sectionName)) {\n            if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(JAVADOC_CHECK_PROPERTIES);\n\n                // override\n                properties.add(\"violateExecutionOnNonTightHtml\");\n            }\n            else if (AbstractCheck.class.isAssignableFrom(clss)) {\n                properties.removeAll(CHECK_PROPERTIES);\n            }\n        }\n        if (AbstractFileSetCheck.class.isAssignableFrom(clss)) {\n            properties.removeAll(FILESET_PROPERTIES);\n\n            // override\n            properties.add(\"fileExtensions\");\n        }\n\n        // remove undocumented properties\n        new HashSet<>(properties).stream()\n            .filter(prop -> UNDOCUMENTED_PROPERTIES.contains(clss.getSimpleName() + \".\" + prop))\n            .forEach(properties::remove);\n\n        if (AbstractCheck.class.isAssignableFrom(clss)) {\n            final AbstractCheck check = (AbstractCheck) instance;\n\n            final int[] acceptableTokens = check.getAcceptableTokens();\n            Arrays.sort(acceptableTokens);\n            final int[] defaultTokens = check.getDefaultTokens();\n            Arrays.sort(defaultTokens);\n            final int[] requiredTokens = check.getRequiredTokens();\n            Arrays.sort(requiredTokens);\n\n            if (!Arrays.equals(acceptableTokens, defaultTokens)\n                    || !Arrays.equals(acceptableTokens, requiredTokens)) {\n                properties.add(\"tokens\");\n            }\n        }\n\n        if (AbstractJavadocCheck.class.isAssignableFrom(clss)) {\n            final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n\n            final int[] acceptableJavadocTokens = check.getAcceptableJavadocTokens();\n            Arrays.sort(acceptableJavadocTokens);\n            final int[] defaultJavadocTokens = check.getDefaultJavadocTokens();\n            Arrays.sort(defaultJavadocTokens);\n            final int[] requiredJavadocTokens = check.getRequiredJavadocTokens();\n            Arrays.sort(requiredJavadocTokens);\n\n            if (!Arrays.equals(acceptableJavadocTokens, defaultJavadocTokens)\n                    || !Arrays.equals(acceptableJavadocTokens, requiredJavadocTokens)) {\n                properties.add(\"javadocTokens\");\n            }\n        }\n    }\n\n    private static void validatePropertySectionProperties(String fileName, String sectionName,\n            Node table, Object instance, Set<String> properties) throws Exception {\n        boolean skip = true;\n        boolean didJavadocTokens = false;\n        boolean didTokens = false;\n\n        for (Node row : XmlUtil.getChildrenElements(table)) {\n            final List<Node> columns = new ArrayList<>(XmlUtil.getChildrenElements(row));\n\n            assertEquals(5, columns.size(), fileName + \" section '\" + sectionName\n                    + \"' should have the requested columns\");\n\n            if (skip) {\n                assertEquals(\"name\", columns.get(0).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"description\", columns.get(1).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"type\", columns.get(2).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"default value\", columns.get(3).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n                assertEquals(\"since\", columns.get(4).getTextContent(),\n                        fileName + \" section '\" + sectionName\n                                + \"' should have the specific title\");\n\n                skip = false;\n                continue;\n            }\n\n            assertFalse(didTokens, fileName + \" section '\" + sectionName\n                    + \"' should have token properties last\");\n\n            final String propertyName = columns.get(0).getTextContent();\n            assertTrue(properties.remove(propertyName), fileName + \" section '\" + sectionName\n                    + \"' should not contain the property: \" + propertyName);\n\n            if (\"tokens\".equals(propertyName)) {\n                final AbstractCheck check = (AbstractCheck) instance;\n                validatePropertySectionPropertyTokens(fileName, sectionName, check, columns);\n                didTokens = true;\n            }\n            else if (\"javadocTokens\".equals(propertyName)) {\n                final AbstractJavadocCheck check = (AbstractJavadocCheck) instance;\n                validatePropertySectionPropertyJavadocTokens(fileName, sectionName, check, columns);\n                didJavadocTokens = true;\n            }\n            else {\n                assertFalse(didJavadocTokens, fileName + \" section '\" + sectionName\n                            + \"' should have javadoc token properties next to last, before tokens\");\n\n                validatePropertySectionPropertyEx(fileName, sectionName, instance, columns,\n                        propertyName);\n            }\n\n            assertWithMessage(\"%s section '%s' should have a version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .isNotEmpty();\n            assertWithMessage(\"%s section '%s' should have a valid version for %s\",\n                            fileName, sectionName, propertyName)\n                    .that(columns.get(4).getTextContent().trim())\n                    .matches(VERSION);\n        }\n    }\n\n    private static void validatePropertySectionPropertyEx(String fileName, String sectionName,\n            Object instance, List<Node> columns, String propertyName) throws Exception {\n        assertWithMessage(\"%s section '%s' should have a description for %s\",\n                        fileName, sectionName, propertyName)\n                .that(columns.get(1).getTextContent().trim())\n                .isNotEmpty();\n\n        final String actualTypeName = columns.get(2).getTextContent().replace(\"\\n\", \"\")\n                .replace(\"\\r\", \"\").replaceAll(\" +\", \" \").trim();\n\n        assertFalse(actualTypeName.isEmpty(),\n                fileName + \" section '\" + sectionName + \"' should have a type for \" + propertyName);\n\n        final Field field = getField(instance.getClass(), propertyName);\n        final Class<?> fieldClss = getFieldClass(fileName, sectionName, instance, field,\n                propertyName);\n\n        final String expectedTypeName = getModulePropertyExpectedTypeName(sectionName, fieldClss,\n                instance, propertyName);\n        final String expectedValue = getModulePropertyExpectedValue(sectionName, propertyName,\n                field, fieldClss, instance);\n\n        assertEquals(expectedTypeName, actualTypeName,\n                fileName + \" section '\" + sectionName\n                        + \"' should have the type for \" + propertyName);\n\n        if (expectedValue != null) {\n            final String actualValue = columns.get(3).getTextContent().trim()\n                    .replaceAll(\"\\\\s+\", \" \")\n                    .replaceAll(\"\\\\s,\", \",\");\n\n            assertEquals(expectedValue, actualValue,\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the value for \" + propertyName);\n        }\n    }\n\n    private static void validatePropertySectionPropertyTokens(String fileName, String sectionName,\n            AbstractCheck check, List<Node> columns) {\n        assertEquals(\"tokens to check\", columns.get(1).getTextContent(),\n                fileName + \" section '\" + sectionName\n                        + \"' should have the basic token description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        String expectedAcceptableTokenText = \"subset of tokens \"\n                + CheckUtil.getTokenText(check.getAcceptableTokens(),\n                check.getRequiredTokens());\n        if (isAllTokensAcceptable(check)) {\n            expectedAcceptableTokenText = \"set of any supported tokens\";\n        }\n        assertEquals(expectedAcceptableTokenText, acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        final String expectedDefaultTokenText = CheckUtil.getTokenText(check.getDefaultTokens(),\n                check.getRequiredTokens());\n        if (expectedDefaultTokenText.isEmpty()) {\n            assertEquals(\"empty\", defaultTokenText,\n                    \"Empty tokens should have 'empty' string in xdoc\");\n        }\n        else {\n            assertEquals(expectedDefaultTokenText, defaultTokenText\n                            .replaceAll(\"\\\\s+\", \" \")\n                            .replaceAll(\"\\\\s,\", \",\")\n                            .replaceAll(\"\\\\s\\\\.\", \".\"),\n                    fileName + \" section '\" + sectionName + \"' should have all the default tokens\");\n            assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                    fileName + \"'s default token section: \" + sectionName\n                          + \"should have ',' or '.' at beginning of the next corresponding lines.\");\n        }\n\n    }\n\n    private static boolean isAllTokensAcceptable(AbstractCheck check) {\n        return Arrays.equals(check.getAcceptableTokens(), TokenUtil.getAllTokenIds());\n    }\n\n    private static void validatePropertySectionPropertyJavadocTokens(String fileName,\n            String sectionName, AbstractJavadocCheck check, List<Node> columns) {\n        assertEquals(\"javadoc tokens to check\",\n                columns.get(1).getTextContent(), fileName + \" section '\" + sectionName\n                        + \"' should have the basic token javadoc description\");\n\n        final String acceptableTokenText = columns.get(2).getTextContent().trim();\n        assertEquals(\"subset of javadoc tokens \"\n                        + CheckUtil.getJavadocTokenText(check.getAcceptableJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                acceptableTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the acceptable javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(acceptableTokenText),\n                fileName + \"'s acceptable javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n\n        final String defaultTokenText = columns.get(3).getTextContent().trim();\n        assertEquals(CheckUtil.getJavadocTokenText(check.getDefaultJavadocTokens(),\n                check.getRequiredJavadocTokens()),\n                defaultTokenText\n                        .replaceAll(\"\\\\s+\", \" \")\n                        .replaceAll(\"\\\\s,\", \",\")\n                        .replaceAll(\"\\\\s\\\\.\", \".\"),\n                fileName + \" section '\" + sectionName\n                        + \"' should have all the default javadoc tokens\");\n        assertFalse(isInvalidTokenPunctuation(defaultTokenText),\n                fileName + \"'s default javadoc token section: \" + sectionName\n                        + \"should have ',' & '.' at beginning of the next corresponding lines.\");\n    }\n\n    private static boolean isInvalidTokenPunctuation(String tokenText) {\n        return Pattern.compile(\"\\\\w,\").matcher(tokenText).find()\n                || Pattern.compile(\"\\\\w\\\\.\").matcher(tokenText).find();\n    }\n\n    /**\n     * Get's the name of the bean property's type for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @param propertyName The property name to work with.\n     * @return String form of property's type.\n     * @noinspection IfStatementWithTooManyBranches, OverlyComplexBooleanExpression\n     */\n    private static String getModulePropertyExpectedTypeName(String sectionName, Class<?> fieldClass,\n            Object instance, String propertyName) {\n        final String instanceName = instance.getClass().getSimpleName();\n        String result = null;\n        final String checkProperty = sectionName + \":\" + propertyName;\n        if ((\"SuppressionCommentFilter\".equals(sectionName)\n                || \"SuppressWithNearbyCommentFilter\".equals(sectionName)\n                || \"SuppressWithPlainTextCommentFilter\".equals(sectionName))\n                    && (\"checkFormat\".equals(propertyName)\n                        || \"messageFormat\".equals(propertyName)\n                        || \"idFormat\".equals(propertyName)\n                        || \"influenceFormat\".equals(propertyName))\n                || (\"RegexpMultiline\".equals(sectionName)\n                    || \"RegexpSingleline\".equals(sectionName)\n                    || \"RegexpSinglelineJava\".equals(sectionName))\n                    && \"format\".equals(propertyName)) {\n            // dynamic custom expression\n            result = \"Regular Expression\";\n        }\n        else if (fieldClass == boolean.class) {\n            result = \"boolean\";\n        }\n        else if (fieldClass == int.class) {\n            result = \"int\";\n        }\n        else if (fieldClass == int[].class) {\n            if (isPropertyTokenType(sectionName, propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"int[]\";\n            }\n        }\n        else if (fieldClass == double[].class) {\n            result = \"double[]\";\n        }\n        else if (fieldClass == String.class || fieldClass == Charset.class) {\n            result = \"String\";\n\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result += \" (either the empty string or an uppercase ISO 3166 2-letter code)\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result += \" (either the empty string or a lowercase ISO 639 code)\";\n            }\n        }\n        else if (fieldClass == String[].class) {\n            if (propertyName.endsWith(\"Tokens\") || propertyName.endsWith(\"Token\")\n                    || \"AtclauseOrderCheck\".equals(instanceName) && \"target\".equals(propertyName)\n                    || \"MultipleStringLiteralsCheck\".equals(instanceName)\n                            && \"ignoreOccurrenceContext\".equals(propertyName)) {\n                result = \"subset of tokens TokenTypes\";\n            }\n            else {\n                result = \"String[]\";\n            }\n        }\n        else if (fieldClass == URI.class) {\n            result = \"URI\";\n        }\n        else if (fieldClass == Pattern.class) {\n            if (\"SuppressionSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:files\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:checks\".equals(checkProperty)\n                || \"SuppressionXpathSingleFilter:message\".equals(checkProperty)\n                || \"IllegalTokenText:format\".equals(checkProperty)) {\n                result = \"Regular Expression\";\n            }\n            else {\n                result = \"Pattern\";\n            }\n        }\n        else if (fieldClass == Pattern[].class) {\n            if (\"ImportOrder:groups\".equals(checkProperty)\n                || \"ImportOrder:staticGroups\".equals(checkProperty)\n                || \"ClassDataAbstractionCoupling:excludeClassesRegexps\".equals(checkProperty)\n                || \"ClassFanOutComplexity:excludeClassesRegexps\".equals(checkProperty)) {\n                result = \"Regular Expressions\";\n            }\n            else {\n                result = \"Pattern[]\";\n            }\n        }\n        else if (fieldClass == Scope.class) {\n            result = \"Scope\";\n        }\n        else if (fieldClass == AccessModifierOption[].class) {\n            result = \"AccessModifierOption[]\";\n        }\n        else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n            result = \"File\";\n        }\n        else if (fieldClass.isEnum()) {\n            result = fieldClass.getSimpleName();\n        }\n        else {\n            fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n        }\n\n        if (\"SuppressWarningsHolder\".equals(instanceName)) {\n            result = result + \" in a format of comma separated attribute=value entries. The \"\n                    + \"attribute is the fully qualified name of the Check and value is its alias.\";\n        }\n\n        return result;\n    }\n\n    /**\n     * Get's the name of the bean property's default value for the class.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @param field The bean property's field.\n     * @param fieldClass The bean property's type.\n     * @param instance The class instance to work with.\n     * @return String form of property's default value.\n     * @noinspection OverlyNestedMethod\n     */\n    private static String getModulePropertyExpectedValue(String sectionName, String propertyName,\n            Field field, Class<?> fieldClass, Object instance) throws Exception {\n        String result = null;\n\n        if (field != null) {\n            Object value = field.get(instance);\n\n            // noinspection IfStatementWithTooManyBranches\n            if (\"Checker\".equals(sectionName) && \"localeCountry\".equals(propertyName)) {\n                result = \"default locale country for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"localeLanguage\".equals(propertyName)) {\n                result = \"default locale language for the Java Virtual Machine\";\n            }\n            else if (\"Checker\".equals(sectionName) && \"charset\".equals(propertyName)) {\n                result = \"UTF-8\";\n            }\n            else if (\"charset\".equals(propertyName)) {\n                result = \"the charset property of the parent Checker module\";\n            }\n            else if (\"PropertyCacheFile\".equals(fieldClass.getSimpleName())) {\n                result = \"null (no cache file)\";\n            }\n            else if (fieldClass == boolean.class) {\n                result = value.toString();\n            }\n            else if (fieldClass == int.class) {\n                if (value.equals(Integer.MAX_VALUE)) {\n                    result = \"2147483647\";\n                }\n                else {\n                    result = value.toString();\n                }\n            }\n            else if (fieldClass == int[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final int[] newArray = new int[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        newArray[index] = (Integer) iterator.next();\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (isPropertyTokenType(sectionName, propertyName)) {\n                    boolean first = true;\n\n                    if (value instanceof BitSet) {\n                        final BitSet list = (BitSet) value;\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < list.size(); i++) {\n                            if (list.get(i)) {\n                                if (first) {\n                                    first = false;\n                                }\n                                else {\n                                    sb.append(\", \");\n                                }\n\n                                sb.append(TokenUtil.getTokenName(i));\n                            }\n                        }\n\n                        result = sb.toString();\n                    }\n                    else {\n                        final StringBuilder sb = new StringBuilder(20);\n\n                        for (int i = 0; i < Array.getLength(value); i++) {\n                            if (first) {\n                                first = false;\n                            }\n                            else {\n                                sb.append(\", \");\n                            }\n\n                            sb.append(TokenUtil.getTokenName((int) Array.get(value, i)));\n                        }\n\n                        result = sb.toString();\n                    }\n                }\n                else {\n                    result = Arrays.toString((int[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n                }\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == double[].class) {\n                result = Arrays.toString((double[]) value).replace(\"[\", \"\").replace(\"]\", \"\")\n                        .replace(\".0\", \"\");\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass == String[].class) {\n                if (value == null) {\n                    result = \"\";\n                }\n                else {\n                    final Stream<?> valuesStream;\n                    if (value instanceof Collection) {\n                        final Collection<?> collection = (Collection<?>) value;\n                        valuesStream = collection.stream();\n                    }\n                    else {\n                        final Object[] array = (Object[]) value;\n                        valuesStream = Arrays.stream(array);\n                    }\n                    result = valuesStream\n                        .map(String.class::cast)\n                        .sorted()\n                        .collect(Collectors.joining(\", \"));\n                }\n\n                if (result.isEmpty()) {\n                    if (\"fileExtensions\".equals(propertyName)) {\n                        result = \"all files\";\n                    }\n                    else {\n                        result = \"{}\";\n                    }\n                }\n            }\n            else if (fieldClass == URI.class || fieldClass == String.class) {\n                if (value != null) {\n                    result = '\"' + value.toString() + '\"';\n                }\n            }\n            else if (fieldClass == Pattern.class) {\n                if (value != null) {\n                    result = '\"' + value.toString().replace(\"\\n\", \"\\\\n\").replace(\"\\t\", \"\\\\t\")\n                            .replace(\"\\r\", \"\\\\r\").replace(\"\\f\", \"\\\\f\") + '\"';\n                }\n            }\n            else if (fieldClass == Pattern[].class) {\n                if (value instanceof Collection) {\n                    final Collection<?> collection = (Collection<?>) value;\n                    final Pattern[] newArray = new Pattern[collection.size()];\n                    final Iterator<?> iterator = collection.iterator();\n                    int index = 0;\n\n                    while (iterator.hasNext()) {\n                        final Object next = iterator.next();\n                        newArray[index] = (Pattern) next;\n                        index++;\n                    }\n\n                    value = newArray;\n                }\n\n                if (value != null && Array.getLength(value) > 0) {\n                    final String[] newArray = new String[Array.getLength(value)];\n\n                    for (int i = 0; i < newArray.length; i++) {\n                        newArray[i] = ((Pattern) Array.get(value, i)).pattern();\n                    }\n\n                    result = Arrays.toString(newArray).replace(\"[\", \"\")\n                            .replace(\"]\", \"\");\n                }\n                else {\n                    result = \"\";\n                }\n\n                if (result.isEmpty()) {\n                    result = \"{}\";\n                }\n            }\n            else if (fieldClass.isEnum()) {\n                if (value != null) {\n                    result = value.toString().toLowerCase(Locale.ENGLISH);\n                }\n            }\n            else if (fieldClass == AccessModifierOption[].class) {\n                result = Arrays.toString((Object[]) value).replace(\"[\", \"\").replace(\"]\", \"\");\n            }\n            else {\n                fail(\"Unknown property type: \" + fieldClass.getSimpleName());\n            }\n\n            if (result == null) {\n                result = \"null\";\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if the given property is takes token names as a type.\n     *\n     * @param sectionName The name of the section/module being worked on.\n     * @param propertyName The property name to work with.\n     * @return {@code true} if the property is takes token names as a type.\n     * @noinspection OverlyComplexBooleanExpression\n     */\n    private static boolean isPropertyTokenType(String sectionName, String propertyName) {\n        return \"AtclauseOrder\".equals(sectionName) && \"target\".equals(propertyName)\n            || \"IllegalType\".equals(sectionName) && \"memberModifiers\".equals(propertyName)\n            || \"MagicNumber\".equals(sectionName)\n                    && \"constantWaiverParentToken\".equals(propertyName)\n            || \"MultipleStringLiterals\".equals(sectionName)\n                    && \"ignoreOccurrenceContext\".equals(propertyName)\n            || \"DescendantToken\".equals(sectionName) && \"limitedTokens\".equals(propertyName);\n    }\n\n    private static Field getField(Class<?> clss, String propertyName) {\n        Field result = null;\n\n        if (clss != null) {\n            try {\n                result = clss.getDeclaredField(propertyName);\n                result.setAccessible(true);\n            }\n            catch (NoSuchFieldException ignored) {\n                result = getField(clss.getSuperclass(), propertyName);\n            }\n        }\n\n        return result;\n    }\n\n    private static Class<?> getFieldClass(String fileName, String sectionName, Object instance,\n            Field field, String propertyName) throws Exception {\n        Class<?> result = null;\n\n        if (field != null) {\n            result = field.getType();\n        }\n        if (result == null) {\n            assertTrue(\n                    PROPERTIES_ALLOWED_GET_TYPES_FROM_METHOD.contains(sectionName + \".\"\n                            + propertyName),\n                    fileName + \" section '\" + sectionName + \"' could not find field \"\n                            + propertyName);\n\n            final PropertyDescriptor descriptor = PropertyUtils.getPropertyDescriptor(instance,\n                    propertyName);\n            result = descriptor.getPropertyType();\n        }\n        if (result == List.class || result == Set.class) {\n            final ParameterizedType type = (ParameterizedType) field.getGenericType();\n            final Class<?> parameterClass = (Class<?>) type.getActualTypeArguments()[0];\n\n            if (parameterClass == Integer.class) {\n                result = int[].class;\n            }\n            else if (parameterClass == String.class) {\n                result = String[].class;\n            }\n            else if (parameterClass == Pattern.class) {\n                result = Pattern[].class;\n            }\n            else {\n                fail(\"Unknown parameterized type: \" + parameterClass.getSimpleName());\n            }\n        }\n        else if (result == BitSet.class) {\n            result = int[].class;\n        }\n\n        return result;\n    }\n\n    private static Set<String> getListById(Node subSection, String id) {\n        Set<String> result = null;\n        final Node node = XmlUtil.findChildElementById(subSection, id);\n        if (node != null) {\n            result = XmlUtil.getChildrenElements(node)\n                    .stream()\n                    .map(Node::getTextContent)\n                    .collect(Collectors.toSet());\n        }\n        return result;\n    }\n\n    private static void validateViolationSection(String fileName, String sectionName,\n                                                 Node subSection,\n                                                 Object instance) throws Exception {\n        final Class<?> clss = instance.getClass();\n        final Set<Field> fields = CheckUtil.getCheckMessages(clss, true);\n        final Set<String> list = new TreeSet<>();\n\n        for (Field field : fields) {\n            // below is required for package/private classes\n            if (!field.isAccessible()) {\n                field.setAccessible(true);\n            }\n\n            list.add(field.get(null).toString());\n        }\n\n        final StringBuilder expectedText = new StringBuilder(120);\n\n        for (String s : list) {\n            expectedText.append(s);\n            expectedText.append('\\n');\n        }\n\n        if (expectedText.length() > 0) {\n            expectedText.append(\"All messages can be customized if the default message doesn't \"\n                    + \"suit you.\\nPlease see the documentation to learn how to.\");\n        }\n\n        if (subSection == null) {\n            assertEquals(\"\", expectedText.toString(), fileName + \" section '\" + sectionName\n                    + \"' should have the expected error keys\");\n        }\n        else {\n            assertEquals(expectedText.toString().trim(),\n                    subSection.getTextContent().replaceAll(\"\\n\\\\s+\", \"\\n\").trim(),\n                    fileName + \" section '\" + sectionName\n                            + \"' should have the expected error keys\");\n\n            for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n                final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n                final String linkText = node.getTextContent().trim();\n                final String expectedUrl;\n\n                if (\"see the documentation\".equals(linkText)) {\n                    expectedUrl = \"config.html#Custom_messages\";\n                }\n                else {\n                    expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources%2F\"\n                            + clss.getPackage().getName().replace(\".\", \"%2F\")\n                            + \"+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22\"\n                            + linkText + \"%22\";\n                }\n\n                assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                        + \"' should have matching url for '\" + linkText + \"'\");\n            }\n        }\n    }\n\n    private static void validateUsageExample(String fileName, String sectionName, Node subSection) {\n        final String text = subSection.getTextContent().replace(\"Checkstyle Style\", \"\")\n                .replace(\"Google Style\", \"\").replace(\"Sun Style\", \"\").trim();\n\n        assertTrue(text.isEmpty(), fileName + \" section '\" + sectionName\n                + \"' has unknown text in 'Example of Usage': \" + text);\n\n        boolean hasCheckstyle = false;\n        boolean hasGoogle = false;\n        boolean hasSun = false;\n\n        for (Node node : XmlUtil.findChildElementsByTag(subSection, \"a\")) {\n            final String url = node.getAttributes().getNamedItem(\"href\").getTextContent();\n            final String linkText = node.getTextContent().trim();\n            String expectedUrl = null;\n\n            if (\"Checkstyle Style\".equals(linkText)) {\n                hasCheckstyle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Aconfig+filename%3Acheckstyle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\" + sectionName;\n            }\n            else if (\"Google Style\".equals(linkText)) {\n                hasGoogle = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                            + \"' should be in google_checks.xml or not reference 'Google Style'\");\n            }\n            else if (\"Sun Style\".equals(linkText)) {\n                hasSun = true;\n                expectedUrl = \"https://github.com/search?q=\"\n                        + \"path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+\"\n                        + \"repo%3Acheckstyle%2Fcheckstyle+\"\n                        + sectionName;\n\n                assertTrue(\n                        SUN_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                                + \"' should be in sun_checks.xml or not reference 'Sun Style'\");\n            }\n\n            assertEquals(expectedUrl, url, fileName + \" section '\" + sectionName\n                    + \"' should have matching url\");\n        }\n\n        assertTrue(hasCheckstyle, fileName + \" section '\" + sectionName\n                + \"' should have a checkstyle section\");\n        assertTrue(hasGoogle\n                || !GOOGLE_MODULES.contains(sectionName), fileName + \" section '\" + sectionName\n                        + \"' should have a google section since it is in it's config\");\n        assertTrue(hasSun || !SUN_MODULES.contains(sectionName),\n                fileName + \" section '\" + sectionName\n                        + \"' should have a sun section since it is in it's config\");\n    }\n\n    private static void validatePackageSection(String fileName, String sectionName,\n            Node subSection, Object instance) {\n        assertEquals(instance.getClass().getPackage().getName(),\n                subSection.getTextContent().trim(), fileName + \" section '\" + sectionName\n                        + \"' should have matching package\");\n    }\n\n    private static void validateParentSection(String fileName, String sectionName,\n            Node subSection) {\n        final String expected;\n\n        if (!\"TreeWalker\".equals(sectionName) && hasParentModule(sectionName)) {\n            expected = \"TreeWalker\";\n        }\n        else {\n            expected = \"Checker\";\n        }\n\n        assertEquals(expected, subSection.getTextContent().trim(),\n                fileName + \" section '\" + sectionName + \"' should have matching parent\");\n    }\n\n    private static boolean hasParentModule(String sectionName) {\n        final String search = \"\\\"\" + sectionName + \"\\\"\";\n        boolean result = true;\n\n        for (String find : XML_FILESET_LIST) {\n            if (find.contains(search)) {\n                result = false;\n                break;\n            }\n        }\n\n        return result;\n    }\n\n    private static Set<String> getProperties(Class<?> clss) {\n        final Set<String> result = new TreeSet<>();\n        final PropertyDescriptor[] map = PropertyUtils.getPropertyDescriptors(clss);\n\n        for (PropertyDescriptor p : map) {\n            if (p.getWriteMethod() != null) {\n                result.add(p.getName());\n            }\n        }\n\n        return result;\n    }\n\n    @Test\n    public void testAllStyleRules() throws Exception {\n        for (Path path : XdocUtil.getXdocsStyleFilePaths(XdocUtil.getXdocsFilePaths())) {\n            final String fileName = path.getFileName().toString();\n            final String styleName = fileName.substring(0, fileName.lastIndexOf('_'));\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"tr\");\n\n            final Set<String> styleChecks;\n            switch (styleName) {\n                case \"google\":\n                    styleChecks = new HashSet<>(GOOGLE_MODULES);\n                    break;\n\n                case \"sun\":\n                    styleChecks = new HashSet<>(SUN_MODULES);\n                    styleChecks.removeAll(IGNORED_SUN_MODULES);\n                    break;\n\n                default:\n                    fail(\"Missing modules list for style file '\" + fileName + \"'\");\n                    styleChecks = null;\n            }\n\n            String lastRuleName = null;\n            String[] lastRuleNumberParts = null;\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node row = sources.item(position);\n                final List<Node> columns = new ArrayList<>(\n                        XmlUtil.findChildElementsByTag(row, \"td\"));\n\n                if (columns.isEmpty()) {\n                    continue;\n                }\n\n                final String ruleName = columns.get(1).getTextContent().trim();\n                lastRuleNumberParts = validateRuleNameOrder(\n                        fileName, lastRuleName, lastRuleNumberParts, ruleName);\n\n                if (!\"--\".equals(ruleName)) {\n                    validateStyleAnchors(XmlUtil.findChildElementsByTag(columns.get(0), \"a\"),\n                            fileName, ruleName);\n                }\n\n                validateStyleModules(XmlUtil.findChildElementsByTag(columns.get(2), \"a\"),\n                        XmlUtil.findChildElementsByTag(columns.get(3), \"a\"), styleChecks, styleName,\n                        ruleName);\n\n                lastRuleName = ruleName;\n            }\n\n            // these modules aren't documented, but are added to the config\n            styleChecks.remove(\"BeforeExecutionExclusionFileFilter\");\n            styleChecks.remove(\"SuppressionFilter\");\n            styleChecks.remove(\"SuppressionXpathFilter\");\n            styleChecks.remove(\"SuppressionXpathSingleFilter\");\n            styleChecks.remove(\"TreeWalker\");\n            styleChecks.remove(\"Checker\");\n\n            assertTrue(styleChecks.isEmpty(),\n                    fileName + \" requires the following check(s) to appear: \" + styleChecks);\n        }\n    }\n\n    private static String[] validateRuleNameOrder(String fileName, String lastRuleName,\n                                                  String[] lastRuleNumberParts, String ruleName) {\n        final String[] ruleNumberParts = ruleName.split(\" \", 2)[0].split(\"\\\\.\");\n\n        if (lastRuleName != null) {\n            final int ruleNumberPartsAmount = ruleNumberParts.length;\n            final int lastRuleNumberPartsAmount = lastRuleNumberParts.length;\n            final String outOfOrderReason = fileName + \" rule '\" + ruleName\n                    + \"' is out of order compared to '\" + lastRuleName + \"'\";\n            boolean lastRuleNumberPartWasEqual = false;\n            int partIndex;\n            for (partIndex = 0; partIndex < ruleNumberPartsAmount; partIndex++) {\n                if (lastRuleNumberPartsAmount <= partIndex) {\n                    // equal up to here and last rule has less parts,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n\n                final String ruleNumberPart = ruleNumberParts[partIndex];\n                final String lastRuleNumberPart = lastRuleNumberParts[partIndex];\n                final boolean ruleNumberPartsAreNumeric = IntStream.concat(\n                        ruleNumberPart.chars(),\n                        lastRuleNumberPart.chars()\n                ).allMatch(Character::isDigit);\n\n                if (ruleNumberPartsAreNumeric) {\n                    final int numericRuleNumberPart = parseInt(ruleNumberPart);\n                    final int numericLastRuleNumberPart = parseInt(lastRuleNumberPart);\n                    assertThat(outOfOrderReason,\n                            numericRuleNumberPart < numericLastRuleNumberPart,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    numericRuleNumberPart, numericLastRuleNumberPart));\n                }\n                else {\n                    assertThat(outOfOrderReason,\n                            ruleNumberPart.compareToIgnoreCase(lastRuleNumberPart) < 0,\n                            describedAs(\"'%0' should not be less than '%1'\",\n                                    is(false),\n                                    ruleNumberPart, lastRuleNumberPart));\n                }\n                lastRuleNumberPartWasEqual = ruleNumberPart.equalsIgnoreCase(lastRuleNumberPart);\n                if (!lastRuleNumberPartWasEqual) {\n                    // number part is not equal but properly ordered,\n                    // thus order is correct, stop comparing\n                    break;\n                }\n            }\n            if (ruleNumberPartsAmount == partIndex && lastRuleNumberPartWasEqual) {\n                if (lastRuleNumberPartsAmount == partIndex) {\n                    fail(fileName + \" rule '\" + ruleName + \"' and rule '\"\n                            + lastRuleName + \"' have the same rule number\");\n                }\n                else {\n                    fail(outOfOrderReason);\n                }\n            }\n        }\n\n        return ruleNumberParts;\n    }\n\n    private static void validateStyleAnchors(Set<Node> anchors, String fileName, String ruleName) {\n        assertEquals(2,\n                anchors.size(), fileName + \" rule '\" + ruleName + \"' must have two row anchors\");\n\n        final int space = ruleName.indexOf(' ');\n        assertNotEquals(-1, space,\n                fileName + \" rule '\" + ruleName\n                        + \"' must have have a space between the rule's number and the rule's name\");\n\n        final String ruleNumber = ruleName.substring(0, space);\n\n        int position = 1;\n\n        for (Node anchor : anchors) {\n            final String actualUrl;\n            final String expectedUrl;\n\n            if (position == 1) {\n                actualUrl = XmlUtil.getNameAttributeOfNode(anchor);\n                expectedUrl = ruleNumber;\n            }\n            else {\n                actualUrl = anchor.getAttributes().getNamedItem(\"href\").getTextContent();\n                expectedUrl = \"#\" + ruleNumber;\n            }\n\n            assertEquals(expectedUrl, actualUrl, fileName + \" rule '\" + ruleName + \"' anchor \"\n                    + position + \" should have matching name/url\");\n\n            position++;\n        }\n    }\n\n    private static void validateStyleModules(Set<Node> checks, Set<Node> configs,\n            Set<String> styleChecks, String styleName, String ruleName) {\n        final Iterator<Node> itrChecks = checks.iterator();\n        final Iterator<Node> itrConfigs = configs.iterator();\n\n        while (itrChecks.hasNext()) {\n            final Node module = itrChecks.next();\n            final String moduleName = module.getTextContent().trim();\n\n            if (!module.getAttributes().getNamedItem(\"href\").getTextContent()\n                    .startsWith(\"config_\")) {\n                continue;\n            }\n\n            assertFalse(moduleName.endsWith(\"Check\"),\n                    styleName + \"_style.xml rule '\" + ruleName + \"' module '\" + moduleName\n                        + \"' shouldn't end with 'Check'\");\n\n            styleChecks.remove(moduleName);\n\n            for (String configName : new String[] {\"config\", \"test\"}) {\n                Node config = null;\n\n                try {\n                    config = itrConfigs.next();\n                }\n                catch (NoSuchElementException ignore) {\n                    fail(styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                            + moduleName + \"' is missing the config link: \" + configName);\n                }\n\n                assertEquals(configName, config.getTextContent().trim(),\n                        styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                + moduleName + \"' has mismatched config/test links\");\n\n                final String configUrl = config.getAttributes().getNamedItem(\"href\")\n                        .getTextContent();\n\n                if (\"config\".equals(configName)) {\n                    final String expectedUrl = \"https://github.com/search?q=\"\n                            + \"path%3Asrc%2Fmain%2Fresources+filename%3A\" + styleName\n                            + \"_checks.xml+repo%3Acheckstyle%2Fcheckstyle+\" + moduleName;\n\n                    assertEquals(expectedUrl, configUrl,\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                }\n                else if (\"test\".equals(configName)) {\n                    assertTrue(\n                            configUrl.startsWith(\"https://github.com/checkstyle/checkstyle/\"\n                                    + \"blob/master/src/it/java/com/\" + styleName\n                                    + \"/checkstyle/test/\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n                    assertTrue(configUrl.endsWith(\"/\" + moduleName + \"Test.java\"),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have matching \" + configName + \" url\");\n\n                    assertTrue(\n                            new File(configUrl.substring(53)\n                                    .replace('/', File.separatorChar)).exists(),\n                            styleName + \"_style.xml rule '\" + ruleName + \"' module '\"\n                                    + moduleName + \"' should have a test that exists\");\n                }\n            }\n        }\n\n        assertFalse(itrConfigs.hasNext(),\n                styleName + \"_style.xml rule '\" + ruleName + \"' has too many configs\");\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate createCharset(name String) : Charset extracted from public setCharset(charset String) : void in class com.puppycrawl.tools.checkstyle.checks.header.AbstractHeaderCheck", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java", "startLine": 78, "endLine": 90, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java", "startLine": 79, "endLine": 86, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java", "startLine": 134, "endLine": 147, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Setter to specify the character encoding to use when reading the headerFile.\n     *\n     * @param charset the charset to use for loading the header from a file\n     * @throws UnsupportedEncodingException if charset is unsupported\n     */\n    public void setCharset(String charset) throws UnsupportedEncodingException {\n        if (!Charset.isSupported(charset)) {\n            final String message = \"unsupported charset: '\" + charset + \"'\";\n            throw new UnsupportedEncodingException(message);\n        }\n        this.charset = charset;\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java", "isPureRefactoring": true, "commitId": "c7ab4222990de0f3035fa2eb1954fbddc7e4cbaf", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.header", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.header.AbstractHeaderCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.header.AbstractHeaderCheck#setCharset", "classSignatureBefore": "public abstract class AbstractHeaderCheck extends AbstractFileSetCheck\n    implements ExternalResourceHolder ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.header.AbstractHeaderCheck#setCharset"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.header.AbstractHeaderCheck"], "classSignatureBeforeSet": ["public abstract class AbstractHeaderCheck extends AbstractFileSetCheck\n    implements ExternalResourceHolder "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics \nTolerable Changes in the body \n Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.header;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.ExternalResourceHolder;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Abstract super class for header checks.\n * Provides support for header and headerFile properties.\n */\npublic abstract class AbstractHeaderCheck extends AbstractFileSetCheck\n    implements ExternalResourceHolder {\n\n    /** Pattern to detect occurrences of '\\n' in text. */\n    private static final Pattern ESCAPED_LINE_FEED_PATTERN = Pattern.compile(\"\\\\\\\\n\");\n\n    /** The lines of the header file. */\n    private final List<String> readerLines = new ArrayList<>();\n\n    /** Specify the name of the file containing the required header. */\n    private URI headerFile;\n\n    /** Specify the character encoding to use when reading the headerFile. */\n    private String charset = System.getProperty(\"file.encoding\", StandardCharsets.UTF_8.name());\n\n    /**\n     * Hook method for post processing header lines.\n     * This implementation does nothing.\n     */\n    protected abstract void postProcessHeaderLines();\n\n    /**\n     * Return the header lines to check against.\n     *\n     * @return the header lines to check against.\n     */\n    protected List<String> getHeaderLines() {\n        final List<String> copy = new ArrayList<>(readerLines);\n        return Collections.unmodifiableList(copy);\n    }\n\n    /**\n     * Setter to specify the character encoding to use when reading the headerFile.\n     *\n     * @param charset the charset to use for loading the header from a file\n     * @throws UnsupportedEncodingException if charset is unsupported\n     */\n    public void setCharset(String charset) throws UnsupportedEncodingException {\n        if (!Charset.isSupported(charset)) {\n            final String message = \"unsupported charset: '\" + charset + \"'\";\n            throw new UnsupportedEncodingException(message);\n        }\n        this.charset = charset;\n    }\n\n    /**\n     * Setter to specify the name of the file containing the required header..\n     *\n     * @param uri the uri of the header to load.\n     * @throws CheckstyleException if fileName is empty.\n     */\n    public void setHeaderFile(URI uri) throws CheckstyleException {\n        if (uri == null) {\n            throw new CheckstyleException(\n                \"property 'headerFile' is missing or invalid in module \"\n                    + getConfiguration().getName());\n        }\n\n        headerFile = uri;\n    }\n\n    /**\n     * Load the header from a file.\n     *\n     * @throws CheckstyleException if the file cannot be loaded\n     */\n    private void loadHeaderFile() throws CheckstyleException {\n        checkHeaderNotInitialized();\n        try (Reader headerReader = new InputStreamReader(new BufferedInputStream(\n                    headerFile.toURL().openStream()), charset)) {\n            loadHeader(headerReader);\n        }\n        catch (final IOException ex) {\n            throw new CheckstyleException(\n                    \"unable to load header file \" + headerFile, ex);\n        }\n    }\n\n    /**\n     * Called before initializing the header.\n     *\n     * @throws IllegalArgumentException if header has already been set\n     */\n    private void checkHeaderNotInitialized() {\n        if (!readerLines.isEmpty()) {\n            throw new IllegalArgumentException(\n                    \"header has already been set - \"\n                    + \"set either header or headerFile, not both\");\n        }\n    }\n\n    /**\n     * Set the header to check against. Individual lines in the header\n     * must be separated by '\\n' characters.\n     *\n     * @param header header content to check against.\n     * @throws IllegalArgumentException if the header cannot be interpreted\n     */\n    public void setHeader(String header) {\n        if (!CommonUtil.isBlank(header)) {\n            checkHeaderNotInitialized();\n\n            final String headerExpandedNewLines = ESCAPED_LINE_FEED_PATTERN\n                    .matcher(header).replaceAll(\"\\n\");\n\n            try (Reader headerReader = new StringReader(headerExpandedNewLines)) {\n                loadHeader(headerReader);\n            }\n            catch (final IOException ex) {\n                throw new IllegalArgumentException(\"unable to load header\", ex);\n            }\n        }\n    }\n\n    /**\n     * Load header to check against from a Reader into readerLines.\n     *\n     * @param headerReader delivers the header to check against\n     * @throws IOException if\n     */\n    private void loadHeader(final Reader headerReader) throws IOException {\n        try (LineNumberReader lnr = new LineNumberReader(headerReader)) {\n            String line;\n            do {\n                line = lnr.readLine();\n                if (line != null) {\n                    readerLines.add(line);\n                }\n            } while (line != null);\n            postProcessHeaderLines();\n        }\n    }\n\n    @Override\n    protected final void finishLocalSetup() throws CheckstyleException {\n        if (headerFile != null) {\n            loadHeaderFile();\n        }\n    }\n\n    @Override\n    public Set<String> getExternalResourceLocations() {\n        final Set<String> result;\n\n        if (headerFile == null) {\n            result = Collections.emptySet();\n        }\n        else {\n            result = Collections.singleton(headerFile.toString());\n        }\n\n        return result;\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.header;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.ExternalResourceHolder;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Abstract super class for header checks.\n * Provides support for header and headerFile properties.\n */\npublic abstract class AbstractHeaderCheck extends AbstractFileSetCheck\n    implements ExternalResourceHolder {\n\n    /** Pattern to detect occurrences of '\\n' in text. */\n    private static final Pattern ESCAPED_LINE_FEED_PATTERN = Pattern.compile(\"\\\\\\\\n\");\n\n    /** The lines of the header file. */\n    private final List<String> readerLines = new ArrayList<>();\n\n    /** Specify the name of the file containing the required header. */\n    private URI headerFile;\n\n    /** Specify the character encoding to use when reading the headerFile. */\n    private Charset charset = createCharset(System.getProperty(\"file.encoding\",\n        StandardCharsets.UTF_8.name()));\n\n    /**\n     * Hook method for post processing header lines.\n     * This implementation does nothing.\n     */\n    protected abstract void postProcessHeaderLines();\n\n    /**\n     * Return the header lines to check against.\n     *\n     * @return the header lines to check against.\n     */\n    protected List<String> getHeaderLines() {\n        final List<String> copy = new ArrayList<>(readerLines);\n        return Collections.unmodifiableList(copy);\n    }\n\n    /**\n     * Setter to specify the charset to use when reading the headerFile.\n     *\n     * @param charset the charset name to use for loading the header from a file\n     */\n    public void setCharset(String charset) {\n        this.charset = createCharset(charset);\n    }\n\n    /**\n     * Setter to specify the name of the file containing the required header..\n     *\n     * @param uri the uri of the header to load.\n     * @throws CheckstyleException if fileName is empty.\n     */\n    public void setHeaderFile(URI uri) throws CheckstyleException {\n        if (uri == null) {\n            throw new CheckstyleException(\n                \"property 'headerFile' is missing or invalid in module \"\n                    + getConfiguration().getName());\n        }\n\n        headerFile = uri;\n    }\n\n    /**\n     * Load the header from a file.\n     *\n     * @throws CheckstyleException if the file cannot be loaded\n     */\n    private void loadHeaderFile() throws CheckstyleException {\n        checkHeaderNotInitialized();\n        try (Reader headerReader = new InputStreamReader(new BufferedInputStream(\n                    headerFile.toURL().openStream()), charset)) {\n            loadHeader(headerReader);\n        }\n        catch (final IOException ex) {\n            throw new CheckstyleException(\n                    \"unable to load header file \" + headerFile, ex);\n        }\n    }\n\n    /**\n     * Called before initializing the header.\n     *\n     * @throws IllegalArgumentException if header has already been set\n     */\n    private void checkHeaderNotInitialized() {\n        if (!readerLines.isEmpty()) {\n            throw new IllegalArgumentException(\n                    \"header has already been set - \"\n                    + \"set either header or headerFile, not both\");\n        }\n    }\n\n    /**\n     * Creates charset by name.\n     *\n     * @param name charset name\n     * @return created charset\n     * @throws UnsupportedCharsetException if charset is unsupported\n     */\n    private static Charset createCharset(String name) {\n        if (!Charset.isSupported(name)) {\n            final String message = \"unsupported charset: '\" + name + \"'\";\n            throw new UnsupportedCharsetException(message);\n        }\n        return Charset.forName(name);\n    }\n\n    /**\n     * Set the header to check against. Individual lines in the header\n     * must be separated by '\\n' characters.\n     *\n     * @param header header content to check against.\n     * @throws IllegalArgumentException if the header cannot be interpreted\n     */\n    public void setHeader(String header) {\n        if (!CommonUtil.isBlank(header)) {\n            checkHeaderNotInitialized();\n\n            final String headerExpandedNewLines = ESCAPED_LINE_FEED_PATTERN\n                    .matcher(header).replaceAll(\"\\n\");\n\n            try (Reader headerReader = new StringReader(headerExpandedNewLines)) {\n                loadHeader(headerReader);\n            }\n            catch (final IOException ex) {\n                throw new IllegalArgumentException(\"unable to load header\", ex);\n            }\n        }\n    }\n\n    /**\n     * Load header to check against from a Reader into readerLines.\n     *\n     * @param headerReader delivers the header to check against\n     * @throws IOException if\n     */\n    private void loadHeader(final Reader headerReader) throws IOException {\n        try (LineNumberReader lnr = new LineNumberReader(headerReader)) {\n            String line;\n            do {\n                line = lnr.readLine();\n                if (line != null) {\n                    readerLines.add(line);\n                }\n            } while (line != null);\n            postProcessHeaderLines();\n        }\n    }\n\n    @Override\n    protected final void finishLocalSetup() throws CheckstyleException {\n        if (headerFile != null) {\n            loadHeaderFile();\n        }\n    }\n\n    @Override\n    public Set<String> getExternalResourceLocations() {\n        final Set<String> result;\n\n        if (headerFile == null) {\n            result = Collections.emptySet();\n        }\n        else {\n            result = Collections.singleton(headerFile.toString());\n        }\n\n        return result;\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Creates charset by name.\n     *\n     * @param name charset name\n     * @return created charset\n     * @throws UnsupportedCharsetException if charset is unsupported\n     */\n    private static Charset createCharset(String name) {\n        if (!Charset.isSupported(name)) {\n            final String message = \"unsupported charset: '\" + name + \"'\";\n            throw new UnsupportedCharsetException(message);\n        }\n        return Charset.forName(name);\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Setter to specify the charset to use when reading the headerFile.\n     *\n     * @param charset the charset name to use for loading the header from a file\n     */\n    public void setCharset(String charset) {\n        this.charset = createCharset(charset);\n    }\n/**\n     * Creates charset by name.\n     *\n     * @param name charset name\n     * @return created charset\n     * @throws UnsupportedCharsetException if charset is unsupported\n     */\n    private static Charset createCharset(String name) {\n        if (!Charset.isSupported(name)) {\n            final String message = \"unsupported charset: '\" + name + \"'\";\n            throw new UnsupportedCharsetException(message);\n        }\n        return Charset.forName(name);\n    }", "diffSourceCode": "-   78:     /**\n-   79:      * Setter to specify the character encoding to use when reading the headerFile.\n-   80:      *\n-   81:      * @param charset the charset to use for loading the header from a file\n-   82:      * @throws UnsupportedEncodingException if charset is unsupported\n+   78: \n+   79:     /**\n+   80:      * Setter to specify the charset to use when reading the headerFile.\n+   81:      *\n+   82:      * @param charset the charset name to use for loading the header from a file\n    83:      */\n-   84:     public void setCharset(String charset) throws UnsupportedEncodingException {\n-   85:         if (!Charset.isSupported(charset)) {\n-   86:             final String message = \"unsupported charset: '\" + charset + \"'\";\n-   87:             throw new UnsupportedEncodingException(message);\n-   88:         }\n-   89:         this.charset = charset;\n-   90:     }\n-  134:                     + \"set either header or headerFile, not both\");\n-  135:         }\n-  136:     }\n-  137: \n-  138:     /**\n-  139:      * Set the header to check against. Individual lines in the header\n-  140:      * must be separated by '\\n' characters.\n-  141:      *\n-  142:      * @param header header content to check against.\n-  143:      * @throws IllegalArgumentException if the header cannot be interpreted\n-  144:      */\n-  145:     public void setHeader(String header) {\n-  146:         if (!CommonUtil.isBlank(header)) {\n-  147:             checkHeaderNotInitialized();\n+   84:     public void setCharset(String charset) {\n+   85:         this.charset = createCharset(charset);\n+   86:     }\n+   87: \n+   88:     /**\n+   89:      * Setter to specify the name of the file containing the required header..\n+   90:      *\n+  134:     /**\n+  135:      * Creates charset by name.\n+  136:      *\n+  137:      * @param name charset name\n+  138:      * @return created charset\n+  139:      * @throws UnsupportedCharsetException if charset is unsupported\n+  140:      */\n+  141:     private static Charset createCharset(String name) {\n+  142:         if (!Charset.isSupported(name)) {\n+  143:             final String message = \"unsupported charset: '\" + name + \"'\";\n+  144:             throw new UnsupportedCharsetException(message);\n+  145:         }\n+  146:         return Charset.forName(name);\n+  147:     }\n", "uniqueId": "c7ab4222990de0f3035fa2eb1954fbddc7e4cbaf_78_90_134_147_79_86", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 23}, "BRANCH": {"missed": 0, "covered": 2}, "LINE": {"missed": 0, "covered": 5}, "COMPLEXITY": {"missed": 0, "covered": 2}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\n/**\n * Load header to check against from a Reader into readerLines.\n *\n * @param headerReader delivers the header to check against\n * @throws IOException if\n */\nprivate void loadHeader(final Reader headerReader) throws IOException {\n    try (LineNumberReader lnr = new LineNumberReader(headerReader)) {\n        String line;\n        do {\n            line = lnr.readLine();\n            if (line != null) {\n                readerLines.add(line);\n            }\n        } while (line != null);\n        postProcessHeaderLines();\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Setter to specify the character encoding to use when reading the headerFile.\n     *\n     * @param charset the charset to use for loading the header from a file\n     * @throws UnsupportedEncodingException if charset is unsupported\n     */\n    public void setCharset(String charset) throws UnsupportedEncodingException {\n        if (!Charset.isSupported(charset)) {\n            final String message = \"unsupported charset: '\" + charset + \"'\";\n            throw new UnsupportedEncodingException(message);\n        }\n        this.charset = charset;\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.header;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.LineNumberReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URI;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.api.AbstractFileSetCheck;\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.ExternalResourceHolder;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Abstract super class for header checks.\n * Provides support for header and headerFile properties.\n */\npublic abstract class AbstractHeaderCheck extends AbstractFileSetCheck\n    implements ExternalResourceHolder {\n\n    /** Pattern to detect occurrences of '\\n' in text. */\n    private static final Pattern ESCAPED_LINE_FEED_PATTERN = Pattern.compile(\"\\\\\\\\n\");\n\n    /** The lines of the header file. */\n    private final List<String> readerLines = new ArrayList<>();\n\n    /** Specify the name of the file containing the required header. */\n    private URI headerFile;\n\n    /** Specify the character encoding to use when reading the headerFile. */\n    private String charset = System.getProperty(\"file.encoding\", StandardCharsets.UTF_8.name());\n\n    /**\n     * Hook method for post processing header lines.\n     * This implementation does nothing.\n     */\n    protected abstract void postProcessHeaderLines();\n\n    /**\n     * Return the header lines to check against.\n     *\n     * @return the header lines to check against.\n     */\n    protected List<String> getHeaderLines() {\n        final List<String> copy = new ArrayList<>(readerLines);\n        return Collections.unmodifiableList(copy);\n    }\n\n    /**\n     * Setter to specify the character encoding to use when reading the headerFile.\n     *\n     * @param charset the charset to use for loading the header from a file\n     * @throws UnsupportedEncodingException if charset is unsupported\n     */\n    public void setCharset(String charset) throws UnsupportedEncodingException {\n        if (!Charset.isSupported(charset)) {\n            final String message = \"unsupported charset: '\" + charset + \"'\";\n            throw new UnsupportedEncodingException(message);\n        }\n        this.charset = charset;\n    }\n\n    /**\n     * Setter to specify the name of the file containing the required header..\n     *\n     * @param uri the uri of the header to load.\n     * @throws CheckstyleException if fileName is empty.\n     */\n    public void setHeaderFile(URI uri) throws CheckstyleException {\n        if (uri == null) {\n            throw new CheckstyleException(\n                \"property 'headerFile' is missing or invalid in module \"\n                    + getConfiguration().getName());\n        }\n\n        headerFile = uri;\n    }\n\n    /**\n     * Load the header from a file.\n     *\n     * @throws CheckstyleException if the file cannot be loaded\n     */\n    private void loadHeaderFile() throws CheckstyleException {\n        checkHeaderNotInitialized();\n        try (Reader headerReader = new InputStreamReader(new BufferedInputStream(\n                    headerFile.toURL().openStream()), charset)) {\n            loadHeader(headerReader);\n        }\n        catch (final IOException ex) {\n            throw new CheckstyleException(\n                    \"unable to load header file \" + headerFile, ex);\n        }\n    }\n\n    /**\n     * Called before initializing the header.\n     *\n     * @throws IllegalArgumentException if header has already been set\n     */\n    private void checkHeaderNotInitialized() {\n        if (!readerLines.isEmpty()) {\n            throw new IllegalArgumentException(\n                    \"header has already been set - \"\n                    + \"set either header or headerFile, not both\");\n        }\n    }\n\n    /**\n     * Set the header to check against. Individual lines in the header\n     * must be separated by '\\n' characters.\n     *\n     * @param header header content to check against.\n     * @throws IllegalArgumentException if the header cannot be interpreted\n     */\n    public void setHeader(String header) {\n        if (!CommonUtil.isBlank(header)) {\n            checkHeaderNotInitialized();\n\n            final String headerExpandedNewLines = ESCAPED_LINE_FEED_PATTERN\n                    .matcher(header).replaceAll(\"\\n\");\n\n            try (Reader headerReader = new StringReader(headerExpandedNewLines)) {\n                loadHeader(headerReader);\n            }\n            catch (final IOException ex) {\n                throw new IllegalArgumentException(\"unable to load header\", ex);\n            }\n        }\n    }\n\n    /**\n     * Load header to check against from a Reader into readerLines.\n     *\n     * @param headerReader delivers the header to check against\n     * @throws IOException if\n     */\n    private void loadHeader(final Reader headerReader) throws IOException {\n        try (LineNumberReader lnr = new LineNumberReader(headerReader)) {\n            String line;\n            do {\n                line = lnr.readLine();\n                if (line != null) {\n                    readerLines.add(line);\n                }\n            } while (line != null);\n            postProcessHeaderLines();\n        }\n    }\n\n    @Override\n    protected final void finishLocalSetup() throws CheckstyleException {\n        if (headerFile != null) {\n            loadHeaderFile();\n        }\n    }\n\n    @Override\n    public Set<String> getExternalResourceLocations() {\n        final Set<String> result;\n\n        if (headerFile == null) {\n            result = Collections.emptySet();\n        }\n        else {\n            result = Collections.singleton(headerFile.toString());\n        }\n\n        return result;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate parse(inputFilePath String, setFilteredViolations boolean) : TestInputConfiguration extracted from public parse(inputFilePath String) : TestInputConfiguration in class com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java", "startLine": 75, "endLine": 90, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java", "startLine": 87, "endLine": 89, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java", "startLine": 91, "endLine": 108, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Parses the input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n        final Path filePath = Paths.get(inputFilePath);\n        final List<String> lines = readFile(filePath);\n        final TestInputConfiguration.Builder inputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        setCheckName(inputConfigBuilder, inputFilePath, lines);\n        setCheckProperties(inputConfigBuilder, inputFilePath, lines);\n        setViolations(inputConfigBuilder, lines);\n        return inputConfigBuilder.build();\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java", "isPureRefactoring": true, "commitId": "e662bd96c3527104fc57a91a130bf74e031c106c", "packageNameBefore": "com.puppycrawl.tools.checkstyle.bdd", "classNameBefore": "com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser", "methodNameBefore": "com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#parse", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#readFile\n methodBody: private static List<String> readFile(Path filePath) throws CheckstyleException {\ntryreturn Files.readAllLines(filePath);\ncatch(IOException ex)throw new CheckstyleException(\"Failed to read \" + filePath,ex);\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.bdd.TestInputConfiguration.Builder#build\n methodBody: public TestInputConfiguration build() {\nreturn new TestInputConfiguration(checkName,defaultProperties,nonDefaultProperties,checkMessages,violations);\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#setCheckName\n methodBody: private static void setCheckName(TestInputConfiguration.Builder inputConfigBuilder,\n                                     String filePath, List<String> lines)\n                    throws CheckstyleException {\nif(lines.size() < 2){throw new CheckstyleException(\"Config not specified in \" + filePath);\n}final String checkName=lines.get(1);\nfinal String fullyQualifiedClassName;\nif(checkName.startsWith(\"com.\")){fullyQualifiedClassName=checkName + \"Check\";\n}{fullyQualifiedClassName=getFullyQualifiedClassName(filePath,checkName);\n}inputConfigBuilder.setCheckName(fullyQualifiedClassName);\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#setViolations\n methodBody: private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines) {\nfor(int lineNo=0; lineNo < lines.size(); lineNo++){final Matcher violationMatcher=VIOLATION_PATTERN.matcher(lines.get(lineNo));\nfinal Matcher violationAboveMatcher=VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\nfinal Matcher violationBelowMatcher=VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\nfinal Matcher multipleViolationsMatcher=MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\nfinal Matcher multipleViolationsAboveMatcher=MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\nfinal Matcher multipleViolationsBelowMatcher=MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\nif(violationMatcher.matches()){inputConfigBuilder.addViolation(lineNo + 1,violationMatcher.group(1));\n}if(violationAboveMatcher.matches()){inputConfigBuilder.addViolation(lineNo,violationAboveMatcher.group(1));\n}if(violationBelowMatcher.matches()){inputConfigBuilder.addViolation(lineNo + 2,violationBelowMatcher.group(1));\n}if(multipleViolationsMatcher.matches()){Collections.nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)),lineNo + 1).forEach(actualLineNumber -> {\n  inputConfigBuilder.addViolation(actualLineNumber,null);\n}\n);\n}if(multipleViolationsAboveMatcher.matches()){Collections.nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)),lineNo).forEach(actualLineNumber -> {\n  inputConfigBuilder.addViolation(actualLineNumber,null);\n}\n);\n}if(multipleViolationsBelowMatcher.matches()){Collections.nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),lineNo + 2).forEach(actualLineNumber -> {\n  inputConfigBuilder.addViolation(actualLineNumber,null);\n}\n);\n}}}\nmethodSignature: com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#setCheckProperties\n methodBody: private static void setCheckProperties(TestInputConfiguration.Builder inputConfigBuilder,\n                                           String inputFilePath,\n                                           List<String> lines)\n                    throws Exception {\nfinal StringBuilder stringBuilder=new StringBuilder(128);\nint lineNo=2;\nfor(String line=lines.get(lineNo); !line.contains(\"*/\"); ++lineNo; line=lines.get(lineNo)){stringBuilder.append(line).append('\\n');\n}final Properties properties=new Properties();\ntry(Reader reader=new StringReader(stringBuilder.toString()))properties.load(reader);\nfor(final Map.Entry<Object,Object> entry: properties.entrySet()){final String key=entry.getKey().toString();\nfinal String value=entry.getValue().toString();\nif(key.startsWith(\"message.\")){inputConfigBuilder.addCheckMessage(key.substring(8),value);\n}if(value.startsWith(\"(file)\")){final String fileName=value.substring(value.indexOf(')') + 1);\nfinal String filePath=getResolvedPath(fileName,inputFilePath);\ninputConfigBuilder.addNonDefaultProperty(key,filePath);\n}if(value.startsWith(\"(default)\")){final String defaultValue=value.substring(value.indexOf(')') + 1);\nif(NULL_STRING.equals(defaultValue)){inputConfigBuilder.addDefaultProperty(key,null);\n}{inputConfigBuilder.addDefaultProperty(key,defaultValue);\n}}{if(NULL_STRING.equals(value)){inputConfigBuilder.addNonDefaultProperty(key,null);\n}{inputConfigBuilder.addNonDefaultProperty(key,value);\n}}}}\nmethodSignature: com.puppycrawl.tools.checkstyle.bdd.TestInputConfiguration.Builder#setCheckName\n methodBody: public void setCheckName(String checkName) {\nthis.checkName=checkName;\n}", "classSignatureBefore": "public final class InlineConfigParser ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#parse"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser"], "classSignatureBeforeSet": ["public final class InlineConfigParser "], "purityCheckResultList": [{"isPure": true, "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Add Parameter-\nOverlapped refactoring - can be identical by undoing the overlapped refactoring- Rename Method-", "description": "Rename Refactoring on the top of the extracted method - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.bdd;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\npublic final class InlineConfigParser {\n\n    /** A pattern matching the symbol: \"\\\" or \"/\". */\n    private static final Pattern SLASH_PATTERN = Pattern.compile(\"[\\\\\\\\/]\");\n\n    /** A pattern to find the string: \"// violation\". */\n    private static final Pattern VIOLATION_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation above\". */\n    private static final Pattern VIOLATION_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation above(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation below\". */\n    private static final Pattern VIOLATION_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation below(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// X violations\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations$\");\n\n    /** A pattern to find the string: \"// X violations above\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations above$\");\n\n    /** A pattern to find the string: \"// X violations below\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations below$\");\n\n    /** The String \"(null)\". */\n    private static final String NULL_STRING = \"(null)\";\n\n    /** Stop instances being created. **/\n    private InlineConfigParser() {\n    }\n\n    /**\n     * Parses the input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n        final Path filePath = Paths.get(inputFilePath);\n        final List<String> lines = readFile(filePath);\n        final TestInputConfiguration.Builder inputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        setCheckName(inputConfigBuilder, inputFilePath, lines);\n        setCheckProperties(inputConfigBuilder, inputFilePath, lines);\n        setViolations(inputConfigBuilder, lines);\n        return inputConfigBuilder.build();\n    }\n\n    private static String getFullyQualifiedClassName(String filePath, String checkName) {\n        final String path = SLASH_PATTERN.matcher(filePath).replaceAll(\"\\\\.\");\n        final int beginIndex = path.indexOf(\"com.puppycrawl\");\n        final int endIndex = path.lastIndexOf(checkName.toLowerCase(Locale.ROOT));\n        return path.substring(beginIndex, endIndex) + checkName + \"Check\";\n    }\n\n    private static String getFilePath(String fileName, String inputFilePath) {\n        final int lastSlashIndex = Math.max(inputFilePath.lastIndexOf('\\\\'),\n                inputFilePath.lastIndexOf('/'));\n        final String root = inputFilePath.substring(0, lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getResourcePath(String fileName, String inputFilePath) {\n        final String filePath = getUriPath(fileName, inputFilePath);\n        final int lastSlashIndex = filePath.lastIndexOf('/');\n        final String root = filePath.substring(filePath.indexOf(\"puppycrawl\") - 5,\n                lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getUriPath(String fileName, String inputFilePath) {\n        return new File(getFilePath(fileName, inputFilePath)).toURI().toString();\n    }\n\n    private static String getResolvedPath(String fileValue, String inputFilePath) {\n        final String resolvedFilePath;\n        if (fileValue.startsWith(\"(resource)\")) {\n            resolvedFilePath =\n                    getResourcePath(fileValue.substring(fileValue.indexOf(')') + 1),\n                            inputFilePath);\n        }\n        else if (fileValue.startsWith(\"(uri)\")) {\n            resolvedFilePath =\n                    getUriPath(fileValue.substring(fileValue.indexOf(')') + 1), inputFilePath);\n        }\n        else {\n            resolvedFilePath = getFilePath(fileValue, inputFilePath);\n        }\n        return resolvedFilePath;\n    }\n\n    private static List<String> readFile(Path filePath) throws CheckstyleException {\n        try {\n            return Files.readAllLines(filePath);\n        }\n        catch (IOException ex) {\n            throw new CheckstyleException(\"Failed to read \" + filePath, ex);\n        }\n    }\n\n    private static void setCheckName(TestInputConfiguration.Builder inputConfigBuilder,\n                                     String filePath, List<String> lines)\n                    throws CheckstyleException {\n        if (lines.size() < 2) {\n            throw new CheckstyleException(\"Config not specified in \" + filePath);\n        }\n        final String checkName = lines.get(1);\n        final String fullyQualifiedClassName;\n        if (checkName.startsWith(\"com.\")) {\n            fullyQualifiedClassName = checkName + \"Check\";\n        }\n        else {\n            fullyQualifiedClassName = getFullyQualifiedClassName(filePath, checkName);\n        }\n        inputConfigBuilder.setCheckName(fullyQualifiedClassName);\n    }\n\n    private static void setCheckProperties(TestInputConfiguration.Builder inputConfigBuilder,\n                                           String inputFilePath,\n                                           List<String> lines)\n                    throws Exception {\n        final StringBuilder stringBuilder = new StringBuilder(128);\n        int lineNo = 2;\n        for (String line = lines.get(lineNo); !line.contains(\"*/\");\n                ++lineNo, line = lines.get(lineNo)) {\n            stringBuilder.append(line).append('\\n');\n        }\n        final Properties properties = new Properties();\n        try (Reader reader = new StringReader(stringBuilder.toString())) {\n            properties.load(reader);\n        }\n        for (final Map.Entry<Object, Object> entry : properties.entrySet()) {\n            final String key = entry.getKey().toString();\n            final String value = entry.getValue().toString();\n            if (key.startsWith(\"message.\")) {\n                inputConfigBuilder.addCheckMessage(key.substring(8), value);\n            }\n            else if (value.startsWith(\"(file)\")) {\n                final String fileName = value.substring(value.indexOf(')') + 1);\n                final String filePath = getResolvedPath(fileName, inputFilePath);\n                inputConfigBuilder.addNonDefaultProperty(key, filePath);\n            }\n            else if (value.startsWith(\"(default)\")) {\n                final String defaultValue = value.substring(value.indexOf(')') + 1);\n                if (NULL_STRING.equals(defaultValue)) {\n                    inputConfigBuilder.addDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addDefaultProperty(key, defaultValue);\n                }\n            }\n            else {\n                if (NULL_STRING.equals(value)) {\n                    inputConfigBuilder.addNonDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addNonDefaultProperty(key, value);\n                }\n            }\n        }\n    }\n\n    private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines) {\n        for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n            final Matcher violationMatcher =\n                    VIOLATION_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationAboveMatcher =\n                    VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationBelowMatcher =\n                    VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsMatcher =\n                    MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsAboveMatcher =\n                    MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsBelowMatcher =\n                    MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n            if (violationMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n            }\n            else if (violationAboveMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n            }\n            else if (violationBelowMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n            }\n            else if (multipleViolationsMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsAboveMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsBelowMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n                                lineNo + 2)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n        }\n    }\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/bdd/InlineConfigParser.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.bdd;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\npublic final class InlineConfigParser {\n\n    /** A pattern matching the symbol: \"\\\" or \"/\". */\n    private static final Pattern SLASH_PATTERN = Pattern.compile(\"[\\\\\\\\/]\");\n\n    /** A pattern to find the string: \"// violation\". */\n    private static final Pattern VIOLATION_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation above\". */\n    private static final Pattern VIOLATION_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation above(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation below\". */\n    private static final Pattern VIOLATION_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation below(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// X violations\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations$\");\n\n    /** A pattern to find the string: \"// X violations above\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations above$\");\n\n    /** A pattern to find the string: \"// X violations below\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations below$\");\n\n    /** A pattern to find the string: \"// filtered violation\". */\n    private static final Pattern FILTERED_VIOLATION_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// filtered violation above\". */\n    private static final Pattern FILTERED_VIOLATION_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation above(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// filtered violation below\". */\n    private static final Pattern FILTERED_VIOLATION_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*filtered violation below(?:\\\\W+'(.*)')?$\");\n\n    /** The String \"(null)\". */\n    private static final String NULL_STRING = \"(null)\";\n\n    /** Stop instances being created. **/\n    private InlineConfigParser() {\n    }\n\n    public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n        return parse(inputFilePath, false);\n    }\n\n    /**\n     * Parses the input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @param setFilteredViolations flag to set filtered violations.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    private static TestInputConfiguration parse(String inputFilePath,\n                                               boolean setFilteredViolations) throws Exception {\n        final Path filePath = Paths.get(inputFilePath);\n        final List<String> lines = readFile(filePath);\n        final TestInputConfiguration.Builder inputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        setCheckName(inputConfigBuilder, inputFilePath, lines);\n        setProperties(inputConfigBuilder, inputFilePath, lines, 2);\n        setViolations(inputConfigBuilder, lines, setFilteredViolations);\n        return inputConfigBuilder.build();\n    }\n\n    public static TestInputConfiguration parseWithFilteredViolations(String inputFilePath)\n            throws Exception {\n        return parse(inputFilePath, true);\n    }\n\n    /**\n     * Parses the filter input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    public static TestInputConfiguration parseFilter(String inputFilePath)\n            throws Exception {\n        final Path filePath = Paths.get(inputFilePath);\n        final List<String> lines = readFile(filePath);\n        final TestInputConfiguration.Builder inputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        final int lineNo = getFilterConfigLineNo(lines);\n        setFilterName(inputConfigBuilder, inputFilePath, lines, lineNo);\n        setProperties(inputConfigBuilder, inputFilePath, lines, lineNo + 1);\n        setViolations(inputConfigBuilder, lines, false);\n        return inputConfigBuilder.build();\n    }\n\n    private static String getFullyQualifiedClassName(String filePath, String moduleName) {\n        String fullyQualifiedClassName;\n        if (moduleName.startsWith(\"com.\")) {\n            fullyQualifiedClassName = moduleName;\n        }\n        else {\n            final String path = SLASH_PATTERN.matcher(filePath).replaceAll(\"\\\\.\");\n            final int beginIndex = path.indexOf(\"com.puppycrawl\");\n            final int endIndex = path.lastIndexOf(moduleName.toLowerCase(Locale.ROOT));\n            fullyQualifiedClassName = path.substring(beginIndex, endIndex) + moduleName;\n        }\n        if (!fullyQualifiedClassName.endsWith(\"Filter\")) {\n            fullyQualifiedClassName += \"Check\";\n        }\n        return fullyQualifiedClassName;\n    }\n\n    private static String getFilePath(String fileName, String inputFilePath) {\n        final int lastSlashIndex = Math.max(inputFilePath.lastIndexOf('\\\\'),\n                inputFilePath.lastIndexOf('/'));\n        final String root = inputFilePath.substring(0, lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getResourcePath(String fileName, String inputFilePath) {\n        final String filePath = getUriPath(fileName, inputFilePath);\n        final int lastSlashIndex = filePath.lastIndexOf('/');\n        final String root = filePath.substring(filePath.indexOf(\"puppycrawl\") - 5,\n                lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getUriPath(String fileName, String inputFilePath) {\n        return new File(getFilePath(fileName, inputFilePath)).toURI().toString();\n    }\n\n    private static String getResolvedPath(String fileValue, String inputFilePath) {\n        final String resolvedFilePath;\n        if (fileValue.startsWith(\"(resource)\")) {\n            resolvedFilePath =\n                    getResourcePath(fileValue.substring(fileValue.indexOf(')') + 1),\n                            inputFilePath);\n        }\n        else if (fileValue.startsWith(\"(uri)\")) {\n            resolvedFilePath =\n                    getUriPath(fileValue.substring(fileValue.indexOf(')') + 1), inputFilePath);\n        }\n        else {\n            resolvedFilePath = getFilePath(fileValue, inputFilePath);\n        }\n        return resolvedFilePath;\n    }\n\n    private static List<String> readFile(Path filePath) throws CheckstyleException {\n        try {\n            return Files.readAllLines(filePath);\n        }\n        catch (IOException ex) {\n            throw new CheckstyleException(\"Failed to read \" + filePath, ex);\n        }\n    }\n\n    private static void setCheckName(TestInputConfiguration.Builder inputConfigBuilder,\n                                     String filePath, List<String> lines)\n                    throws CheckstyleException {\n        if (lines.size() < 2) {\n            throw new CheckstyleException(\"Config not specified in \" + filePath);\n        }\n        final String checkName = lines.get(1);\n        final String fullyQualifiedClassName = getFullyQualifiedClassName(filePath, checkName);\n        inputConfigBuilder.setModuleName(fullyQualifiedClassName);\n    }\n\n    private static int getFilterConfigLineNo(List<String> lines) {\n        int lineNo = 1;\n        while (!lines.get(lineNo - 1).isEmpty() || lines.get(lineNo).isEmpty()) {\n            lineNo++;\n        }\n        return lineNo;\n    }\n\n    private static void setFilterName(TestInputConfiguration.Builder inputConfigBuilder,\n                                      String filePath, List<String> lines, int lineNo)\n            throws CheckstyleException {\n        final String filterName = lines.get(lineNo);\n        if (!filterName.endsWith(\"Filter\")) {\n            throw new CheckstyleException(\"Filter not specified in \" + filePath);\n        }\n        final String fullyQualifiedClassName = getFullyQualifiedClassName(filePath, filterName);\n        inputConfigBuilder.setModuleName(fullyQualifiedClassName);\n    }\n\n    private static void setProperties(TestInputConfiguration.Builder inputConfigBuilder,\n                                      String inputFilePath,\n                                      List<String> lines,\n                                      int beginLineNo)\n                    throws Exception {\n        final StringBuilder stringBuilder = new StringBuilder(128);\n        int lineNo = beginLineNo;\n        for (String line = lines.get(lineNo); !line.isEmpty() && !\"*/\".equals(line);\n                ++lineNo, line = lines.get(lineNo)) {\n            stringBuilder.append(line).append('\\n');\n        }\n        final Properties properties = new Properties();\n        try (Reader reader = new StringReader(stringBuilder.toString())) {\n            properties.load(reader);\n        }\n        for (final Map.Entry<Object, Object> entry : properties.entrySet()) {\n            final String key = entry.getKey().toString();\n            final String value = entry.getValue().toString();\n            if (key.startsWith(\"message.\")) {\n                inputConfigBuilder.addCheckMessage(key.substring(8), value);\n            }\n            else if (value.startsWith(\"(file)\")) {\n                final String fileName = value.substring(value.indexOf(')') + 1);\n                final String filePath = getResolvedPath(fileName, inputFilePath);\n                inputConfigBuilder.addNonDefaultProperty(key, filePath);\n            }\n            else if (value.startsWith(\"(default)\")) {\n                final String defaultValue = value.substring(value.indexOf(')') + 1);\n                if (NULL_STRING.equals(defaultValue)) {\n                    inputConfigBuilder.addDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addDefaultProperty(key, defaultValue);\n                }\n            }\n            else {\n                if (NULL_STRING.equals(value)) {\n                    inputConfigBuilder.addNonDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addNonDefaultProperty(key, value);\n                }\n            }\n        }\n    }\n\n    private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines, boolean useFilteredViolations) {\n        for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n            final Matcher violationMatcher =\n                    VIOLATION_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationAboveMatcher =\n                    VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationBelowMatcher =\n                    VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsMatcher =\n                    MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsAboveMatcher =\n                    MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsBelowMatcher =\n                    MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n            if (violationMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n            }\n            else if (violationAboveMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n            }\n            else if (violationBelowMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n            }\n            else if (multipleViolationsMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsAboveMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsBelowMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n                                lineNo + 2)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (useFilteredViolations) {\n                setFilteredViolation(inputConfigBuilder, lineNo + 1, lines.get(lineNo));\n            }\n        }\n    }\n\n    private static void setFilteredViolation(TestInputConfiguration.Builder inputConfigBuilder,\n                                             int lineNo, String line) {\n        final Matcher violationMatcher =\n                FILTERED_VIOLATION_PATTERN.matcher(line);\n        final Matcher violationAboveMatcher =\n                FILTERED_VIOLATION_ABOVE_PATTERN.matcher(line);\n        final Matcher violationBelowMatcher =\n                FILTERED_VIOLATION_BELOW_PATTERN.matcher(line);\n        if (violationMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo, violationMatcher.group(1));\n        }\n        else if (violationAboveMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo - 1, violationAboveMatcher.group(1));\n        }\n        else if (violationBelowMatcher.matches()) {\n            inputConfigBuilder.addViolation(lineNo + 1, violationBelowMatcher.group(1));\n        }\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Parses the input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @param setFilteredViolations flag to set filtered violations.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    private static TestInputConfiguration parse(String inputFilePath,\n                                               boolean setFilteredViolations) throws Exception {\n        final Path filePath = Paths.get(inputFilePath);\n        final List<String> lines = readFile(filePath);\n        final TestInputConfiguration.Builder inputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        setCheckName(inputConfigBuilder, inputFilePath, lines);\n        setProperties(inputConfigBuilder, inputFilePath, lines, 2);\n        setViolations(inputConfigBuilder, lines, setFilteredViolations);\n        return inputConfigBuilder.build();\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#readFile\n methodBody: private static List<String> readFile(Path filePath) throws CheckstyleException {\ntryreturn Files.readAllLines(filePath);\ncatch(IOException ex)throw new CheckstyleException(\"Failed to read \" + filePath,ex);\n}", "methodSignature: com.puppycrawl.tools.checkstyle.bdd.TestInputConfiguration.Builder#build\n methodBody: public TestInputConfiguration build() {\nreturn new TestInputConfiguration(checkName,defaultProperties,nonDefaultProperties,checkMessages,violations);\n}", "methodSignature: com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#setCheckName\n methodBody: private static void setCheckName(TestInputConfiguration.Builder inputConfigBuilder,\n                                     String filePath, List<String> lines)\n                    throws CheckstyleException {\nif(lines.size() < 2){throw new CheckstyleException(\"Config not specified in \" + filePath);\n}final String checkName=lines.get(1);\nfinal String fullyQualifiedClassName;\nif(checkName.startsWith(\"com.\")){fullyQualifiedClassName=checkName + \"Check\";\n}{fullyQualifiedClassName=getFullyQualifiedClassName(filePath,checkName);\n}inputConfigBuilder.setCheckName(fullyQualifiedClassName);\n}", "methodSignature: com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#setViolations\n methodBody: private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines) {\nfor(int lineNo=0; lineNo < lines.size(); lineNo++){final Matcher violationMatcher=VIOLATION_PATTERN.matcher(lines.get(lineNo));\nfinal Matcher violationAboveMatcher=VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\nfinal Matcher violationBelowMatcher=VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\nfinal Matcher multipleViolationsMatcher=MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\nfinal Matcher multipleViolationsAboveMatcher=MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\nfinal Matcher multipleViolationsBelowMatcher=MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\nif(violationMatcher.matches()){inputConfigBuilder.addViolation(lineNo + 1,violationMatcher.group(1));\n}if(violationAboveMatcher.matches()){inputConfigBuilder.addViolation(lineNo,violationAboveMatcher.group(1));\n}if(violationBelowMatcher.matches()){inputConfigBuilder.addViolation(lineNo + 2,violationBelowMatcher.group(1));\n}if(multipleViolationsMatcher.matches()){Collections.nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)),lineNo + 1).forEach(actualLineNumber -> {\n  inputConfigBuilder.addViolation(actualLineNumber,null);\n}\n);\n}if(multipleViolationsAboveMatcher.matches()){Collections.nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)),lineNo).forEach(actualLineNumber -> {\n  inputConfigBuilder.addViolation(actualLineNumber,null);\n}\n);\n}if(multipleViolationsBelowMatcher.matches()){Collections.nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),lineNo + 2).forEach(actualLineNumber -> {\n  inputConfigBuilder.addViolation(actualLineNumber,null);\n}\n);\n}}}", "methodSignature: com.puppycrawl.tools.checkstyle.bdd.InlineConfigParser#setCheckProperties\n methodBody: private static void setCheckProperties(TestInputConfiguration.Builder inputConfigBuilder,\n                                           String inputFilePath,\n                                           List<String> lines)\n                    throws Exception {\nfinal StringBuilder stringBuilder=new StringBuilder(128);\nint lineNo=2;\nfor(String line=lines.get(lineNo); !line.contains(\"*/\"); ++lineNo; line=lines.get(lineNo)){stringBuilder.append(line).append('\\n');\n}final Properties properties=new Properties();\ntry(Reader reader=new StringReader(stringBuilder.toString()))properties.load(reader);\nfor(final Map.Entry<Object,Object> entry: properties.entrySet()){final String key=entry.getKey().toString();\nfinal String value=entry.getValue().toString();\nif(key.startsWith(\"message.\")){inputConfigBuilder.addCheckMessage(key.substring(8),value);\n}if(value.startsWith(\"(file)\")){final String fileName=value.substring(value.indexOf(')') + 1);\nfinal String filePath=getResolvedPath(fileName,inputFilePath);\ninputConfigBuilder.addNonDefaultProperty(key,filePath);\n}if(value.startsWith(\"(default)\")){final String defaultValue=value.substring(value.indexOf(')') + 1);\nif(NULL_STRING.equals(defaultValue)){inputConfigBuilder.addDefaultProperty(key,null);\n}{inputConfigBuilder.addDefaultProperty(key,defaultValue);\n}}{if(NULL_STRING.equals(value)){inputConfigBuilder.addNonDefaultProperty(key,null);\n}{inputConfigBuilder.addNonDefaultProperty(key,value);\n}}}}", "methodSignature: com.puppycrawl.tools.checkstyle.bdd.TestInputConfiguration.Builder#setCheckName\n methodBody: public void setCheckName(String checkName) {\nthis.checkName=checkName;\n}"], "sourceCodeAfterRefactoring": "public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n        return parse(inputFilePath, false);\n    }\n/**\n     * Parses the input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @param setFilteredViolations flag to set filtered violations.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    private static TestInputConfiguration parse(String inputFilePath,\n                                               boolean setFilteredViolations) throws Exception {\n        final Path filePath = Paths.get(inputFilePath);\n        final List<String> lines = readFile(filePath);\n        final TestInputConfiguration.Builder inputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        setCheckName(inputConfigBuilder, inputFilePath, lines);\n        setProperties(inputConfigBuilder, inputFilePath, lines, 2);\n        setViolations(inputConfigBuilder, lines, setFilteredViolations);\n        return inputConfigBuilder.build();\n    }", "diffSourceCode": "-   75:     /**\n-   76:      * Parses the input file provided.\n-   77:      *\n-   78:      * @param inputFilePath the input file path.\n-   79:      * @throws Exception if unable to read file or file not formatted properly.\n-   80:      */\n-   81:     public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n-   82:         final Path filePath = Paths.get(inputFilePath);\n-   83:         final List<String> lines = readFile(filePath);\n-   84:         final TestInputConfiguration.Builder inputConfigBuilder =\n-   85:                 new TestInputConfiguration.Builder();\n-   86:         setCheckName(inputConfigBuilder, inputFilePath, lines);\n-   87:         setCheckProperties(inputConfigBuilder, inputFilePath, lines);\n-   88:         setViolations(inputConfigBuilder, lines);\n-   89:         return inputConfigBuilder.build();\n-   90:     }\n-   91: \n-   92:     private static String getFullyQualifiedClassName(String filePath, String checkName) {\n-   93:         final String path = SLASH_PATTERN.matcher(filePath).replaceAll(\"\\\\.\");\n-   94:         final int beginIndex = path.indexOf(\"com.puppycrawl\");\n-   95:         final int endIndex = path.lastIndexOf(checkName.toLowerCase(Locale.ROOT));\n-   96:         return path.substring(beginIndex, endIndex) + checkName + \"Check\";\n-   97:     }\n-   98: \n-   99:     private static String getFilePath(String fileName, String inputFilePath) {\n-  100:         final int lastSlashIndex = Math.max(inputFilePath.lastIndexOf('\\\\'),\n-  101:                 inputFilePath.lastIndexOf('/'));\n-  102:         final String root = inputFilePath.substring(0, lastSlashIndex + 1);\n-  103:         return root + fileName;\n-  104:     }\n-  105: \n-  106:     private static String getResourcePath(String fileName, String inputFilePath) {\n-  107:         final String filePath = getUriPath(fileName, inputFilePath);\n-  108:         final int lastSlashIndex = filePath.lastIndexOf('/');\n+   75: \n+   76:     /** A pattern to find the string: \"// filtered violation below\". */\n+   77:     private static final Pattern FILTERED_VIOLATION_BELOW_PATTERN = Pattern\n+   78:             .compile(\".*//\\\\s*filtered violation below(?:\\\\W+'(.*)')?$\");\n+   79: \n+   80:     /** The String \"(null)\". */\n+   81:     private static final String NULL_STRING = \"(null)\";\n+   82: \n+   83:     /** Stop instances being created. **/\n+   84:     private InlineConfigParser() {\n+   85:     }\n+   86: \n+   87:     public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n+   88:         return parse(inputFilePath, false);\n+   89:     }\n+   90: \n+   91:     /**\n+   92:      * Parses the input file provided.\n+   93:      *\n+   94:      * @param inputFilePath the input file path.\n+   95:      * @param setFilteredViolations flag to set filtered violations.\n+   96:      * @throws Exception if unable to read file or file not formatted properly.\n+   97:      */\n+   98:     private static TestInputConfiguration parse(String inputFilePath,\n+   99:                                                boolean setFilteredViolations) throws Exception {\n+  100:         final Path filePath = Paths.get(inputFilePath);\n+  101:         final List<String> lines = readFile(filePath);\n+  102:         final TestInputConfiguration.Builder inputConfigBuilder =\n+  103:                 new TestInputConfiguration.Builder();\n+  104:         setCheckName(inputConfigBuilder, inputFilePath, lines);\n+  105:         setProperties(inputConfigBuilder, inputFilePath, lines, 2);\n+  106:         setViolations(inputConfigBuilder, lines, setFilteredViolations);\n+  107:         return inputConfigBuilder.build();\n+  108:     }\n", "uniqueId": "e662bd96c3527104fc57a91a130bf74e031c106c_75_90_91_108_87_89", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nprivate static String getClassNameFromPath(String filePath, String checkName) {\n    final String path = SLASH_PATTERN.matcher(filePath).replaceAll(\"\\\\.\");\n    final int beginIndex = path.indexOf(\"com.puppycrawl\");\n    final int endIndex = path.lastIndexOf(checkName.toLowerCase(Locale.ROOT));\n    return path.substring(beginIndex, endIndex) + checkName + \"Check\";\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Parses the input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n        final Path filePath = Paths.get(inputFilePath);\n        final List<String> lines = readFile(filePath);\n        final TestInputConfiguration.Builder inputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        setCheckName(inputConfigBuilder, inputFilePath, lines);\n        setCheckProperties(inputConfigBuilder, inputFilePath, lines);\n        setViolations(inputConfigBuilder, lines);\n        return inputConfigBuilder.build();\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.bdd;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\n\npublic final class InlineConfigParser {\n\n    /** A pattern matching the symbol: \"\\\" or \"/\". */\n    private static final Pattern SLASH_PATTERN = Pattern.compile(\"[\\\\\\\\/]\");\n\n    /** A pattern to find the string: \"// violation\". */\n    private static final Pattern VIOLATION_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation above\". */\n    private static final Pattern VIOLATION_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation above(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// violation below\". */\n    private static final Pattern VIOLATION_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*violation below(?:\\\\W+'(.*)')?$\");\n\n    /** A pattern to find the string: \"// X violations\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations$\");\n\n    /** A pattern to find the string: \"// X violations above\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_ABOVE_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations above$\");\n\n    /** A pattern to find the string: \"// X violations below\". */\n    private static final Pattern MULTIPLE_VIOLATIONS_BELOW_PATTERN = Pattern\n            .compile(\".*//\\\\s*(\\\\d+) violations below$\");\n\n    /** The String \"(null)\". */\n    private static final String NULL_STRING = \"(null)\";\n\n    /** Stop instances being created. **/\n    private InlineConfigParser() {\n    }\n\n    /**\n     * Parses the input file provided.\n     *\n     * @param inputFilePath the input file path.\n     * @throws Exception if unable to read file or file not formatted properly.\n     */\n    public static TestInputConfiguration parse(String inputFilePath) throws Exception {\n        final Path filePath = Paths.get(inputFilePath);\n        final List<String> lines = readFile(filePath);\n        final TestInputConfiguration.Builder inputConfigBuilder =\n                new TestInputConfiguration.Builder();\n        setCheckName(inputConfigBuilder, inputFilePath, lines);\n        setCheckProperties(inputConfigBuilder, inputFilePath, lines);\n        setViolations(inputConfigBuilder, lines);\n        return inputConfigBuilder.build();\n    }\n\n    private static String getFullyQualifiedClassName(String filePath, String checkName) {\n        final String path = SLASH_PATTERN.matcher(filePath).replaceAll(\"\\\\.\");\n        final int beginIndex = path.indexOf(\"com.puppycrawl\");\n        final int endIndex = path.lastIndexOf(checkName.toLowerCase(Locale.ROOT));\n        return path.substring(beginIndex, endIndex) + checkName + \"Check\";\n    }\n\n    private static String getFilePath(String fileName, String inputFilePath) {\n        final int lastSlashIndex = Math.max(inputFilePath.lastIndexOf('\\\\'),\n                inputFilePath.lastIndexOf('/'));\n        final String root = inputFilePath.substring(0, lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getResourcePath(String fileName, String inputFilePath) {\n        final String filePath = getUriPath(fileName, inputFilePath);\n        final int lastSlashIndex = filePath.lastIndexOf('/');\n        final String root = filePath.substring(filePath.indexOf(\"puppycrawl\") - 5,\n                lastSlashIndex + 1);\n        return root + fileName;\n    }\n\n    private static String getUriPath(String fileName, String inputFilePath) {\n        return new File(getFilePath(fileName, inputFilePath)).toURI().toString();\n    }\n\n    private static String getResolvedPath(String fileValue, String inputFilePath) {\n        final String resolvedFilePath;\n        if (fileValue.startsWith(\"(resource)\")) {\n            resolvedFilePath =\n                    getResourcePath(fileValue.substring(fileValue.indexOf(')') + 1),\n                            inputFilePath);\n        }\n        else if (fileValue.startsWith(\"(uri)\")) {\n            resolvedFilePath =\n                    getUriPath(fileValue.substring(fileValue.indexOf(')') + 1), inputFilePath);\n        }\n        else {\n            resolvedFilePath = getFilePath(fileValue, inputFilePath);\n        }\n        return resolvedFilePath;\n    }\n\n    private static List<String> readFile(Path filePath) throws CheckstyleException {\n        try {\n            return Files.readAllLines(filePath);\n        }\n        catch (IOException ex) {\n            throw new CheckstyleException(\"Failed to read \" + filePath, ex);\n        }\n    }\n\n    private static void setCheckName(TestInputConfiguration.Builder inputConfigBuilder,\n                                     String filePath, List<String> lines)\n                    throws CheckstyleException {\n        if (lines.size() < 2) {\n            throw new CheckstyleException(\"Config not specified in \" + filePath);\n        }\n        final String checkName = lines.get(1);\n        final String fullyQualifiedClassName;\n        if (checkName.startsWith(\"com.\")) {\n            fullyQualifiedClassName = checkName + \"Check\";\n        }\n        else {\n            fullyQualifiedClassName = getFullyQualifiedClassName(filePath, checkName);\n        }\n        inputConfigBuilder.setCheckName(fullyQualifiedClassName);\n    }\n\n    private static void setCheckProperties(TestInputConfiguration.Builder inputConfigBuilder,\n                                           String inputFilePath,\n                                           List<String> lines)\n                    throws Exception {\n        final StringBuilder stringBuilder = new StringBuilder(128);\n        int lineNo = 2;\n        for (String line = lines.get(lineNo); !line.contains(\"*/\");\n                ++lineNo, line = lines.get(lineNo)) {\n            stringBuilder.append(line).append('\\n');\n        }\n        final Properties properties = new Properties();\n        try (Reader reader = new StringReader(stringBuilder.toString())) {\n            properties.load(reader);\n        }\n        for (final Map.Entry<Object, Object> entry : properties.entrySet()) {\n            final String key = entry.getKey().toString();\n            final String value = entry.getValue().toString();\n            if (key.startsWith(\"message.\")) {\n                inputConfigBuilder.addCheckMessage(key.substring(8), value);\n            }\n            else if (value.startsWith(\"(file)\")) {\n                final String fileName = value.substring(value.indexOf(')') + 1);\n                final String filePath = getResolvedPath(fileName, inputFilePath);\n                inputConfigBuilder.addNonDefaultProperty(key, filePath);\n            }\n            else if (value.startsWith(\"(default)\")) {\n                final String defaultValue = value.substring(value.indexOf(')') + 1);\n                if (NULL_STRING.equals(defaultValue)) {\n                    inputConfigBuilder.addDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addDefaultProperty(key, defaultValue);\n                }\n            }\n            else {\n                if (NULL_STRING.equals(value)) {\n                    inputConfigBuilder.addNonDefaultProperty(key, null);\n                }\n                else {\n                    inputConfigBuilder.addNonDefaultProperty(key, value);\n                }\n            }\n        }\n    }\n\n    private static void setViolations(TestInputConfiguration.Builder inputConfigBuilder,\n                                      List<String> lines) {\n        for (int lineNo = 0; lineNo < lines.size(); lineNo++) {\n            final Matcher violationMatcher =\n                    VIOLATION_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationAboveMatcher =\n                    VIOLATION_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher violationBelowMatcher =\n                    VIOLATION_BELOW_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsMatcher =\n                    MULTIPLE_VIOLATIONS_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsAboveMatcher =\n                    MULTIPLE_VIOLATIONS_ABOVE_PATTERN.matcher(lines.get(lineNo));\n            final Matcher multipleViolationsBelowMatcher =\n                    MULTIPLE_VIOLATIONS_BELOW_PATTERN.matcher(lines.get(lineNo));\n            if (violationMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 1, violationMatcher.group(1));\n            }\n            else if (violationAboveMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo, violationAboveMatcher.group(1));\n            }\n            else if (violationBelowMatcher.matches()) {\n                inputConfigBuilder.addViolation(lineNo + 2, violationBelowMatcher.group(1));\n            }\n            else if (multipleViolationsMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsMatcher.group(1)), lineNo + 1)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsAboveMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsAboveMatcher.group(1)), lineNo)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n            else if (multipleViolationsBelowMatcher.matches()) {\n                Collections\n                        .nCopies(Integer.parseInt(multipleViolationsBelowMatcher.group(1)),\n                                lineNo + 2)\n                        .forEach(actualLineNumber -> {\n                            inputConfigBuilder.addViolation(actualLineNumber, null);\n                        });\n            }\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic addProperty(propertyName String, value String) : void extracted from public addAttribute(attributeName String, value String) : void in class com.puppycrawl.tools.checkstyle.DefaultConfiguration", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "startLine": 124, "endLine": 138, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "startLine": 134, "endLine": 145, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "startLine": 147, "endLine": 161, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Adds an attribute to this configuration.\n     *\n     * @param attributeName the name of the attribute.\n     * @param value the value of the attribute.\n     */\n    public void addAttribute(String attributeName, String value) {\n        final String current = attributeMap.get(attributeName);\n        if (current == null) {\n            attributeMap.put(attributeName, value);\n        }\n        else {\n            attributeMap.put(attributeName, current + \",\" + value);\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "isPureRefactoring": true, "commitId": "a42a3e1733f3c7583177a3c96de65e6a2fd7671f", "packageNameBefore": "com.puppycrawl.tools.checkstyle", "classNameBefore": "com.puppycrawl.tools.checkstyle.DefaultConfiguration", "methodNameBefore": "com.puppycrawl.tools.checkstyle.DefaultConfiguration#addAttribute", "classSignatureBefore": "public final class DefaultConfiguration implements Configuration ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.DefaultConfiguration#addAttribute"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.DefaultConfiguration"], "classSignatureBeforeSet": ["public final class DefaultConfiguration implements Configuration "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Attribute-", "description": "Rename Attribute on the top of the extracted method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Default implementation of the Configuration interface.\n *\n * @noinspection SerializableHasSerializationMethods\n */\npublic final class DefaultConfiguration implements Configuration {\n\n    private static final long serialVersionUID = 1157875385356127169L;\n\n    /** Constant for optimization. */\n    private static final Configuration[] EMPTY_CONFIGURATION_ARRAY = new Configuration[0];\n\n    /** The name of this configuration. */\n    private final String name;\n\n    /** The list of child Configurations. */\n    private final List<Configuration> children = new ArrayList<>();\n\n    /** The map from attribute names to attribute values. */\n    private final Map<String, String> attributeMap = new HashMap<>();\n\n    /** The map containing custom messages. */\n    private final Map<String, String> messages = new HashMap<>();\n\n    /** The thread mode configuration. */\n    private final ThreadModeSettings threadModeSettings;\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     */\n    public DefaultConfiguration(String name) {\n        this(name, ThreadModeSettings.SINGLE_THREAD_MODE_INSTANCE);\n    }\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     * @param threadModeSettings the thread mode configuration.\n     */\n    public DefaultConfiguration(String name,\n        ThreadModeSettings threadModeSettings) {\n        this.name = name;\n        this.threadModeSettings = threadModeSettings;\n    }\n\n    @Override\n    public String[] getAttributeNames() {\n        final Set<String> keySet = attributeMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }\n\n    @Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        if (!attributeMap.containsKey(attributeName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + attributeName + \"' in \" + name);\n        }\n        return attributeMap.get(attributeName);\n    }\n\n    @Override\n    public Configuration[] getChildren() {\n        return children.toArray(\n                EMPTY_CONFIGURATION_ARRAY);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Makes a configuration a child of this configuration.\n     *\n     * @param configuration the child configuration.\n     */\n    public void addChild(Configuration configuration) {\n        children.add(configuration);\n    }\n\n    /**\n     * Removes a child of this configuration.\n     *\n     * @param configuration the child configuration to remove.\n     */\n    public void removeChild(final Configuration configuration) {\n        children.remove(configuration);\n    }\n\n    /**\n     * Adds an attribute to this configuration.\n     *\n     * @param attributeName the name of the attribute.\n     * @param value the value of the attribute.\n     */\n    public void addAttribute(String attributeName, String value) {\n        final String current = attributeMap.get(attributeName);\n        if (current == null) {\n            attributeMap.put(attributeName, value);\n        }\n        else {\n            attributeMap.put(attributeName, current + \",\" + value);\n        }\n    }\n\n    /**\n     * Adds a custom message to this configuration.\n     *\n     * @param key the message key\n     * @param value the custom message pattern\n     */\n    public void addMessage(String key, String value) {\n        messages.put(key, value);\n    }\n\n    /**\n     * Returns an unmodifiable map instance containing the custom messages\n     * for this configuration.\n     *\n     * @return unmodifiable map containing custom messages\n     */\n    @Override\n    public Map<String, String> getMessages() {\n        return new HashMap<>(messages);\n    }\n\n    /**\n     * Gets the thread mode configuration.\n     *\n     * @return the thread mode configuration.\n     */\n    public ThreadModeSettings getThreadModeSettings() {\n        return threadModeSettings;\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Default implementation of the Configuration interface.\n *\n * @noinspection SerializableHasSerializationMethods\n */\npublic final class DefaultConfiguration implements Configuration {\n\n    private static final long serialVersionUID = 1157875385356127169L;\n\n    /** Constant for optimization. */\n    private static final Configuration[] EMPTY_CONFIGURATION_ARRAY = new Configuration[0];\n\n    /** The name of this configuration. */\n    private final String name;\n\n    /** The list of child Configurations. */\n    private final List<Configuration> children = new ArrayList<>();\n\n    /** The map from property names to property values. */\n    private final Map<String, String> propertyMap = new HashMap<>();\n\n    /** The map containing custom messages. */\n    private final Map<String, String> messages = new HashMap<>();\n\n    /** The thread mode configuration. */\n    private final ThreadModeSettings threadModeSettings;\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     */\n    public DefaultConfiguration(String name) {\n        this(name, ThreadModeSettings.SINGLE_THREAD_MODE_INSTANCE);\n    }\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     * @param threadModeSettings the thread mode configuration.\n     */\n    public DefaultConfiguration(String name,\n        ThreadModeSettings threadModeSettings) {\n        this.name = name;\n        this.threadModeSettings = threadModeSettings;\n    }\n\n    @Override\n    public String[] getAttributeNames() {\n        return getPropertyNames();\n    }\n\n    @Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        return getProperty(attributeName);\n    }\n\n    @Override\n    public String[] getPropertyNames() {\n        final Set<String> keySet = propertyMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }\n\n    @Override\n    public String getProperty(String propertyName) throws CheckstyleException {\n        if (!propertyMap.containsKey(propertyName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + propertyName + \"' in \" + name);\n        }\n        return propertyMap.get(propertyName);\n    }\n\n    @Override\n    public Configuration[] getChildren() {\n        return children.toArray(\n                EMPTY_CONFIGURATION_ARRAY);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Makes a configuration a child of this configuration.\n     *\n     * @param configuration the child configuration.\n     */\n    public void addChild(Configuration configuration) {\n        children.add(configuration);\n    }\n\n    /**\n     * Removes a child of this configuration.\n     *\n     * @param configuration the child configuration to remove.\n     */\n    public void removeChild(final Configuration configuration) {\n        children.remove(configuration);\n    }\n\n    /**\n     * Adds n property to this configuration.\n     *\n     * @param attributeName the name of the property.\n     * @param value the value of the property.\n     * @deprecated This shall be removed in future releases. Please use\n     *      {@code addProperty(String propertyName, String value)} instead.\n     */\n    @Deprecated\n    public void addAttribute(String attributeName, String value) {\n        addProperty(attributeName, value);\n    }\n\n    /**\n     * Adds n property to this configuration.\n     *\n     * @param propertyName the name of the property.\n     * @param value the value of the property.\n     */\n    public void addProperty(String propertyName, String value) {\n        final String current = propertyMap.get(propertyName);\n        if (current == null) {\n            propertyMap.put(propertyName, value);\n        }\n        else {\n            propertyMap.put(propertyName, current + \",\" + value);\n        }\n    }\n\n    /**\n     * Adds a custom message to this configuration.\n     *\n     * @param key the message key\n     * @param value the custom message pattern\n     */\n    public void addMessage(String key, String value) {\n        messages.put(key, value);\n    }\n\n    /**\n     * Returns an unmodifiable map instance containing the custom messages\n     * for this configuration.\n     *\n     * @return unmodifiable map containing custom messages\n     */\n    @Override\n    public Map<String, String> getMessages() {\n        return new HashMap<>(messages);\n    }\n\n    /**\n     * Gets the thread mode configuration.\n     *\n     * @return the thread mode configuration.\n     */\n    public ThreadModeSettings getThreadModeSettings() {\n        return threadModeSettings;\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Adds n property to this configuration.\n     *\n     * @param propertyName the name of the property.\n     * @param value the value of the property.\n     */\n    public void addProperty(String propertyName, String value) {\n        final String current = propertyMap.get(propertyName);\n        if (current == null) {\n            propertyMap.put(propertyName, value);\n        }\n        else {\n            propertyMap.put(propertyName, current + \",\" + value);\n        }\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Adds n property to this configuration.\n     *\n     * @param attributeName the name of the property.\n     * @param value the value of the property.\n     * @deprecated This shall be removed in future releases. Please use\n     *      {@code addProperty(String propertyName, String value)} instead.\n     */\n    @Deprecated\n    public void addAttribute(String attributeName, String value) {\n        addProperty(attributeName, value);\n    }\n/**\n     * Adds n property to this configuration.\n     *\n     * @param propertyName the name of the property.\n     * @param value the value of the property.\n     */\n    public void addProperty(String propertyName, String value) {\n        final String current = propertyMap.get(propertyName);\n        if (current == null) {\n            propertyMap.put(propertyName, value);\n        }\n        else {\n            propertyMap.put(propertyName, current + \",\" + value);\n        }\n    }", "diffSourceCode": "-  124:     /**\n-  125:      * Adds an attribute to this configuration.\n-  126:      *\n-  127:      * @param attributeName the name of the attribute.\n-  128:      * @param value the value of the attribute.\n+  124: \n+  125:     /**\n+  126:      * Removes a child of this configuration.\n+  127:      *\n+  128:      * @param configuration the child configuration to remove.\n   129:      */\n-  130:     public void addAttribute(String attributeName, String value) {\n-  131:         final String current = attributeMap.get(attributeName);\n-  132:         if (current == null) {\n-  133:             attributeMap.put(attributeName, value);\n-  134:         }\n-  135:         else {\n-  136:             attributeMap.put(attributeName, current + \",\" + value);\n-  137:         }\n-  138:     }\n-  139: \n-  140:     /**\n-  141:      * Adds a custom message to this configuration.\n-  142:      *\n-  143:      * @param key the message key\n-  144:      * @param value the custom message pattern\n-  145:      */\n-  147:         messages.put(key, value);\n-  148:     }\n-  149: \n-  150:     /**\n-  151:      * Returns an unmodifiable map instance containing the custom messages\n-  152:      * for this configuration.\n-  153:      *\n-  154:      * @return unmodifiable map containing custom messages\n-  155:      */\n-  156:     @Override\n-  157:     public Map<String, String> getMessages() {\n-  158:         return new HashMap<>(messages);\n-  159:     }\n-  160: \n-  161:     /**\n+  130:     public void removeChild(final Configuration configuration) {\n+  131:         children.remove(configuration);\n+  132:     }\n+  133: \n+  134:     /**\n+  135:      * Adds n property to this configuration.\n+  136:      *\n+  137:      * @param attributeName the name of the property.\n+  138:      * @param value the value of the property.\n+  139:      * @deprecated This shall be removed in future releases. Please use\n+  140:      *      {@code addProperty(String propertyName, String value)} instead.\n+  141:      */\n+  142:     @Deprecated\n+  143:     public void addAttribute(String attributeName, String value) {\n+  144:         addProperty(attributeName, value);\n+  145:     }\n+  147:     /**\n+  148:      * Adds n property to this configuration.\n+  149:      *\n+  150:      * @param propertyName the name of the property.\n+  151:      * @param value the value of the property.\n+  152:      */\n+  153:     public void addProperty(String propertyName, String value) {\n+  154:         final String current = propertyMap.get(propertyName);\n+  155:         if (current == null) {\n+  156:             propertyMap.put(propertyName, value);\n+  157:         }\n+  158:         else {\n+  159:             propertyMap.put(propertyName, current + \",\" + value);\n+  160:         }\n+  161:     }\n", "uniqueId": "a42a3e1733f3c7583177a3c96de65e6a2fd7671f_124_138_147_161_134_145", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 31}, "BRANCH": {"missed": 0, "covered": 2}, "LINE": {"missed": 0, "covered": 5}, "COMPLEXITY": {"missed": 0, "covered": 2}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\n/**\n * Adds an attribute to this configuration.\n *\n * @param attributeName the name of the attribute.\n * @param value the value of the attribute.\n */\npublic void addAttribute(String attributeName, String value) {\n    final String current = attributeMap.get(attributeName);\n    if (current == null) {\n        attributeMap.put(attributeName, value);\n    }\n    else {\n        attributeMap.put(attributeName, current + \",\" + value);\n    }\n}\n\n/**\n * Adds a custom message to this configuration.\n *\n * @param key the message key\n * @param value the custom message pattern\n */\npublic void addMessage(String key, String value) {\n    messages.put(key, value);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Adds an attribute to this configuration.\n     *\n     * @param attributeName the name of the attribute.\n     * @param value the value of the attribute.\n     */\n    public void addAttribute(String attributeName, String value) {\n        final String current = attributeMap.get(attributeName);\n        if (current == null) {\n            attributeMap.put(attributeName, value);\n        }\n        else {\n            attributeMap.put(attributeName, current + \",\" + value);\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Default implementation of the Configuration interface.\n *\n * @noinspection SerializableHasSerializationMethods\n */\npublic final class DefaultConfiguration implements Configuration {\n\n    private static final long serialVersionUID = 1157875385356127169L;\n\n    /** Constant for optimization. */\n    private static final Configuration[] EMPTY_CONFIGURATION_ARRAY = new Configuration[0];\n\n    /** The name of this configuration. */\n    private final String name;\n\n    /** The list of child Configurations. */\n    private final List<Configuration> children = new ArrayList<>();\n\n    /** The map from attribute names to attribute values. */\n    private final Map<String, String> attributeMap = new HashMap<>();\n\n    /** The map containing custom messages. */\n    private final Map<String, String> messages = new HashMap<>();\n\n    /** The thread mode configuration. */\n    private final ThreadModeSettings threadModeSettings;\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     */\n    public DefaultConfiguration(String name) {\n        this(name, ThreadModeSettings.SINGLE_THREAD_MODE_INSTANCE);\n    }\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     * @param threadModeSettings the thread mode configuration.\n     */\n    public DefaultConfiguration(String name,\n        ThreadModeSettings threadModeSettings) {\n        this.name = name;\n        this.threadModeSettings = threadModeSettings;\n    }\n\n    @Override\n    public String[] getAttributeNames() {\n        final Set<String> keySet = attributeMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }\n\n    @Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        if (!attributeMap.containsKey(attributeName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + attributeName + \"' in \" + name);\n        }\n        return attributeMap.get(attributeName);\n    }\n\n    @Override\n    public Configuration[] getChildren() {\n        return children.toArray(\n                EMPTY_CONFIGURATION_ARRAY);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Makes a configuration a child of this configuration.\n     *\n     * @param configuration the child configuration.\n     */\n    public void addChild(Configuration configuration) {\n        children.add(configuration);\n    }\n\n    /**\n     * Removes a child of this configuration.\n     *\n     * @param configuration the child configuration to remove.\n     */\n    public void removeChild(final Configuration configuration) {\n        children.remove(configuration);\n    }\n\n    /**\n     * Adds an attribute to this configuration.\n     *\n     * @param attributeName the name of the attribute.\n     * @param value the value of the attribute.\n     */\n    public void addAttribute(String attributeName, String value) {\n        final String current = attributeMap.get(attributeName);\n        if (current == null) {\n            attributeMap.put(attributeName, value);\n        }\n        else {\n            attributeMap.put(attributeName, current + \",\" + value);\n        }\n    }\n\n    /**\n     * Adds a custom message to this configuration.\n     *\n     * @param key the message key\n     * @param value the custom message pattern\n     */\n    public void addMessage(String key, String value) {\n        messages.put(key, value);\n    }\n\n    /**\n     * Returns an unmodifiable map instance containing the custom messages\n     * for this configuration.\n     *\n     * @return unmodifiable map containing custom messages\n     */\n    @Override\n    public Map<String, String> getMessages() {\n        return new HashMap<>(messages);\n    }\n\n    /**\n     * Gets the thread mode configuration.\n     *\n     * @return the thread mode configuration.\n     */\n    public ThreadModeSettings getThreadModeSettings() {\n        return threadModeSettings;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic getProperty(propertyName String) : String extracted from public getAttribute(attributeName String) : String in class com.puppycrawl.tools.checkstyle.DefaultConfiguration", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "startLine": 86, "endLine": 93, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "startLine": 85, "endLine": 88, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "startLine": 96, "endLine": 103, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        if (!attributeMap.containsKey(attributeName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + attributeName + \"' in \" + name);\n        }\n        return attributeMap.get(attributeName);\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "isPureRefactoring": true, "commitId": "a42a3e1733f3c7583177a3c96de65e6a2fd7671f", "packageNameBefore": "com.puppycrawl.tools.checkstyle", "classNameBefore": "com.puppycrawl.tools.checkstyle.DefaultConfiguration", "methodNameBefore": "com.puppycrawl.tools.checkstyle.DefaultConfiguration#getAttribute", "classSignatureBefore": "public final class DefaultConfiguration implements Configuration ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.DefaultConfiguration#getAttribute"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.DefaultConfiguration"], "classSignatureBeforeSet": ["public final class DefaultConfiguration implements Configuration "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics\nTolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Default implementation of the Configuration interface.\n *\n * @noinspection SerializableHasSerializationMethods\n */\npublic final class DefaultConfiguration implements Configuration {\n\n    private static final long serialVersionUID = 1157875385356127169L;\n\n    /** Constant for optimization. */\n    private static final Configuration[] EMPTY_CONFIGURATION_ARRAY = new Configuration[0];\n\n    /** The name of this configuration. */\n    private final String name;\n\n    /** The list of child Configurations. */\n    private final List<Configuration> children = new ArrayList<>();\n\n    /** The map from attribute names to attribute values. */\n    private final Map<String, String> attributeMap = new HashMap<>();\n\n    /** The map containing custom messages. */\n    private final Map<String, String> messages = new HashMap<>();\n\n    /** The thread mode configuration. */\n    private final ThreadModeSettings threadModeSettings;\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     */\n    public DefaultConfiguration(String name) {\n        this(name, ThreadModeSettings.SINGLE_THREAD_MODE_INSTANCE);\n    }\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     * @param threadModeSettings the thread mode configuration.\n     */\n    public DefaultConfiguration(String name,\n        ThreadModeSettings threadModeSettings) {\n        this.name = name;\n        this.threadModeSettings = threadModeSettings;\n    }\n\n    @Override\n    public String[] getAttributeNames() {\n        final Set<String> keySet = attributeMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }\n\n    @Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        if (!attributeMap.containsKey(attributeName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + attributeName + \"' in \" + name);\n        }\n        return attributeMap.get(attributeName);\n    }\n\n    @Override\n    public Configuration[] getChildren() {\n        return children.toArray(\n                EMPTY_CONFIGURATION_ARRAY);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Makes a configuration a child of this configuration.\n     *\n     * @param configuration the child configuration.\n     */\n    public void addChild(Configuration configuration) {\n        children.add(configuration);\n    }\n\n    /**\n     * Removes a child of this configuration.\n     *\n     * @param configuration the child configuration to remove.\n     */\n    public void removeChild(final Configuration configuration) {\n        children.remove(configuration);\n    }\n\n    /**\n     * Adds an attribute to this configuration.\n     *\n     * @param attributeName the name of the attribute.\n     * @param value the value of the attribute.\n     */\n    public void addAttribute(String attributeName, String value) {\n        final String current = attributeMap.get(attributeName);\n        if (current == null) {\n            attributeMap.put(attributeName, value);\n        }\n        else {\n            attributeMap.put(attributeName, current + \",\" + value);\n        }\n    }\n\n    /**\n     * Adds a custom message to this configuration.\n     *\n     * @param key the message key\n     * @param value the custom message pattern\n     */\n    public void addMessage(String key, String value) {\n        messages.put(key, value);\n    }\n\n    /**\n     * Returns an unmodifiable map instance containing the custom messages\n     * for this configuration.\n     *\n     * @return unmodifiable map containing custom messages\n     */\n    @Override\n    public Map<String, String> getMessages() {\n        return new HashMap<>(messages);\n    }\n\n    /**\n     * Gets the thread mode configuration.\n     *\n     * @return the thread mode configuration.\n     */\n    public ThreadModeSettings getThreadModeSettings() {\n        return threadModeSettings;\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Default implementation of the Configuration interface.\n *\n * @noinspection SerializableHasSerializationMethods\n */\npublic final class DefaultConfiguration implements Configuration {\n\n    private static final long serialVersionUID = 1157875385356127169L;\n\n    /** Constant for optimization. */\n    private static final Configuration[] EMPTY_CONFIGURATION_ARRAY = new Configuration[0];\n\n    /** The name of this configuration. */\n    private final String name;\n\n    /** The list of child Configurations. */\n    private final List<Configuration> children = new ArrayList<>();\n\n    /** The map from property names to property values. */\n    private final Map<String, String> propertyMap = new HashMap<>();\n\n    /** The map containing custom messages. */\n    private final Map<String, String> messages = new HashMap<>();\n\n    /** The thread mode configuration. */\n    private final ThreadModeSettings threadModeSettings;\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     */\n    public DefaultConfiguration(String name) {\n        this(name, ThreadModeSettings.SINGLE_THREAD_MODE_INSTANCE);\n    }\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     * @param threadModeSettings the thread mode configuration.\n     */\n    public DefaultConfiguration(String name,\n        ThreadModeSettings threadModeSettings) {\n        this.name = name;\n        this.threadModeSettings = threadModeSettings;\n    }\n\n    @Override\n    public String[] getAttributeNames() {\n        return getPropertyNames();\n    }\n\n    @Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        return getProperty(attributeName);\n    }\n\n    @Override\n    public String[] getPropertyNames() {\n        final Set<String> keySet = propertyMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }\n\n    @Override\n    public String getProperty(String propertyName) throws CheckstyleException {\n        if (!propertyMap.containsKey(propertyName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + propertyName + \"' in \" + name);\n        }\n        return propertyMap.get(propertyName);\n    }\n\n    @Override\n    public Configuration[] getChildren() {\n        return children.toArray(\n                EMPTY_CONFIGURATION_ARRAY);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Makes a configuration a child of this configuration.\n     *\n     * @param configuration the child configuration.\n     */\n    public void addChild(Configuration configuration) {\n        children.add(configuration);\n    }\n\n    /**\n     * Removes a child of this configuration.\n     *\n     * @param configuration the child configuration to remove.\n     */\n    public void removeChild(final Configuration configuration) {\n        children.remove(configuration);\n    }\n\n    /**\n     * Adds n property to this configuration.\n     *\n     * @param attributeName the name of the property.\n     * @param value the value of the property.\n     * @deprecated This shall be removed in future releases. Please use\n     *      {@code addProperty(String propertyName, String value)} instead.\n     */\n    @Deprecated\n    public void addAttribute(String attributeName, String value) {\n        addProperty(attributeName, value);\n    }\n\n    /**\n     * Adds n property to this configuration.\n     *\n     * @param propertyName the name of the property.\n     * @param value the value of the property.\n     */\n    public void addProperty(String propertyName, String value) {\n        final String current = propertyMap.get(propertyName);\n        if (current == null) {\n            propertyMap.put(propertyName, value);\n        }\n        else {\n            propertyMap.put(propertyName, current + \",\" + value);\n        }\n    }\n\n    /**\n     * Adds a custom message to this configuration.\n     *\n     * @param key the message key\n     * @param value the custom message pattern\n     */\n    public void addMessage(String key, String value) {\n        messages.put(key, value);\n    }\n\n    /**\n     * Returns an unmodifiable map instance containing the custom messages\n     * for this configuration.\n     *\n     * @return unmodifiable map containing custom messages\n     */\n    @Override\n    public Map<String, String> getMessages() {\n        return new HashMap<>(messages);\n    }\n\n    /**\n     * Gets the thread mode configuration.\n     *\n     * @return the thread mode configuration.\n     */\n    public ThreadModeSettings getThreadModeSettings() {\n        return threadModeSettings;\n    }\n\n}\n", "diffSourceCodeSet": ["@Override\n    public String getProperty(String propertyName) throws CheckstyleException {\n        if (!propertyMap.containsKey(propertyName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + propertyName + \"' in \" + name);\n        }\n        return propertyMap.get(propertyName);\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        return getProperty(attributeName);\n    }\n@Override\n    public String getProperty(String propertyName) throws CheckstyleException {\n        if (!propertyMap.containsKey(propertyName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + propertyName + \"' in \" + name);\n        }\n        return propertyMap.get(propertyName);\n    }", "diffSourceCode": "-   85: \n-   86:     @Override\n-   87:     public String getAttribute(String attributeName) throws CheckstyleException {\n-   88:         if (!attributeMap.containsKey(attributeName)) {\n-   89:             throw new CheckstyleException(\n-   90:                     \"missing key '\" + attributeName + \"' in \" + name);\n-   91:         }\n-   92:         return attributeMap.get(attributeName);\n-   93:     }\n-   96:     public Configuration[] getChildren() {\n-   97:         return children.toArray(\n-   98:                 EMPTY_CONFIGURATION_ARRAY);\n-   99:     }\n-  100: \n-  101:     @Override\n-  102:     public String getName() {\n-  103:         return name;\n+   85:     @Override\n+   86:     public String getAttribute(String attributeName) throws CheckstyleException {\n+   87:         return getProperty(attributeName);\n+   88:     }\n+   89: \n+   90:     @Override\n+   91:     public String[] getPropertyNames() {\n+   92:         final Set<String> keySet = propertyMap.keySet();\n+   93:         return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n+   96:     @Override\n+   97:     public String getProperty(String propertyName) throws CheckstyleException {\n+   98:         if (!propertyMap.containsKey(propertyName)) {\n+   99:             throw new CheckstyleException(\n+  100:                     \"missing key '\" + propertyName + \"' in \" + name);\n+  101:         }\n+  102:         return propertyMap.get(propertyName);\n+  103:     }\n", "uniqueId": "a42a3e1733f3c7583177a3c96de65e6a2fd7671f_86_93_96_103_85_88", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 28}, "BRANCH": {"missed": 0, "covered": 2}, "LINE": {"missed": 0, "covered": 3}, "COMPLEXITY": {"missed": 0, "covered": 2}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nprivate void checkAttributeExistence(String attributeName) throws CheckstyleException {\n    if (!attributeMap.containsKey(attributeName)) {\n        throw new CheckstyleException(\n                \"missing key '\" + attributeName + \"' in \" + name);\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        if (!attributeMap.containsKey(attributeName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + attributeName + \"' in \" + name);\n        }\n        return attributeMap.get(attributeName);\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Default implementation of the Configuration interface.\n *\n * @noinspection SerializableHasSerializationMethods\n */\npublic final class DefaultConfiguration implements Configuration {\n\n    private static final long serialVersionUID = 1157875385356127169L;\n\n    /** Constant for optimization. */\n    private static final Configuration[] EMPTY_CONFIGURATION_ARRAY = new Configuration[0];\n\n    /** The name of this configuration. */\n    private final String name;\n\n    /** The list of child Configurations. */\n    private final List<Configuration> children = new ArrayList<>();\n\n    /** The map from attribute names to attribute values. */\n    private final Map<String, String> attributeMap = new HashMap<>();\n\n    /** The map containing custom messages. */\n    private final Map<String, String> messages = new HashMap<>();\n\n    /** The thread mode configuration. */\n    private final ThreadModeSettings threadModeSettings;\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     */\n    public DefaultConfiguration(String name) {\n        this(name, ThreadModeSettings.SINGLE_THREAD_MODE_INSTANCE);\n    }\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     * @param threadModeSettings the thread mode configuration.\n     */\n    public DefaultConfiguration(String name,\n        ThreadModeSettings threadModeSettings) {\n        this.name = name;\n        this.threadModeSettings = threadModeSettings;\n    }\n\n    @Override\n    public String[] getAttributeNames() {\n        final Set<String> keySet = attributeMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }\n\n    @Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        if (!attributeMap.containsKey(attributeName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + attributeName + \"' in \" + name);\n        }\n        return attributeMap.get(attributeName);\n    }\n\n    @Override\n    public Configuration[] getChildren() {\n        return children.toArray(\n                EMPTY_CONFIGURATION_ARRAY);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Makes a configuration a child of this configuration.\n     *\n     * @param configuration the child configuration.\n     */\n    public void addChild(Configuration configuration) {\n        children.add(configuration);\n    }\n\n    /**\n     * Removes a child of this configuration.\n     *\n     * @param configuration the child configuration to remove.\n     */\n    public void removeChild(final Configuration configuration) {\n        children.remove(configuration);\n    }\n\n    /**\n     * Adds an attribute to this configuration.\n     *\n     * @param attributeName the name of the attribute.\n     * @param value the value of the attribute.\n     */\n    public void addAttribute(String attributeName, String value) {\n        final String current = attributeMap.get(attributeName);\n        if (current == null) {\n            attributeMap.put(attributeName, value);\n        }\n        else {\n            attributeMap.put(attributeName, current + \",\" + value);\n        }\n    }\n\n    /**\n     * Adds a custom message to this configuration.\n     *\n     * @param key the message key\n     * @param value the custom message pattern\n     */\n    public void addMessage(String key, String value) {\n        messages.put(key, value);\n    }\n\n    /**\n     * Returns an unmodifiable map instance containing the custom messages\n     * for this configuration.\n     *\n     * @return unmodifiable map containing custom messages\n     */\n    @Override\n    public Map<String, String> getMessages() {\n        return new HashMap<>(messages);\n    }\n\n    /**\n     * Gets the thread mode configuration.\n     *\n     * @return the thread mode configuration.\n     */\n    public ThreadModeSettings getThreadModeSettings() {\n        return threadModeSettings;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic getPropertyNames() : String[] extracted from public getAttributeNames() : String[] in class com.puppycrawl.tools.checkstyle.DefaultConfiguration", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "startLine": 80, "endLine": 84, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "startLine": 80, "endLine": 83, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "startLine": 90, "endLine": 94, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public String[] getAttributeNames() {\n        final Set<String> keySet = attributeMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "isPureRefactoring": true, "commitId": "a42a3e1733f3c7583177a3c96de65e6a2fd7671f", "packageNameBefore": "com.puppycrawl.tools.checkstyle", "classNameBefore": "com.puppycrawl.tools.checkstyle.DefaultConfiguration", "methodNameBefore": "com.puppycrawl.tools.checkstyle.DefaultConfiguration#getAttributeNames", "classSignatureBefore": "public final class DefaultConfiguration implements Configuration ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.DefaultConfiguration#getAttributeNames"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.DefaultConfiguration"], "classSignatureBeforeSet": ["public final class DefaultConfiguration implements Configuration "], "purityCheckResultList": [{"isPure": true, "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Attribute-", "description": "Rename Attribute on the top of the extracted method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Default implementation of the Configuration interface.\n *\n * @noinspection SerializableHasSerializationMethods\n */\npublic final class DefaultConfiguration implements Configuration {\n\n    private static final long serialVersionUID = 1157875385356127169L;\n\n    /** Constant for optimization. */\n    private static final Configuration[] EMPTY_CONFIGURATION_ARRAY = new Configuration[0];\n\n    /** The name of this configuration. */\n    private final String name;\n\n    /** The list of child Configurations. */\n    private final List<Configuration> children = new ArrayList<>();\n\n    /** The map from attribute names to attribute values. */\n    private final Map<String, String> attributeMap = new HashMap<>();\n\n    /** The map containing custom messages. */\n    private final Map<String, String> messages = new HashMap<>();\n\n    /** The thread mode configuration. */\n    private final ThreadModeSettings threadModeSettings;\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     */\n    public DefaultConfiguration(String name) {\n        this(name, ThreadModeSettings.SINGLE_THREAD_MODE_INSTANCE);\n    }\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     * @param threadModeSettings the thread mode configuration.\n     */\n    public DefaultConfiguration(String name,\n        ThreadModeSettings threadModeSettings) {\n        this.name = name;\n        this.threadModeSettings = threadModeSettings;\n    }\n\n    @Override\n    public String[] getAttributeNames() {\n        final Set<String> keySet = attributeMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }\n\n    @Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        if (!attributeMap.containsKey(attributeName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + attributeName + \"' in \" + name);\n        }\n        return attributeMap.get(attributeName);\n    }\n\n    @Override\n    public Configuration[] getChildren() {\n        return children.toArray(\n                EMPTY_CONFIGURATION_ARRAY);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Makes a configuration a child of this configuration.\n     *\n     * @param configuration the child configuration.\n     */\n    public void addChild(Configuration configuration) {\n        children.add(configuration);\n    }\n\n    /**\n     * Removes a child of this configuration.\n     *\n     * @param configuration the child configuration to remove.\n     */\n    public void removeChild(final Configuration configuration) {\n        children.remove(configuration);\n    }\n\n    /**\n     * Adds an attribute to this configuration.\n     *\n     * @param attributeName the name of the attribute.\n     * @param value the value of the attribute.\n     */\n    public void addAttribute(String attributeName, String value) {\n        final String current = attributeMap.get(attributeName);\n        if (current == null) {\n            attributeMap.put(attributeName, value);\n        }\n        else {\n            attributeMap.put(attributeName, current + \",\" + value);\n        }\n    }\n\n    /**\n     * Adds a custom message to this configuration.\n     *\n     * @param key the message key\n     * @param value the custom message pattern\n     */\n    public void addMessage(String key, String value) {\n        messages.put(key, value);\n    }\n\n    /**\n     * Returns an unmodifiable map instance containing the custom messages\n     * for this configuration.\n     *\n     * @return unmodifiable map containing custom messages\n     */\n    @Override\n    public Map<String, String> getMessages() {\n        return new HashMap<>(messages);\n    }\n\n    /**\n     * Gets the thread mode configuration.\n     *\n     * @return the thread mode configuration.\n     */\n    public ThreadModeSettings getThreadModeSettings() {\n        return threadModeSettings;\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Default implementation of the Configuration interface.\n *\n * @noinspection SerializableHasSerializationMethods\n */\npublic final class DefaultConfiguration implements Configuration {\n\n    private static final long serialVersionUID = 1157875385356127169L;\n\n    /** Constant for optimization. */\n    private static final Configuration[] EMPTY_CONFIGURATION_ARRAY = new Configuration[0];\n\n    /** The name of this configuration. */\n    private final String name;\n\n    /** The list of child Configurations. */\n    private final List<Configuration> children = new ArrayList<>();\n\n    /** The map from property names to property values. */\n    private final Map<String, String> propertyMap = new HashMap<>();\n\n    /** The map containing custom messages. */\n    private final Map<String, String> messages = new HashMap<>();\n\n    /** The thread mode configuration. */\n    private final ThreadModeSettings threadModeSettings;\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     */\n    public DefaultConfiguration(String name) {\n        this(name, ThreadModeSettings.SINGLE_THREAD_MODE_INSTANCE);\n    }\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     * @param threadModeSettings the thread mode configuration.\n     */\n    public DefaultConfiguration(String name,\n        ThreadModeSettings threadModeSettings) {\n        this.name = name;\n        this.threadModeSettings = threadModeSettings;\n    }\n\n    @Override\n    public String[] getAttributeNames() {\n        return getPropertyNames();\n    }\n\n    @Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        return getProperty(attributeName);\n    }\n\n    @Override\n    public String[] getPropertyNames() {\n        final Set<String> keySet = propertyMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }\n\n    @Override\n    public String getProperty(String propertyName) throws CheckstyleException {\n        if (!propertyMap.containsKey(propertyName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + propertyName + \"' in \" + name);\n        }\n        return propertyMap.get(propertyName);\n    }\n\n    @Override\n    public Configuration[] getChildren() {\n        return children.toArray(\n                EMPTY_CONFIGURATION_ARRAY);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Makes a configuration a child of this configuration.\n     *\n     * @param configuration the child configuration.\n     */\n    public void addChild(Configuration configuration) {\n        children.add(configuration);\n    }\n\n    /**\n     * Removes a child of this configuration.\n     *\n     * @param configuration the child configuration to remove.\n     */\n    public void removeChild(final Configuration configuration) {\n        children.remove(configuration);\n    }\n\n    /**\n     * Adds n property to this configuration.\n     *\n     * @param attributeName the name of the property.\n     * @param value the value of the property.\n     * @deprecated This shall be removed in future releases. Please use\n     *      {@code addProperty(String propertyName, String value)} instead.\n     */\n    @Deprecated\n    public void addAttribute(String attributeName, String value) {\n        addProperty(attributeName, value);\n    }\n\n    /**\n     * Adds n property to this configuration.\n     *\n     * @param propertyName the name of the property.\n     * @param value the value of the property.\n     */\n    public void addProperty(String propertyName, String value) {\n        final String current = propertyMap.get(propertyName);\n        if (current == null) {\n            propertyMap.put(propertyName, value);\n        }\n        else {\n            propertyMap.put(propertyName, current + \",\" + value);\n        }\n    }\n\n    /**\n     * Adds a custom message to this configuration.\n     *\n     * @param key the message key\n     * @param value the custom message pattern\n     */\n    public void addMessage(String key, String value) {\n        messages.put(key, value);\n    }\n\n    /**\n     * Returns an unmodifiable map instance containing the custom messages\n     * for this configuration.\n     *\n     * @return unmodifiable map containing custom messages\n     */\n    @Override\n    public Map<String, String> getMessages() {\n        return new HashMap<>(messages);\n    }\n\n    /**\n     * Gets the thread mode configuration.\n     *\n     * @return the thread mode configuration.\n     */\n    public ThreadModeSettings getThreadModeSettings() {\n        return threadModeSettings;\n    }\n\n}\n", "diffSourceCodeSet": ["@Override\n    public String[] getPropertyNames() {\n        final Set<String> keySet = propertyMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Override\n    public String[] getAttributeNames() {\n        return getPropertyNames();\n    }\n@Override\n    public String[] getPropertyNames() {\n        final Set<String> keySet = propertyMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }", "diffSourceCode": "    80:     @Override\n    81:     public String[] getAttributeNames() {\n-   82:         final Set<String> keySet = attributeMap.keySet();\n-   83:         return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n-   84:     }\n-   90:                     \"missing key '\" + attributeName + \"' in \" + name);\n-   91:         }\n-   92:         return attributeMap.get(attributeName);\n-   93:     }\n-   94: \n+   82:         return getPropertyNames();\n+   83:     }\n+   84: \n+   90:     @Override\n+   91:     public String[] getPropertyNames() {\n+   92:         final Set<String> keySet = propertyMap.keySet();\n+   93:         return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n+   94:     }\n", "uniqueId": "a42a3e1733f3c7583177a3c96de65e6a2fd7671f_80_84_90_94_80_83", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 9}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nprivate Set<String> getKeySet() {\n    return attributeMap.keySet();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public String[] getAttributeNames() {\n        final Set<String> keySet = attributeMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * Default implementation of the Configuration interface.\n *\n * @noinspection SerializableHasSerializationMethods\n */\npublic final class DefaultConfiguration implements Configuration {\n\n    private static final long serialVersionUID = 1157875385356127169L;\n\n    /** Constant for optimization. */\n    private static final Configuration[] EMPTY_CONFIGURATION_ARRAY = new Configuration[0];\n\n    /** The name of this configuration. */\n    private final String name;\n\n    /** The list of child Configurations. */\n    private final List<Configuration> children = new ArrayList<>();\n\n    /** The map from attribute names to attribute values. */\n    private final Map<String, String> attributeMap = new HashMap<>();\n\n    /** The map containing custom messages. */\n    private final Map<String, String> messages = new HashMap<>();\n\n    /** The thread mode configuration. */\n    private final ThreadModeSettings threadModeSettings;\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     */\n    public DefaultConfiguration(String name) {\n        this(name, ThreadModeSettings.SINGLE_THREAD_MODE_INSTANCE);\n    }\n\n    /**\n     * Instantiates a DefaultConfiguration.\n     *\n     * @param name the name for this DefaultConfiguration.\n     * @param threadModeSettings the thread mode configuration.\n     */\n    public DefaultConfiguration(String name,\n        ThreadModeSettings threadModeSettings) {\n        this.name = name;\n        this.threadModeSettings = threadModeSettings;\n    }\n\n    @Override\n    public String[] getAttributeNames() {\n        final Set<String> keySet = attributeMap.keySet();\n        return keySet.toArray(CommonUtil.EMPTY_STRING_ARRAY);\n    }\n\n    @Override\n    public String getAttribute(String attributeName) throws CheckstyleException {\n        if (!attributeMap.containsKey(attributeName)) {\n            throw new CheckstyleException(\n                    \"missing key '\" + attributeName + \"' in \" + name);\n        }\n        return attributeMap.get(attributeName);\n    }\n\n    @Override\n    public Configuration[] getChildren() {\n        return children.toArray(\n                EMPTY_CONFIGURATION_ARRAY);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Makes a configuration a child of this configuration.\n     *\n     * @param configuration the child configuration.\n     */\n    public void addChild(Configuration configuration) {\n        children.add(configuration);\n    }\n\n    /**\n     * Removes a child of this configuration.\n     *\n     * @param configuration the child configuration to remove.\n     */\n    public void removeChild(final Configuration configuration) {\n        children.remove(configuration);\n    }\n\n    /**\n     * Adds an attribute to this configuration.\n     *\n     * @param attributeName the name of the attribute.\n     * @param value the value of the attribute.\n     */\n    public void addAttribute(String attributeName, String value) {\n        final String current = attributeMap.get(attributeName);\n        if (current == null) {\n            attributeMap.put(attributeName, value);\n        }\n        else {\n            attributeMap.put(attributeName, current + \",\" + value);\n        }\n    }\n\n    /**\n     * Adds a custom message to this configuration.\n     *\n     * @param key the message key\n     * @param value the custom message pattern\n     */\n    public void addMessage(String key, String value) {\n        messages.put(key, value);\n    }\n\n    /**\n     * Returns an unmodifiable map instance containing the custom messages\n     * for this configuration.\n     *\n     * @return unmodifiable map containing custom messages\n     */\n    @Override\n    public Map<String, String> getMessages() {\n        return new HashMap<>(messages);\n    }\n\n    /**\n     * Gets the thread mode configuration.\n     *\n     * @return the thread mode configuration.\n     */\n    public ThreadModeSettings getThreadModeSettings() {\n        return threadModeSettings;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic checkForAnnotationIndentation(firstNodesOnLines NavigableMap<Integer,DetailAST>, indentLevel int) : void extracted from public checkIndentation(firstNode DetailAST, lastNode DetailAST, indentLevel int, startIndent int, ignoreFirstLine LineWrappingOptions) : void in class com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java", "startLine": 127, "endLine": 184, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java", "startLine": 127, "endLine": 172, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java", "startLine": 174, "endLine": 198, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks line wrapping into expressions and definitions.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @param indentLevel Indentation all wrapped lines should use.\n     * @param startIndent Indentation first line before wrapped lines used.\n     * @param ignoreFirstLine Test if first line's indentation should be checked or not.\n     */\n    public void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel,\n            int startIndent, LineWrappingOptions ignoreFirstLine) {\n        final NavigableMap<Integer, DetailAST> firstNodesOnLines = collectFirstNodes(firstNode,\n                lastNode);\n\n        final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n        if (firstLineNode.getType() == TokenTypes.AT) {\n            DetailAST node = firstLineNode.getParent();\n            while (node != null) {\n                if (node.getType() == TokenTypes.ANNOTATION) {\n                    final DetailAST atNode = node.getFirstChild();\n                    final NavigableMap<Integer, DetailAST> annotationLines =\n                        firstNodesOnLines.subMap(\n                            node.getLineNo(),\n                            true,\n                            getNextNodeLine(firstNodesOnLines, node),\n                            true\n                        );\n                    checkAnnotationIndentation(atNode, annotationLines, indentLevel);\n                }\n                node = node.getNextSibling();\n            }\n        }\n\n        if (ignoreFirstLine == LineWrappingOptions.IGNORE_FIRST_LINE) {\n            // First node should be removed because it was already checked before.\n            firstNodesOnLines.remove(firstNodesOnLines.firstKey());\n        }\n\n        final int firstNodeIndent;\n        if (startIndent == -1) {\n            firstNodeIndent = getLineStart(firstLineNode);\n        }\n        else {\n            firstNodeIndent = startIndent;\n        }\n        final int currentIndent = firstNodeIndent + indentLevel;\n\n        for (DetailAST node : firstNodesOnLines.values()) {\n            final int currentType = node.getType();\n\n            if (currentType == TokenTypes.RPAREN) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else if (!TokenUtil.isOfType(currentType, IGNORED_LIST)) {\n                logWarningMessage(node, currentIndent);\n            }\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java", "isPureRefactoring": true, "commitId": "29e5e1210c6a292327a5a55b31b34180cd91f393", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.indentation", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#checkIndentation", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheckTest#getLineStart\n methodBody: private static int getLineStart(String line, final int tabWidth) {\nint lineStart=0;\nfor(int index=0; index < line.length(); ++index){if(!Character.isWhitespace(line.charAt(index))){lineStart=CommonUtil.lengthExpandedTabs(line,index,tabWidth);\nbreak;\n}}return lineStart;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#getLineStart\n methodBody: private int getLineStart(String line) {\nint index=0;\nwhile(Character.isWhitespace(line.charAt(index))){index++;\n}return CommonUtil.lengthExpandedTabs(line,index,indentCheck.getIndentationTabWidth());\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#logWarningMessage\n methodBody: private void logWarningMessage(DetailAST currentNode, int currentIndent) {\nif(indentCheck.isForceStrictCondition()){if(expandedTabsColumnNo(currentNode) != currentIndent){indentCheck.indentationLog(currentNode,IndentationCheck.MSG_ERROR,currentNode.getText(),expandedTabsColumnNo(currentNode),currentIndent);\n}}{if(expandedTabsColumnNo(currentNode) < currentIndent){indentCheck.indentationLog(currentNode,IndentationCheck.MSG_ERROR,currentNode.getText(),expandedTabsColumnNo(currentNode),currentIndent);\n}}}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#getNextNodeLine\n methodBody: private static Integer getNextNodeLine(\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, DetailAST node) {\nInteger nextNodeLine=firstNodesOnLines.higherKey(node.getLastChild().getLineNo());\nif(nextNodeLine == null){nextNodeLine=firstNodesOnLines.lastKey();\n}return nextNodeLine;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#collectFirstNodes\n methodBody: private NavigableMap<Integer, DetailAST> collectFirstNodes(DetailAST firstNode,\n            DetailAST lastNode) {\nfinal NavigableMap<Integer,DetailAST> result=new TreeMap<>();\nresult.put(firstNode.getLineNo(),firstNode);\nDetailAST curNode=firstNode.getFirstChild();\nwhile(curNode != lastNode){if(curNode.getType() == TokenTypes.OBJBLOCK || curNode.getType() == TokenTypes.SLIST){curNode=curNode.getLastChild();\n}final DetailAST firstTokenOnLine=result.get(curNode.getLineNo());\nif(firstTokenOnLine == null || expandedTabsColumnNo(firstTokenOnLine) >= expandedTabsColumnNo(curNode)){result.put(curNode.getLineNo(),curNode);\n}curNode=getNextCurNode(curNode);\n}return result;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#checkAnnotationIndentation\n methodBody: private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {\nfinal int firstNodeIndent=getLineStart(atNode);\nfinal int currentIndent=firstNodeIndent + indentLevel;\nfinal Collection<DetailAST> values=firstNodesOnLines.values();\nfinal DetailAST lastAnnotationNode=atNode.getParent().getLastChild();\nfinal int lastAnnotationLine=lastAnnotationNode.getLineNo();\nfinal Iterator<DetailAST> itr=values.iterator();\nwhile(firstNodesOnLines.size() > 1){final DetailAST node=itr.next();\nfinal DetailAST parentNode=node.getParent();\nfinal boolean isArrayInitPresentInAncestors=isParentContainsTokenType(node,TokenTypes.ANNOTATION_ARRAY_INIT);\nfinal boolean isCurrentNodeCloseAnnotationAloneInLine=node.getLineNo() == lastAnnotationLine && isEndOfScope(lastAnnotationNode,node);\nif(!isArrayInitPresentInAncestors && (isCurrentNodeCloseAnnotationAloneInLine || node.getType() == TokenTypes.AT && (parentNode.getParent().getType() == TokenTypes.MODIFIERS || parentNode.getParent().getType() == TokenTypes.ANNOTATIONS) || TokenUtil.areOnSameLine(node,atNode))){logWarningMessage(node,firstNodeIndent);\n}if(!isArrayInitPresentInAncestors){logWarningMessage(node,currentIndent);\n}itr.remove();\n}}", "classSignatureBefore": "public class LineWrappingHandler ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#checkIndentation"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler"], "classSignatureBeforeSet": ["public class LineWrappingHandler "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.indentation;\n\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NavigableMap;\nimport java.util.TreeMap;\n\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * This class checks line-wrapping into definitions and expressions. The\n * line-wrapping indentation should be not less than value of the\n * lineWrappingIndentation parameter.\n *\n */\npublic class LineWrappingHandler {\n\n    /**\n     * Enum to be used for test if first line's indentation should be checked or not.\n     */\n    public enum LineWrappingOptions {\n\n        /**\n         * First line's indentation should NOT be checked.\n         */\n        IGNORE_FIRST_LINE,\n        /**\n         * First line's indentation should be checked.\n         */\n        NONE;\n\n        /**\n         * Builds enum value from boolean.\n         *\n         * @param val value.\n         * @return enum instance.\n         *\n         * @noinspection BooleanParameter\n         */\n        public static LineWrappingOptions ofBoolean(boolean val) {\n            LineWrappingOptions option = NONE;\n            if (val) {\n                option = IGNORE_FIRST_LINE;\n            }\n            return option;\n        }\n\n    }\n\n    /**\n     * The list of ignored token types for being checked by lineWrapping indentation\n     * inside {@code checkIndentation()} as these tokens are checked for lineWrapping\n     * inside their dedicated handlers.\n     *\n     * @see NewHandler#getIndentImpl()\n     * @see BlockParentHandler#curlyIndent()\n     * @see ArrayInitHandler#getIndentImpl()\n     */\n    private static final int[] IGNORED_LIST = {\n        TokenTypes.RCURLY,\n        TokenTypes.LITERAL_NEW,\n        TokenTypes.ARRAY_INIT,\n    };\n\n    /**\n     * The current instance of {@code IndentationCheck} class using this\n     * handler. This field used to get access to private fields of\n     * IndentationCheck instance.\n     */\n    private final IndentationCheck indentCheck;\n\n    /**\n     * Sets values of class field, finds last node and calculates indentation level.\n     *\n     * @param instance\n     *            instance of IndentationCheck.\n     */\n    public LineWrappingHandler(IndentationCheck instance) {\n        indentCheck = instance;\n    }\n\n    /**\n     * Checks line wrapping into expressions and definitions using property\n     * 'lineWrappingIndentation'.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     */\n    public void checkIndentation(DetailAST firstNode, DetailAST lastNode) {\n        checkIndentation(firstNode, lastNode, indentCheck.getLineWrappingIndentation());\n    }\n\n    /**\n     * Checks line wrapping into expressions and definitions.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @param indentLevel Indentation all wrapped lines should use.\n     */\n    private void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel) {\n        checkIndentation(firstNode, lastNode, indentLevel,\n                -1, LineWrappingOptions.IGNORE_FIRST_LINE);\n    }\n\n    /**\n     * Checks line wrapping into expressions and definitions.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @param indentLevel Indentation all wrapped lines should use.\n     * @param startIndent Indentation first line before wrapped lines used.\n     * @param ignoreFirstLine Test if first line's indentation should be checked or not.\n     */\n    public void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel,\n            int startIndent, LineWrappingOptions ignoreFirstLine) {\n        final NavigableMap<Integer, DetailAST> firstNodesOnLines = collectFirstNodes(firstNode,\n                lastNode);\n\n        final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n        if (firstLineNode.getType() == TokenTypes.AT) {\n            DetailAST node = firstLineNode.getParent();\n            while (node != null) {\n                if (node.getType() == TokenTypes.ANNOTATION) {\n                    final DetailAST atNode = node.getFirstChild();\n                    final NavigableMap<Integer, DetailAST> annotationLines =\n                        firstNodesOnLines.subMap(\n                            node.getLineNo(),\n                            true,\n                            getNextNodeLine(firstNodesOnLines, node),\n                            true\n                        );\n                    checkAnnotationIndentation(atNode, annotationLines, indentLevel);\n                }\n                node = node.getNextSibling();\n            }\n        }\n\n        if (ignoreFirstLine == LineWrappingOptions.IGNORE_FIRST_LINE) {\n            // First node should be removed because it was already checked before.\n            firstNodesOnLines.remove(firstNodesOnLines.firstKey());\n        }\n\n        final int firstNodeIndent;\n        if (startIndent == -1) {\n            firstNodeIndent = getLineStart(firstLineNode);\n        }\n        else {\n            firstNodeIndent = startIndent;\n        }\n        final int currentIndent = firstNodeIndent + indentLevel;\n\n        for (DetailAST node : firstNodesOnLines.values()) {\n            final int currentType = node.getType();\n\n            if (currentType == TokenTypes.RPAREN) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else if (!TokenUtil.isOfType(currentType, IGNORED_LIST)) {\n                logWarningMessage(node, currentIndent);\n            }\n        }\n    }\n\n    /**\n     * Gets the next node line from the firstNodesOnLines map unless there is no next line, in\n     * which case, it returns the last line.\n     *\n     * @param firstNodesOnLines NavigableMap of lines and their first nodes.\n     * @param node the node for which to find the next node line\n     * @return the line number of the next line in the map\n     */\n    private static Integer getNextNodeLine(\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, DetailAST node) {\n        Integer nextNodeLine = firstNodesOnLines.higherKey(node.getLastChild().getLineNo());\n        if (nextNodeLine == null) {\n            nextNodeLine = firstNodesOnLines.lastKey();\n        }\n        return nextNodeLine;\n    }\n\n    /**\n     * Finds first nodes on line and puts them into Map.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @return NavigableMap which contains lines numbers as a key and first\n     *         nodes on lines as a values.\n     */\n    private NavigableMap<Integer, DetailAST> collectFirstNodes(DetailAST firstNode,\n            DetailAST lastNode) {\n        final NavigableMap<Integer, DetailAST> result = new TreeMap<>();\n\n        result.put(firstNode.getLineNo(), firstNode);\n        DetailAST curNode = firstNode.getFirstChild();\n\n        while (curNode != lastNode) {\n            if (curNode.getType() == TokenTypes.OBJBLOCK\n                    || curNode.getType() == TokenTypes.SLIST) {\n                curNode = curNode.getLastChild();\n            }\n\n            final DetailAST firstTokenOnLine = result.get(curNode.getLineNo());\n\n            if (firstTokenOnLine == null\n                || expandedTabsColumnNo(firstTokenOnLine) >= expandedTabsColumnNo(curNode)) {\n                result.put(curNode.getLineNo(), curNode);\n            }\n            curNode = getNextCurNode(curNode);\n        }\n        return result;\n    }\n\n    /**\n     * Returns next curNode node.\n     *\n     * @param curNode current node.\n     * @return next curNode node.\n     */\n    private static DetailAST getNextCurNode(DetailAST curNode) {\n        DetailAST nodeToVisit = curNode.getFirstChild();\n        DetailAST currentNode = curNode;\n\n        while (nodeToVisit == null) {\n            nodeToVisit = currentNode.getNextSibling();\n            if (nodeToVisit == null) {\n                currentNode = currentNode.getParent();\n            }\n        }\n        return nodeToVisit;\n    }\n\n    /**\n     * Checks line wrapping into annotations.\n     *\n     * @param atNode block tag node.\n     * @param firstNodesOnLines map which contains\n     *     first nodes as values and line numbers as keys.\n     * @param indentLevel line wrapping indentation.\n     */\n    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {\n        final int firstNodeIndent = getLineStart(atNode);\n        final int currentIndent = firstNodeIndent + indentLevel;\n        final Collection<DetailAST> values = firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode = atNode.getParent().getLastChild();\n        final int lastAnnotationLine = lastAnnotationNode.getLineNo();\n\n        final Iterator<DetailAST> itr = values.iterator();\n        while (firstNodesOnLines.size() > 1) {\n            final DetailAST node = itr.next();\n\n            final DetailAST parentNode = node.getParent();\n            final boolean isArrayInitPresentInAncestors =\n                isParentContainsTokenType(node, TokenTypes.ANNOTATION_ARRAY_INIT);\n            final boolean isCurrentNodeCloseAnnotationAloneInLine =\n                node.getLineNo() == lastAnnotationLine\n                    && isEndOfScope(lastAnnotationNode, node);\n            if (!isArrayInitPresentInAncestors\n                    && (isCurrentNodeCloseAnnotationAloneInLine\n                    || node.getType() == TokenTypes.AT\n                    && (parentNode.getParent().getType() == TokenTypes.MODIFIERS\n                        || parentNode.getParent().getType() == TokenTypes.ANNOTATIONS)\n                    || TokenUtil.areOnSameLine(node, atNode))) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else if (!isArrayInitPresentInAncestors) {\n                logWarningMessage(node, currentIndent);\n            }\n            itr.remove();\n        }\n    }\n\n    /**\n     * Checks line for end of scope.  Handles occurrences of close braces and close parenthesis on\n     * the same line.\n     *\n     * @param lastAnnotationNode the last node of the annotation\n     * @param node the node indicating where to begin checking\n     * @return true if all the nodes up to the last annotation node are end of scope nodes\n     *         false otherwise\n     */\n    private static boolean isEndOfScope(final DetailAST lastAnnotationNode, final DetailAST node) {\n        DetailAST checkNode = node;\n        boolean endOfScope = true;\n        while (endOfScope && !checkNode.equals(lastAnnotationNode)) {\n            switch (checkNode.getType()) {\n                case TokenTypes.RCURLY:\n                case TokenTypes.RBRACK:\n                    while (checkNode.getNextSibling() == null) {\n                        checkNode = checkNode.getParent();\n                    }\n                    checkNode = checkNode.getNextSibling();\n                    break;\n                default:\n                    endOfScope = false;\n            }\n        }\n        return endOfScope;\n    }\n\n    /**\n     * Checks that some parent of given node contains given token type.\n     *\n     * @param node node to check\n     * @param type type to look for\n     * @return true if there is a parent of given type\n     */\n    private static boolean isParentContainsTokenType(final DetailAST node, int type) {\n        boolean returnValue = false;\n        for (DetailAST ast = node.getParent(); ast != null; ast = ast.getParent()) {\n            if (ast.getType() == type) {\n                returnValue = true;\n                break;\n            }\n        }\n        return returnValue;\n    }\n\n    /**\n     * Get the column number for the start of a given expression, expanding\n     * tabs out into spaces in the process.\n     *\n     * @param ast   the expression to find the start of\n     *\n     * @return the column number for the start of the expression\n     */\n    private int expandedTabsColumnNo(DetailAST ast) {\n        final String line =\n            indentCheck.getLine(ast.getLineNo() - 1);\n\n        return CommonUtil.lengthExpandedTabs(line, ast.getColumnNo(),\n            indentCheck.getIndentationTabWidth());\n    }\n\n    /**\n     * Get the start of the line for the given expression.\n     *\n     * @param ast   the expression to find the start of the line for\n     *\n     * @return the start of the line for the given expression\n     */\n    private int getLineStart(DetailAST ast) {\n        final String line = indentCheck.getLine(ast.getLineNo() - 1);\n        return getLineStart(line);\n    }\n\n    /**\n     * Get the start of the specified line.\n     *\n     * @param line the specified line number\n     * @return the start of the specified line\n     */\n    private int getLineStart(String line) {\n        int index = 0;\n        while (Character.isWhitespace(line.charAt(index))) {\n            index++;\n        }\n        return CommonUtil.lengthExpandedTabs(line, index, indentCheck.getIndentationTabWidth());\n    }\n\n    /**\n     * Logs warning message if indentation is incorrect.\n     *\n     * @param currentNode\n     *            current node which probably invoked a violation.\n     * @param currentIndent\n     *            correct indentation.\n     */\n    private void logWarningMessage(DetailAST currentNode, int currentIndent) {\n        if (indentCheck.isForceStrictCondition()) {\n            if (expandedTabsColumnNo(currentNode) != currentIndent) {\n                indentCheck.indentationLog(currentNode,\n                        IndentationCheck.MSG_ERROR, currentNode.getText(),\n                        expandedTabsColumnNo(currentNode), currentIndent);\n            }\n        }\n        else {\n            if (expandedTabsColumnNo(currentNode) < currentIndent) {\n                indentCheck.indentationLog(currentNode,\n                        IndentationCheck.MSG_ERROR, currentNode.getText(),\n                        expandedTabsColumnNo(currentNode), currentIndent);\n            }\n        }\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.indentation;\n\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NavigableMap;\nimport java.util.TreeMap;\n\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * This class checks line-wrapping into definitions and expressions. The\n * line-wrapping indentation should be not less than value of the\n * lineWrappingIndentation parameter.\n *\n */\npublic class LineWrappingHandler {\n\n    /**\n     * Enum to be used for test if first line's indentation should be checked or not.\n     */\n    public enum LineWrappingOptions {\n\n        /**\n         * First line's indentation should NOT be checked.\n         */\n        IGNORE_FIRST_LINE,\n        /**\n         * First line's indentation should be checked.\n         */\n        NONE;\n\n        /**\n         * Builds enum value from boolean.\n         *\n         * @param val value.\n         * @return enum instance.\n         *\n         * @noinspection BooleanParameter\n         */\n        public static LineWrappingOptions ofBoolean(boolean val) {\n            LineWrappingOptions option = NONE;\n            if (val) {\n                option = IGNORE_FIRST_LINE;\n            }\n            return option;\n        }\n\n    }\n\n    /**\n     * The list of ignored token types for being checked by lineWrapping indentation\n     * inside {@code checkIndentation()} as these tokens are checked for lineWrapping\n     * inside their dedicated handlers.\n     *\n     * @see NewHandler#getIndentImpl()\n     * @see BlockParentHandler#curlyIndent()\n     * @see ArrayInitHandler#getIndentImpl()\n     */\n    private static final int[] IGNORED_LIST = {\n        TokenTypes.RCURLY,\n        TokenTypes.LITERAL_NEW,\n        TokenTypes.ARRAY_INIT,\n    };\n\n    /**\n     * The current instance of {@code IndentationCheck} class using this\n     * handler. This field used to get access to private fields of\n     * IndentationCheck instance.\n     */\n    private final IndentationCheck indentCheck;\n\n    /**\n     * Sets values of class field, finds last node and calculates indentation level.\n     *\n     * @param instance\n     *            instance of IndentationCheck.\n     */\n    public LineWrappingHandler(IndentationCheck instance) {\n        indentCheck = instance;\n    }\n\n    /**\n     * Checks line wrapping into expressions and definitions using property\n     * 'lineWrappingIndentation'.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     */\n    public void checkIndentation(DetailAST firstNode, DetailAST lastNode) {\n        checkIndentation(firstNode, lastNode, indentCheck.getLineWrappingIndentation());\n    }\n\n    /**\n     * Checks line wrapping into expressions and definitions.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @param indentLevel Indentation all wrapped lines should use.\n     */\n    private void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel) {\n        checkIndentation(firstNode, lastNode, indentLevel,\n                -1, LineWrappingOptions.IGNORE_FIRST_LINE);\n    }\n\n    /**\n     * Checks line wrapping into expressions and definitions.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @param indentLevel Indentation all wrapped lines should use.\n     * @param startIndent Indentation first line before wrapped lines used.\n     * @param ignoreFirstLine Test if first line's indentation should be checked or not.\n     */\n    public void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel,\n            int startIndent, LineWrappingOptions ignoreFirstLine) {\n        final NavigableMap<Integer, DetailAST> firstNodesOnLines = collectFirstNodes(firstNode,\n                lastNode);\n\n        final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n        if (firstLineNode.getType() == TokenTypes.AT) {\n            checkForAnnotationIndentation(firstNodesOnLines, indentLevel);\n        }\n\n        if (ignoreFirstLine == LineWrappingOptions.IGNORE_FIRST_LINE) {\n            // First node should be removed because it was already checked before.\n            firstNodesOnLines.remove(firstNodesOnLines.firstKey());\n        }\n\n        final int firstNodeIndent;\n        if (startIndent == -1) {\n            firstNodeIndent = getLineStart(firstLineNode);\n        }\n        else {\n            firstNodeIndent = startIndent;\n        }\n        final int currentIndent = firstNodeIndent + indentLevel;\n\n        for (DetailAST node : firstNodesOnLines.values()) {\n            final int currentType = node.getType();\n            if (checkForNullParameterChild(node) || checkForMethodLparenNewLine(node)) {\n                continue;\n            }\n            if (currentType == TokenTypes.RPAREN) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else if (!TokenUtil.isOfType(currentType, IGNORED_LIST)) {\n                logWarningMessage(node, currentIndent);\n            }\n        }\n    }\n\n    /**\n     * Checks for annotation indentation.\n     *\n     * @param firstNodesOnLines the nodes which are present in the beginning of each line.\n     * @param indentLevel line wrapping indentation.\n     */\n    public void checkForAnnotationIndentation(\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {\n        final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n        DetailAST node = firstLineNode.getParent();\n        while (node != null) {\n            if (node.getType() == TokenTypes.ANNOTATION) {\n                final DetailAST atNode = node.getFirstChild();\n                final NavigableMap<Integer, DetailAST> annotationLines =\n                        firstNodesOnLines.subMap(\n                                node.getLineNo(),\n                                true,\n                                getNextNodeLine(firstNodesOnLines, node),\n                                true\n                        );\n                checkAnnotationIndentation(atNode, annotationLines, indentLevel);\n            }\n            node = node.getNextSibling();\n        }\n    }\n\n    /**\n     * Checks whether parameter node has any child or not.\n     *\n     * @param node the node for which to check.\n     * @return true if  parameter has no child.\n     */\n    public static boolean checkForNullParameterChild(DetailAST node) {\n        return node.getFirstChild() == null && node.getType() == TokenTypes.PARAMETERS;\n    }\n\n    /**\n     * Checks whether the method lparen starts from a new line or not.\n     *\n     * @param node the node for which to check.\n     * @return true if method lparen starts from a new line.\n     */\n    public static boolean checkForMethodLparenNewLine(DetailAST node) {\n        final int parentType = node.getParent().getType();\n        return parentType == TokenTypes.METHOD_DEF && node.getType() == TokenTypes.LPAREN;\n    }\n\n    /**\n     * Gets the next node line from the firstNodesOnLines map unless there is no next line, in\n     * which case, it returns the last line.\n     *\n     * @param firstNodesOnLines NavigableMap of lines and their first nodes.\n     * @param node the node for which to find the next node line\n     * @return the line number of the next line in the map\n     */\n    private static Integer getNextNodeLine(\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, DetailAST node) {\n        Integer nextNodeLine = firstNodesOnLines.higherKey(node.getLastChild().getLineNo());\n        if (nextNodeLine == null) {\n            nextNodeLine = firstNodesOnLines.lastKey();\n        }\n        return nextNodeLine;\n    }\n\n    /**\n     * Finds first nodes on line and puts them into Map.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @return NavigableMap which contains lines numbers as a key and first\n     *         nodes on lines as a values.\n     */\n    private NavigableMap<Integer, DetailAST> collectFirstNodes(DetailAST firstNode,\n            DetailAST lastNode) {\n        final NavigableMap<Integer, DetailAST> result = new TreeMap<>();\n\n        result.put(firstNode.getLineNo(), firstNode);\n        DetailAST curNode = firstNode.getFirstChild();\n\n        while (curNode != lastNode) {\n            if (curNode.getType() == TokenTypes.OBJBLOCK\n                    || curNode.getType() == TokenTypes.SLIST) {\n                curNode = curNode.getLastChild();\n            }\n\n            final DetailAST firstTokenOnLine = result.get(curNode.getLineNo());\n\n            if (firstTokenOnLine == null\n                || expandedTabsColumnNo(firstTokenOnLine) >= expandedTabsColumnNo(curNode)) {\n                result.put(curNode.getLineNo(), curNode);\n            }\n            curNode = getNextCurNode(curNode);\n        }\n        return result;\n    }\n\n    /**\n     * Returns next curNode node.\n     *\n     * @param curNode current node.\n     * @return next curNode node.\n     */\n    private static DetailAST getNextCurNode(DetailAST curNode) {\n        DetailAST nodeToVisit = curNode.getFirstChild();\n        DetailAST currentNode = curNode;\n\n        while (nodeToVisit == null) {\n            nodeToVisit = currentNode.getNextSibling();\n            if (nodeToVisit == null) {\n                currentNode = currentNode.getParent();\n            }\n        }\n        return nodeToVisit;\n    }\n\n    /**\n     * Checks line wrapping into annotations.\n     *\n     * @param atNode block tag node.\n     * @param firstNodesOnLines map which contains\n     *     first nodes as values and line numbers as keys.\n     * @param indentLevel line wrapping indentation.\n     */\n    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {\n        final int firstNodeIndent = getLineStart(atNode);\n        final int currentIndent = firstNodeIndent + indentLevel;\n        final Collection<DetailAST> values = firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode = atNode.getParent().getLastChild();\n        final int lastAnnotationLine = lastAnnotationNode.getLineNo();\n\n        final Iterator<DetailAST> itr = values.iterator();\n        while (firstNodesOnLines.size() > 1) {\n            final DetailAST node = itr.next();\n\n            final DetailAST parentNode = node.getParent();\n            final boolean isArrayInitPresentInAncestors =\n                isParentContainsTokenType(node, TokenTypes.ANNOTATION_ARRAY_INIT);\n            final boolean isCurrentNodeCloseAnnotationAloneInLine =\n                node.getLineNo() == lastAnnotationLine\n                    && isEndOfScope(lastAnnotationNode, node);\n            if (!isArrayInitPresentInAncestors\n                    && (isCurrentNodeCloseAnnotationAloneInLine\n                    || node.getType() == TokenTypes.AT\n                    && (parentNode.getParent().getType() == TokenTypes.MODIFIERS\n                        || parentNode.getParent().getType() == TokenTypes.ANNOTATIONS)\n                    || TokenUtil.areOnSameLine(node, atNode))) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else if (!isArrayInitPresentInAncestors) {\n                logWarningMessage(node, currentIndent);\n            }\n            itr.remove();\n        }\n    }\n\n    /**\n     * Checks line for end of scope.  Handles occurrences of close braces and close parenthesis on\n     * the same line.\n     *\n     * @param lastAnnotationNode the last node of the annotation\n     * @param node the node indicating where to begin checking\n     * @return true if all the nodes up to the last annotation node are end of scope nodes\n     *         false otherwise\n     */\n    private static boolean isEndOfScope(final DetailAST lastAnnotationNode, final DetailAST node) {\n        DetailAST checkNode = node;\n        boolean endOfScope = true;\n        while (endOfScope && !checkNode.equals(lastAnnotationNode)) {\n            switch (checkNode.getType()) {\n                case TokenTypes.RCURLY:\n                case TokenTypes.RBRACK:\n                    while (checkNode.getNextSibling() == null) {\n                        checkNode = checkNode.getParent();\n                    }\n                    checkNode = checkNode.getNextSibling();\n                    break;\n                default:\n                    endOfScope = false;\n            }\n        }\n        return endOfScope;\n    }\n\n    /**\n     * Checks that some parent of given node contains given token type.\n     *\n     * @param node node to check\n     * @param type type to look for\n     * @return true if there is a parent of given type\n     */\n    private static boolean isParentContainsTokenType(final DetailAST node, int type) {\n        boolean returnValue = false;\n        for (DetailAST ast = node.getParent(); ast != null; ast = ast.getParent()) {\n            if (ast.getType() == type) {\n                returnValue = true;\n                break;\n            }\n        }\n        return returnValue;\n    }\n\n    /**\n     * Get the column number for the start of a given expression, expanding\n     * tabs out into spaces in the process.\n     *\n     * @param ast   the expression to find the start of\n     *\n     * @return the column number for the start of the expression\n     */\n    private int expandedTabsColumnNo(DetailAST ast) {\n        final String line =\n            indentCheck.getLine(ast.getLineNo() - 1);\n\n        return CommonUtil.lengthExpandedTabs(line, ast.getColumnNo(),\n            indentCheck.getIndentationTabWidth());\n    }\n\n    /**\n     * Get the start of the line for the given expression.\n     *\n     * @param ast   the expression to find the start of the line for\n     *\n     * @return the start of the line for the given expression\n     */\n    private int getLineStart(DetailAST ast) {\n        final String line = indentCheck.getLine(ast.getLineNo() - 1);\n        return getLineStart(line);\n    }\n\n    /**\n     * Get the start of the specified line.\n     *\n     * @param line the specified line number\n     * @return the start of the specified line\n     */\n    private int getLineStart(String line) {\n        int index = 0;\n        while (Character.isWhitespace(line.charAt(index))) {\n            index++;\n        }\n        return CommonUtil.lengthExpandedTabs(line, index, indentCheck.getIndentationTabWidth());\n    }\n\n    /**\n     * Logs warning message if indentation is incorrect.\n     *\n     * @param currentNode\n     *            current node which probably invoked a violation.\n     * @param currentIndent\n     *            correct indentation.\n     */\n    private void logWarningMessage(DetailAST currentNode, int currentIndent) {\n        if (indentCheck.isForceStrictCondition()) {\n            if (expandedTabsColumnNo(currentNode) != currentIndent) {\n                indentCheck.indentationLog(currentNode,\n                        IndentationCheck.MSG_ERROR, currentNode.getText(),\n                        expandedTabsColumnNo(currentNode), currentIndent);\n            }\n        }\n        else {\n            if (expandedTabsColumnNo(currentNode) < currentIndent) {\n                indentCheck.indentationLog(currentNode,\n                        IndentationCheck.MSG_ERROR, currentNode.getText(),\n                        expandedTabsColumnNo(currentNode), currentIndent);\n            }\n        }\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Checks for annotation indentation.\n     *\n     * @param firstNodesOnLines the nodes which are present in the beginning of each line.\n     * @param indentLevel line wrapping indentation.\n     */\n    public void checkForAnnotationIndentation(\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {\n        final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n        DetailAST node = firstLineNode.getParent();\n        while (node != null) {\n            if (node.getType() == TokenTypes.ANNOTATION) {\n                final DetailAST atNode = node.getFirstChild();\n                final NavigableMap<Integer, DetailAST> annotationLines =\n                        firstNodesOnLines.subMap(\n                                node.getLineNo(),\n                                true,\n                                getNextNodeLine(firstNodesOnLines, node),\n                                true\n                        );\n                checkAnnotationIndentation(atNode, annotationLines, indentLevel);\n            }\n            node = node.getNextSibling();\n        }\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.IndentationCheckTest#getLineStart\n methodBody: private static int getLineStart(String line, final int tabWidth) {\nint lineStart=0;\nfor(int index=0; index < line.length(); ++index){if(!Character.isWhitespace(line.charAt(index))){lineStart=CommonUtil.lengthExpandedTabs(line,index,tabWidth);\nbreak;\n}}return lineStart;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#getLineStart\n methodBody: private int getLineStart(String line) {\nint index=0;\nwhile(Character.isWhitespace(line.charAt(index))){index++;\n}return CommonUtil.lengthExpandedTabs(line,index,indentCheck.getIndentationTabWidth());\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#logWarningMessage\n methodBody: private void logWarningMessage(DetailAST currentNode, int currentIndent) {\nif(indentCheck.isForceStrictCondition()){if(expandedTabsColumnNo(currentNode) != currentIndent){indentCheck.indentationLog(currentNode,IndentationCheck.MSG_ERROR,currentNode.getText(),expandedTabsColumnNo(currentNode),currentIndent);\n}}{if(expandedTabsColumnNo(currentNode) < currentIndent){indentCheck.indentationLog(currentNode,IndentationCheck.MSG_ERROR,currentNode.getText(),expandedTabsColumnNo(currentNode),currentIndent);\n}}}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#getNextNodeLine\n methodBody: private static Integer getNextNodeLine(\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, DetailAST node) {\nInteger nextNodeLine=firstNodesOnLines.higherKey(node.getLastChild().getLineNo());\nif(nextNodeLine == null){nextNodeLine=firstNodesOnLines.lastKey();\n}return nextNodeLine;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#collectFirstNodes\n methodBody: private NavigableMap<Integer, DetailAST> collectFirstNodes(DetailAST firstNode,\n            DetailAST lastNode) {\nfinal NavigableMap<Integer,DetailAST> result=new TreeMap<>();\nresult.put(firstNode.getLineNo(),firstNode);\nDetailAST curNode=firstNode.getFirstChild();\nwhile(curNode != lastNode){if(curNode.getType() == TokenTypes.OBJBLOCK || curNode.getType() == TokenTypes.SLIST){curNode=curNode.getLastChild();\n}final DetailAST firstTokenOnLine=result.get(curNode.getLineNo());\nif(firstTokenOnLine == null || expandedTabsColumnNo(firstTokenOnLine) >= expandedTabsColumnNo(curNode)){result.put(curNode.getLineNo(),curNode);\n}curNode=getNextCurNode(curNode);\n}return result;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.indentation.LineWrappingHandler#checkAnnotationIndentation\n methodBody: private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {\nfinal int firstNodeIndent=getLineStart(atNode);\nfinal int currentIndent=firstNodeIndent + indentLevel;\nfinal Collection<DetailAST> values=firstNodesOnLines.values();\nfinal DetailAST lastAnnotationNode=atNode.getParent().getLastChild();\nfinal int lastAnnotationLine=lastAnnotationNode.getLineNo();\nfinal Iterator<DetailAST> itr=values.iterator();\nwhile(firstNodesOnLines.size() > 1){final DetailAST node=itr.next();\nfinal DetailAST parentNode=node.getParent();\nfinal boolean isArrayInitPresentInAncestors=isParentContainsTokenType(node,TokenTypes.ANNOTATION_ARRAY_INIT);\nfinal boolean isCurrentNodeCloseAnnotationAloneInLine=node.getLineNo() == lastAnnotationLine && isEndOfScope(lastAnnotationNode,node);\nif(!isArrayInitPresentInAncestors && (isCurrentNodeCloseAnnotationAloneInLine || node.getType() == TokenTypes.AT && (parentNode.getParent().getType() == TokenTypes.MODIFIERS || parentNode.getParent().getType() == TokenTypes.ANNOTATIONS) || TokenUtil.areOnSameLine(node,atNode))){logWarningMessage(node,firstNodeIndent);\n}if(!isArrayInitPresentInAncestors){logWarningMessage(node,currentIndent);\n}itr.remove();\n}}"], "sourceCodeAfterRefactoring": "/**\n     * Checks line wrapping into expressions and definitions.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @param indentLevel Indentation all wrapped lines should use.\n     * @param startIndent Indentation first line before wrapped lines used.\n     * @param ignoreFirstLine Test if first line's indentation should be checked or not.\n     */\n    public void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel,\n            int startIndent, LineWrappingOptions ignoreFirstLine) {\n        final NavigableMap<Integer, DetailAST> firstNodesOnLines = collectFirstNodes(firstNode,\n                lastNode);\n\n        final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n        if (firstLineNode.getType() == TokenTypes.AT) {\n            checkForAnnotationIndentation(firstNodesOnLines, indentLevel);\n        }\n\n        if (ignoreFirstLine == LineWrappingOptions.IGNORE_FIRST_LINE) {\n            // First node should be removed because it was already checked before.\n            firstNodesOnLines.remove(firstNodesOnLines.firstKey());\n        }\n\n        final int firstNodeIndent;\n        if (startIndent == -1) {\n            firstNodeIndent = getLineStart(firstLineNode);\n        }\n        else {\n            firstNodeIndent = startIndent;\n        }\n        final int currentIndent = firstNodeIndent + indentLevel;\n\n        for (DetailAST node : firstNodesOnLines.values()) {\n            final int currentType = node.getType();\n            if (checkForNullParameterChild(node) || checkForMethodLparenNewLine(node)) {\n                continue;\n            }\n            if (currentType == TokenTypes.RPAREN) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else if (!TokenUtil.isOfType(currentType, IGNORED_LIST)) {\n                logWarningMessage(node, currentIndent);\n            }\n        }\n    }\n/**\n     * Checks for annotation indentation.\n     *\n     * @param firstNodesOnLines the nodes which are present in the beginning of each line.\n     * @param indentLevel line wrapping indentation.\n     */\n    public void checkForAnnotationIndentation(\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {\n        final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n        DetailAST node = firstLineNode.getParent();\n        while (node != null) {\n            if (node.getType() == TokenTypes.ANNOTATION) {\n                final DetailAST atNode = node.getFirstChild();\n                final NavigableMap<Integer, DetailAST> annotationLines =\n                        firstNodesOnLines.subMap(\n                                node.getLineNo(),\n                                true,\n                                getNextNodeLine(firstNodesOnLines, node),\n                                true\n                        );\n                checkAnnotationIndentation(atNode, annotationLines, indentLevel);\n            }\n            node = node.getNextSibling();\n        }\n    }", "diffSourceCode": "   127:     /**\n   128:      * Checks line wrapping into expressions and definitions.\n   129:      *\n   130:      * @param firstNode First node to start examining.\n   131:      * @param lastNode Last node to examine inclusively.\n   132:      * @param indentLevel Indentation all wrapped lines should use.\n   133:      * @param startIndent Indentation first line before wrapped lines used.\n   134:      * @param ignoreFirstLine Test if first line's indentation should be checked or not.\n   135:      */\n   136:     public void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel,\n   137:             int startIndent, LineWrappingOptions ignoreFirstLine) {\n   138:         final NavigableMap<Integer, DetailAST> firstNodesOnLines = collectFirstNodes(firstNode,\n   139:                 lastNode);\n   140: \n   141:         final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n   142:         if (firstLineNode.getType() == TokenTypes.AT) {\n-  143:             DetailAST node = firstLineNode.getParent();\n-  144:             while (node != null) {\n-  145:                 if (node.getType() == TokenTypes.ANNOTATION) {\n-  146:                     final DetailAST atNode = node.getFirstChild();\n-  147:                     final NavigableMap<Integer, DetailAST> annotationLines =\n-  148:                         firstNodesOnLines.subMap(\n-  149:                             node.getLineNo(),\n-  150:                             true,\n-  151:                             getNextNodeLine(firstNodesOnLines, node),\n-  152:                             true\n-  153:                         );\n-  154:                     checkAnnotationIndentation(atNode, annotationLines, indentLevel);\n-  155:                 }\n-  156:                 node = node.getNextSibling();\n-  157:             }\n-  158:         }\n+  143:             checkForAnnotationIndentation(firstNodesOnLines, indentLevel);\n+  144:         }\n+  145: \n+  146:         if (ignoreFirstLine == LineWrappingOptions.IGNORE_FIRST_LINE) {\n+  147:             // First node should be removed because it was already checked before.\n+  148:             firstNodesOnLines.remove(firstNodesOnLines.firstKey());\n+  149:         }\n+  150: \n+  151:         final int firstNodeIndent;\n+  152:         if (startIndent == -1) {\n+  153:             firstNodeIndent = getLineStart(firstLineNode);\n+  154:         }\n+  155:         else {\n+  156:             firstNodeIndent = startIndent;\n+  157:         }\n+  158:         final int currentIndent = firstNodeIndent + indentLevel;\n   159: \n-  160:         if (ignoreFirstLine == LineWrappingOptions.IGNORE_FIRST_LINE) {\n-  161:             // First node should be removed because it was already checked before.\n-  162:             firstNodesOnLines.remove(firstNodesOnLines.firstKey());\n-  163:         }\n-  164: \n-  165:         final int firstNodeIndent;\n-  166:         if (startIndent == -1) {\n-  167:             firstNodeIndent = getLineStart(firstLineNode);\n-  168:         }\n-  169:         else {\n-  170:             firstNodeIndent = startIndent;\n+  160:         for (DetailAST node : firstNodesOnLines.values()) {\n+  161:             final int currentType = node.getType();\n+  162:             if (checkForNullParameterChild(node) || checkForMethodLparenNewLine(node)) {\n+  163:                 continue;\n+  164:             }\n+  165:             if (currentType == TokenTypes.RPAREN) {\n+  166:                 logWarningMessage(node, firstNodeIndent);\n+  167:             }\n+  168:             else if (!TokenUtil.isOfType(currentType, IGNORED_LIST)) {\n+  169:                 logWarningMessage(node, currentIndent);\n+  170:             }\n   171:         }\n-  172:         final int currentIndent = firstNodeIndent + indentLevel;\n+  172:     }\n   173: \n-  174:         for (DetailAST node : firstNodesOnLines.values()) {\n-  175:             final int currentType = node.getType();\n-  176: \n-  177:             if (currentType == TokenTypes.RPAREN) {\n-  178:                 logWarningMessage(node, firstNodeIndent);\n-  179:             }\n-  180:             else if (!TokenUtil.isOfType(currentType, IGNORED_LIST)) {\n-  181:                 logWarningMessage(node, currentIndent);\n-  182:             }\n-  183:         }\n-  184:     }\n-  185: \n-  186:     /**\n-  187:      * Gets the next node line from the firstNodesOnLines map unless there is no next line, in\n-  188:      * which case, it returns the last line.\n-  189:      *\n-  190:      * @param firstNodesOnLines NavigableMap of lines and their first nodes.\n-  191:      * @param node the node for which to find the next node line\n-  192:      * @return the line number of the next line in the map\n-  193:      */\n-  194:     private static Integer getNextNodeLine(\n-  195:             NavigableMap<Integer, DetailAST> firstNodesOnLines, DetailAST node) {\n-  196:         Integer nextNodeLine = firstNodesOnLines.higherKey(node.getLastChild().getLineNo());\n-  197:         if (nextNodeLine == null) {\n-  198:             nextNodeLine = firstNodesOnLines.lastKey();\n+  174:     /**\n+  175:      * Checks for annotation indentation.\n+  176:      *\n+  177:      * @param firstNodesOnLines the nodes which are present in the beginning of each line.\n+  178:      * @param indentLevel line wrapping indentation.\n+  179:      */\n+  180:     public void checkForAnnotationIndentation(\n+  181:             NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {\n+  182:         final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n+  183:         DetailAST node = firstLineNode.getParent();\n+  184:         while (node != null) {\n+  185:             if (node.getType() == TokenTypes.ANNOTATION) {\n+  186:                 final DetailAST atNode = node.getFirstChild();\n+  187:                 final NavigableMap<Integer, DetailAST> annotationLines =\n+  188:                         firstNodesOnLines.subMap(\n+  189:                                 node.getLineNo(),\n+  190:                                 true,\n+  191:                                 getNextNodeLine(firstNodesOnLines, node),\n+  192:                                 true\n+  193:                         );\n+  194:                 checkAnnotationIndentation(atNode, annotationLines, indentLevel);\n+  195:             }\n+  196:             node = node.getNextSibling();\n+  197:         }\n+  198:     }\n", "uniqueId": "29e5e1210c6a292327a5a55b31b34180cd91f393_127_184_174_198_127_172", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 101}, "BRANCH": {"missed": 0, "covered": 16}, "LINE": {"missed": 0, "covered": 27}, "COMPLEXITY": {"missed": 0, "covered": 9}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nRefactored Method Code:\n\n    /**\n     * Checks line wrapping into expressions and definitions.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @param indentLevel Indentation all wrapped lines should use.\n     */\n    private void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel) {\n        checkIndentation(firstNode, lastNode, indentLevel,\n                -1, LineWrappingOptions.IGNORE_FIRST_LINE);\n    }\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Checks line wrapping into expressions and definitions.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @param indentLevel Indentation all wrapped lines should use.\n     * @param startIndent Indentation first line before wrapped lines used.\n     * @param ignoreFirstLine Test if first line's indentation should be checked or not.\n     */\n    public void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel,\n            int startIndent, LineWrappingOptions ignoreFirstLine) {\n        final NavigableMap<Integer, DetailAST> firstNodesOnLines = collectFirstNodes(firstNode,\n                lastNode);\n\n        final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n        if (firstLineNode.getType() == TokenTypes.AT) {\n            DetailAST node = firstLineNode.getParent();\n            while (node != null) {\n                if (node.getType() == TokenTypes.ANNOTATION) {\n                    final DetailAST atNode = node.getFirstChild();\n                    final NavigableMap<Integer, DetailAST> annotationLines =\n                        firstNodesOnLines.subMap(\n                            node.getLineNo(),\n                            true,\n                            getNextNodeLine(firstNodesOnLines, node),\n                            true\n                        );\n                    checkAnnotationIndentation(atNode, annotationLines, indentLevel);\n                }\n                node = node.getNextSibling();\n            }\n        }\n\n        if (ignoreFirstLine == LineWrappingOptions.IGNORE_FIRST_LINE) {\n            // First node should be removed because it was already checked before.\n            firstNodesOnLines.remove(firstNodesOnLines.firstKey());\n        }\n\n        final int firstNodeIndent;\n        if (startIndent == -1) {\n            firstNodeIndent = getLineStart(firstLineNode);\n        }\n        else {\n            firstNodeIndent = startIndent;\n        }\n        final int currentIndent = firstNodeIndent + indentLevel;\n\n        for (DetailAST node : firstNodesOnLines.values()) {\n            final int currentType = node.getType();\n\n            if (currentType == TokenTypes.RPAREN) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else if (!TokenUtil.isOfType(currentType, IGNORED_LIST)) {\n                logWarningMessage(node, currentIndent);\n            }\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.indentation;\n\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.NavigableMap;\nimport java.util.TreeMap;\n\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * This class checks line-wrapping into definitions and expressions. The\n * line-wrapping indentation should be not less than value of the\n * lineWrappingIndentation parameter.\n *\n */\npublic class LineWrappingHandler {\n\n    /**\n     * Enum to be used for test if first line's indentation should be checked or not.\n     */\n    public enum LineWrappingOptions {\n\n        /**\n         * First line's indentation should NOT be checked.\n         */\n        IGNORE_FIRST_LINE,\n        /**\n         * First line's indentation should be checked.\n         */\n        NONE;\n\n        /**\n         * Builds enum value from boolean.\n         *\n         * @param val value.\n         * @return enum instance.\n         *\n         * @noinspection BooleanParameter\n         */\n        public static LineWrappingOptions ofBoolean(boolean val) {\n            LineWrappingOptions option = NONE;\n            if (val) {\n                option = IGNORE_FIRST_LINE;\n            }\n            return option;\n        }\n\n    }\n\n    /**\n     * The list of ignored token types for being checked by lineWrapping indentation\n     * inside {@code checkIndentation()} as these tokens are checked for lineWrapping\n     * inside their dedicated handlers.\n     *\n     * @see NewHandler#getIndentImpl()\n     * @see BlockParentHandler#curlyIndent()\n     * @see ArrayInitHandler#getIndentImpl()\n     */\n    private static final int[] IGNORED_LIST = {\n        TokenTypes.RCURLY,\n        TokenTypes.LITERAL_NEW,\n        TokenTypes.ARRAY_INIT,\n    };\n\n    /**\n     * The current instance of {@code IndentationCheck} class using this\n     * handler. This field used to get access to private fields of\n     * IndentationCheck instance.\n     */\n    private final IndentationCheck indentCheck;\n\n    /**\n     * Sets values of class field, finds last node and calculates indentation level.\n     *\n     * @param instance\n     *            instance of IndentationCheck.\n     */\n    public LineWrappingHandler(IndentationCheck instance) {\n        indentCheck = instance;\n    }\n\n    /**\n     * Checks line wrapping into expressions and definitions using property\n     * 'lineWrappingIndentation'.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     */\n    public void checkIndentation(DetailAST firstNode, DetailAST lastNode) {\n        checkIndentation(firstNode, lastNode, indentCheck.getLineWrappingIndentation());\n    }\n\n    /**\n     * Checks line wrapping into expressions and definitions.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @param indentLevel Indentation all wrapped lines should use.\n     */\n    private void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel) {\n        checkIndentation(firstNode, lastNode, indentLevel,\n                -1, LineWrappingOptions.IGNORE_FIRST_LINE);\n    }\n\n    /**\n     * Checks line wrapping into expressions and definitions.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @param indentLevel Indentation all wrapped lines should use.\n     * @param startIndent Indentation first line before wrapped lines used.\n     * @param ignoreFirstLine Test if first line's indentation should be checked or not.\n     */\n    public void checkIndentation(DetailAST firstNode, DetailAST lastNode, int indentLevel,\n            int startIndent, LineWrappingOptions ignoreFirstLine) {\n        final NavigableMap<Integer, DetailAST> firstNodesOnLines = collectFirstNodes(firstNode,\n                lastNode);\n\n        final DetailAST firstLineNode = firstNodesOnLines.get(firstNodesOnLines.firstKey());\n        if (firstLineNode.getType() == TokenTypes.AT) {\n            DetailAST node = firstLineNode.getParent();\n            while (node != null) {\n                if (node.getType() == TokenTypes.ANNOTATION) {\n                    final DetailAST atNode = node.getFirstChild();\n                    final NavigableMap<Integer, DetailAST> annotationLines =\n                        firstNodesOnLines.subMap(\n                            node.getLineNo(),\n                            true,\n                            getNextNodeLine(firstNodesOnLines, node),\n                            true\n                        );\n                    checkAnnotationIndentation(atNode, annotationLines, indentLevel);\n                }\n                node = node.getNextSibling();\n            }\n        }\n\n        if (ignoreFirstLine == LineWrappingOptions.IGNORE_FIRST_LINE) {\n            // First node should be removed because it was already checked before.\n            firstNodesOnLines.remove(firstNodesOnLines.firstKey());\n        }\n\n        final int firstNodeIndent;\n        if (startIndent == -1) {\n            firstNodeIndent = getLineStart(firstLineNode);\n        }\n        else {\n            firstNodeIndent = startIndent;\n        }\n        final int currentIndent = firstNodeIndent + indentLevel;\n\n        for (DetailAST node : firstNodesOnLines.values()) {\n            final int currentType = node.getType();\n\n            if (currentType == TokenTypes.RPAREN) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else if (!TokenUtil.isOfType(currentType, IGNORED_LIST)) {\n                logWarningMessage(node, currentIndent);\n            }\n        }\n    }\n\n    /**\n     * Gets the next node line from the firstNodesOnLines map unless there is no next line, in\n     * which case, it returns the last line.\n     *\n     * @param firstNodesOnLines NavigableMap of lines and their first nodes.\n     * @param node the node for which to find the next node line\n     * @return the line number of the next line in the map\n     */\n    private static Integer getNextNodeLine(\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, DetailAST node) {\n        Integer nextNodeLine = firstNodesOnLines.higherKey(node.getLastChild().getLineNo());\n        if (nextNodeLine == null) {\n            nextNodeLine = firstNodesOnLines.lastKey();\n        }\n        return nextNodeLine;\n    }\n\n    /**\n     * Finds first nodes on line and puts them into Map.\n     *\n     * @param firstNode First node to start examining.\n     * @param lastNode Last node to examine inclusively.\n     * @return NavigableMap which contains lines numbers as a key and first\n     *         nodes on lines as a values.\n     */\n    private NavigableMap<Integer, DetailAST> collectFirstNodes(DetailAST firstNode,\n            DetailAST lastNode) {\n        final NavigableMap<Integer, DetailAST> result = new TreeMap<>();\n\n        result.put(firstNode.getLineNo(), firstNode);\n        DetailAST curNode = firstNode.getFirstChild();\n\n        while (curNode != lastNode) {\n            if (curNode.getType() == TokenTypes.OBJBLOCK\n                    || curNode.getType() == TokenTypes.SLIST) {\n                curNode = curNode.getLastChild();\n            }\n\n            final DetailAST firstTokenOnLine = result.get(curNode.getLineNo());\n\n            if (firstTokenOnLine == null\n                || expandedTabsColumnNo(firstTokenOnLine) >= expandedTabsColumnNo(curNode)) {\n                result.put(curNode.getLineNo(), curNode);\n            }\n            curNode = getNextCurNode(curNode);\n        }\n        return result;\n    }\n\n    /**\n     * Returns next curNode node.\n     *\n     * @param curNode current node.\n     * @return next curNode node.\n     */\n    private static DetailAST getNextCurNode(DetailAST curNode) {\n        DetailAST nodeToVisit = curNode.getFirstChild();\n        DetailAST currentNode = curNode;\n\n        while (nodeToVisit == null) {\n            nodeToVisit = currentNode.getNextSibling();\n            if (nodeToVisit == null) {\n                currentNode = currentNode.getParent();\n            }\n        }\n        return nodeToVisit;\n    }\n\n    /**\n     * Checks line wrapping into annotations.\n     *\n     * @param atNode block tag node.\n     * @param firstNodesOnLines map which contains\n     *     first nodes as values and line numbers as keys.\n     * @param indentLevel line wrapping indentation.\n     */\n    private void checkAnnotationIndentation(DetailAST atNode,\n            NavigableMap<Integer, DetailAST> firstNodesOnLines, int indentLevel) {\n        final int firstNodeIndent = getLineStart(atNode);\n        final int currentIndent = firstNodeIndent + indentLevel;\n        final Collection<DetailAST> values = firstNodesOnLines.values();\n        final DetailAST lastAnnotationNode = atNode.getParent().getLastChild();\n        final int lastAnnotationLine = lastAnnotationNode.getLineNo();\n\n        final Iterator<DetailAST> itr = values.iterator();\n        while (firstNodesOnLines.size() > 1) {\n            final DetailAST node = itr.next();\n\n            final DetailAST parentNode = node.getParent();\n            final boolean isArrayInitPresentInAncestors =\n                isParentContainsTokenType(node, TokenTypes.ANNOTATION_ARRAY_INIT);\n            final boolean isCurrentNodeCloseAnnotationAloneInLine =\n                node.getLineNo() == lastAnnotationLine\n                    && isEndOfScope(lastAnnotationNode, node);\n            if (!isArrayInitPresentInAncestors\n                    && (isCurrentNodeCloseAnnotationAloneInLine\n                    || node.getType() == TokenTypes.AT\n                    && (parentNode.getParent().getType() == TokenTypes.MODIFIERS\n                        || parentNode.getParent().getType() == TokenTypes.ANNOTATIONS)\n                    || TokenUtil.areOnSameLine(node, atNode))) {\n                logWarningMessage(node, firstNodeIndent);\n            }\n            else if (!isArrayInitPresentInAncestors) {\n                logWarningMessage(node, currentIndent);\n            }\n            itr.remove();\n        }\n    }\n\n    /**\n     * Checks line for end of scope.  Handles occurrences of close braces and close parenthesis on\n     * the same line.\n     *\n     * @param lastAnnotationNode the last node of the annotation\n     * @param node the node indicating where to begin checking\n     * @return true if all the nodes up to the last annotation node are end of scope nodes\n     *         false otherwise\n     */\n    private static boolean isEndOfScope(final DetailAST lastAnnotationNode, final DetailAST node) {\n        DetailAST checkNode = node;\n        boolean endOfScope = true;\n        while (endOfScope && !checkNode.equals(lastAnnotationNode)) {\n            switch (checkNode.getType()) {\n                case TokenTypes.RCURLY:\n                case TokenTypes.RBRACK:\n                    while (checkNode.getNextSibling() == null) {\n                        checkNode = checkNode.getParent();\n                    }\n                    checkNode = checkNode.getNextSibling();\n                    break;\n                default:\n                    endOfScope = false;\n            }\n        }\n        return endOfScope;\n    }\n\n    /**\n     * Checks that some parent of given node contains given token type.\n     *\n     * @param node node to check\n     * @param type type to look for\n     * @return true if there is a parent of given type\n     */\n    private static boolean isParentContainsTokenType(final DetailAST node, int type) {\n        boolean returnValue = false;\n        for (DetailAST ast = node.getParent(); ast != null; ast = ast.getParent()) {\n            if (ast.getType() == type) {\n                returnValue = true;\n                break;\n            }\n        }\n        return returnValue;\n    }\n\n    /**\n     * Get the column number for the start of a given expression, expanding\n     * tabs out into spaces in the process.\n     *\n     * @param ast   the expression to find the start of\n     *\n     * @return the column number for the start of the expression\n     */\n    private int expandedTabsColumnNo(DetailAST ast) {\n        final String line =\n            indentCheck.getLine(ast.getLineNo() - 1);\n\n        return CommonUtil.lengthExpandedTabs(line, ast.getColumnNo(),\n            indentCheck.getIndentationTabWidth());\n    }\n\n    /**\n     * Get the start of the line for the given expression.\n     *\n     * @param ast   the expression to find the start of the line for\n     *\n     * @return the start of the line for the given expression\n     */\n    private int getLineStart(DetailAST ast) {\n        final String line = indentCheck.getLine(ast.getLineNo() - 1);\n        return getLineStart(line);\n    }\n\n    /**\n     * Get the start of the specified line.\n     *\n     * @param line the specified line number\n     * @return the start of the specified line\n     */\n    private int getLineStart(String line) {\n        int index = 0;\n        while (Character.isWhitespace(line.charAt(index))) {\n            index++;\n        }\n        return CommonUtil.lengthExpandedTabs(line, index, indentCheck.getIndentationTabWidth());\n    }\n\n    /**\n     * Logs warning message if indentation is incorrect.\n     *\n     * @param currentNode\n     *            current node which probably invoked a violation.\n     * @param currentIndent\n     *            correct indentation.\n     */\n    private void logWarningMessage(DetailAST currentNode, int currentIndent) {\n        if (indentCheck.isForceStrictCondition()) {\n            if (expandedTabsColumnNo(currentNode) != currentIndent) {\n                indentCheck.indentationLog(currentNode,\n                        IndentationCheck.MSG_ERROR, currentNode.getText(),\n                        expandedTabsColumnNo(currentNode), currentIndent);\n            }\n        }\n        else {\n            if (expandedTabsColumnNo(currentNode) < currentIndent) {\n                indentCheck.indentationLog(currentNode,\n                        IndentationCheck.MSG_ERROR, currentNode.getText(),\n                        expandedTabsColumnNo(currentNode), currentIndent);\n            }\n        }\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate addSuppressions(values List<String>, targetAST DetailAST) : void extracted from public visitToken(ast DetailAST) : void in class com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java", "startLine": 301, "endLine": 340, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java", "startLine": 302, "endLine": 315, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java", "startLine": 317, "endLine": 348, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public void visitToken(DetailAST ast) {\n        // check whether annotation is SuppressWarnings\n        // expected children: AT ( IDENT | DOT ) LPAREN <values> RPAREN\n        String identifier = getIdentifier(getNthChild(ast, 1));\n        if (identifier.startsWith(JAVA_LANG_PREFIX)) {\n            identifier = identifier.substring(JAVA_LANG_PREFIX.length());\n        }\n        if (\"SuppressWarnings\".equals(identifier)) {\n            final List<String> values = getAllAnnotationValues(ast);\n            if (!isAnnotationEmpty(values)) {\n                final DetailAST targetAST = getAnnotationTarget(ast);\n\n                // get text range of target\n                final int firstLine = targetAST.getLineNo();\n                final int firstColumn = targetAST.getColumnNo();\n                final DetailAST nextAST = targetAST.getNextSibling();\n                final int lastLine;\n                final int lastColumn;\n                if (nextAST == null) {\n                    lastLine = Integer.MAX_VALUE;\n                    lastColumn = Integer.MAX_VALUE;\n                }\n                else {\n                    lastLine = nextAST.getLineNo();\n                    lastColumn = nextAST.getColumnNo() - 1;\n                }\n\n                // add suppression entries for listed checks\n                final List<Entry> entries = ENTRIES.get();\n                for (String value : values) {\n                    String checkName = value;\n                    // strip off the checkstyle-only prefix if present\n                    checkName = removeCheckstylePrefixIfExists(checkName);\n                    entries.add(new Entry(checkName, firstLine, firstColumn,\n                            lastLine, lastColumn));\n                }\n            }\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java", "isPureRefactoring": true, "commitId": "77721c4ac3fc9252bfe9840dcb6fae93e0965562", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#visitToken", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#getIdentifier\n methodBody: private static String getIdentifier(DetailAST ast) {\nif(ast == null){throw new IllegalArgumentException(\"Identifier AST expected, but get null.\");\n}final String identifier;\nif(ast.getType() == TokenTypes.IDENT){identifier=ast.getText();\n}{identifier=getIdentifier(ast.getFirstChild()) + \".\" + getIdentifier(ast.getLastChild());\n}return identifier;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#getNthChild\n methodBody: private static DetailAST getNthChild(DetailAST ast, int index) {\nDetailAST child=ast.getFirstChild();\nfor(int i=0; i < index && child != null; ++i){child=child.getNextSibling();\n}return child;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#isAnnotationEmpty\n methodBody: private static boolean isAnnotationEmpty(List<String> values) {\nreturn values == null;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#removeCheckstylePrefixIfExists\n methodBody: private static String removeCheckstylePrefixIfExists(String checkName) {\nString result=checkName;\nif(checkName.startsWith(CHECKSTYLE_PREFIX)){result=checkName.substring(CHECKSTYLE_PREFIX.length());\n}return result;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#getAllAnnotationValues\n methodBody: private static List<String> getAllAnnotationValues(DetailAST ast) {\nList<String> values=null;\nfinal DetailAST lparenAST=ast.findFirstToken(TokenTypes.LPAREN);\nif(lparenAST != null){final DetailAST nextAST=lparenAST.getNextSibling();\nfinal int nextType=nextAST.getType();\nswitch(nextType)case TokenTypes.EXPR:case TokenTypes.ANNOTATION_ARRAY_INIT:values=getAnnotationValues(nextAST);\nbreak;\ncase TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:values=getAnnotationValues(getNthChild(nextAST,2));\nbreak;\ncase TokenTypes.RPAREN:break;\ndefault:throw new IllegalArgumentException(\"Unexpected AST: \" + nextAST);\n}return values;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#getAnnotationTarget\n methodBody: private static DetailAST getAnnotationTarget(DetailAST ast) {\nfinal DetailAST targetAST;\nfinal DetailAST parentAST=ast.getParent();\nswitch(parentAST.getType())case TokenTypes.MODIFIERS:case TokenTypes.ANNOTATIONS:case TokenTypes.ANNOTATION:case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:targetAST=parentAST.getParent();\nbreak;\ndefault:throw new IllegalArgumentException(\"Unexpected container AST: \" + parentAST);\nreturn targetAST;\n}", "classSignatureBefore": "public class SuppressWarningsHolder\n    extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#visitToken"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder"], "classSignatureBeforeSet": ["public class SuppressWarningsHolder\n    extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Inline Variable-", "description": "Inline Variable on top of the extracted method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AuditEvent;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\n\n/**\n * <p>\n * Maintains a set of check suppressions from {@code @SuppressWarnings} annotations.\n * It allows to prevent Checkstyle from reporting violations from parts of code that were\n * annotated with {@code @SuppressWarnings} and using name of the check to be excluded.\n * You can also define aliases for check names that need to be suppressed.\n * </p>\n * <ul>\n * <li>\n * Property {@code aliasList} - Specify aliases for check names that can be used in code\n * within {@code SuppressWarnings}.\n * Type is {@code java.lang.String[]}.\n * Default value is {@code null}.\n * </li>\n * </ul>\n * <p>\n * To prevent {@code FooCheck} violations from being reported write:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"foo\") interface I { }\n * &#64;SuppressWarnings(\"foo\") enum E { }\n * &#64;SuppressWarnings(\"foo\") InputSuppressWarningsFilter() { }\n * </pre>\n * <p>\n * Some real check examples:\n * </p>\n * <p>\n * This will prevent from invocation of the MemberNameCheck:\n * </p>\n * <pre>\n * &#64;SuppressWarnings({\"membername\"})\n * private int J;\n * </pre>\n * <p>\n * You can also use a {@code checkstyle} prefix to prevent compiler from\n * processing this annotations. For example this will prevent ConstantNameCheck:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"checkstyle:constantname\")\n * private static final int m = 0;\n * </pre>\n * <p>\n * The general rule is that the argument of the {@code @SuppressWarnings} will be\n * matched against class name of the checker in lower case and without {@code Check}\n * suffix if present.\n * </p>\n * <p>\n * If {@code aliasList} property was provided you can use your own names e.g below\n * code will work if there was provided a {@code ParameterNumberCheck=paramnum} in\n * the {@code aliasList}:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"paramnum\")\n * public void needsLotsOfParameters(@SuppressWarnings(\"unused\") int a,\n *   int b, int c, int d, int e, int f, int g, int h) {\n *   ...\n * }\n * </pre>\n * <p>\n * It is possible to suppress all the checkstyle warnings with the argument {@code \"all\"}:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"all\")\n * public void someFunctionWithInvalidStyle() {\n *   //...\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n *\n * @since 5.7\n */\n@StatelessCheck\npublic class SuppressWarningsHolder\n    extends AbstractCheck {\n\n    /**\n     * Optional prefix for warning suppressions that are only intended to be\n     * recognized by checkstyle. For instance, to suppress {@code\n     * FallThroughCheck} only in checkstyle (and not in javac), use the\n     * suppression {@code \"checkstyle:fallthrough\"} or {@code \"checkstyle:FallThrough\"}.\n     * To suppress the warning in both tools, just use {@code \"fallthrough\"}.\n     */\n    private static final String CHECKSTYLE_PREFIX = \"checkstyle:\";\n\n    /** Java.lang namespace prefix, which is stripped from SuppressWarnings */\n    private static final String JAVA_LANG_PREFIX = \"java.lang.\";\n\n    /** Suffix to be removed from subclasses of Check. */\n    private static final String CHECK_SUFFIX = \"Check\";\n\n    /** Special warning id for matching all the warnings. */\n    private static final String ALL_WARNING_MATCHING_ID = \"all\";\n\n    /** A map from check source names to suppression aliases. */\n    private static final Map<String, String> CHECK_ALIAS_MAP = new HashMap<>();\n\n    /**\n     * A thread-local holder for the list of suppression entries for the last\n     * file parsed.\n     */\n    private static final ThreadLocal<List<Entry>> ENTRIES =\n            ThreadLocal.withInitial(LinkedList::new);\n\n    /**\n     * Compiled pattern used to match whitespace in text block content.\n     */\n    private static final Pattern WHITESPACE = Pattern.compile(\"\\\\s+\");\n\n    /**\n     * Compiled pattern used to match preceding newline in text block content.\n     */\n    private static final Pattern NEWLINE = Pattern.compile(\"\\\\n\");\n\n    /**\n     * Returns the default alias for the source name of a check, which is the\n     * source name in lower case with any dotted prefix or \"Check\" suffix\n     * removed.\n     *\n     * @param sourceName the source name of the check (generally the class\n     *        name)\n     * @return the default alias for the given check\n     */\n    public static String getDefaultAlias(String sourceName) {\n        int endIndex = sourceName.length();\n        if (sourceName.endsWith(CHECK_SUFFIX)) {\n            endIndex -= CHECK_SUFFIX.length();\n        }\n        final int startIndex = sourceName.lastIndexOf('.') + 1;\n        return sourceName.substring(startIndex, endIndex).toLowerCase(Locale.ENGLISH);\n    }\n\n    /**\n     * Returns the alias for the source name of a check. If an alias has been\n     * explicitly registered via {@link #setAliasList(String...)}, that\n     * alias is returned; otherwise, the default alias is used.\n     *\n     * @param sourceName the source name of the check (generally the class\n     *        name)\n     * @return the current alias for the given check\n     */\n    public static String getAlias(String sourceName) {\n        String checkAlias = CHECK_ALIAS_MAP.get(sourceName);\n        if (checkAlias == null) {\n            checkAlias = getDefaultAlias(sourceName);\n        }\n        return checkAlias;\n    }\n\n    /**\n     * Registers an alias for the source name of a check.\n     *\n     * @param sourceName the source name of the check (generally the class\n     *        name)\n     * @param checkAlias the alias used in {@link SuppressWarnings} annotations\n     */\n    private static void registerAlias(String sourceName, String checkAlias) {\n        CHECK_ALIAS_MAP.put(sourceName, checkAlias);\n    }\n\n    /**\n     * Setter to specify aliases for check names that can be used in code\n     * within {@code SuppressWarnings}.\n     *\n     * @param aliasList the list of comma-separated alias assignments\n     * @throws IllegalArgumentException when alias item does not have '='\n     */\n    public void setAliasList(String... aliasList) {\n        for (String sourceAlias : aliasList) {\n            final int index = sourceAlias.indexOf('=');\n            if (index > 0) {\n                registerAlias(sourceAlias.substring(0, index), sourceAlias\n                    .substring(index + 1));\n            }\n            else if (!sourceAlias.isEmpty()) {\n                throw new IllegalArgumentException(\n                    \"'=' expected in alias list item: \" + sourceAlias);\n            }\n        }\n    }\n\n    /**\n     * Checks for a suppression of a check with the given source name and\n     * location in the last file processed.\n     *\n     * @param event audit event.\n     * @return whether the check with the given name is suppressed at the given\n     *         source location\n     */\n    public static boolean isSuppressed(AuditEvent event) {\n        final List<Entry> entries = ENTRIES.get();\n        final String sourceName = event.getSourceName();\n        final String checkAlias = getAlias(sourceName);\n        final int line = event.getLine();\n        final int column = event.getColumn();\n        boolean suppressed = false;\n        for (Entry entry : entries) {\n            final boolean afterStart = isSuppressedAfterEventStart(line, column, entry);\n            final boolean beforeEnd = isSuppressedBeforeEventEnd(line, column, entry);\n            final boolean nameMatches =\n                ALL_WARNING_MATCHING_ID.equals(entry.getCheckName())\n                    || entry.getCheckName().equalsIgnoreCase(checkAlias);\n            final boolean idMatches = event.getModuleId() != null\n                && event.getModuleId().equals(entry.getCheckName());\n            if (afterStart && beforeEnd && (nameMatches || idMatches)) {\n                suppressed = true;\n                break;\n            }\n        }\n        return suppressed;\n    }\n\n    /**\n     * Checks whether suppression entry position is after the audit event occurrence position\n     * in the source file.\n     *\n     * @param line the line number in the source file where the event occurred.\n     * @param column the column number in the source file where the event occurred.\n     * @param entry suppression entry.\n     * @return true if suppression entry position is after the audit event occurrence position\n     *         in the source file.\n     */\n    private static boolean isSuppressedAfterEventStart(int line, int column, Entry entry) {\n        return entry.getFirstLine() < line\n            || entry.getFirstLine() == line\n            && (column == 0 || entry.getFirstColumn() <= column);\n    }\n\n    /**\n     * Checks whether suppression entry position is before the audit event occurrence position\n     * in the source file.\n     *\n     * @param line the line number in the source file where the event occurred.\n     * @param column the column number in the source file where the event occurred.\n     * @param entry suppression entry.\n     * @return true if suppression entry position is before the audit event occurrence position\n     *         in the source file.\n     */\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n            || entry.getLastLine() == line && entry\n                .getLastColumn() >= column;\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {TokenTypes.ANNOTATION};\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        ENTRIES.get().clear();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        // check whether annotation is SuppressWarnings\n        // expected children: AT ( IDENT | DOT ) LPAREN <values> RPAREN\n        String identifier = getIdentifier(getNthChild(ast, 1));\n        if (identifier.startsWith(JAVA_LANG_PREFIX)) {\n            identifier = identifier.substring(JAVA_LANG_PREFIX.length());\n        }\n        if (\"SuppressWarnings\".equals(identifier)) {\n            final List<String> values = getAllAnnotationValues(ast);\n            if (!isAnnotationEmpty(values)) {\n                final DetailAST targetAST = getAnnotationTarget(ast);\n\n                // get text range of target\n                final int firstLine = targetAST.getLineNo();\n                final int firstColumn = targetAST.getColumnNo();\n                final DetailAST nextAST = targetAST.getNextSibling();\n                final int lastLine;\n                final int lastColumn;\n                if (nextAST == null) {\n                    lastLine = Integer.MAX_VALUE;\n                    lastColumn = Integer.MAX_VALUE;\n                }\n                else {\n                    lastLine = nextAST.getLineNo();\n                    lastColumn = nextAST.getColumnNo() - 1;\n                }\n\n                // add suppression entries for listed checks\n                final List<Entry> entries = ENTRIES.get();\n                for (String value : values) {\n                    String checkName = value;\n                    // strip off the checkstyle-only prefix if present\n                    checkName = removeCheckstylePrefixIfExists(checkName);\n                    entries.add(new Entry(checkName, firstLine, firstColumn,\n                            lastLine, lastColumn));\n                }\n            }\n        }\n    }\n\n    /**\n     * Method removes checkstyle prefix (checkstyle:) from check name if exists.\n     *\n     * @param checkName\n     *            - name of the check\n     * @return check name without prefix\n     */\n    private static String removeCheckstylePrefixIfExists(String checkName) {\n        String result = checkName;\n        if (checkName.startsWith(CHECKSTYLE_PREFIX)) {\n            result = checkName.substring(CHECKSTYLE_PREFIX.length());\n        }\n        return result;\n    }\n\n    /**\n     * Get all annotation values.\n     *\n     * @param ast annotation token\n     * @return list values\n     */\n    private static List<String> getAllAnnotationValues(DetailAST ast) {\n        // get values of annotation\n        List<String> values = null;\n        final DetailAST lparenAST = ast.findFirstToken(TokenTypes.LPAREN);\n        if (lparenAST != null) {\n            final DetailAST nextAST = lparenAST.getNextSibling();\n            final int nextType = nextAST.getType();\n            switch (nextType) {\n                case TokenTypes.EXPR:\n                case TokenTypes.ANNOTATION_ARRAY_INIT:\n                    values = getAnnotationValues(nextAST);\n                    break;\n\n                case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:\n                    // expected children: IDENT ASSIGN ( EXPR |\n                    // ANNOTATION_ARRAY_INIT )\n                    values = getAnnotationValues(getNthChild(nextAST, 2));\n                    break;\n\n                case TokenTypes.RPAREN:\n                    // no value present (not valid Java)\n                    break;\n\n                default:\n                    // unknown annotation value type (new syntax?)\n                    throw new IllegalArgumentException(\"Unexpected AST: \" + nextAST);\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Checks that annotation is empty.\n     *\n     * @param values list of values in the annotation\n     * @return whether annotation is empty or contains some values\n     */\n    private static boolean isAnnotationEmpty(List<String> values) {\n        return values == null;\n    }\n\n    /**\n     * Get target of annotation.\n     *\n     * @param ast the AST node to get the child of\n     * @return get target of annotation\n     */\n    private static DetailAST getAnnotationTarget(DetailAST ast) {\n        final DetailAST targetAST;\n        final DetailAST parentAST = ast.getParent();\n        switch (parentAST.getType()) {\n            case TokenTypes.MODIFIERS:\n            case TokenTypes.ANNOTATIONS:\n            case TokenTypes.ANNOTATION:\n            case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:\n                targetAST = parentAST.getParent();\n                break;\n            default:\n                // unexpected container type\n                throw new IllegalArgumentException(\"Unexpected container AST: \" + parentAST);\n        }\n        return targetAST;\n    }\n\n    /**\n     * Returns the n'th child of an AST node.\n     *\n     * @param ast the AST node to get the child of\n     * @param index the index of the child to get\n     * @return the n'th child of the given AST node, or {@code null} if none\n     */\n    private static DetailAST getNthChild(DetailAST ast, int index) {\n        DetailAST child = ast.getFirstChild();\n        for (int i = 0; i < index && child != null; ++i) {\n            child = child.getNextSibling();\n        }\n        return child;\n    }\n\n    /**\n     * Returns the Java identifier represented by an AST.\n     *\n     * @param ast an AST node for an IDENT or DOT\n     * @return the Java identifier represented by the given AST subtree\n     * @throws IllegalArgumentException if the AST is invalid\n     */\n    private static String getIdentifier(DetailAST ast) {\n        if (ast == null) {\n            throw new IllegalArgumentException(\"Identifier AST expected, but get null.\");\n        }\n        final String identifier;\n        if (ast.getType() == TokenTypes.IDENT) {\n            identifier = ast.getText();\n        }\n        else {\n            identifier = getIdentifier(ast.getFirstChild()) + \".\"\n                + getIdentifier(ast.getLastChild());\n        }\n        return identifier;\n    }\n\n    /**\n     * Returns the literal string expression represented by an AST.\n     *\n     * @param ast an AST node for an EXPR\n     * @return the Java string represented by the given AST expression\n     *         or empty string if expression is too complex\n     * @throws IllegalArgumentException if the AST is invalid\n     */\n    private static String getStringExpr(DetailAST ast) {\n        final DetailAST firstChild = ast.getFirstChild();\n        String expr = \"\";\n\n        switch (firstChild.getType()) {\n            case TokenTypes.STRING_LITERAL:\n                // NOTE: escaped characters are not unescaped\n                final String quotedText = firstChild.getText();\n                expr = quotedText.substring(1, quotedText.length() - 1);\n                break;\n            case TokenTypes.IDENT:\n                expr = firstChild.getText();\n                break;\n            case TokenTypes.DOT:\n                expr = firstChild.getLastChild().getText();\n                break;\n            case TokenTypes.TEXT_BLOCK_LITERAL_BEGIN:\n                final String textBlockContent = firstChild.getFirstChild().getText();\n                expr = getContentWithoutPrecedingWhitespace(textBlockContent);\n                break;\n            default:\n                // annotations with complex expressions cannot suppress warnings\n        }\n        return expr;\n    }\n\n    /**\n     * Returns the annotation values represented by an AST.\n     *\n     * @param ast an AST node for an EXPR or ANNOTATION_ARRAY_INIT\n     * @return the list of Java string represented by the given AST for an\n     *         expression or annotation array initializer\n     * @throws IllegalArgumentException if the AST is invalid\n     */\n    private static List<String> getAnnotationValues(DetailAST ast) {\n        final List<String> annotationValues;\n        switch (ast.getType()) {\n            case TokenTypes.EXPR:\n                annotationValues = Collections.singletonList(getStringExpr(ast));\n                break;\n            case TokenTypes.ANNOTATION_ARRAY_INIT:\n                annotationValues = findAllExpressionsInChildren(ast);\n                break;\n            default:\n                throw new IllegalArgumentException(\n                        \"Expression or annotation array initializer AST expected: \" + ast);\n        }\n        return annotationValues;\n    }\n\n    /**\n     * Method looks at children and returns list of expressions in strings.\n     *\n     * @param parent ast, that contains children\n     * @return list of expressions in strings\n     */\n    private static List<String> findAllExpressionsInChildren(DetailAST parent) {\n        final List<String> valueList = new LinkedList<>();\n        DetailAST childAST = parent.getFirstChild();\n        while (childAST != null) {\n            if (childAST.getType() == TokenTypes.EXPR) {\n                valueList.add(getStringExpr(childAST));\n            }\n            childAST = childAST.getNextSibling();\n        }\n        return valueList;\n    }\n\n    /**\n     * Remove preceding newline and whitespace from the content of a text block.\n     *\n     * @param textBlockContent the actual text in a text block.\n     * @return content of text block with preceding whitespace and newline removed.\n     */\n    private static String getContentWithoutPrecedingWhitespace(String textBlockContent) {\n        final String contentWithNoPrecedingNewline =\n            NEWLINE.matcher(textBlockContent).replaceAll(\"\");\n        return WHITESPACE.matcher(contentWithNoPrecedingNewline).replaceAll(\"\");\n    }\n\n    @Override\n    public void destroy() {\n        super.destroy();\n        ENTRIES.remove();\n    }\n\n    /** Records a particular suppression for a region of a file. */\n    private static class Entry {\n\n        /** The source name of the suppressed check. */\n        private final String checkName;\n        /** The suppression region for the check - first line. */\n        private final int firstLine;\n        /** The suppression region for the check - first column. */\n        private final int firstColumn;\n        /** The suppression region for the check - last line. */\n        private final int lastLine;\n        /** The suppression region for the check - last column. */\n        private final int lastColumn;\n\n        /**\n         * Constructs a new suppression region entry.\n         *\n         * @param checkName the source name of the suppressed check\n         * @param firstLine the first line of the suppression region\n         * @param firstColumn the first column of the suppression region\n         * @param lastLine the last line of the suppression region\n         * @param lastColumn the last column of the suppression region\n         */\n        /* package */ Entry(String checkName, int firstLine, int firstColumn,\n            int lastLine, int lastColumn) {\n            this.checkName = checkName;\n            this.firstLine = firstLine;\n            this.firstColumn = firstColumn;\n            this.lastLine = lastLine;\n            this.lastColumn = lastColumn;\n        }\n\n        /**\n         * Gets he source name of the suppressed check.\n         *\n         * @return the source name of the suppressed check\n         */\n        public String getCheckName() {\n            return checkName;\n        }\n\n        /**\n         * Gets the first line of the suppression region.\n         *\n         * @return the first line of the suppression region\n         */\n        public int getFirstLine() {\n            return firstLine;\n        }\n\n        /**\n         * Gets the first column of the suppression region.\n         *\n         * @return the first column of the suppression region\n         */\n        public int getFirstColumn() {\n            return firstColumn;\n        }\n\n        /**\n         * Gets the last line of the suppression region.\n         *\n         * @return the last line of the suppression region\n         */\n        public int getLastLine() {\n            return lastLine;\n        }\n\n        /**\n         * Gets the last column of the suppression region.\n         *\n         * @return the last column of the suppression region\n         */\n        public int getLastColumn() {\n            return lastColumn;\n        }\n\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AuditEvent;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\n\n/**\n * <p>\n * Maintains a set of check suppressions from {@code @SuppressWarnings} annotations.\n * It allows to prevent Checkstyle from reporting violations from parts of code that were\n * annotated with {@code @SuppressWarnings} and using name of the check to be excluded.\n * You can also define aliases for check names that need to be suppressed.\n * </p>\n * <ul>\n * <li>\n * Property {@code aliasList} - Specify aliases for check names that can be used in code\n * within {@code SuppressWarnings}.\n * Type is {@code java.lang.String[]}.\n * Default value is {@code null}.\n * </li>\n * </ul>\n * <p>\n * To prevent {@code FooCheck} violations from being reported write:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"foo\") interface I { }\n * &#64;SuppressWarnings(\"foo\") enum E { }\n * &#64;SuppressWarnings(\"foo\") InputSuppressWarningsFilter() { }\n * </pre>\n * <p>\n * Some real check examples:\n * </p>\n * <p>\n * This will prevent from invocation of the MemberNameCheck:\n * </p>\n * <pre>\n * &#64;SuppressWarnings({\"membername\"})\n * private int J;\n * </pre>\n * <p>\n * You can also use a {@code checkstyle} prefix to prevent compiler from\n * processing this annotations. For example this will prevent ConstantNameCheck:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"checkstyle:constantname\")\n * private static final int m = 0;\n * </pre>\n * <p>\n * The general rule is that the argument of the {@code @SuppressWarnings} will be\n * matched against class name of the checker in lower case and without {@code Check}\n * suffix if present.\n * </p>\n * <p>\n * If {@code aliasList} property was provided you can use your own names e.g below\n * code will work if there was provided a {@code ParameterNumberCheck=paramnum} in\n * the {@code aliasList}:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"paramnum\")\n * public void needsLotsOfParameters(@SuppressWarnings(\"unused\") int a,\n *   int b, int c, int d, int e, int f, int g, int h) {\n *   ...\n * }\n * </pre>\n * <p>\n * It is possible to suppress all the checkstyle warnings with the argument {@code \"all\"}:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"all\")\n * public void someFunctionWithInvalidStyle() {\n *   //...\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n *\n * @since 5.7\n */\n@StatelessCheck\npublic class SuppressWarningsHolder\n    extends AbstractCheck {\n\n    /**\n     * Optional prefix for warning suppressions that are only intended to be\n     * recognized by checkstyle. For instance, to suppress {@code\n     * FallThroughCheck} only in checkstyle (and not in javac), use the\n     * suppression {@code \"checkstyle:fallthrough\"} or {@code \"checkstyle:FallThrough\"}.\n     * To suppress the warning in both tools, just use {@code \"fallthrough\"}.\n     */\n    private static final String CHECKSTYLE_PREFIX = \"checkstyle:\";\n\n    /** Java.lang namespace prefix, which is stripped from SuppressWarnings */\n    private static final String JAVA_LANG_PREFIX = \"java.lang.\";\n\n    /** Suffix to be removed from subclasses of Check. */\n    private static final String CHECK_SUFFIX = \"Check\";\n\n    /** Special warning id for matching all the warnings. */\n    private static final String ALL_WARNING_MATCHING_ID = \"all\";\n\n    /** A map from check source names to suppression aliases. */\n    private static final Map<String, String> CHECK_ALIAS_MAP = new HashMap<>();\n\n    /**\n     * A thread-local holder for the list of suppression entries for the last\n     * file parsed.\n     */\n    private static final ThreadLocal<List<Entry>> ENTRIES =\n            ThreadLocal.withInitial(LinkedList::new);\n\n    /**\n     * Compiled pattern used to match whitespace in text block content.\n     */\n    private static final Pattern WHITESPACE = Pattern.compile(\"\\\\s+\");\n\n    /**\n     * Compiled pattern used to match preceding newline in text block content.\n     */\n    private static final Pattern NEWLINE = Pattern.compile(\"\\\\n\");\n\n    /**\n     * Returns the default alias for the source name of a check, which is the\n     * source name in lower case with any dotted prefix or \"Check\" suffix\n     * removed.\n     *\n     * @param sourceName the source name of the check (generally the class\n     *        name)\n     * @return the default alias for the given check\n     */\n    public static String getDefaultAlias(String sourceName) {\n        int endIndex = sourceName.length();\n        if (sourceName.endsWith(CHECK_SUFFIX)) {\n            endIndex -= CHECK_SUFFIX.length();\n        }\n        final int startIndex = sourceName.lastIndexOf('.') + 1;\n        return sourceName.substring(startIndex, endIndex).toLowerCase(Locale.ENGLISH);\n    }\n\n    /**\n     * Returns the alias for the source name of a check. If an alias has been\n     * explicitly registered via {@link #setAliasList(String...)}, that\n     * alias is returned; otherwise, the default alias is used.\n     *\n     * @param sourceName the source name of the check (generally the class\n     *        name)\n     * @return the current alias for the given check\n     */\n    public static String getAlias(String sourceName) {\n        String checkAlias = CHECK_ALIAS_MAP.get(sourceName);\n        if (checkAlias == null) {\n            checkAlias = getDefaultAlias(sourceName);\n        }\n        return checkAlias;\n    }\n\n    /**\n     * Registers an alias for the source name of a check.\n     *\n     * @param sourceName the source name of the check (generally the class\n     *        name)\n     * @param checkAlias the alias used in {@link SuppressWarnings} annotations\n     */\n    private static void registerAlias(String sourceName, String checkAlias) {\n        CHECK_ALIAS_MAP.put(sourceName, checkAlias);\n    }\n\n    /**\n     * Setter to specify aliases for check names that can be used in code\n     * within {@code SuppressWarnings}.\n     *\n     * @param aliasList the list of comma-separated alias assignments\n     * @throws IllegalArgumentException when alias item does not have '='\n     */\n    public void setAliasList(String... aliasList) {\n        for (String sourceAlias : aliasList) {\n            final int index = sourceAlias.indexOf('=');\n            if (index > 0) {\n                registerAlias(sourceAlias.substring(0, index), sourceAlias\n                    .substring(index + 1));\n            }\n            else if (!sourceAlias.isEmpty()) {\n                throw new IllegalArgumentException(\n                    \"'=' expected in alias list item: \" + sourceAlias);\n            }\n        }\n    }\n\n    /**\n     * Checks for a suppression of a check with the given source name and\n     * location in the last file processed.\n     *\n     * @param event audit event.\n     * @return whether the check with the given name is suppressed at the given\n     *         source location\n     */\n    public static boolean isSuppressed(AuditEvent event) {\n        final List<Entry> entries = ENTRIES.get();\n        final String sourceName = event.getSourceName();\n        final String checkAlias = getAlias(sourceName);\n        final int line = event.getLine();\n        final int column = event.getColumn();\n        boolean suppressed = false;\n        for (Entry entry : entries) {\n            final boolean afterStart = isSuppressedAfterEventStart(line, column, entry);\n            final boolean beforeEnd = isSuppressedBeforeEventEnd(line, column, entry);\n            final boolean nameMatches =\n                ALL_WARNING_MATCHING_ID.equals(entry.getCheckName())\n                    || entry.getCheckName().equalsIgnoreCase(checkAlias);\n            final boolean idMatches = event.getModuleId() != null\n                && event.getModuleId().equals(entry.getCheckName());\n            if (afterStart && beforeEnd && (nameMatches || idMatches)) {\n                suppressed = true;\n                break;\n            }\n        }\n        return suppressed;\n    }\n\n    /**\n     * Checks whether suppression entry position is after the audit event occurrence position\n     * in the source file.\n     *\n     * @param line the line number in the source file where the event occurred.\n     * @param column the column number in the source file where the event occurred.\n     * @param entry suppression entry.\n     * @return true if suppression entry position is after the audit event occurrence position\n     *         in the source file.\n     */\n    private static boolean isSuppressedAfterEventStart(int line, int column, Entry entry) {\n        return entry.getFirstLine() < line\n            || entry.getFirstLine() == line\n            && (column == 0 || entry.getFirstColumn() <= column);\n    }\n\n    /**\n     * Checks whether suppression entry position is before the audit event occurrence position\n     * in the source file.\n     *\n     * @param line the line number in the source file where the event occurred.\n     * @param column the column number in the source file where the event occurred.\n     * @param entry suppression entry.\n     * @return true if suppression entry position is before the audit event occurrence position\n     *         in the source file.\n     */\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n            || entry.getLastLine() == line && entry\n                .getLastColumn() >= column;\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {TokenTypes.ANNOTATION};\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        ENTRIES.get().clear();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        // check whether annotation is SuppressWarnings\n        // expected children: AT ( IDENT | DOT ) LPAREN <values> RPAREN\n        String identifier = getIdentifier(getNthChild(ast, 1));\n        if (identifier.startsWith(JAVA_LANG_PREFIX)) {\n            identifier = identifier.substring(JAVA_LANG_PREFIX.length());\n        }\n        if (\"SuppressWarnings\".equals(identifier)) {\n            getAnnotationTarget(ast).ifPresent(targetAST -> {\n                addSuppressions(getAllAnnotationValues(ast), targetAST);\n            });\n        }\n    }\n\n    /**\n     * Method to populate list of suppression entries.\n     *\n     * @param values\n     *            - list of check names\n     * @param targetAST\n     *            - annotation target\n     */\n    private static void addSuppressions(List<String> values, DetailAST targetAST) {\n        // get text range of target\n        final int firstLine = targetAST.getLineNo();\n        final int firstColumn = targetAST.getColumnNo();\n        final DetailAST nextAST = targetAST.getNextSibling();\n        final int lastLine;\n        final int lastColumn;\n        if (nextAST == null) {\n            lastLine = Integer.MAX_VALUE;\n            lastColumn = Integer.MAX_VALUE;\n        }\n        else {\n            lastLine = nextAST.getLineNo();\n            lastColumn = nextAST.getColumnNo() - 1;\n        }\n\n        final List<Entry> entries = ENTRIES.get();\n        for (String value : values) {\n            // strip off the checkstyle-only prefix if present\n            final String checkName = removeCheckstylePrefixIfExists(value);\n            entries.add(new Entry(checkName, firstLine, firstColumn,\n                    lastLine, lastColumn));\n        }\n    }\n\n    /**\n     * Method removes checkstyle prefix (checkstyle:) from check name if exists.\n     *\n     * @param checkName\n     *            - name of the check\n     * @return check name without prefix\n     */\n    private static String removeCheckstylePrefixIfExists(String checkName) {\n        String result = checkName;\n        if (checkName.startsWith(CHECKSTYLE_PREFIX)) {\n            result = checkName.substring(CHECKSTYLE_PREFIX.length());\n        }\n        return result;\n    }\n\n    /**\n     * Get all annotation values.\n     *\n     * @param ast annotation token\n     * @return list values\n     */\n    private static List<String> getAllAnnotationValues(DetailAST ast) {\n        // get values of annotation\n        List<String> values = Collections.emptyList();\n        final DetailAST lparenAST = ast.findFirstToken(TokenTypes.LPAREN);\n        if (lparenAST != null) {\n            final DetailAST nextAST = lparenAST.getNextSibling();\n            final int nextType = nextAST.getType();\n            switch (nextType) {\n                case TokenTypes.EXPR:\n                case TokenTypes.ANNOTATION_ARRAY_INIT:\n                    values = getAnnotationValues(nextAST);\n                    break;\n\n                case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:\n                    // expected children: IDENT ASSIGN ( EXPR |\n                    // ANNOTATION_ARRAY_INIT )\n                    values = getAnnotationValues(getNthChild(nextAST, 2));\n                    break;\n\n                case TokenTypes.RPAREN:\n                    // no value present (not valid Java)\n                    break;\n\n                default:\n                    // unknown annotation value type (new syntax?)\n                    throw new IllegalArgumentException(\"Unexpected AST: \" + nextAST);\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Get target of annotation.\n     *\n     * @param ast the AST node to get the child of\n     * @return get target of annotation\n     */\n    private static Optional<DetailAST> getAnnotationTarget(DetailAST ast) {\n        final Optional<DetailAST> result;\n        final DetailAST parentAST = ast.getParent();\n        switch (parentAST.getType()) {\n            case TokenTypes.MODIFIERS:\n            case TokenTypes.ANNOTATIONS:\n            case TokenTypes.ANNOTATION:\n            case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:\n                result = Optional.of(parentAST.getParent());\n                break;\n            case TokenTypes.LITERAL_DEFAULT:\n                result = Optional.empty();\n                break;\n            case TokenTypes.ANNOTATION_ARRAY_INIT:\n                result = getAnnotationTarget(parentAST);\n                break;\n            default:\n                // unexpected container type\n                throw new IllegalArgumentException(\"Unexpected container AST: \" + parentAST);\n        }\n        return result;\n    }\n\n    /**\n     * Returns the n'th child of an AST node.\n     *\n     * @param ast the AST node to get the child of\n     * @param index the index of the child to get\n     * @return the n'th child of the given AST node, or {@code null} if none\n     */\n    private static DetailAST getNthChild(DetailAST ast, int index) {\n        DetailAST child = ast.getFirstChild();\n        for (int i = 0; i < index && child != null; ++i) {\n            child = child.getNextSibling();\n        }\n        return child;\n    }\n\n    /**\n     * Returns the Java identifier represented by an AST.\n     *\n     * @param ast an AST node for an IDENT or DOT\n     * @return the Java identifier represented by the given AST subtree\n     * @throws IllegalArgumentException if the AST is invalid\n     */\n    private static String getIdentifier(DetailAST ast) {\n        if (ast == null) {\n            throw new IllegalArgumentException(\"Identifier AST expected, but get null.\");\n        }\n        final String identifier;\n        if (ast.getType() == TokenTypes.IDENT) {\n            identifier = ast.getText();\n        }\n        else {\n            identifier = getIdentifier(ast.getFirstChild()) + \".\"\n                + getIdentifier(ast.getLastChild());\n        }\n        return identifier;\n    }\n\n    /**\n     * Returns the literal string expression represented by an AST.\n     *\n     * @param ast an AST node for an EXPR\n     * @return the Java string represented by the given AST expression\n     *         or empty string if expression is too complex\n     * @throws IllegalArgumentException if the AST is invalid\n     */\n    private static String getStringExpr(DetailAST ast) {\n        final DetailAST firstChild = ast.getFirstChild();\n        String expr = \"\";\n\n        switch (firstChild.getType()) {\n            case TokenTypes.STRING_LITERAL:\n                // NOTE: escaped characters are not unescaped\n                final String quotedText = firstChild.getText();\n                expr = quotedText.substring(1, quotedText.length() - 1);\n                break;\n            case TokenTypes.IDENT:\n                expr = firstChild.getText();\n                break;\n            case TokenTypes.DOT:\n                expr = firstChild.getLastChild().getText();\n                break;\n            case TokenTypes.TEXT_BLOCK_LITERAL_BEGIN:\n                final String textBlockContent = firstChild.getFirstChild().getText();\n                expr = getContentWithoutPrecedingWhitespace(textBlockContent);\n                break;\n            default:\n                // annotations with complex expressions cannot suppress warnings\n        }\n        return expr;\n    }\n\n    /**\n     * Returns the annotation values represented by an AST.\n     *\n     * @param ast an AST node for an EXPR or ANNOTATION_ARRAY_INIT\n     * @return the list of Java string represented by the given AST for an\n     *         expression or annotation array initializer\n     * @throws IllegalArgumentException if the AST is invalid\n     */\n    private static List<String> getAnnotationValues(DetailAST ast) {\n        final List<String> annotationValues;\n        switch (ast.getType()) {\n            case TokenTypes.EXPR:\n                annotationValues = Collections.singletonList(getStringExpr(ast));\n                break;\n            case TokenTypes.ANNOTATION_ARRAY_INIT:\n                annotationValues = findAllExpressionsInChildren(ast);\n                break;\n            default:\n                throw new IllegalArgumentException(\n                        \"Expression or annotation array initializer AST expected: \" + ast);\n        }\n        return annotationValues;\n    }\n\n    /**\n     * Method looks at children and returns list of expressions in strings.\n     *\n     * @param parent ast, that contains children\n     * @return list of expressions in strings\n     */\n    private static List<String> findAllExpressionsInChildren(DetailAST parent) {\n        final List<String> valueList = new LinkedList<>();\n        DetailAST childAST = parent.getFirstChild();\n        while (childAST != null) {\n            if (childAST.getType() == TokenTypes.EXPR) {\n                valueList.add(getStringExpr(childAST));\n            }\n            childAST = childAST.getNextSibling();\n        }\n        return valueList;\n    }\n\n    /**\n     * Remove preceding newline and whitespace from the content of a text block.\n     *\n     * @param textBlockContent the actual text in a text block.\n     * @return content of text block with preceding whitespace and newline removed.\n     */\n    private static String getContentWithoutPrecedingWhitespace(String textBlockContent) {\n        final String contentWithNoPrecedingNewline =\n            NEWLINE.matcher(textBlockContent).replaceAll(\"\");\n        return WHITESPACE.matcher(contentWithNoPrecedingNewline).replaceAll(\"\");\n    }\n\n    @Override\n    public void destroy() {\n        super.destroy();\n        ENTRIES.remove();\n    }\n\n    /** Records a particular suppression for a region of a file. */\n    private static class Entry {\n\n        /** The source name of the suppressed check. */\n        private final String checkName;\n        /** The suppression region for the check - first line. */\n        private final int firstLine;\n        /** The suppression region for the check - first column. */\n        private final int firstColumn;\n        /** The suppression region for the check - last line. */\n        private final int lastLine;\n        /** The suppression region for the check - last column. */\n        private final int lastColumn;\n\n        /**\n         * Constructs a new suppression region entry.\n         *\n         * @param checkName the source name of the suppressed check\n         * @param firstLine the first line of the suppression region\n         * @param firstColumn the first column of the suppression region\n         * @param lastLine the last line of the suppression region\n         * @param lastColumn the last column of the suppression region\n         */\n        /* package */ Entry(String checkName, int firstLine, int firstColumn,\n            int lastLine, int lastColumn) {\n            this.checkName = checkName;\n            this.firstLine = firstLine;\n            this.firstColumn = firstColumn;\n            this.lastLine = lastLine;\n            this.lastColumn = lastColumn;\n        }\n\n        /**\n         * Gets he source name of the suppressed check.\n         *\n         * @return the source name of the suppressed check\n         */\n        public String getCheckName() {\n            return checkName;\n        }\n\n        /**\n         * Gets the first line of the suppression region.\n         *\n         * @return the first line of the suppression region\n         */\n        public int getFirstLine() {\n            return firstLine;\n        }\n\n        /**\n         * Gets the first column of the suppression region.\n         *\n         * @return the first column of the suppression region\n         */\n        public int getFirstColumn() {\n            return firstColumn;\n        }\n\n        /**\n         * Gets the last line of the suppression region.\n         *\n         * @return the last line of the suppression region\n         */\n        public int getLastLine() {\n            return lastLine;\n        }\n\n        /**\n         * Gets the last column of the suppression region.\n         *\n         * @return the last column of the suppression region\n         */\n        public int getLastColumn() {\n            return lastColumn;\n        }\n\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Method to populate list of suppression entries.\n     *\n     * @param values\n     *            - list of check names\n     * @param targetAST\n     *            - annotation target\n     */\n    private static void addSuppressions(List<String> values, DetailAST targetAST) {\n        // get text range of target\n        final int firstLine = targetAST.getLineNo();\n        final int firstColumn = targetAST.getColumnNo();\n        final DetailAST nextAST = targetAST.getNextSibling();\n        final int lastLine;\n        final int lastColumn;\n        if (nextAST == null) {\n            lastLine = Integer.MAX_VALUE;\n            lastColumn = Integer.MAX_VALUE;\n        }\n        else {\n            lastLine = nextAST.getLineNo();\n            lastColumn = nextAST.getColumnNo() - 1;\n        }\n\n        final List<Entry> entries = ENTRIES.get();\n        for (String value : values) {\n            // strip off the checkstyle-only prefix if present\n            final String checkName = removeCheckstylePrefixIfExists(value);\n            entries.add(new Entry(checkName, firstLine, firstColumn,\n                    lastLine, lastColumn));\n        }\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#getIdentifier\n methodBody: private static String getIdentifier(DetailAST ast) {\nif(ast == null){throw new IllegalArgumentException(\"Identifier AST expected, but get null.\");\n}final String identifier;\nif(ast.getType() == TokenTypes.IDENT){identifier=ast.getText();\n}{identifier=getIdentifier(ast.getFirstChild()) + \".\" + getIdentifier(ast.getLastChild());\n}return identifier;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#getNthChild\n methodBody: private static DetailAST getNthChild(DetailAST ast, int index) {\nDetailAST child=ast.getFirstChild();\nfor(int i=0; i < index && child != null; ++i){child=child.getNextSibling();\n}return child;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#isAnnotationEmpty\n methodBody: private static boolean isAnnotationEmpty(List<String> values) {\nreturn values == null;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#removeCheckstylePrefixIfExists\n methodBody: private static String removeCheckstylePrefixIfExists(String checkName) {\nString result=checkName;\nif(checkName.startsWith(CHECKSTYLE_PREFIX)){result=checkName.substring(CHECKSTYLE_PREFIX.length());\n}return result;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#getAllAnnotationValues\n methodBody: private static List<String> getAllAnnotationValues(DetailAST ast) {\nList<String> values=null;\nfinal DetailAST lparenAST=ast.findFirstToken(TokenTypes.LPAREN);\nif(lparenAST != null){final DetailAST nextAST=lparenAST.getNextSibling();\nfinal int nextType=nextAST.getType();\nswitch(nextType)case TokenTypes.EXPR:case TokenTypes.ANNOTATION_ARRAY_INIT:values=getAnnotationValues(nextAST);\nbreak;\ncase TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:values=getAnnotationValues(getNthChild(nextAST,2));\nbreak;\ncase TokenTypes.RPAREN:break;\ndefault:throw new IllegalArgumentException(\"Unexpected AST: \" + nextAST);\n}return values;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.checks.SuppressWarningsHolder#getAnnotationTarget\n methodBody: private static DetailAST getAnnotationTarget(DetailAST ast) {\nfinal DetailAST targetAST;\nfinal DetailAST parentAST=ast.getParent();\nswitch(parentAST.getType())case TokenTypes.MODIFIERS:case TokenTypes.ANNOTATIONS:case TokenTypes.ANNOTATION:case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:targetAST=parentAST.getParent();\nbreak;\ndefault:throw new IllegalArgumentException(\"Unexpected container AST: \" + parentAST);\nreturn targetAST;\n}"], "sourceCodeAfterRefactoring": "@Override\n    public void visitToken(DetailAST ast) {\n        // check whether annotation is SuppressWarnings\n        // expected children: AT ( IDENT | DOT ) LPAREN <values> RPAREN\n        String identifier = getIdentifier(getNthChild(ast, 1));\n        if (identifier.startsWith(JAVA_LANG_PREFIX)) {\n            identifier = identifier.substring(JAVA_LANG_PREFIX.length());\n        }\n        if (\"SuppressWarnings\".equals(identifier)) {\n            getAnnotationTarget(ast).ifPresent(targetAST -> {\n                addSuppressions(getAllAnnotationValues(ast), targetAST);\n            });\n        }\n    }\n/**\n     * Method to populate list of suppression entries.\n     *\n     * @param values\n     *            - list of check names\n     * @param targetAST\n     *            - annotation target\n     */\n    private static void addSuppressions(List<String> values, DetailAST targetAST) {\n        // get text range of target\n        final int firstLine = targetAST.getLineNo();\n        final int firstColumn = targetAST.getColumnNo();\n        final DetailAST nextAST = targetAST.getNextSibling();\n        final int lastLine;\n        final int lastColumn;\n        if (nextAST == null) {\n            lastLine = Integer.MAX_VALUE;\n            lastColumn = Integer.MAX_VALUE;\n        }\n        else {\n            lastLine = nextAST.getLineNo();\n            lastColumn = nextAST.getColumnNo() - 1;\n        }\n\n        final List<Entry> entries = ENTRIES.get();\n        for (String value : values) {\n            // strip off the checkstyle-only prefix if present\n            final String checkName = removeCheckstylePrefixIfExists(value);\n            entries.add(new Entry(checkName, firstLine, firstColumn,\n                    lastLine, lastColumn));\n        }\n    }", "diffSourceCode": "-  301:     @Override\n-  302:     public void visitToken(DetailAST ast) {\n-  303:         // check whether annotation is SuppressWarnings\n-  304:         // expected children: AT ( IDENT | DOT ) LPAREN <values> RPAREN\n-  305:         String identifier = getIdentifier(getNthChild(ast, 1));\n-  306:         if (identifier.startsWith(JAVA_LANG_PREFIX)) {\n-  307:             identifier = identifier.substring(JAVA_LANG_PREFIX.length());\n-  308:         }\n-  309:         if (\"SuppressWarnings\".equals(identifier)) {\n-  310:             final List<String> values = getAllAnnotationValues(ast);\n-  311:             if (!isAnnotationEmpty(values)) {\n-  312:                 final DetailAST targetAST = getAnnotationTarget(ast);\n-  313: \n-  314:                 // get text range of target\n-  315:                 final int firstLine = targetAST.getLineNo();\n-  316:                 final int firstColumn = targetAST.getColumnNo();\n-  317:                 final DetailAST nextAST = targetAST.getNextSibling();\n-  318:                 final int lastLine;\n-  319:                 final int lastColumn;\n-  320:                 if (nextAST == null) {\n-  321:                     lastLine = Integer.MAX_VALUE;\n-  322:                     lastColumn = Integer.MAX_VALUE;\n-  323:                 }\n-  324:                 else {\n-  325:                     lastLine = nextAST.getLineNo();\n-  326:                     lastColumn = nextAST.getColumnNo() - 1;\n-  327:                 }\n-  328: \n-  329:                 // add suppression entries for listed checks\n-  330:                 final List<Entry> entries = ENTRIES.get();\n-  331:                 for (String value : values) {\n-  332:                     String checkName = value;\n-  333:                     // strip off the checkstyle-only prefix if present\n-  334:                     checkName = removeCheckstylePrefixIfExists(checkName);\n-  335:                     entries.add(new Entry(checkName, firstLine, firstColumn,\n-  336:                             lastLine, lastColumn));\n-  337:                 }\n-  338:             }\n+  301: \n+  302:     @Override\n+  303:     public void visitToken(DetailAST ast) {\n+  304:         // check whether annotation is SuppressWarnings\n+  305:         // expected children: AT ( IDENT | DOT ) LPAREN <values> RPAREN\n+  306:         String identifier = getIdentifier(getNthChild(ast, 1));\n+  307:         if (identifier.startsWith(JAVA_LANG_PREFIX)) {\n+  308:             identifier = identifier.substring(JAVA_LANG_PREFIX.length());\n+  309:         }\n+  310:         if (\"SuppressWarnings\".equals(identifier)) {\n+  311:             getAnnotationTarget(ast).ifPresent(targetAST -> {\n+  312:                 addSuppressions(getAllAnnotationValues(ast), targetAST);\n+  313:             });\n+  314:         }\n+  315:     }\n+  316: \n+  317:     /**\n+  318:      * Method to populate list of suppression entries.\n+  319:      *\n+  320:      * @param values\n+  321:      *            - list of check names\n+  322:      * @param targetAST\n+  323:      *            - annotation target\n+  324:      */\n+  325:     private static void addSuppressions(List<String> values, DetailAST targetAST) {\n+  326:         // get text range of target\n+  327:         final int firstLine = targetAST.getLineNo();\n+  328:         final int firstColumn = targetAST.getColumnNo();\n+  329:         final DetailAST nextAST = targetAST.getNextSibling();\n+  330:         final int lastLine;\n+  331:         final int lastColumn;\n+  332:         if (nextAST == null) {\n+  333:             lastLine = Integer.MAX_VALUE;\n+  334:             lastColumn = Integer.MAX_VALUE;\n+  335:         }\n+  336:         else {\n+  337:             lastLine = nextAST.getLineNo();\n+  338:             lastColumn = nextAST.getColumnNo() - 1;\n   339:         }\n-  340:     }\n-  341: \n-  342:     /**\n-  343:      * Method removes checkstyle prefix (checkstyle:) from check name if exists.\n-  344:      *\n-  345:      * @param checkName\n-  346:      *            - name of the check\n-  347:      * @return check name without prefix\n-  348:      */\n+  340: \n+  341:         final List<Entry> entries = ENTRIES.get();\n+  342:         for (String value : values) {\n+  343:             // strip off the checkstyle-only prefix if present\n+  344:             final String checkName = removeCheckstylePrefixIfExists(value);\n+  345:             entries.add(new Entry(checkName, firstLine, firstColumn,\n+  346:                     lastLine, lastColumn));\n+  347:         }\n+  348:     }\n", "uniqueId": "77721c4ac3fc9252bfe9840dcb6fae93e0965562_301_340_317_348_302_315", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 83}, "BRANCH": {"missed": 0, "covered": 10}, "LINE": {"missed": 0, "covered": 22}, "COMPLEXITY": {"missed": 0, "covered": 6}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nprivate String getCheckNameWithoutPrefix(String checkName) {\n    String result = checkName;\n    if (checkName.startsWith(CHECKSTYLE_PREFIX)) {\n        result = checkName.substring(CHECKSTYLE_PREFIX.length());\n    }\n    return result;\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Override\n    public void visitToken(DetailAST ast) {\n        // check whether annotation is SuppressWarnings\n        // expected children: AT ( IDENT | DOT ) LPAREN <values> RPAREN\n        String identifier = getIdentifier(getNthChild(ast, 1));\n        if (identifier.startsWith(JAVA_LANG_PREFIX)) {\n            identifier = identifier.substring(JAVA_LANG_PREFIX.length());\n        }\n        if (\"SuppressWarnings\".equals(identifier)) {\n            final List<String> values = getAllAnnotationValues(ast);\n            if (!isAnnotationEmpty(values)) {\n                final DetailAST targetAST = getAnnotationTarget(ast);\n\n                // get text range of target\n                final int firstLine = targetAST.getLineNo();\n                final int firstColumn = targetAST.getColumnNo();\n                final DetailAST nextAST = targetAST.getNextSibling();\n                final int lastLine;\n                final int lastColumn;\n                if (nextAST == null) {\n                    lastLine = Integer.MAX_VALUE;\n                    lastColumn = Integer.MAX_VALUE;\n                }\n                else {\n                    lastLine = nextAST.getLineNo();\n                    lastColumn = nextAST.getColumnNo() - 1;\n                }\n\n                // add suppression entries for listed checks\n                final List<Entry> entries = ENTRIES.get();\n                for (String value : values) {\n                    String checkName = value;\n                    // strip off the checkstyle-only prefix if present\n                    checkName = removeCheckstylePrefixIfExists(checkName);\n                    entries.add(new Entry(checkName, firstLine, firstColumn,\n                            lastLine, lastColumn));\n                }\n            }\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.AuditEvent;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\n\n/**\n * <p>\n * Maintains a set of check suppressions from {@code @SuppressWarnings} annotations.\n * It allows to prevent Checkstyle from reporting violations from parts of code that were\n * annotated with {@code @SuppressWarnings} and using name of the check to be excluded.\n * You can also define aliases for check names that need to be suppressed.\n * </p>\n * <ul>\n * <li>\n * Property {@code aliasList} - Specify aliases for check names that can be used in code\n * within {@code SuppressWarnings}.\n * Type is {@code java.lang.String[]}.\n * Default value is {@code null}.\n * </li>\n * </ul>\n * <p>\n * To prevent {@code FooCheck} violations from being reported write:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"foo\") interface I { }\n * &#64;SuppressWarnings(\"foo\") enum E { }\n * &#64;SuppressWarnings(\"foo\") InputSuppressWarningsFilter() { }\n * </pre>\n * <p>\n * Some real check examples:\n * </p>\n * <p>\n * This will prevent from invocation of the MemberNameCheck:\n * </p>\n * <pre>\n * &#64;SuppressWarnings({\"membername\"})\n * private int J;\n * </pre>\n * <p>\n * You can also use a {@code checkstyle} prefix to prevent compiler from\n * processing this annotations. For example this will prevent ConstantNameCheck:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"checkstyle:constantname\")\n * private static final int m = 0;\n * </pre>\n * <p>\n * The general rule is that the argument of the {@code @SuppressWarnings} will be\n * matched against class name of the checker in lower case and without {@code Check}\n * suffix if present.\n * </p>\n * <p>\n * If {@code aliasList} property was provided you can use your own names e.g below\n * code will work if there was provided a {@code ParameterNumberCheck=paramnum} in\n * the {@code aliasList}:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"paramnum\")\n * public void needsLotsOfParameters(@SuppressWarnings(\"unused\") int a,\n *   int b, int c, int d, int e, int f, int g, int h) {\n *   ...\n * }\n * </pre>\n * <p>\n * It is possible to suppress all the checkstyle warnings with the argument {@code \"all\"}:\n * </p>\n * <pre>\n * &#64;SuppressWarnings(\"all\")\n * public void someFunctionWithInvalidStyle() {\n *   //...\n * }\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n *\n * @since 5.7\n */\n@StatelessCheck\npublic class SuppressWarningsHolder\n    extends AbstractCheck {\n\n    /**\n     * Optional prefix for warning suppressions that are only intended to be\n     * recognized by checkstyle. For instance, to suppress {@code\n     * FallThroughCheck} only in checkstyle (and not in javac), use the\n     * suppression {@code \"checkstyle:fallthrough\"} or {@code \"checkstyle:FallThrough\"}.\n     * To suppress the warning in both tools, just use {@code \"fallthrough\"}.\n     */\n    private static final String CHECKSTYLE_PREFIX = \"checkstyle:\";\n\n    /** Java.lang namespace prefix, which is stripped from SuppressWarnings */\n    private static final String JAVA_LANG_PREFIX = \"java.lang.\";\n\n    /** Suffix to be removed from subclasses of Check. */\n    private static final String CHECK_SUFFIX = \"Check\";\n\n    /** Special warning id for matching all the warnings. */\n    private static final String ALL_WARNING_MATCHING_ID = \"all\";\n\n    /** A map from check source names to suppression aliases. */\n    private static final Map<String, String> CHECK_ALIAS_MAP = new HashMap<>();\n\n    /**\n     * A thread-local holder for the list of suppression entries for the last\n     * file parsed.\n     */\n    private static final ThreadLocal<List<Entry>> ENTRIES =\n            ThreadLocal.withInitial(LinkedList::new);\n\n    /**\n     * Compiled pattern used to match whitespace in text block content.\n     */\n    private static final Pattern WHITESPACE = Pattern.compile(\"\\\\s+\");\n\n    /**\n     * Compiled pattern used to match preceding newline in text block content.\n     */\n    private static final Pattern NEWLINE = Pattern.compile(\"\\\\n\");\n\n    /**\n     * Returns the default alias for the source name of a check, which is the\n     * source name in lower case with any dotted prefix or \"Check\" suffix\n     * removed.\n     *\n     * @param sourceName the source name of the check (generally the class\n     *        name)\n     * @return the default alias for the given check\n     */\n    public static String getDefaultAlias(String sourceName) {\n        int endIndex = sourceName.length();\n        if (sourceName.endsWith(CHECK_SUFFIX)) {\n            endIndex -= CHECK_SUFFIX.length();\n        }\n        final int startIndex = sourceName.lastIndexOf('.') + 1;\n        return sourceName.substring(startIndex, endIndex).toLowerCase(Locale.ENGLISH);\n    }\n\n    /**\n     * Returns the alias for the source name of a check. If an alias has been\n     * explicitly registered via {@link #setAliasList(String...)}, that\n     * alias is returned; otherwise, the default alias is used.\n     *\n     * @param sourceName the source name of the check (generally the class\n     *        name)\n     * @return the current alias for the given check\n     */\n    public static String getAlias(String sourceName) {\n        String checkAlias = CHECK_ALIAS_MAP.get(sourceName);\n        if (checkAlias == null) {\n            checkAlias = getDefaultAlias(sourceName);\n        }\n        return checkAlias;\n    }\n\n    /**\n     * Registers an alias for the source name of a check.\n     *\n     * @param sourceName the source name of the check (generally the class\n     *        name)\n     * @param checkAlias the alias used in {@link SuppressWarnings} annotations\n     */\n    private static void registerAlias(String sourceName, String checkAlias) {\n        CHECK_ALIAS_MAP.put(sourceName, checkAlias);\n    }\n\n    /**\n     * Setter to specify aliases for check names that can be used in code\n     * within {@code SuppressWarnings}.\n     *\n     * @param aliasList the list of comma-separated alias assignments\n     * @throws IllegalArgumentException when alias item does not have '='\n     */\n    public void setAliasList(String... aliasList) {\n        for (String sourceAlias : aliasList) {\n            final int index = sourceAlias.indexOf('=');\n            if (index > 0) {\n                registerAlias(sourceAlias.substring(0, index), sourceAlias\n                    .substring(index + 1));\n            }\n            else if (!sourceAlias.isEmpty()) {\n                throw new IllegalArgumentException(\n                    \"'=' expected in alias list item: \" + sourceAlias);\n            }\n        }\n    }\n\n    /**\n     * Checks for a suppression of a check with the given source name and\n     * location in the last file processed.\n     *\n     * @param event audit event.\n     * @return whether the check with the given name is suppressed at the given\n     *         source location\n     */\n    public static boolean isSuppressed(AuditEvent event) {\n        final List<Entry> entries = ENTRIES.get();\n        final String sourceName = event.getSourceName();\n        final String checkAlias = getAlias(sourceName);\n        final int line = event.getLine();\n        final int column = event.getColumn();\n        boolean suppressed = false;\n        for (Entry entry : entries) {\n            final boolean afterStart = isSuppressedAfterEventStart(line, column, entry);\n            final boolean beforeEnd = isSuppressedBeforeEventEnd(line, column, entry);\n            final boolean nameMatches =\n                ALL_WARNING_MATCHING_ID.equals(entry.getCheckName())\n                    || entry.getCheckName().equalsIgnoreCase(checkAlias);\n            final boolean idMatches = event.getModuleId() != null\n                && event.getModuleId().equals(entry.getCheckName());\n            if (afterStart && beforeEnd && (nameMatches || idMatches)) {\n                suppressed = true;\n                break;\n            }\n        }\n        return suppressed;\n    }\n\n    /**\n     * Checks whether suppression entry position is after the audit event occurrence position\n     * in the source file.\n     *\n     * @param line the line number in the source file where the event occurred.\n     * @param column the column number in the source file where the event occurred.\n     * @param entry suppression entry.\n     * @return true if suppression entry position is after the audit event occurrence position\n     *         in the source file.\n     */\n    private static boolean isSuppressedAfterEventStart(int line, int column, Entry entry) {\n        return entry.getFirstLine() < line\n            || entry.getFirstLine() == line\n            && (column == 0 || entry.getFirstColumn() <= column);\n    }\n\n    /**\n     * Checks whether suppression entry position is before the audit event occurrence position\n     * in the source file.\n     *\n     * @param line the line number in the source file where the event occurred.\n     * @param column the column number in the source file where the event occurred.\n     * @param entry suppression entry.\n     * @return true if suppression entry position is before the audit event occurrence position\n     *         in the source file.\n     */\n    private static boolean isSuppressedBeforeEventEnd(int line, int column, Entry entry) {\n        return entry.getLastLine() > line\n            || entry.getLastLine() == line && entry\n                .getLastColumn() >= column;\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {TokenTypes.ANNOTATION};\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        ENTRIES.get().clear();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        // check whether annotation is SuppressWarnings\n        // expected children: AT ( IDENT | DOT ) LPAREN <values> RPAREN\n        String identifier = getIdentifier(getNthChild(ast, 1));\n        if (identifier.startsWith(JAVA_LANG_PREFIX)) {\n            identifier = identifier.substring(JAVA_LANG_PREFIX.length());\n        }\n        if (\"SuppressWarnings\".equals(identifier)) {\n            final List<String> values = getAllAnnotationValues(ast);\n            if (!isAnnotationEmpty(values)) {\n                final DetailAST targetAST = getAnnotationTarget(ast);\n\n                // get text range of target\n                final int firstLine = targetAST.getLineNo();\n                final int firstColumn = targetAST.getColumnNo();\n                final DetailAST nextAST = targetAST.getNextSibling();\n                final int lastLine;\n                final int lastColumn;\n                if (nextAST == null) {\n                    lastLine = Integer.MAX_VALUE;\n                    lastColumn = Integer.MAX_VALUE;\n                }\n                else {\n                    lastLine = nextAST.getLineNo();\n                    lastColumn = nextAST.getColumnNo() - 1;\n                }\n\n                // add suppression entries for listed checks\n                final List<Entry> entries = ENTRIES.get();\n                for (String value : values) {\n                    String checkName = value;\n                    // strip off the checkstyle-only prefix if present\n                    checkName = removeCheckstylePrefixIfExists(checkName);\n                    entries.add(new Entry(checkName, firstLine, firstColumn,\n                            lastLine, lastColumn));\n                }\n            }\n        }\n    }\n\n    /**\n     * Method removes checkstyle prefix (checkstyle:) from check name if exists.\n     *\n     * @param checkName\n     *            - name of the check\n     * @return check name without prefix\n     */\n    private static String removeCheckstylePrefixIfExists(String checkName) {\n        String result = checkName;\n        if (checkName.startsWith(CHECKSTYLE_PREFIX)) {\n            result = checkName.substring(CHECKSTYLE_PREFIX.length());\n        }\n        return result;\n    }\n\n    /**\n     * Get all annotation values.\n     *\n     * @param ast annotation token\n     * @return list values\n     */\n    private static List<String> getAllAnnotationValues(DetailAST ast) {\n        // get values of annotation\n        List<String> values = null;\n        final DetailAST lparenAST = ast.findFirstToken(TokenTypes.LPAREN);\n        if (lparenAST != null) {\n            final DetailAST nextAST = lparenAST.getNextSibling();\n            final int nextType = nextAST.getType();\n            switch (nextType) {\n                case TokenTypes.EXPR:\n                case TokenTypes.ANNOTATION_ARRAY_INIT:\n                    values = getAnnotationValues(nextAST);\n                    break;\n\n                case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:\n                    // expected children: IDENT ASSIGN ( EXPR |\n                    // ANNOTATION_ARRAY_INIT )\n                    values = getAnnotationValues(getNthChild(nextAST, 2));\n                    break;\n\n                case TokenTypes.RPAREN:\n                    // no value present (not valid Java)\n                    break;\n\n                default:\n                    // unknown annotation value type (new syntax?)\n                    throw new IllegalArgumentException(\"Unexpected AST: \" + nextAST);\n            }\n        }\n        return values;\n    }\n\n    /**\n     * Checks that annotation is empty.\n     *\n     * @param values list of values in the annotation\n     * @return whether annotation is empty or contains some values\n     */\n    private static boolean isAnnotationEmpty(List<String> values) {\n        return values == null;\n    }\n\n    /**\n     * Get target of annotation.\n     *\n     * @param ast the AST node to get the child of\n     * @return get target of annotation\n     */\n    private static DetailAST getAnnotationTarget(DetailAST ast) {\n        final DetailAST targetAST;\n        final DetailAST parentAST = ast.getParent();\n        switch (parentAST.getType()) {\n            case TokenTypes.MODIFIERS:\n            case TokenTypes.ANNOTATIONS:\n            case TokenTypes.ANNOTATION:\n            case TokenTypes.ANNOTATION_MEMBER_VALUE_PAIR:\n                targetAST = parentAST.getParent();\n                break;\n            default:\n                // unexpected container type\n                throw new IllegalArgumentException(\"Unexpected container AST: \" + parentAST);\n        }\n        return targetAST;\n    }\n\n    /**\n     * Returns the n'th child of an AST node.\n     *\n     * @param ast the AST node to get the child of\n     * @param index the index of the child to get\n     * @return the n'th child of the given AST node, or {@code null} if none\n     */\n    private static DetailAST getNthChild(DetailAST ast, int index) {\n        DetailAST child = ast.getFirstChild();\n        for (int i = 0; i < index && child != null; ++i) {\n            child = child.getNextSibling();\n        }\n        return child;\n    }\n\n    /**\n     * Returns the Java identifier represented by an AST.\n     *\n     * @param ast an AST node for an IDENT or DOT\n     * @return the Java identifier represented by the given AST subtree\n     * @throws IllegalArgumentException if the AST is invalid\n     */\n    private static String getIdentifier(DetailAST ast) {\n        if (ast == null) {\n            throw new IllegalArgumentException(\"Identifier AST expected, but get null.\");\n        }\n        final String identifier;\n        if (ast.getType() == TokenTypes.IDENT) {\n            identifier = ast.getText();\n        }\n        else {\n            identifier = getIdentifier(ast.getFirstChild()) + \".\"\n                + getIdentifier(ast.getLastChild());\n        }\n        return identifier;\n    }\n\n    /**\n     * Returns the literal string expression represented by an AST.\n     *\n     * @param ast an AST node for an EXPR\n     * @return the Java string represented by the given AST expression\n     *         or empty string if expression is too complex\n     * @throws IllegalArgumentException if the AST is invalid\n     */\n    private static String getStringExpr(DetailAST ast) {\n        final DetailAST firstChild = ast.getFirstChild();\n        String expr = \"\";\n\n        switch (firstChild.getType()) {\n            case TokenTypes.STRING_LITERAL:\n                // NOTE: escaped characters are not unescaped\n                final String quotedText = firstChild.getText();\n                expr = quotedText.substring(1, quotedText.length() - 1);\n                break;\n            case TokenTypes.IDENT:\n                expr = firstChild.getText();\n                break;\n            case TokenTypes.DOT:\n                expr = firstChild.getLastChild().getText();\n                break;\n            case TokenTypes.TEXT_BLOCK_LITERAL_BEGIN:\n                final String textBlockContent = firstChild.getFirstChild().getText();\n                expr = getContentWithoutPrecedingWhitespace(textBlockContent);\n                break;\n            default:\n                // annotations with complex expressions cannot suppress warnings\n        }\n        return expr;\n    }\n\n    /**\n     * Returns the annotation values represented by an AST.\n     *\n     * @param ast an AST node for an EXPR or ANNOTATION_ARRAY_INIT\n     * @return the list of Java string represented by the given AST for an\n     *         expression or annotation array initializer\n     * @throws IllegalArgumentException if the AST is invalid\n     */\n    private static List<String> getAnnotationValues(DetailAST ast) {\n        final List<String> annotationValues;\n        switch (ast.getType()) {\n            case TokenTypes.EXPR:\n                annotationValues = Collections.singletonList(getStringExpr(ast));\n                break;\n            case TokenTypes.ANNOTATION_ARRAY_INIT:\n                annotationValues = findAllExpressionsInChildren(ast);\n                break;\n            default:\n                throw new IllegalArgumentException(\n                        \"Expression or annotation array initializer AST expected: \" + ast);\n        }\n        return annotationValues;\n    }\n\n    /**\n     * Method looks at children and returns list of expressions in strings.\n     *\n     * @param parent ast, that contains children\n     * @return list of expressions in strings\n     */\n    private static List<String> findAllExpressionsInChildren(DetailAST parent) {\n        final List<String> valueList = new LinkedList<>();\n        DetailAST childAST = parent.getFirstChild();\n        while (childAST != null) {\n            if (childAST.getType() == TokenTypes.EXPR) {\n                valueList.add(getStringExpr(childAST));\n            }\n            childAST = childAST.getNextSibling();\n        }\n        return valueList;\n    }\n\n    /**\n     * Remove preceding newline and whitespace from the content of a text block.\n     *\n     * @param textBlockContent the actual text in a text block.\n     * @return content of text block with preceding whitespace and newline removed.\n     */\n    private static String getContentWithoutPrecedingWhitespace(String textBlockContent) {\n        final String contentWithNoPrecedingNewline =\n            NEWLINE.matcher(textBlockContent).replaceAll(\"\");\n        return WHITESPACE.matcher(contentWithNoPrecedingNewline).replaceAll(\"\");\n    }\n\n    @Override\n    public void destroy() {\n        super.destroy();\n        ENTRIES.remove();\n    }\n\n    /** Records a particular suppression for a region of a file. */\n    private static class Entry {\n\n        /** The source name of the suppressed check. */\n        private final String checkName;\n        /** The suppression region for the check - first line. */\n        private final int firstLine;\n        /** The suppression region for the check - first column. */\n        private final int firstColumn;\n        /** The suppression region for the check - last line. */\n        private final int lastLine;\n        /** The suppression region for the check - last column. */\n        private final int lastColumn;\n\n        /**\n         * Constructs a new suppression region entry.\n         *\n         * @param checkName the source name of the suppressed check\n         * @param firstLine the first line of the suppression region\n         * @param firstColumn the first column of the suppression region\n         * @param lastLine the last line of the suppression region\n         * @param lastColumn the last column of the suppression region\n         */\n        /* package */ Entry(String checkName, int firstLine, int firstColumn,\n            int lastLine, int lastColumn) {\n            this.checkName = checkName;\n            this.firstLine = firstLine;\n            this.firstColumn = firstColumn;\n            this.lastLine = lastLine;\n            this.lastColumn = lastColumn;\n        }\n\n        /**\n         * Gets he source name of the suppressed check.\n         *\n         * @return the source name of the suppressed check\n         */\n        public String getCheckName() {\n            return checkName;\n        }\n\n        /**\n         * Gets the first line of the suppression region.\n         *\n         * @return the first line of the suppression region\n         */\n        public int getFirstLine() {\n            return firstLine;\n        }\n\n        /**\n         * Gets the first column of the suppression region.\n         *\n         * @return the first column of the suppression region\n         */\n        public int getFirstColumn() {\n            return firstColumn;\n        }\n\n        /**\n         * Gets the last line of the suppression region.\n         *\n         * @return the last line of the suppression region\n         */\n        public int getLastLine() {\n            return lastLine;\n        }\n\n        /**\n         * Gets the last column of the suppression region.\n         *\n         * @return the last column of the suppression region\n         */\n        public int getLastColumn() {\n            return lastColumn;\n        }\n\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate isChildNodeTextMatches(ast DetailNode, pattern Pattern) : boolean extracted from private isExamplesText(ast DetailNode) : boolean in class com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java", "startLine": 638, "endLine": 648, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java", "startLine": 622, "endLine": 630, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java", "startLine": 664, "endLine": 677, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks whether the paragraph node corresponds to the example section.\n     *\n     * @param ast javadoc paragraph node\n     * @return true if the section matches the example section marker\n     */\n    private static boolean isExamplesText(DetailNode ast) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(ast, JavadocTokenTypes.TEXT, 0);\n        return resultNode.isPresent()\n                && EXAMPLES_TAG.matcher(resultNode.get().getText()).matches();\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java", "isPureRefactoring": true, "commitId": "21c8e04bc929aa8e9242810535a9ca3bfee59561", "packageNameBefore": "com.puppycrawl.tools.checkstyle.meta", "classNameBefore": "com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper", "methodNameBefore": "com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper#isExamplesText", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper#getText\n methodBody: private static String getText(DetailNode parentNode) {\nreturn Arrays.stream(parentNode.getChildren()).filter(child -> child.getType() == JavadocTokenTypes.TEXT).map(node -> QUOTE_PATTERN.matcher(node.getText().trim()).replaceAll(\"\")).collect(Collectors.joining(\" \"));\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper#getFirstChildOfType\n methodBody: private static Optional<DetailNode> getFirstChildOfType(DetailNode node, int tokenType,\n                                                            int offset) {\nreturn Arrays.stream(node.getChildren()).filter(child -> child.getIndex() >= offset && child.getType() == tokenType).findFirst();\n}", "classSignatureBefore": "public class JavadocMetadataScraper extends AbstractJavadocCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper#isExamplesText"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper"], "classSignatureBeforeSet": ["public class JavadocMetadataScraper extends AbstractJavadocCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.meta;\n\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.DetailNode;\nimport com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * Class for scraping module metadata from the corresponding class' class-level javadoc.\n */\n@FileStatefulCheck\npublic class JavadocMetadataScraper extends AbstractJavadocCheck {\n\n    /** Module details store used for testing. */\n    private static final Map<String, ModuleDetails> MODULE_DETAILS_STORE = new HashMap<>();\n\n    /** Regular expression for property location in class-level javadocs. */\n    private static final Pattern PROPERTY_TAG = Pattern.compile(\"\\\\s*Property\\\\s*\");\n\n    /** Regular expression for property type location in class-level javadocs. */\n    private static final Pattern TYPE_TAG = Pattern.compile(\"^ Type is\\\\s.*\");\n\n    /** Regular expression for property validation type location in class-level javadocs. */\n    private static final Pattern VALIDATION_TYPE_TAG =\n            Pattern.compile(\"\\\\s.*Validation type is\\\\s.*\");\n\n    /** Regular expression for property default value location in class-level javadocs. */\n    private static final Pattern DEFAULT_VALUE_TAG = Pattern.compile(\"^ Default value is:*.*\");\n\n    /** Regular expression for check example location in class-level javadocs. */\n    private static final Pattern EXAMPLES_TAG =\n            Pattern.compile(\"\\\\s*To configure the (default )?check.*\");\n\n    /** Regular expression for module parent location in class-level javadocs. */\n    private static final Pattern PARENT_TAG = Pattern.compile(\"\\\\s*Parent is\\\\s*\");\n\n    /** Regular expression for module violation messages location in class-level javadocs. */\n    private static final Pattern VIOLATION_MESSAGES_TAG =\n            Pattern.compile(\"\\\\s*Violation Message Keys:\\\\s*\");\n\n    /** Regular expression for detecting ANTLR tokens(for e.g. CLASS_DEF). */\n    private static final Pattern TOKEN_TEXT_PATTERN = Pattern.compile(\"([A-Z_]{2,})+\");\n\n    /** Regular expression for removal of @code{-} present at the beginning of texts. */\n    private static final Pattern DESC_CLEAN = Pattern.compile(\"-\\\\s\");\n\n    /** Regular expression for file separator corresponding to the host OS. */\n    private static final Pattern FILE_SEPARATOR_PATTERN =\n            Pattern.compile(Pattern.quote(System.getProperty(\"file.separator\")));\n\n    /** Regular expression for quotes. */\n    private static final Pattern QUOTE_PATTERN = Pattern.compile(\"\\\"\");\n\n    /** Java file extension. */\n    private static final String JAVA_FILE_EXTENSION = \".java\";\n\n    /**\n     * This set contains faulty property default value which should not be written to the XML\n     * metadata files.\n     */\n    private static final Set<String> PROPERTIES_TO_NOT_WRITE = Collections.unmodifiableSet(\n            new HashSet<>(Arrays.asList(\n                    \"null\",\n                    \"the charset property of the parent <a href=https://checkstyle.org/\"\n                        + \"config.html#Checker>Checker</a> module\"\n    )));\n\n    /**\n     * Format for exception message for missing type for check property.\n     */\n    private static final String PROP_TYPE_MISSING = \"Type for property '%s' is missing\";\n\n    /**\n     * Format for exception message for missing default value for check property.\n     */\n    private static final String PROP_DEFAULT_VALUE_MISSING =\n        \"Default value for property '%s' is missing\";\n\n    /** ModuleDetails instance for each module AST traversal. */\n    private ModuleDetails moduleDetails;\n\n    /**\n     * Boolean variable which lets us know whether violation message section is being scraped\n     * currently.\n     */\n    private boolean scrapingViolationMessageList;\n\n    /**\n     * Boolean variable which lets us know whether we should scan and scrape the current javadoc\n     * or not. Since we need only class level javadoc, it becomes true at its root and false after\n     * encountering {@code JavadocTokenTypes.SINCE_LITERAL}.\n     */\n    private boolean toScan;\n\n    /** DetailNode pointing to the root node of the class level javadoc of the class. */\n    private DetailNode rootNode;\n\n    /**\n     * Child number of the property section node, where parent is the class level javadoc root\n     * node.\n     */\n    private int propertySectionStartIdx;\n\n    /**\n     * Child number of the example section node, where parent is the class level javadoc root\n     * node.\n     */\n    private int exampleSectionStartIdx;\n\n    /**\n     * Child number of the parent section node, where parent is the class level javadoc root\n     * node.\n     */\n    private int parentSectionStartIdx;\n\n    @Override\n    public int[] getDefaultJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.JAVADOC,\n            JavadocTokenTypes.PARAGRAPH,\n            JavadocTokenTypes.LI,\n            JavadocTokenTypes.SINCE_LITERAL,\n        };\n    }\n\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return getAcceptableJavadocTokens();\n    }\n\n    @Override\n    public void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n            moduleDetails = new ModuleDetails();\n            toScan = false;\n            scrapingViolationMessageList = false;\n            propertySectionStartIdx = -1;\n            exampleSectionStartIdx = -1;\n            parentSectionStartIdx = -1;\n\n            final String filePath = getFileContents().getFileName();\n            String moduleName = getModuleSimpleName();\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.contains(checkModuleExtension)) {\n                moduleName = moduleName.substring(0, moduleName.indexOf(checkModuleExtension));\n            }\n            moduleDetails.setName(moduleName);\n            moduleDetails.setFullQualifiedName(getPackageName(filePath));\n            moduleDetails.setModuleType(getModuleType());\n        }\n    }\n\n    @Override\n    public void visitJavadocToken(DetailNode ast) {\n        if (toScan) {\n            scrapeContent(ast);\n        }\n\n        if (ast.getType() == JavadocTokenTypes.JAVADOC) {\n            final DetailAST parent = getParent(getBlockCommentAst());\n            if (parent != null && parent.getType() == TokenTypes.CLASS_DEF) {\n                rootNode = ast;\n                toScan = true;\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.SINCE_LITERAL) {\n            toScan = false;\n        }\n    }\n\n    @Override\n    public void finishJavadocTree(DetailNode rootAst) {\n        moduleDetails.setDescription(getDescriptionText());\n        if (isTopLevelClassJavadoc()) {\n            if (getFileContents().getFileName().contains(\"test\")) {\n                MODULE_DETAILS_STORE.put(moduleDetails.getFullQualifiedName(), moduleDetails);\n            }\n            else {\n                try {\n                    XmlMetaWriter.write(moduleDetails);\n                }\n                catch (TransformerException | ParserConfigurationException ex) {\n                    throw new IllegalStateException(\"Failed to write metadata into XML file for \"\n                            + \"module: \" + getModuleSimpleName(), ex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method containing the core logic of scraping. This keeps track and decides which phase of\n     * scraping we are in, and accordingly call other subroutines.\n     *\n     * @param ast javadoc ast\n     */\n    public void scrapeContent(DetailNode ast) {\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n            if (isParentText(ast)) {\n                parentSectionStartIdx = getParentIndexOf(ast);\n                moduleDetails.setParent(getParentText(ast));\n            }\n            else if (isViolationMessagesText(ast)) {\n                scrapingViolationMessageList = true;\n            }\n            else if (exampleSectionStartIdx == -1\n                    && isExamplesText(ast)) {\n                exampleSectionStartIdx = getParentIndexOf(ast);\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n            if (isPropertyList(ast)) {\n                if (propertySectionStartIdx == -1) {\n                    propertySectionStartIdx = getParentIndexOf(ast);\n                }\n                moduleDetails.addToProperties(createProperties(ast));\n            }\n            else if (scrapingViolationMessageList) {\n                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n            }\n        }\n    }\n\n    /**\n     * Create the modulePropertyDetails content.\n     *\n     * @param nodeLi list item javadoc node\n     * @return modulePropertyDetail object for the corresponding property\n     */\n    private static ModulePropertyDetails createProperties(DetailNode nodeLi) {\n        final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n\n        final Optional<DetailNode> propertyNameNode = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n        if (propertyNameNode.isPresent()) {\n            final DetailNode propertyNameTag = propertyNameNode.get();\n            final String propertyName = getTextFromTag(propertyNameTag);\n\n            final DetailNode propertyType = getFirstChildOfMatchingText(nodeLi, TYPE_TAG)\n                .orElseThrow(() -> {\n                    return new MetadataGenerationException(String.format(\n                        Locale.ROOT, PROP_TYPE_MISSING, propertyName)\n                    );\n                });\n            final String propertyDesc = DESC_CLEAN.matcher(\n                    constructSubTreeText(nodeLi, propertyNameTag.getIndex() + 1,\n                            propertyType.getIndex() - 1))\n                    .replaceAll(Matcher.quoteReplacement(\"\"));\n\n            modulePropertyDetails.setDescription(propertyDesc.trim());\n            modulePropertyDetails.setName(propertyName);\n            modulePropertyDetails.setType(getTagTextFromProperty(nodeLi, propertyType));\n\n            final Optional<DetailNode> validationTypeNodeOpt = getFirstChildOfMatchingText(nodeLi,\n                VALIDATION_TYPE_TAG);\n            if (validationTypeNodeOpt.isPresent()) {\n                final DetailNode validationTypeNode = validationTypeNodeOpt.get();\n                modulePropertyDetails.setValidationType(getTagTextFromProperty(nodeLi,\n                    validationTypeNode));\n            }\n\n            final String defaultValue = getFirstChildOfMatchingText(nodeLi, DEFAULT_VALUE_TAG)\n                .map(defaultValueNode -> getPropertyDefaultText(nodeLi, defaultValueNode))\n                .orElseThrow(() -> {\n                    return new MetadataGenerationException(String.format(\n                        Locale.ROOT, PROP_DEFAULT_VALUE_MISSING, propertyName)\n                    );\n                });\n            if (!PROPERTIES_TO_NOT_WRITE.contains(defaultValue)) {\n                modulePropertyDetails.setDefaultValue(defaultValue);\n            }\n        }\n        return modulePropertyDetails;\n    }\n\n    /**\n     * Get tag text from property data.\n     *\n     * @param nodeLi javadoc li item node\n     * @param propertyMeta property javadoc node\n     * @return property metadata text\n     */\n    private static String getTagTextFromProperty(DetailNode nodeLi, DetailNode propertyMeta) {\n        final Optional<DetailNode> tagNodeOpt = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, propertyMeta.getIndex() + 1);\n        DetailNode tagNode = null;\n        if (tagNodeOpt.isPresent()) {\n            tagNode = tagNodeOpt.get();\n        }\n        return getTextFromTag(tagNode);\n    }\n\n    /**\n     * Clean up the default token text by removing hyperlinks, and only keeping token type text.\n     *\n     * @param initialText unclean text\n     * @return clean text\n     */\n    private static String cleanDefaultTokensText(String initialText) {\n        final Set<String> tokens = new LinkedHashSet<>();\n        final Matcher matcher = TOKEN_TEXT_PATTERN.matcher(initialText);\n        while (matcher.find()) {\n            tokens.add(matcher.group(0));\n        }\n        return String.join(\",\", tokens);\n    }\n\n    /**\n     * Performs a DFS of the subtree with a node as the root and constructs the text of that\n     * tree, ignoring JavadocToken texts.\n     *\n     * @param node root node of subtree\n     * @param childLeftLimit the left index of root children from where to scan\n     * @param childRightLimit the right index of root children till where to scan\n     * @return constructed text of subtree\n     */\n    private static String constructSubTreeText(DetailNode node, int childLeftLimit,\n                                               int childRightLimit) {\n        final StringBuilder result = new StringBuilder(1024);\n        DetailNode detailNode = node;\n\n        final Deque<DetailNode> stack = new ArrayDeque<>();\n        stack.addFirst(detailNode);\n        final Set<DetailNode> visited = new HashSet<>();\n        while (!stack.isEmpty()) {\n            detailNode = stack.getFirst();\n            stack.removeFirst();\n\n            if (!visited.contains(detailNode)) {\n                final String childText = detailNode.getText();\n                if (detailNode.getType() != JavadocTokenTypes.LEADING_ASTERISK\n                        && !TOKEN_TEXT_PATTERN.matcher(childText).matches()) {\n                    result.insert(0, detailNode.getText());\n                }\n                visited.add(detailNode);\n            }\n\n            for (DetailNode child : detailNode.getChildren()) {\n                if (child.getParent().equals(node)\n                        && (child.getIndex() < childLeftLimit\n                        || child.getIndex() > childRightLimit)) {\n                    continue;\n                }\n                if (!visited.contains(child)) {\n                    stack.addFirst(child);\n                }\n            }\n        }\n        return result.toString().trim();\n    }\n\n    /**\n     * Create the description text with starting index as 0 and ending index would be the first\n     * valid non zero index amongst in the order of {@code propertySectionStartIdx},\n     * {@code exampleSectionStartIdx} and {@code parentSectionStartIdx}.\n     *\n     * @return description text\n     */\n    private String getDescriptionText() {\n        final int descriptionEndIdx;\n        if (propertySectionStartIdx > -1) {\n            descriptionEndIdx = propertySectionStartIdx;\n        }\n        else if (exampleSectionStartIdx > -1) {\n            descriptionEndIdx = exampleSectionStartIdx;\n        }\n        else {\n            descriptionEndIdx = parentSectionStartIdx;\n        }\n        return constructSubTreeText(rootNode, 0, descriptionEndIdx - 1);\n    }\n\n    /**\n     * Create property default text, which is either normal property value or list of tokens.\n     *\n     * @param nodeLi list item javadoc node\n     * @param defaultValueNode default value node\n     * @return default property text\n     */\n    private static String getPropertyDefaultText(DetailNode nodeLi, DetailNode defaultValueNode) {\n        final Optional<DetailNode> propertyDefaultValueTagNode = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, defaultValueNode.getIndex() + 1);\n        DetailNode propertyDefaultValueTag = null;\n        if (propertyDefaultValueTagNode.isPresent()) {\n            propertyDefaultValueTag = propertyDefaultValueTagNode.get();\n        }\n        final String result;\n        if (propertyDefaultValueTag == null) {\n            final String tokenText = constructSubTreeText(nodeLi,\n                    defaultValueNode.getIndex(), nodeLi.getChildren().length);\n            result = cleanDefaultTokensText(tokenText);\n        }\n        else {\n            result = getTextFromTag(propertyDefaultValueTag);\n        }\n        return result;\n    }\n\n    /**\n     * Get the violation message text for a specific key from the list item.\n     *\n     * @param nodeLi list item javadoc node\n     * @return violation message key text\n     */\n    private static String getViolationMessages(DetailNode nodeLi) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n        return resultNode.map(JavadocMetadataScraper::getTextFromTag).orElse(\"\");\n    }\n\n    /**\n     * Get text from {@code JavadocTokenTypes.JAVADOC_INLINE_TAG}.\n     *\n     * @param nodeTag target javadoc tag\n     * @return text contained by the tag\n     */\n    private static String getTextFromTag(DetailNode nodeTag) {\n        return Optional.ofNullable(nodeTag).map(JavadocMetadataScraper::getText).orElse(\"\");\n    }\n\n    /**\n     * Returns the first child node which matches the provided {@code TokenType} and has the\n     * children index after the offset value.\n     *\n     * @param node parent node\n     * @param tokenType token type to match\n     * @param offset children array index offset\n     * @return the first child satisfying the conditions\n     */\n    private static Optional<DetailNode> getFirstChildOfType(DetailNode node, int tokenType,\n                                                            int offset) {\n        return Arrays.stream(node.getChildren())\n                .filter(child -> child.getIndex() >= offset && child.getType() == tokenType)\n                .findFirst();\n    }\n\n    /**\n     * Get joined text from all text children nodes.\n     *\n     * @param parentNode parent node\n     * @return the joined text of node\n     */\n    private static String getText(DetailNode parentNode) {\n        return Arrays.stream(parentNode.getChildren())\n                .filter(child -> child.getType() == JavadocTokenTypes.TEXT)\n                .map(node -> QUOTE_PATTERN.matcher(node.getText().trim()).replaceAll(\"\"))\n                .collect(Collectors.joining(\" \"));\n    }\n\n    /**\n     * Get first child of parent node matching the provided pattern.\n     *\n     * @param node parent node\n     * @param pattern pattern to match against\n     * @return the first child node matching the condition\n     */\n    private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n                                                                    Pattern pattern) {\n        return Arrays.stream(node.getChildren())\n                .filter(child -> pattern.matcher(child.getText()).matches())\n                .findFirst();\n    }\n\n    /**\n     * Returns parent node, removing modifier/annotation nodes.\n     *\n     * @param commentBlock child node.\n     * @return parent node.\n     */\n    private static DetailAST getParent(DetailAST commentBlock) {\n        final DetailAST parentNode = commentBlock.getParent();\n        DetailAST result = null;\n        if (parentNode != null) {\n            result = parentNode;\n            if (result.getType() == TokenTypes.ANNOTATION) {\n                result = parentNode.getParent().getParent();\n            }\n            else if (result.getType() == TokenTypes.MODIFIERS) {\n                result = parentNode.getParent();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Traverse parents until we reach the root node (@code{JavadocTokenTypes.JAVADOC})\n     * child and return its index.\n     *\n     * @param node subtree child node\n     * @return root node child index\n     */\n    private static int getParentIndexOf(DetailNode node) {\n        DetailNode currNode = node;\n        while (currNode.getParent().getIndex() != -1) {\n            currNode = currNode.getParent();\n        }\n        return currNode.getIndex();\n    }\n\n    /**\n     * Get module parent text from paragraph javadoc node.\n     *\n     * @param nodeParagraph paragraph javadoc node\n     * @return parent text\n     */\n    private static String getParentText(DetailNode nodeParagraph) {\n        String result = null;\n        final Optional<DetailNode> resultNode = getFirstChildOfType(nodeParagraph,\n                JavadocTokenTypes.TEXT, 0);\n        if (resultNode.isPresent()\n                && PARENT_TAG.matcher(resultNode.get().getText()).matches()) {\n            final Optional<DetailNode> childNode = getFirstChildOfType(nodeParagraph,\n                    JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n            if (childNode.isPresent()) {\n                result = getTextFromTag(childNode.get());\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get module type(check/filter/filefilter) based on file name.\n     *\n     * @return module type\n     */\n    private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        final ModuleType result;\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n        return result;\n    }\n\n    /**\n     * Extract simple file name from the whole file path name.\n     *\n     * @return simple module name\n     */\n    private String getModuleSimpleName() {\n        final String fullFileName = getFileContents().getFileName();\n        final String[] pathTokens = FILE_SEPARATOR_PATTERN.split(fullFileName);\n        final String fileName = pathTokens[pathTokens.length - 1];\n        return fileName.substring(0, fileName.length() - JAVA_FILE_EXTENSION.length());\n    }\n\n    /**\n     * Retrieve package name of module from the absolute file path.\n     *\n     * @param filePath absolute file path\n     * @return package name\n     */\n    private static String getPackageName(String filePath) {\n        final Deque<String> result = new ArrayDeque<>();\n        final String[] filePathTokens = FILE_SEPARATOR_PATTERN.split(filePath);\n        for (int i = filePathTokens.length - 1; i >= 0; i--) {\n            if (\"java\".equals(filePathTokens[i]) || \"resources\".equals(filePathTokens[i])) {\n                break;\n            }\n            result.addFirst(filePathTokens[i]);\n        }\n        final String fileName = result.removeLast();\n        result.addLast(fileName.substring(0, fileName.length() - JAVA_FILE_EXTENSION.length()));\n        return String.join(\".\", result);\n    }\n\n    /**\n     * Getter method for {@code moduleDetailsStore}.\n     *\n     * @return map containing module details of supplied checks.\n     */\n    public static Map<String, ModuleDetails> getModuleDetailsStore() {\n        return Collections.unmodifiableMap(MODULE_DETAILS_STORE);\n    }\n\n    /**\n     * Check if the current javadoc block comment AST corresponds to the top-level class as we\n     * only want to scrape top-level class javadoc.\n     *\n     * @return true if the current AST corresponds to top level class\n     */\n    public boolean isTopLevelClassJavadoc() {\n        final DetailAST parent = getParent(getBlockCommentAst());\n        final Optional<DetailAST> className = TokenUtil\n                .findFirstTokenByPredicate(parent, child -> {\n                    return parent.getType() == TokenTypes.CLASS_DEF\n                            && child.getType() == TokenTypes.IDENT;\n                });\n        return className.isPresent()\n                && getModuleSimpleName().equals(className.get().getText());\n    }\n\n    /**\n     * Checks whether the paragraph node corresponds to the example section.\n     *\n     * @param ast javadoc paragraph node\n     * @return true if the section matches the example section marker\n     */\n    private static boolean isExamplesText(DetailNode ast) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(ast, JavadocTokenTypes.TEXT, 0);\n        return resultNode.isPresent()\n                && EXAMPLES_TAG.matcher(resultNode.get().getText()).matches();\n    }\n\n    /**\n     * Checks whether the list item node is part of a property list.\n     *\n     * @param nodeLi {@code JavadocTokenType.LI} node\n     * @return true if the node is part of a property list\n     */\n    private static boolean isPropertyList(DetailNode nodeLi) {\n        final Optional<DetailNode> firstTextChildToken =\n                getFirstChildOfType(nodeLi, JavadocTokenTypes.TEXT, 0);\n        return firstTextChildToken.isPresent()\n                && PROPERTY_TAG.matcher(firstTextChildToken.get().getText()).matches();\n    }\n\n    /**\n     * Checks whether the {@code JavadocTokenType.PARAGRAPH} node is referring to the violation\n     * message keys javadoc segment.\n     *\n     * @param nodeParagraph paragraph javadoc node\n     * @return true if paragraph node contains the violation message keys text\n     */\n    private static boolean isViolationMessagesText(DetailNode nodeParagraph) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(nodeParagraph,\n                JavadocTokenTypes.TEXT, 0);\n        return resultNode.isPresent()\n                && VIOLATION_MESSAGES_TAG.matcher(resultNode.get().getText()).matches();\n    }\n\n    /**\n     * Checks whether the {@code JavadocTokenType.PARAGRAPH} node is referring to the parent\n     * javadoc segment.\n     *\n     * @param nodeParagraph paragraph javadoc node\n     * @return true if paragraph node contains the parent text\n     */\n    private static boolean isParentText(DetailNode nodeParagraph) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(nodeParagraph,\n                JavadocTokenTypes.TEXT, 0);\n        return resultNode.isPresent()\n                && PARENT_TAG.matcher(resultNode.get().getText()).matches();\n    }\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.meta;\n\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.DetailNode;\nimport com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * Class for scraping module metadata from the corresponding class' class-level javadoc.\n */\n@FileStatefulCheck\npublic class JavadocMetadataScraper extends AbstractJavadocCheck {\n\n    /** Module details store used for testing. */\n    private static final Map<String, ModuleDetails> MODULE_DETAILS_STORE = new HashMap<>();\n\n    /** Regular expression for property location in class-level javadocs. */\n    private static final Pattern PROPERTY_TAG = Pattern.compile(\"\\\\s*Property\\\\s*\");\n\n    /** Regular expression for property type location in class-level javadocs. */\n    private static final Pattern TYPE_TAG = Pattern.compile(\"^ Type is\\\\s.*\");\n\n    /** Regular expression for property validation type location in class-level javadocs. */\n    private static final Pattern VALIDATION_TYPE_TAG =\n            Pattern.compile(\"\\\\s.*Validation type is\\\\s.*\");\n\n    /** Regular expression for property default value location in class-level javadocs. */\n    private static final Pattern DEFAULT_VALUE_TAG = Pattern.compile(\"^ Default value is:*.*\");\n\n    /** Regular expression for check example location in class-level javadocs. */\n    private static final Pattern EXAMPLES_TAG =\n            Pattern.compile(\"\\\\s*To configure the (default )?check.*\");\n\n    /** Regular expression for module parent location in class-level javadocs. */\n    private static final Pattern PARENT_TAG = Pattern.compile(\"\\\\s*Parent is\\\\s*\");\n\n    /** Regular expression for module violation messages location in class-level javadocs. */\n    private static final Pattern VIOLATION_MESSAGES_TAG =\n            Pattern.compile(\"\\\\s*Violation Message Keys:\\\\s*\");\n\n    /** Regular expression for detecting ANTLR tokens(for e.g. CLASS_DEF). */\n    private static final Pattern TOKEN_TEXT_PATTERN = Pattern.compile(\"([A-Z_]{2,})+\");\n\n    /** Regular expression for removal of @code{-} present at the beginning of texts. */\n    private static final Pattern DESC_CLEAN = Pattern.compile(\"-\\\\s\");\n\n    /** Regular expression for file separator corresponding to the host OS. */\n    private static final Pattern FILE_SEPARATOR_PATTERN =\n            Pattern.compile(Pattern.quote(System.getProperty(\"file.separator\")));\n\n    /** Regular expression for quotes. */\n    private static final Pattern QUOTE_PATTERN = Pattern.compile(\"\\\"\");\n\n    /** Java file extension. */\n    private static final String JAVA_FILE_EXTENSION = \".java\";\n\n    /**\n     * This set contains faulty property default value which should not be written to the XML\n     * metadata files.\n     */\n    private static final Set<String> PROPERTIES_TO_NOT_WRITE = Collections.unmodifiableSet(\n            new HashSet<>(Arrays.asList(\n                    \"null\",\n                    \"the charset property of the parent <a href=https://checkstyle.org/\"\n                        + \"config.html#Checker>Checker</a> module\"\n    )));\n\n    /**\n     * Format for exception message for missing type for check property.\n     */\n    private static final String PROP_TYPE_MISSING = \"Type for property '%s' is missing\";\n\n    /**\n     * Format for exception message for missing default value for check property.\n     */\n    private static final String PROP_DEFAULT_VALUE_MISSING =\n        \"Default value for property '%s' is missing\";\n\n    /** ModuleDetails instance for each module AST traversal. */\n    private ModuleDetails moduleDetails;\n\n    /**\n     * Boolean variable which lets us know whether violation message section is being scraped\n     * currently.\n     */\n    private boolean scrapingViolationMessageList;\n\n    /**\n     * Boolean variable which lets us know whether we should scan and scrape the current javadoc\n     * or not. Since we need only class level javadoc, it becomes true at its root and false after\n     * encountering {@code JavadocTokenTypes.SINCE_LITERAL}.\n     */\n    private boolean toScan;\n\n    /** DetailNode pointing to the root node of the class level javadoc of the class. */\n    private DetailNode rootNode;\n\n    /**\n     * Child number of the property section node, where parent is the class level javadoc root\n     * node.\n     */\n    private int propertySectionStartIdx;\n\n    /**\n     * Child number of the example section node, where parent is the class level javadoc root\n     * node.\n     */\n    private int exampleSectionStartIdx;\n\n    /**\n     * Child number of the parent section node, where parent is the class level javadoc root\n     * node.\n     */\n    private int parentSectionStartIdx;\n\n    @Override\n    public int[] getDefaultJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.JAVADOC,\n            JavadocTokenTypes.PARAGRAPH,\n            JavadocTokenTypes.LI,\n            JavadocTokenTypes.SINCE_LITERAL,\n        };\n    }\n\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return getAcceptableJavadocTokens();\n    }\n\n    @Override\n    public void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n            moduleDetails = new ModuleDetails();\n            toScan = false;\n            scrapingViolationMessageList = false;\n            propertySectionStartIdx = -1;\n            exampleSectionStartIdx = -1;\n            parentSectionStartIdx = -1;\n\n            final String filePath = getFileContents().getFileName();\n            String moduleName = getModuleSimpleName();\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.contains(checkModuleExtension)) {\n                moduleName = moduleName.substring(0, moduleName.indexOf(checkModuleExtension));\n            }\n            moduleDetails.setName(moduleName);\n            moduleDetails.setFullQualifiedName(getPackageName(filePath));\n            moduleDetails.setModuleType(getModuleType());\n        }\n    }\n\n    @Override\n    public void visitJavadocToken(DetailNode ast) {\n        if (toScan) {\n            scrapeContent(ast);\n        }\n\n        if (ast.getType() == JavadocTokenTypes.JAVADOC) {\n            final DetailAST parent = getParent(getBlockCommentAst());\n            if (parent.getType() == TokenTypes.CLASS_DEF) {\n                rootNode = ast;\n                toScan = true;\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.SINCE_LITERAL) {\n            toScan = false;\n        }\n    }\n\n    @Override\n    public void finishJavadocTree(DetailNode rootAst) {\n        moduleDetails.setDescription(getDescriptionText());\n        if (isTopLevelClassJavadoc()) {\n            if (getFileContents().getFileName().contains(\"test\")) {\n                MODULE_DETAILS_STORE.put(moduleDetails.getFullQualifiedName(), moduleDetails);\n            }\n            else {\n                try {\n                    XmlMetaWriter.write(moduleDetails);\n                }\n                catch (TransformerException | ParserConfigurationException ex) {\n                    throw new IllegalStateException(\"Failed to write metadata into XML file for \"\n                            + \"module: \" + getModuleSimpleName(), ex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method containing the core logic of scraping. This keeps track and decides which phase of\n     * scraping we are in, and accordingly call other subroutines.\n     *\n     * @param ast javadoc ast\n     */\n    public void scrapeContent(DetailNode ast) {\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n            if (isParentText(ast)) {\n                parentSectionStartIdx = getParentIndexOf(ast);\n                moduleDetails.setParent(getParentText(ast));\n            }\n            else if (isViolationMessagesText(ast)) {\n                scrapingViolationMessageList = true;\n            }\n            else if (exampleSectionStartIdx == -1\n                    && isExamplesText(ast)) {\n                exampleSectionStartIdx = getParentIndexOf(ast);\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n            if (isPropertyList(ast)) {\n                if (propertySectionStartIdx == -1) {\n                    propertySectionStartIdx = getParentIndexOf(ast);\n                }\n                moduleDetails.addToProperties(createProperties(ast));\n            }\n            else if (scrapingViolationMessageList) {\n                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n            }\n        }\n    }\n\n    /**\n     * Create the modulePropertyDetails content.\n     *\n     * @param nodeLi list item javadoc node\n     * @return modulePropertyDetail object for the corresponding property\n     */\n    private static ModulePropertyDetails createProperties(DetailNode nodeLi) {\n        final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n\n        final Optional<DetailNode> propertyNameNode = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n        if (propertyNameNode.isPresent()) {\n            final DetailNode propertyNameTag = propertyNameNode.get();\n            final String propertyName = getTextFromTag(propertyNameTag);\n\n            final DetailNode propertyType = getFirstChildOfMatchingText(nodeLi, TYPE_TAG)\n                .orElseThrow(() -> {\n                    return new MetadataGenerationException(String.format(\n                        Locale.ROOT, PROP_TYPE_MISSING, propertyName)\n                    );\n                });\n            final String propertyDesc = DESC_CLEAN.matcher(\n                    constructSubTreeText(nodeLi, propertyNameTag.getIndex() + 1,\n                            propertyType.getIndex() - 1))\n                    .replaceAll(Matcher.quoteReplacement(\"\"));\n\n            modulePropertyDetails.setDescription(propertyDesc.trim());\n            modulePropertyDetails.setName(propertyName);\n            modulePropertyDetails.setType(getTagTextFromProperty(nodeLi, propertyType));\n\n            final Optional<DetailNode> validationTypeNodeOpt = getFirstChildOfMatchingText(nodeLi,\n                VALIDATION_TYPE_TAG);\n            if (validationTypeNodeOpt.isPresent()) {\n                final DetailNode validationTypeNode = validationTypeNodeOpt.get();\n                modulePropertyDetails.setValidationType(getTagTextFromProperty(nodeLi,\n                    validationTypeNode));\n            }\n\n            final String defaultValue = getFirstChildOfMatchingText(nodeLi, DEFAULT_VALUE_TAG)\n                .map(defaultValueNode -> getPropertyDefaultText(nodeLi, defaultValueNode))\n                .orElseThrow(() -> {\n                    return new MetadataGenerationException(String.format(\n                        Locale.ROOT, PROP_DEFAULT_VALUE_MISSING, propertyName)\n                    );\n                });\n            if (!PROPERTIES_TO_NOT_WRITE.contains(defaultValue)) {\n                modulePropertyDetails.setDefaultValue(defaultValue);\n            }\n        }\n        return modulePropertyDetails;\n    }\n\n    /**\n     * Get tag text from property data.\n     *\n     * @param nodeLi javadoc li item node\n     * @param propertyMeta property javadoc node\n     * @return property metadata text\n     */\n    private static String getTagTextFromProperty(DetailNode nodeLi, DetailNode propertyMeta) {\n        final Optional<DetailNode> tagNodeOpt = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, propertyMeta.getIndex() + 1);\n        DetailNode tagNode = null;\n        if (tagNodeOpt.isPresent()) {\n            tagNode = tagNodeOpt.get();\n        }\n        return getTextFromTag(tagNode);\n    }\n\n    /**\n     * Clean up the default token text by removing hyperlinks, and only keeping token type text.\n     *\n     * @param initialText unclean text\n     * @return clean text\n     */\n    private static String cleanDefaultTokensText(String initialText) {\n        final Set<String> tokens = new LinkedHashSet<>();\n        final Matcher matcher = TOKEN_TEXT_PATTERN.matcher(initialText);\n        while (matcher.find()) {\n            tokens.add(matcher.group(0));\n        }\n        return String.join(\",\", tokens);\n    }\n\n    /**\n     * Performs a DFS of the subtree with a node as the root and constructs the text of that\n     * tree, ignoring JavadocToken texts.\n     *\n     * @param node root node of subtree\n     * @param childLeftLimit the left index of root children from where to scan\n     * @param childRightLimit the right index of root children till where to scan\n     * @return constructed text of subtree\n     */\n    private static String constructSubTreeText(DetailNode node, int childLeftLimit,\n                                               int childRightLimit) {\n        final StringBuilder result = new StringBuilder(1024);\n        DetailNode detailNode = node;\n\n        final Deque<DetailNode> stack = new ArrayDeque<>();\n        stack.addFirst(detailNode);\n        final Set<DetailNode> visited = new HashSet<>();\n        while (!stack.isEmpty()) {\n            detailNode = stack.getFirst();\n            stack.removeFirst();\n\n            if (!visited.contains(detailNode)) {\n                final String childText = detailNode.getText();\n                if (detailNode.getType() != JavadocTokenTypes.LEADING_ASTERISK\n                        && !TOKEN_TEXT_PATTERN.matcher(childText).matches()) {\n                    result.insert(0, detailNode.getText());\n                }\n                visited.add(detailNode);\n            }\n\n            for (DetailNode child : detailNode.getChildren()) {\n                if (child.getParent().equals(node)\n                        && (child.getIndex() < childLeftLimit\n                        || child.getIndex() > childRightLimit)) {\n                    continue;\n                }\n                if (!visited.contains(child)) {\n                    stack.addFirst(child);\n                }\n            }\n        }\n        return result.toString().trim();\n    }\n\n    /**\n     * Create the description text with starting index as 0 and ending index would be the first\n     * valid non zero index amongst in the order of {@code propertySectionStartIdx},\n     * {@code exampleSectionStartIdx} and {@code parentSectionStartIdx}.\n     *\n     * @return description text\n     */\n    private String getDescriptionText() {\n        final int descriptionEndIdx;\n        if (propertySectionStartIdx > -1) {\n            descriptionEndIdx = propertySectionStartIdx;\n        }\n        else if (exampleSectionStartIdx > -1) {\n            descriptionEndIdx = exampleSectionStartIdx;\n        }\n        else {\n            descriptionEndIdx = parentSectionStartIdx;\n        }\n        return constructSubTreeText(rootNode, 0, descriptionEndIdx - 1);\n    }\n\n    /**\n     * Create property default text, which is either normal property value or list of tokens.\n     *\n     * @param nodeLi list item javadoc node\n     * @param defaultValueNode default value node\n     * @return default property text\n     */\n    private static String getPropertyDefaultText(DetailNode nodeLi, DetailNode defaultValueNode) {\n        final Optional<DetailNode> propertyDefaultValueTag = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, defaultValueNode.getIndex() + 1);\n        final String result;\n        if (propertyDefaultValueTag.isPresent()) {\n            result = getTextFromTag(propertyDefaultValueTag.get());\n        }\n        else {\n            final String tokenText = constructSubTreeText(nodeLi,\n                    defaultValueNode.getIndex(), nodeLi.getChildren().length);\n            result = cleanDefaultTokensText(tokenText);\n        }\n        return result;\n    }\n\n    /**\n     * Get the violation message text for a specific key from the list item.\n     *\n     * @param nodeLi list item javadoc node\n     * @return violation message key text\n     */\n    private static String getViolationMessages(DetailNode nodeLi) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n        return resultNode.map(JavadocMetadataScraper::getTextFromTag).orElse(\"\");\n    }\n\n    /**\n     * Get text from {@code JavadocTokenTypes.JAVADOC_INLINE_TAG}.\n     *\n     * @param nodeTag target javadoc tag\n     * @return text contained by the tag\n     */\n    private static String getTextFromTag(DetailNode nodeTag) {\n        return Optional.ofNullable(nodeTag).map(JavadocMetadataScraper::getText).orElse(\"\");\n    }\n\n    /**\n     * Returns the first child node which matches the provided {@code TokenType} and has the\n     * children index after the offset value.\n     *\n     * @param node parent node\n     * @param tokenType token type to match\n     * @param offset children array index offset\n     * @return the first child satisfying the conditions\n     */\n    private static Optional<DetailNode> getFirstChildOfType(DetailNode node, int tokenType,\n                                                            int offset) {\n        return Arrays.stream(node.getChildren())\n                .filter(child -> child.getIndex() >= offset && child.getType() == tokenType)\n                .findFirst();\n    }\n\n    /**\n     * Get joined text from all text children nodes.\n     *\n     * @param parentNode parent node\n     * @return the joined text of node\n     */\n    private static String getText(DetailNode parentNode) {\n        return Arrays.stream(parentNode.getChildren())\n                .filter(child -> child.getType() == JavadocTokenTypes.TEXT)\n                .map(node -> QUOTE_PATTERN.matcher(node.getText().trim()).replaceAll(\"\"))\n                .collect(Collectors.joining(\" \"));\n    }\n\n    /**\n     * Get first child of parent node matching the provided pattern.\n     *\n     * @param node parent node\n     * @param pattern pattern to match against\n     * @return the first child node matching the condition\n     */\n    private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n                                                                    Pattern pattern) {\n        return Arrays.stream(node.getChildren())\n                .filter(child -> pattern.matcher(child.getText()).matches())\n                .findFirst();\n    }\n\n    /**\n     * Returns parent node, removing modifier/annotation nodes.\n     *\n     * @param commentBlock child node.\n     * @return parent node.\n     */\n    private static DetailAST getParent(DetailAST commentBlock) {\n        final DetailAST parentNode = commentBlock.getParent();\n        DetailAST result = parentNode;\n        if (result.getType() == TokenTypes.ANNOTATION) {\n            result = parentNode.getParent().getParent();\n        }\n        else if (result.getType() == TokenTypes.MODIFIERS) {\n            result = parentNode.getParent();\n        }\n        return result;\n    }\n\n    /**\n     * Traverse parents until we reach the root node (@code{JavadocTokenTypes.JAVADOC})\n     * child and return its index.\n     *\n     * @param node subtree child node\n     * @return root node child index\n     */\n    private static int getParentIndexOf(DetailNode node) {\n        DetailNode currNode = node;\n        while (currNode.getParent().getIndex() != -1) {\n            currNode = currNode.getParent();\n        }\n        return currNode.getIndex();\n    }\n\n    /**\n     * Get module parent text from paragraph javadoc node.\n     *\n     * @param nodeParagraph paragraph javadoc node\n     * @return parent text\n     */\n    private static String getParentText(DetailNode nodeParagraph) {\n        return getFirstChildOfType(nodeParagraph, JavadocTokenTypes.JAVADOC_INLINE_TAG, 0)\n                .map(JavadocMetadataScraper::getTextFromTag)\n                .orElse(null);\n    }\n\n    /**\n     * Get module type(check/filter/filefilter) based on file name.\n     *\n     * @return module type\n     */\n    private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        final ModuleType result;\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n        return result;\n    }\n\n    /**\n     * Extract simple file name from the whole file path name.\n     *\n     * @return simple module name\n     */\n    private String getModuleSimpleName() {\n        final String fullFileName = getFileContents().getFileName();\n        final String[] pathTokens = FILE_SEPARATOR_PATTERN.split(fullFileName);\n        final String fileName = pathTokens[pathTokens.length - 1];\n        return fileName.substring(0, fileName.length() - JAVA_FILE_EXTENSION.length());\n    }\n\n    /**\n     * Retrieve package name of module from the absolute file path.\n     *\n     * @param filePath absolute file path\n     * @return package name\n     */\n    private static String getPackageName(String filePath) {\n        final Deque<String> result = new ArrayDeque<>();\n        final String[] filePathTokens = FILE_SEPARATOR_PATTERN.split(filePath);\n        for (int i = filePathTokens.length - 1; i >= 0; i--) {\n            if (\"java\".equals(filePathTokens[i]) || \"resources\".equals(filePathTokens[i])) {\n                break;\n            }\n            result.addFirst(filePathTokens[i]);\n        }\n        final String fileName = result.removeLast();\n        result.addLast(fileName.substring(0, fileName.length() - JAVA_FILE_EXTENSION.length()));\n        return String.join(\".\", result);\n    }\n\n    /**\n     * Getter method for {@code moduleDetailsStore}.\n     *\n     * @return map containing module details of supplied checks.\n     */\n    public static Map<String, ModuleDetails> getModuleDetailsStore() {\n        return Collections.unmodifiableMap(MODULE_DETAILS_STORE);\n    }\n\n    /**\n     * Check if the current javadoc block comment AST corresponds to the top-level class as we\n     * only want to scrape top-level class javadoc.\n     *\n     * @return true if the current AST corresponds to top level class\n     */\n    public boolean isTopLevelClassJavadoc() {\n        final DetailAST parent = getParent(getBlockCommentAst());\n        final Optional<DetailAST> className = TokenUtil\n                .findFirstTokenByPredicate(parent, child -> {\n                    return parent.getType() == TokenTypes.CLASS_DEF\n                            && child.getType() == TokenTypes.IDENT;\n                });\n        return className.isPresent()\n                && getModuleSimpleName().equals(className.get().getText());\n    }\n\n    /**\n     * Checks whether the paragraph node corresponds to the example section.\n     *\n     * @param ast javadoc paragraph node\n     * @return true if the section matches the example section marker\n     */\n    private static boolean isExamplesText(DetailNode ast) {\n        return isChildNodeTextMatches(ast, EXAMPLES_TAG);\n    }\n\n    /**\n     * Checks whether the list item node is part of a property list.\n     *\n     * @param nodeLi {@code JavadocTokenType.LI} node\n     * @return true if the node is part of a property list\n     */\n    private static boolean isPropertyList(DetailNode nodeLi) {\n        return isChildNodeTextMatches(nodeLi, PROPERTY_TAG);\n    }\n\n    /**\n     * Checks whether the {@code JavadocTokenType.PARAGRAPH} node is referring to the violation\n     * message keys javadoc segment.\n     *\n     * @param nodeParagraph paragraph javadoc node\n     * @return true if paragraph node contains the violation message keys text\n     */\n    private static boolean isViolationMessagesText(DetailNode nodeParagraph) {\n        return isChildNodeTextMatches(nodeParagraph, VIOLATION_MESSAGES_TAG);\n    }\n\n    /**\n     * Checks whether the {@code JavadocTokenType.PARAGRAPH} node is referring to the parent\n     * javadoc segment.\n     *\n     * @param nodeParagraph paragraph javadoc node\n     * @return true if paragraph node contains the parent text\n     */\n    private static boolean isParentText(DetailNode nodeParagraph) {\n        return isChildNodeTextMatches(nodeParagraph, PARENT_TAG);\n    }\n\n    /**\n     * Checks whether the first child {@code JavadocTokenType.TEXT} node matches given pattern.\n     *\n     * @param ast parent javadoc node\n     * @param pattern pattern to match\n     * @return true if one of child text nodes matches pattern\n     */\n    private static boolean isChildNodeTextMatches(DetailNode ast, Pattern pattern) {\n        return getFirstChildOfType(ast, JavadocTokenTypes.TEXT, 0)\n                .map(DetailNode::getText)\n                .map(pattern::matcher)\n                .map(Matcher::matches)\n                .orElse(false);\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Checks whether the first child {@code JavadocTokenType.TEXT} node matches given pattern.\n     *\n     * @param ast parent javadoc node\n     * @param pattern pattern to match\n     * @return true if one of child text nodes matches pattern\n     */\n    private static boolean isChildNodeTextMatches(DetailNode ast, Pattern pattern) {\n        return getFirstChildOfType(ast, JavadocTokenTypes.TEXT, 0)\n                .map(DetailNode::getText)\n                .map(pattern::matcher)\n                .map(Matcher::matches)\n                .orElse(false);\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper#getText\n methodBody: private static String getText(DetailNode parentNode) {\nreturn Arrays.stream(parentNode.getChildren()).filter(child -> child.getType() == JavadocTokenTypes.TEXT).map(node -> QUOTE_PATTERN.matcher(node.getText().trim()).replaceAll(\"\")).collect(Collectors.joining(\" \"));\n}", "methodSignature: com.puppycrawl.tools.checkstyle.meta.JavadocMetadataScraper#getFirstChildOfType\n methodBody: private static Optional<DetailNode> getFirstChildOfType(DetailNode node, int tokenType,\n                                                            int offset) {\nreturn Arrays.stream(node.getChildren()).filter(child -> child.getIndex() >= offset && child.getType() == tokenType).findFirst();\n}"], "sourceCodeAfterRefactoring": "/**\n     * Checks whether the paragraph node corresponds to the example section.\n     *\n     * @param ast javadoc paragraph node\n     * @return true if the section matches the example section marker\n     */\n    private static boolean isExamplesText(DetailNode ast) {\n        return isChildNodeTextMatches(ast, EXAMPLES_TAG);\n    }\n/**\n     * Checks whether the first child {@code JavadocTokenType.TEXT} node matches given pattern.\n     *\n     * @param ast parent javadoc node\n     * @param pattern pattern to match\n     * @return true if one of child text nodes matches pattern\n     */\n    private static boolean isChildNodeTextMatches(DetailNode ast, Pattern pattern) {\n        return getFirstChildOfType(ast, JavadocTokenTypes.TEXT, 0)\n                .map(DetailNode::getText)\n                .map(pattern::matcher)\n                .map(Matcher::matches)\n                .orElse(false);\n    }", "diffSourceCode": "-  622:      * Check if the current javadoc block comment AST corresponds to the top-level class as we\n-  623:      * only want to scrape top-level class javadoc.\n+  622:     /**\n+  623:      * Checks whether the paragraph node corresponds to the example section.\n   624:      *\n-  625:      * @return true if the current AST corresponds to top level class\n-  626:      */\n-  627:     public boolean isTopLevelClassJavadoc() {\n-  628:         final DetailAST parent = getParent(getBlockCommentAst());\n-  629:         final Optional<DetailAST> className = TokenUtil\n-  630:                 .findFirstTokenByPredicate(parent, child -> {\n-  638:     /**\n-  639:      * Checks whether the paragraph node corresponds to the example section.\n-  640:      *\n-  641:      * @param ast javadoc paragraph node\n-  642:      * @return true if the section matches the example section marker\n-  643:      */\n-  644:     private static boolean isExamplesText(DetailNode ast) {\n-  645:         final Optional<DetailNode> resultNode = getFirstChildOfType(ast, JavadocTokenTypes.TEXT, 0);\n-  646:         return resultNode.isPresent()\n-  647:                 && EXAMPLES_TAG.matcher(resultNode.get().getText()).matches();\n-  648:     }\n-  664:      * Checks whether the {@code JavadocTokenType.PARAGRAPH} node is referring to the violation\n-  665:      * message keys javadoc segment.\n+  625:      * @param ast javadoc paragraph node\n+  626:      * @return true if the section matches the example section marker\n+  627:      */\n+  628:     private static boolean isExamplesText(DetailNode ast) {\n+  629:         return isChildNodeTextMatches(ast, EXAMPLES_TAG);\n+  630:     }\n+  638:     private static boolean isPropertyList(DetailNode nodeLi) {\n+  639:         return isChildNodeTextMatches(nodeLi, PROPERTY_TAG);\n+  640:     }\n+  641: \n+  642:     /**\n+  643:      * Checks whether the {@code JavadocTokenType.PARAGRAPH} node is referring to the violation\n+  644:      * message keys javadoc segment.\n+  645:      *\n+  646:      * @param nodeParagraph paragraph javadoc node\n+  647:      * @return true if paragraph node contains the violation message keys text\n+  648:      */\n+  664:     /**\n+  665:      * Checks whether the first child {@code JavadocTokenType.TEXT} node matches given pattern.\n   666:      *\n-  667:      * @param nodeParagraph paragraph javadoc node\n-  668:      * @return true if paragraph node contains the violation message keys text\n-  669:      */\n-  670:     private static boolean isViolationMessagesText(DetailNode nodeParagraph) {\n-  671:         final Optional<DetailNode> resultNode = getFirstChildOfType(nodeParagraph,\n-  672:                 JavadocTokenTypes.TEXT, 0);\n-  673:         return resultNode.isPresent()\n-  674:                 && VIOLATION_MESSAGES_TAG.matcher(resultNode.get().getText()).matches();\n-  675:     }\n-  676: \n-  677:     /**\n+  667:      * @param ast parent javadoc node\n+  668:      * @param pattern pattern to match\n+  669:      * @return true if one of child text nodes matches pattern\n+  670:      */\n+  671:     private static boolean isChildNodeTextMatches(DetailNode ast, Pattern pattern) {\n+  672:         return getFirstChildOfType(ast, JavadocTokenTypes.TEXT, 0)\n+  673:                 .map(DetailNode::getText)\n+  674:                 .map(pattern::matcher)\n+  675:                 .map(Matcher::matches)\n+  676:                 .orElse(false);\n+  677:     }\n", "uniqueId": "21c8e04bc929aa8e9242810535a9ca3bfee59561_638_648_664_677_622_630", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 20}, "BRANCH": {"missed": 1, "covered": 3}, "LINE": {"missed": 0, "covered": 3}, "COMPLEXITY": {"missed": 1, "covered": 2}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nRefactored Method Code:\n##########################\n/**\n * Extracts the text content from a given Javadoc inline tag node.\n *\n * @param nodeTag the Javadoc inline tag node\n * @return the text content of the tag\n */\nprivate static String extractTextFromTag(DetailNode nodeTag) {\n    return Optional.ofNullable(nodeTag).map(tag -> tag.getText()).orElse(\"\");\n}\n```", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Checks whether the paragraph node corresponds to the example section.\n     *\n     * @param ast javadoc paragraph node\n     * @return true if the section matches the example section marker\n     */\n    private static boolean isExamplesText(DetailNode ast) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(ast, JavadocTokenTypes.TEXT, 0);\n        return resultNode.isPresent()\n                && EXAMPLES_TAG.matcher(resultNode.get().getText()).matches();\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.meta;\n\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.TransformerException;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.DetailNode;\nimport com.puppycrawl.tools.checkstyle.api.JavadocTokenTypes;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.AbstractJavadocCheck;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * Class for scraping module metadata from the corresponding class' class-level javadoc.\n */\n@FileStatefulCheck\npublic class JavadocMetadataScraper extends AbstractJavadocCheck {\n\n    /** Module details store used for testing. */\n    private static final Map<String, ModuleDetails> MODULE_DETAILS_STORE = new HashMap<>();\n\n    /** Regular expression for property location in class-level javadocs. */\n    private static final Pattern PROPERTY_TAG = Pattern.compile(\"\\\\s*Property\\\\s*\");\n\n    /** Regular expression for property type location in class-level javadocs. */\n    private static final Pattern TYPE_TAG = Pattern.compile(\"^ Type is\\\\s.*\");\n\n    /** Regular expression for property validation type location in class-level javadocs. */\n    private static final Pattern VALIDATION_TYPE_TAG =\n            Pattern.compile(\"\\\\s.*Validation type is\\\\s.*\");\n\n    /** Regular expression for property default value location in class-level javadocs. */\n    private static final Pattern DEFAULT_VALUE_TAG = Pattern.compile(\"^ Default value is:*.*\");\n\n    /** Regular expression for check example location in class-level javadocs. */\n    private static final Pattern EXAMPLES_TAG =\n            Pattern.compile(\"\\\\s*To configure the (default )?check.*\");\n\n    /** Regular expression for module parent location in class-level javadocs. */\n    private static final Pattern PARENT_TAG = Pattern.compile(\"\\\\s*Parent is\\\\s*\");\n\n    /** Regular expression for module violation messages location in class-level javadocs. */\n    private static final Pattern VIOLATION_MESSAGES_TAG =\n            Pattern.compile(\"\\\\s*Violation Message Keys:\\\\s*\");\n\n    /** Regular expression for detecting ANTLR tokens(for e.g. CLASS_DEF). */\n    private static final Pattern TOKEN_TEXT_PATTERN = Pattern.compile(\"([A-Z_]{2,})+\");\n\n    /** Regular expression for removal of @code{-} present at the beginning of texts. */\n    private static final Pattern DESC_CLEAN = Pattern.compile(\"-\\\\s\");\n\n    /** Regular expression for file separator corresponding to the host OS. */\n    private static final Pattern FILE_SEPARATOR_PATTERN =\n            Pattern.compile(Pattern.quote(System.getProperty(\"file.separator\")));\n\n    /** Regular expression for quotes. */\n    private static final Pattern QUOTE_PATTERN = Pattern.compile(\"\\\"\");\n\n    /** Java file extension. */\n    private static final String JAVA_FILE_EXTENSION = \".java\";\n\n    /**\n     * This set contains faulty property default value which should not be written to the XML\n     * metadata files.\n     */\n    private static final Set<String> PROPERTIES_TO_NOT_WRITE = Collections.unmodifiableSet(\n            new HashSet<>(Arrays.asList(\n                    \"null\",\n                    \"the charset property of the parent <a href=https://checkstyle.org/\"\n                        + \"config.html#Checker>Checker</a> module\"\n    )));\n\n    /**\n     * Format for exception message for missing type for check property.\n     */\n    private static final String PROP_TYPE_MISSING = \"Type for property '%s' is missing\";\n\n    /**\n     * Format for exception message for missing default value for check property.\n     */\n    private static final String PROP_DEFAULT_VALUE_MISSING =\n        \"Default value for property '%s' is missing\";\n\n    /** ModuleDetails instance for each module AST traversal. */\n    private ModuleDetails moduleDetails;\n\n    /**\n     * Boolean variable which lets us know whether violation message section is being scraped\n     * currently.\n     */\n    private boolean scrapingViolationMessageList;\n\n    /**\n     * Boolean variable which lets us know whether we should scan and scrape the current javadoc\n     * or not. Since we need only class level javadoc, it becomes true at its root and false after\n     * encountering {@code JavadocTokenTypes.SINCE_LITERAL}.\n     */\n    private boolean toScan;\n\n    /** DetailNode pointing to the root node of the class level javadoc of the class. */\n    private DetailNode rootNode;\n\n    /**\n     * Child number of the property section node, where parent is the class level javadoc root\n     * node.\n     */\n    private int propertySectionStartIdx;\n\n    /**\n     * Child number of the example section node, where parent is the class level javadoc root\n     * node.\n     */\n    private int exampleSectionStartIdx;\n\n    /**\n     * Child number of the parent section node, where parent is the class level javadoc root\n     * node.\n     */\n    private int parentSectionStartIdx;\n\n    @Override\n    public int[] getDefaultJavadocTokens() {\n        return new int[] {\n            JavadocTokenTypes.JAVADOC,\n            JavadocTokenTypes.PARAGRAPH,\n            JavadocTokenTypes.LI,\n            JavadocTokenTypes.SINCE_LITERAL,\n        };\n    }\n\n    @Override\n    public int[] getRequiredJavadocTokens() {\n        return getAcceptableJavadocTokens();\n    }\n\n    @Override\n    public void beginJavadocTree(DetailNode rootAst) {\n        if (isTopLevelClassJavadoc()) {\n            moduleDetails = new ModuleDetails();\n            toScan = false;\n            scrapingViolationMessageList = false;\n            propertySectionStartIdx = -1;\n            exampleSectionStartIdx = -1;\n            parentSectionStartIdx = -1;\n\n            final String filePath = getFileContents().getFileName();\n            String moduleName = getModuleSimpleName();\n            final String checkModuleExtension = \"Check\";\n            if (moduleName.contains(checkModuleExtension)) {\n                moduleName = moduleName.substring(0, moduleName.indexOf(checkModuleExtension));\n            }\n            moduleDetails.setName(moduleName);\n            moduleDetails.setFullQualifiedName(getPackageName(filePath));\n            moduleDetails.setModuleType(getModuleType());\n        }\n    }\n\n    @Override\n    public void visitJavadocToken(DetailNode ast) {\n        if (toScan) {\n            scrapeContent(ast);\n        }\n\n        if (ast.getType() == JavadocTokenTypes.JAVADOC) {\n            final DetailAST parent = getParent(getBlockCommentAst());\n            if (parent != null && parent.getType() == TokenTypes.CLASS_DEF) {\n                rootNode = ast;\n                toScan = true;\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.SINCE_LITERAL) {\n            toScan = false;\n        }\n    }\n\n    @Override\n    public void finishJavadocTree(DetailNode rootAst) {\n        moduleDetails.setDescription(getDescriptionText());\n        if (isTopLevelClassJavadoc()) {\n            if (getFileContents().getFileName().contains(\"test\")) {\n                MODULE_DETAILS_STORE.put(moduleDetails.getFullQualifiedName(), moduleDetails);\n            }\n            else {\n                try {\n                    XmlMetaWriter.write(moduleDetails);\n                }\n                catch (TransformerException | ParserConfigurationException ex) {\n                    throw new IllegalStateException(\"Failed to write metadata into XML file for \"\n                            + \"module: \" + getModuleSimpleName(), ex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Method containing the core logic of scraping. This keeps track and decides which phase of\n     * scraping we are in, and accordingly call other subroutines.\n     *\n     * @param ast javadoc ast\n     */\n    public void scrapeContent(DetailNode ast) {\n        if (ast.getType() == JavadocTokenTypes.PARAGRAPH) {\n            if (isParentText(ast)) {\n                parentSectionStartIdx = getParentIndexOf(ast);\n                moduleDetails.setParent(getParentText(ast));\n            }\n            else if (isViolationMessagesText(ast)) {\n                scrapingViolationMessageList = true;\n            }\n            else if (exampleSectionStartIdx == -1\n                    && isExamplesText(ast)) {\n                exampleSectionStartIdx = getParentIndexOf(ast);\n            }\n        }\n        else if (ast.getType() == JavadocTokenTypes.LI) {\n            if (isPropertyList(ast)) {\n                if (propertySectionStartIdx == -1) {\n                    propertySectionStartIdx = getParentIndexOf(ast);\n                }\n                moduleDetails.addToProperties(createProperties(ast));\n            }\n            else if (scrapingViolationMessageList) {\n                moduleDetails.addToViolationMessages(getViolationMessages(ast));\n            }\n        }\n    }\n\n    /**\n     * Create the modulePropertyDetails content.\n     *\n     * @param nodeLi list item javadoc node\n     * @return modulePropertyDetail object for the corresponding property\n     */\n    private static ModulePropertyDetails createProperties(DetailNode nodeLi) {\n        final ModulePropertyDetails modulePropertyDetails = new ModulePropertyDetails();\n\n        final Optional<DetailNode> propertyNameNode = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n        if (propertyNameNode.isPresent()) {\n            final DetailNode propertyNameTag = propertyNameNode.get();\n            final String propertyName = getTextFromTag(propertyNameTag);\n\n            final DetailNode propertyType = getFirstChildOfMatchingText(nodeLi, TYPE_TAG)\n                .orElseThrow(() -> {\n                    return new MetadataGenerationException(String.format(\n                        Locale.ROOT, PROP_TYPE_MISSING, propertyName)\n                    );\n                });\n            final String propertyDesc = DESC_CLEAN.matcher(\n                    constructSubTreeText(nodeLi, propertyNameTag.getIndex() + 1,\n                            propertyType.getIndex() - 1))\n                    .replaceAll(Matcher.quoteReplacement(\"\"));\n\n            modulePropertyDetails.setDescription(propertyDesc.trim());\n            modulePropertyDetails.setName(propertyName);\n            modulePropertyDetails.setType(getTagTextFromProperty(nodeLi, propertyType));\n\n            final Optional<DetailNode> validationTypeNodeOpt = getFirstChildOfMatchingText(nodeLi,\n                VALIDATION_TYPE_TAG);\n            if (validationTypeNodeOpt.isPresent()) {\n                final DetailNode validationTypeNode = validationTypeNodeOpt.get();\n                modulePropertyDetails.setValidationType(getTagTextFromProperty(nodeLi,\n                    validationTypeNode));\n            }\n\n            final String defaultValue = getFirstChildOfMatchingText(nodeLi, DEFAULT_VALUE_TAG)\n                .map(defaultValueNode -> getPropertyDefaultText(nodeLi, defaultValueNode))\n                .orElseThrow(() -> {\n                    return new MetadataGenerationException(String.format(\n                        Locale.ROOT, PROP_DEFAULT_VALUE_MISSING, propertyName)\n                    );\n                });\n            if (!PROPERTIES_TO_NOT_WRITE.contains(defaultValue)) {\n                modulePropertyDetails.setDefaultValue(defaultValue);\n            }\n        }\n        return modulePropertyDetails;\n    }\n\n    /**\n     * Get tag text from property data.\n     *\n     * @param nodeLi javadoc li item node\n     * @param propertyMeta property javadoc node\n     * @return property metadata text\n     */\n    private static String getTagTextFromProperty(DetailNode nodeLi, DetailNode propertyMeta) {\n        final Optional<DetailNode> tagNodeOpt = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, propertyMeta.getIndex() + 1);\n        DetailNode tagNode = null;\n        if (tagNodeOpt.isPresent()) {\n            tagNode = tagNodeOpt.get();\n        }\n        return getTextFromTag(tagNode);\n    }\n\n    /**\n     * Clean up the default token text by removing hyperlinks, and only keeping token type text.\n     *\n     * @param initialText unclean text\n     * @return clean text\n     */\n    private static String cleanDefaultTokensText(String initialText) {\n        final Set<String> tokens = new LinkedHashSet<>();\n        final Matcher matcher = TOKEN_TEXT_PATTERN.matcher(initialText);\n        while (matcher.find()) {\n            tokens.add(matcher.group(0));\n        }\n        return String.join(\",\", tokens);\n    }\n\n    /**\n     * Performs a DFS of the subtree with a node as the root and constructs the text of that\n     * tree, ignoring JavadocToken texts.\n     *\n     * @param node root node of subtree\n     * @param childLeftLimit the left index of root children from where to scan\n     * @param childRightLimit the right index of root children till where to scan\n     * @return constructed text of subtree\n     */\n    private static String constructSubTreeText(DetailNode node, int childLeftLimit,\n                                               int childRightLimit) {\n        final StringBuilder result = new StringBuilder(1024);\n        DetailNode detailNode = node;\n\n        final Deque<DetailNode> stack = new ArrayDeque<>();\n        stack.addFirst(detailNode);\n        final Set<DetailNode> visited = new HashSet<>();\n        while (!stack.isEmpty()) {\n            detailNode = stack.getFirst();\n            stack.removeFirst();\n\n            if (!visited.contains(detailNode)) {\n                final String childText = detailNode.getText();\n                if (detailNode.getType() != JavadocTokenTypes.LEADING_ASTERISK\n                        && !TOKEN_TEXT_PATTERN.matcher(childText).matches()) {\n                    result.insert(0, detailNode.getText());\n                }\n                visited.add(detailNode);\n            }\n\n            for (DetailNode child : detailNode.getChildren()) {\n                if (child.getParent().equals(node)\n                        && (child.getIndex() < childLeftLimit\n                        || child.getIndex() > childRightLimit)) {\n                    continue;\n                }\n                if (!visited.contains(child)) {\n                    stack.addFirst(child);\n                }\n            }\n        }\n        return result.toString().trim();\n    }\n\n    /**\n     * Create the description text with starting index as 0 and ending index would be the first\n     * valid non zero index amongst in the order of {@code propertySectionStartIdx},\n     * {@code exampleSectionStartIdx} and {@code parentSectionStartIdx}.\n     *\n     * @return description text\n     */\n    private String getDescriptionText() {\n        final int descriptionEndIdx;\n        if (propertySectionStartIdx > -1) {\n            descriptionEndIdx = propertySectionStartIdx;\n        }\n        else if (exampleSectionStartIdx > -1) {\n            descriptionEndIdx = exampleSectionStartIdx;\n        }\n        else {\n            descriptionEndIdx = parentSectionStartIdx;\n        }\n        return constructSubTreeText(rootNode, 0, descriptionEndIdx - 1);\n    }\n\n    /**\n     * Create property default text, which is either normal property value or list of tokens.\n     *\n     * @param nodeLi list item javadoc node\n     * @param defaultValueNode default value node\n     * @return default property text\n     */\n    private static String getPropertyDefaultText(DetailNode nodeLi, DetailNode defaultValueNode) {\n        final Optional<DetailNode> propertyDefaultValueTagNode = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, defaultValueNode.getIndex() + 1);\n        DetailNode propertyDefaultValueTag = null;\n        if (propertyDefaultValueTagNode.isPresent()) {\n            propertyDefaultValueTag = propertyDefaultValueTagNode.get();\n        }\n        final String result;\n        if (propertyDefaultValueTag == null) {\n            final String tokenText = constructSubTreeText(nodeLi,\n                    defaultValueNode.getIndex(), nodeLi.getChildren().length);\n            result = cleanDefaultTokensText(tokenText);\n        }\n        else {\n            result = getTextFromTag(propertyDefaultValueTag);\n        }\n        return result;\n    }\n\n    /**\n     * Get the violation message text for a specific key from the list item.\n     *\n     * @param nodeLi list item javadoc node\n     * @return violation message key text\n     */\n    private static String getViolationMessages(DetailNode nodeLi) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(nodeLi,\n                JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n        return resultNode.map(JavadocMetadataScraper::getTextFromTag).orElse(\"\");\n    }\n\n    /**\n     * Get text from {@code JavadocTokenTypes.JAVADOC_INLINE_TAG}.\n     *\n     * @param nodeTag target javadoc tag\n     * @return text contained by the tag\n     */\n    private static String getTextFromTag(DetailNode nodeTag) {\n        return Optional.ofNullable(nodeTag).map(JavadocMetadataScraper::getText).orElse(\"\");\n    }\n\n    /**\n     * Returns the first child node which matches the provided {@code TokenType} and has the\n     * children index after the offset value.\n     *\n     * @param node parent node\n     * @param tokenType token type to match\n     * @param offset children array index offset\n     * @return the first child satisfying the conditions\n     */\n    private static Optional<DetailNode> getFirstChildOfType(DetailNode node, int tokenType,\n                                                            int offset) {\n        return Arrays.stream(node.getChildren())\n                .filter(child -> child.getIndex() >= offset && child.getType() == tokenType)\n                .findFirst();\n    }\n\n    /**\n     * Get joined text from all text children nodes.\n     *\n     * @param parentNode parent node\n     * @return the joined text of node\n     */\n    private static String getText(DetailNode parentNode) {\n        return Arrays.stream(parentNode.getChildren())\n                .filter(child -> child.getType() == JavadocTokenTypes.TEXT)\n                .map(node -> QUOTE_PATTERN.matcher(node.getText().trim()).replaceAll(\"\"))\n                .collect(Collectors.joining(\" \"));\n    }\n\n    /**\n     * Get first child of parent node matching the provided pattern.\n     *\n     * @param node parent node\n     * @param pattern pattern to match against\n     * @return the first child node matching the condition\n     */\n    private static Optional<DetailNode> getFirstChildOfMatchingText(DetailNode node,\n                                                                    Pattern pattern) {\n        return Arrays.stream(node.getChildren())\n                .filter(child -> pattern.matcher(child.getText()).matches())\n                .findFirst();\n    }\n\n    /**\n     * Returns parent node, removing modifier/annotation nodes.\n     *\n     * @param commentBlock child node.\n     * @return parent node.\n     */\n    private static DetailAST getParent(DetailAST commentBlock) {\n        final DetailAST parentNode = commentBlock.getParent();\n        DetailAST result = null;\n        if (parentNode != null) {\n            result = parentNode;\n            if (result.getType() == TokenTypes.ANNOTATION) {\n                result = parentNode.getParent().getParent();\n            }\n            else if (result.getType() == TokenTypes.MODIFIERS) {\n                result = parentNode.getParent();\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Traverse parents until we reach the root node (@code{JavadocTokenTypes.JAVADOC})\n     * child and return its index.\n     *\n     * @param node subtree child node\n     * @return root node child index\n     */\n    private static int getParentIndexOf(DetailNode node) {\n        DetailNode currNode = node;\n        while (currNode.getParent().getIndex() != -1) {\n            currNode = currNode.getParent();\n        }\n        return currNode.getIndex();\n    }\n\n    /**\n     * Get module parent text from paragraph javadoc node.\n     *\n     * @param nodeParagraph paragraph javadoc node\n     * @return parent text\n     */\n    private static String getParentText(DetailNode nodeParagraph) {\n        String result = null;\n        final Optional<DetailNode> resultNode = getFirstChildOfType(nodeParagraph,\n                JavadocTokenTypes.TEXT, 0);\n        if (resultNode.isPresent()\n                && PARENT_TAG.matcher(resultNode.get().getText()).matches()) {\n            final Optional<DetailNode> childNode = getFirstChildOfType(nodeParagraph,\n                    JavadocTokenTypes.JAVADOC_INLINE_TAG, 0);\n            if (childNode.isPresent()) {\n                result = getTextFromTag(childNode.get());\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get module type(check/filter/filefilter) based on file name.\n     *\n     * @return module type\n     */\n    private ModuleType getModuleType() {\n        final String simpleModuleName = getModuleSimpleName();\n        final ModuleType result;\n        if (simpleModuleName.endsWith(\"FileFilter\")) {\n            result = ModuleType.FILEFILTER;\n        }\n        else if (simpleModuleName.endsWith(\"Filter\")) {\n            result = ModuleType.FILTER;\n        }\n        else {\n            result = ModuleType.CHECK;\n        }\n        return result;\n    }\n\n    /**\n     * Extract simple file name from the whole file path name.\n     *\n     * @return simple module name\n     */\n    private String getModuleSimpleName() {\n        final String fullFileName = getFileContents().getFileName();\n        final String[] pathTokens = FILE_SEPARATOR_PATTERN.split(fullFileName);\n        final String fileName = pathTokens[pathTokens.length - 1];\n        return fileName.substring(0, fileName.length() - JAVA_FILE_EXTENSION.length());\n    }\n\n    /**\n     * Retrieve package name of module from the absolute file path.\n     *\n     * @param filePath absolute file path\n     * @return package name\n     */\n    private static String getPackageName(String filePath) {\n        final Deque<String> result = new ArrayDeque<>();\n        final String[] filePathTokens = FILE_SEPARATOR_PATTERN.split(filePath);\n        for (int i = filePathTokens.length - 1; i >= 0; i--) {\n            if (\"java\".equals(filePathTokens[i]) || \"resources\".equals(filePathTokens[i])) {\n                break;\n            }\n            result.addFirst(filePathTokens[i]);\n        }\n        final String fileName = result.removeLast();\n        result.addLast(fileName.substring(0, fileName.length() - JAVA_FILE_EXTENSION.length()));\n        return String.join(\".\", result);\n    }\n\n    /**\n     * Getter method for {@code moduleDetailsStore}.\n     *\n     * @return map containing module details of supplied checks.\n     */\n    public static Map<String, ModuleDetails> getModuleDetailsStore() {\n        return Collections.unmodifiableMap(MODULE_DETAILS_STORE);\n    }\n\n    /**\n     * Check if the current javadoc block comment AST corresponds to the top-level class as we\n     * only want to scrape top-level class javadoc.\n     *\n     * @return true if the current AST corresponds to top level class\n     */\n    public boolean isTopLevelClassJavadoc() {\n        final DetailAST parent = getParent(getBlockCommentAst());\n        final Optional<DetailAST> className = TokenUtil\n                .findFirstTokenByPredicate(parent, child -> {\n                    return parent.getType() == TokenTypes.CLASS_DEF\n                            && child.getType() == TokenTypes.IDENT;\n                });\n        return className.isPresent()\n                && getModuleSimpleName().equals(className.get().getText());\n    }\n\n    /**\n     * Checks whether the paragraph node corresponds to the example section.\n     *\n     * @param ast javadoc paragraph node\n     * @return true if the section matches the example section marker\n     */\n    private static boolean isExamplesText(DetailNode ast) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(ast, JavadocTokenTypes.TEXT, 0);\n        return resultNode.isPresent()\n                && EXAMPLES_TAG.matcher(resultNode.get().getText()).matches();\n    }\n\n    /**\n     * Checks whether the list item node is part of a property list.\n     *\n     * @param nodeLi {@code JavadocTokenType.LI} node\n     * @return true if the node is part of a property list\n     */\n    private static boolean isPropertyList(DetailNode nodeLi) {\n        final Optional<DetailNode> firstTextChildToken =\n                getFirstChildOfType(nodeLi, JavadocTokenTypes.TEXT, 0);\n        return firstTextChildToken.isPresent()\n                && PROPERTY_TAG.matcher(firstTextChildToken.get().getText()).matches();\n    }\n\n    /**\n     * Checks whether the {@code JavadocTokenType.PARAGRAPH} node is referring to the violation\n     * message keys javadoc segment.\n     *\n     * @param nodeParagraph paragraph javadoc node\n     * @return true if paragraph node contains the violation message keys text\n     */\n    private static boolean isViolationMessagesText(DetailNode nodeParagraph) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(nodeParagraph,\n                JavadocTokenTypes.TEXT, 0);\n        return resultNode.isPresent()\n                && VIOLATION_MESSAGES_TAG.matcher(resultNode.get().getText()).matches();\n    }\n\n    /**\n     * Checks whether the {@code JavadocTokenType.PARAGRAPH} node is referring to the parent\n     * javadoc segment.\n     *\n     * @param nodeParagraph paragraph javadoc node\n     * @return true if paragraph node contains the parent text\n     */\n    private static boolean isParentText(DetailNode nodeParagraph) {\n        final Optional<DetailNode> resultNode = getFirstChildOfType(nodeParagraph,\n                JavadocTokenTypes.TEXT, 0);\n        return resultNode.isPresent()\n                && PARENT_TAG.matcher(resultNode.get().getText()).matches();\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic addDeclaredType(type String) : void extracted from private processIdent(ast DetailAST) : void in class com.puppycrawl.tools.checkstyle.checks.imports.UnusedImportsCheck & moved to class com.puppycrawl.tools.checkstyle.checks.imports.UnusedImportsCheck.Frame", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java", "startLine": 240, "endLine": 254, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java", "startLine": 262, "endLine": 277, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java", "startLine": 432, "endLine": 439, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Collects references made by IDENT.\n     *\n     * @param ast the IDENT node to process\n     */\n    private void processIdent(DetailAST ast) {\n        final DetailAST parent = ast.getParent();\n        final int parentType = parent.getType();\n        if (parentType != TokenTypes.DOT\n            && parentType != TokenTypes.METHOD_DEF\n            || parentType == TokenTypes.DOT\n                && ast.getNextSibling() != null) {\n            referenced.add(ast.getText());\n        }\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java", "isPureRefactoring": true, "commitId": "ba76f3e4f33194b0a1d687e95a58395bd9590321", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.imports", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.imports.UnusedImportsCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.imports.UnusedImportsCheck#processIdent", "classSignatureBefore": "public class UnusedImportsCheck extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.imports.UnusedImportsCheck#processIdent"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.imports.UnusedImportsCheck"], "classSignatureBeforeSet": ["public class UnusedImportsCheck extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Move Attribute-", "description": "Move Attribute on top of the extracted method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.imports;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FileContents;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TextBlock;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.JavadocTag;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n\n/**\n * <p>\n * Checks for unused import statements. Checkstyle uses a simple but very\n * reliable algorithm to report on unused import statements. An import statement\n * is considered unused if:\n * </p>\n * <ul>\n * <li>\n * It is not referenced in the file. The algorithm does not support wild-card\n * imports like {@code import java.io.*;}. Most IDE's provide very sophisticated\n * checks for imports that handle wild-card imports.\n * </li>\n * <li>\n * It is a duplicate of another import. This is when a class is imported more\n * than once.\n * </li>\n * <li>\n * The class imported is from the {@code java.lang} package. For example\n * importing {@code java.lang.String}.\n * </li>\n * <li>\n * The class imported is from the same package.\n * </li>\n * <li>\n * <b>Optionally:</b> it is referenced in Javadoc comments. This check is on by\n * default, but it is considered bad practice to introduce a compile time\n * dependency for documentation purposes only. As an example, the import\n * {@code java.util.List} would be considered referenced with the Javadoc\n * comment {@code {@link List}}. The alternative to avoid introducing a compile\n * time dependency would be to write the Javadoc comment as {@code {&#64;link java.util.List}}.\n * </li>\n * </ul>\n * <p>\n * The main limitation of this check is handling the case where an imported type\n * has the same name as a declaration, such as a member variable.\n * </p>\n * <p>\n * For example, in the following case the import {@code java.awt.Component}\n * will not be flagged as unused:\n * </p>\n * <pre>\n * import java.awt.Component;\n * class FooBar {\n *   private Object Component; // a bad practice in my opinion\n *   ...\n * }\n * </pre>\n * <ul>\n * <li>\n * Property {@code processJavadoc} - Control whether to process Javadoc comments.\n * Type is {@code boolean}.\n * Default value is {@code true}.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=\"UnusedImports\"/&gt;\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code import.unused}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@FileStatefulCheck\npublic class UnusedImportsCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"import.unused\";\n\n    /** Regex to match class names. */\n    private static final Pattern CLASS_NAME = CommonUtil.createPattern(\n           \"((:?[\\\\p{L}_$][\\\\p{L}\\\\p{N}_$]*\\\\.)*[\\\\p{L}_$][\\\\p{L}\\\\p{N}_$]*)\");\n    /** Regex to match the first class name. */\n    private static final Pattern FIRST_CLASS_NAME = CommonUtil.createPattern(\n           \"^\" + CLASS_NAME);\n    /** Regex to match argument names. */\n    private static final Pattern ARGUMENT_NAME = CommonUtil.createPattern(\n           \"[(,]\\\\s*\" + CLASS_NAME.pattern());\n\n    /** Regexp pattern to match java.lang package. */\n    private static final Pattern JAVA_LANG_PACKAGE_PATTERN =\n        CommonUtil.createPattern(\"^java\\\\.lang\\\\.[a-zA-Z]+$\");\n\n    /** Suffix for the star import. */\n    private static final String STAR_IMPORT_SUFFIX = \".*\";\n\n    /** Set of the imports. */\n    private final Set<FullIdent> imports = new HashSet<>();\n\n    /** Set of references - possibly to imports or other things. */\n    private final Set<String> referenced = new HashSet<>();\n\n    /** Flag to indicate when time to start collecting references. */\n    private boolean collect;\n    /** Control whether to process Javadoc comments. */\n    private boolean processJavadoc = true;\n\n    /**\n     * Setter to control whether to process Javadoc comments.\n     *\n     * @param value Flag for processing Javadoc comments.\n     */\n    public void setProcessJavadoc(boolean value) {\n        processJavadoc = value;\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        collect = false;\n        imports.clear();\n        referenced.clear();\n    }\n\n    @Override\n    public void finishTree(DetailAST rootAST) {\n        // loop over all the imports to see if referenced.\n        imports.stream()\n            .filter(imprt -> isUnusedImport(imprt.getText()))\n            .forEach(imprt -> log(imprt.getDetailAst(), MSG_KEY, imprt.getText()));\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.IDENT,\n            TokenTypes.IMPORT,\n            TokenTypes.STATIC_IMPORT,\n            // Definitions that may contain Javadoc...\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.ANNOTATION_FIELD_DEF,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.ENUM_CONSTANT_DEF,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.RECORD_DEF,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.IDENT) {\n            if (collect) {\n                processIdent(ast);\n            }\n        }\n        else if (ast.getType() == TokenTypes.IMPORT) {\n            processImport(ast);\n        }\n        else if (ast.getType() == TokenTypes.STATIC_IMPORT) {\n            processStaticImport(ast);\n        }\n        else {\n            collect = true;\n            if (processJavadoc) {\n                collectReferencesFromJavadoc(ast);\n            }\n        }\n    }\n\n    /**\n     * Checks whether an import is unused.\n     *\n     * @param imprt an import.\n     * @return true if an import is unused.\n     */\n    private boolean isUnusedImport(String imprt) {\n        final Matcher javaLangPackageMatcher = JAVA_LANG_PACKAGE_PATTERN.matcher(imprt);\n        return !referenced.contains(CommonUtil.baseClassName(imprt))\n            || javaLangPackageMatcher.matches();\n    }\n\n    /**\n     * Collects references made by IDENT.\n     *\n     * @param ast the IDENT node to process\n     */\n    private void processIdent(DetailAST ast) {\n        final DetailAST parent = ast.getParent();\n        final int parentType = parent.getType();\n        if (parentType != TokenTypes.DOT\n            && parentType != TokenTypes.METHOD_DEF\n            || parentType == TokenTypes.DOT\n                && ast.getNextSibling() != null) {\n            referenced.add(ast.getText());\n        }\n    }\n\n    /**\n     * Collects the details of imports.\n     *\n     * @param ast node containing the import details\n     */\n    private void processImport(DetailAST ast) {\n        final FullIdent name = FullIdent.createFullIdentBelow(ast);\n        if (!name.getText().endsWith(STAR_IMPORT_SUFFIX)) {\n            imports.add(name);\n        }\n    }\n\n    /**\n     * Collects the details of static imports.\n     *\n     * @param ast node containing the static import details\n     */\n    private void processStaticImport(DetailAST ast) {\n        final FullIdent name =\n            FullIdent.createFullIdent(\n                ast.getFirstChild().getNextSibling());\n        if (!name.getText().endsWith(STAR_IMPORT_SUFFIX)) {\n            imports.add(name);\n        }\n    }\n\n    /**\n     * Collects references made in Javadoc comments.\n     *\n     * @param ast node to inspect for Javadoc\n     */\n    private void collectReferencesFromJavadoc(DetailAST ast) {\n        final FileContents contents = getFileContents();\n        final int lineNo = ast.getLineNo();\n        final TextBlock textBlock = contents.getJavadocBefore(lineNo);\n        if (textBlock != null) {\n            referenced.addAll(collectReferencesFromJavadoc(textBlock));\n        }\n    }\n\n    /**\n     * Process a javadoc {@link TextBlock} and return the set of classes\n     * referenced within.\n     *\n     * @param textBlock The javadoc block to parse\n     * @return a set of classes referenced in the javadoc block\n     */\n    private static Set<String> collectReferencesFromJavadoc(TextBlock textBlock) {\n        final List<JavadocTag> tags = new ArrayList<>();\n        // gather all the inline tags, like @link\n        // INLINE tags inside BLOCKs get hidden when using ALL\n        tags.addAll(getValidTags(textBlock, JavadocUtil.JavadocTagType.INLINE));\n        // gather all the block-level tags, like @throws and @see\n        tags.addAll(getValidTags(textBlock, JavadocUtil.JavadocTagType.BLOCK));\n\n        final Set<String> references = new HashSet<>();\n\n        tags.stream()\n            .filter(JavadocTag::canReferenceImports)\n            .forEach(tag -> references.addAll(processJavadocTag(tag)));\n        return references;\n    }\n\n    /**\n     * Returns the list of valid tags found in a javadoc {@link TextBlock}.\n     *\n     * @param cmt The javadoc block to parse\n     * @param tagType The type of tags we're interested in\n     * @return the list of tags\n     */\n    private static List<JavadocTag> getValidTags(TextBlock cmt,\n            JavadocUtil.JavadocTagType tagType) {\n        return JavadocUtil.getJavadocTags(cmt, tagType).getValidTags();\n    }\n\n    /**\n     * Returns a list of references found in a javadoc {@link JavadocTag}.\n     *\n     * @param tag The javadoc tag to parse\n     * @return A list of references found in this tag\n     */\n    private static Set<String> processJavadocTag(JavadocTag tag) {\n        final Set<String> references = new HashSet<>();\n        final String identifier = tag.getFirstArg().trim();\n        for (Pattern pattern : new Pattern[]\n        {FIRST_CLASS_NAME, ARGUMENT_NAME}) {\n            references.addAll(matchPattern(identifier, pattern));\n        }\n        return references;\n    }\n\n    /**\n     * Extracts a list of texts matching a {@link Pattern} from a\n     * {@link String}.\n     *\n     * @param identifier The String to match the pattern against\n     * @param pattern The Pattern used to extract the texts\n     * @return A list of texts which matched the pattern\n     */\n    private static Set<String> matchPattern(String identifier, Pattern pattern) {\n        final Set<String> references = new HashSet<>();\n        final Matcher matcher = pattern.matcher(identifier);\n        while (matcher.find()) {\n            references.add(topLevelType(matcher.group(1)));\n        }\n        return references;\n    }\n\n    /**\n     * If the given type string contains \".\" (e.g. \"Map.Entry\"), returns the\n     * top level type (e.g. \"Map\"), as that is what must be imported for the\n     * type to resolve. Otherwise, returns the type as-is.\n     *\n     * @param type A possibly qualified type name\n     * @return The simple name of the top level type\n     */\n    private static String topLevelType(String type) {\n        final String topLevelType;\n        final int dotIndex = type.indexOf('.');\n        if (dotIndex == -1) {\n            topLevelType = type;\n        }\n        else {\n            topLevelType = type.substring(0, dotIndex);\n        }\n        return topLevelType;\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.imports;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FileContents;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TextBlock;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.JavadocTag;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * <p>\n * Checks for unused import statements. Checkstyle uses a simple but very\n * reliable algorithm to report on unused import statements. An import statement\n * is considered unused if:\n * </p>\n * <ul>\n * <li>\n * It is not referenced in the file. The algorithm does not support wild-card\n * imports like {@code import java.io.*;}. Most IDE's provide very sophisticated\n * checks for imports that handle wild-card imports.\n * </li>\n * <li>\n * It is a duplicate of another import. This is when a class is imported more\n * than once.\n * </li>\n * <li>\n * The class imported is from the {@code java.lang} package. For example\n * importing {@code java.lang.String}.\n * </li>\n * <li>\n * The class imported is from the same package.\n * </li>\n * <li>\n * <b>Optionally:</b> it is referenced in Javadoc comments. This check is on by\n * default, but it is considered bad practice to introduce a compile time\n * dependency for documentation purposes only. As an example, the import\n * {@code java.util.List} would be considered referenced with the Javadoc\n * comment {@code {@link List}}. The alternative to avoid introducing a compile\n * time dependency would be to write the Javadoc comment as {@code {&#64;link java.util.List}}.\n * </li>\n * </ul>\n * <p>\n * The main limitation of this check is handling the case where an imported type\n * has the same name as a declaration, such as a member variable.\n * </p>\n * <p>\n * For example, in the following case the import {@code java.awt.Component}\n * will not be flagged as unused:\n * </p>\n * <pre>\n * import java.awt.Component;\n * class FooBar {\n *   private Object Component; // a bad practice in my opinion\n *   ...\n * }\n * </pre>\n * <ul>\n * <li>\n * Property {@code processJavadoc} - Control whether to process Javadoc comments.\n * Type is {@code boolean}.\n * Default value is {@code true}.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=\"UnusedImports\"/&gt;\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code import.unused}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@FileStatefulCheck\npublic class UnusedImportsCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"import.unused\";\n\n    /** Regex to match class names. */\n    private static final Pattern CLASS_NAME = CommonUtil.createPattern(\n           \"((:?[\\\\p{L}_$][\\\\p{L}\\\\p{N}_$]*\\\\.)*[\\\\p{L}_$][\\\\p{L}\\\\p{N}_$]*)\");\n    /** Regex to match the first class name. */\n    private static final Pattern FIRST_CLASS_NAME = CommonUtil.createPattern(\n           \"^\" + CLASS_NAME);\n    /** Regex to match argument names. */\n    private static final Pattern ARGUMENT_NAME = CommonUtil.createPattern(\n           \"[(,]\\\\s*\" + CLASS_NAME.pattern());\n\n    /** Regexp pattern to match java.lang package. */\n    private static final Pattern JAVA_LANG_PACKAGE_PATTERN =\n        CommonUtil.createPattern(\"^java\\\\.lang\\\\.[a-zA-Z]+$\");\n\n    /** Suffix for the star import. */\n    private static final String STAR_IMPORT_SUFFIX = \".*\";\n\n    /** Set of the imports. */\n    private final Set<FullIdent> imports = new HashSet<>();\n\n    /** Flag to indicate when time to start collecting references. */\n    private boolean collect;\n    /** Control whether to process Javadoc comments. */\n    private boolean processJavadoc = true;\n\n    /**\n     * The scope is being processed.\n     * Types declared in a scope can shadow imported types.\n     */\n    private Frame currentFrame;\n\n    /**\n     * Setter to control whether to process Javadoc comments.\n     *\n     * @param value Flag for processing Javadoc comments.\n     */\n    public void setProcessJavadoc(boolean value) {\n        processJavadoc = value;\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        collect = false;\n        currentFrame = Frame.compilationUnit();\n        imports.clear();\n    }\n\n    @Override\n    public void finishTree(DetailAST rootAST) {\n        currentFrame.finish();\n        // loop over all the imports to see if referenced.\n        imports.stream()\n            .filter(imprt -> isUnusedImport(imprt.getText()))\n            .forEach(imprt -> log(imprt.getDetailAst(), MSG_KEY, imprt.getText()));\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.IDENT,\n            TokenTypes.IMPORT,\n            TokenTypes.STATIC_IMPORT,\n            // Definitions that may contain Javadoc...\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.ANNOTATION_FIELD_DEF,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.ENUM_CONSTANT_DEF,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.RECORD_DEF,\n            TokenTypes.COMPACT_CTOR_DEF,\n            // Tokens for creating a new frame\n            TokenTypes.OBJBLOCK,\n            TokenTypes.SLIST,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.IDENT:\n                if (collect) {\n                    processIdent(ast);\n                }\n                break;\n            case TokenTypes.IMPORT:\n                processImport(ast);\n                break;\n            case TokenTypes.STATIC_IMPORT:\n                processStaticImport(ast);\n                break;\n            case TokenTypes.OBJBLOCK:\n            case TokenTypes.SLIST:\n                currentFrame = currentFrame.push();\n                break;\n            default:\n                collect = true;\n                if (processJavadoc) {\n                    collectReferencesFromJavadoc(ast);\n                }\n                break;\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (TokenUtil.isOfType(ast, TokenTypes.OBJBLOCK, TokenTypes.SLIST)) {\n            currentFrame = currentFrame.pop();\n        }\n    }\n\n    /**\n     * Checks whether an import is unused.\n     *\n     * @param imprt an import.\n     * @return true if an import is unused.\n     */\n    private boolean isUnusedImport(String imprt) {\n        final Matcher javaLangPackageMatcher = JAVA_LANG_PACKAGE_PATTERN.matcher(imprt);\n        return !currentFrame.isReferencedType(CommonUtil.baseClassName(imprt))\n            || javaLangPackageMatcher.matches();\n    }\n\n    /**\n     * Collects references made by IDENT.\n     *\n     * @param ast the IDENT node to process\n     */\n    private void processIdent(DetailAST ast) {\n        final DetailAST parent = ast.getParent();\n        final int parentType = parent.getType();\n        if (TokenUtil.isTypeDeclaration(parentType)) {\n            currentFrame.addDeclaredType(ast.getText());\n        }\n        else if (parentType != TokenTypes.DOT && parentType != TokenTypes.METHOD_DEF\n                || parentType == TokenTypes.DOT && ast.getNextSibling() != null) {\n            currentFrame.addReferencedType(ast.getText());\n        }\n    }\n\n    /**\n     * Collects the details of imports.\n     *\n     * @param ast node containing the import details\n     */\n    private void processImport(DetailAST ast) {\n        final FullIdent name = FullIdent.createFullIdentBelow(ast);\n        if (!name.getText().endsWith(STAR_IMPORT_SUFFIX)) {\n            imports.add(name);\n        }\n    }\n\n    /**\n     * Collects the details of static imports.\n     *\n     * @param ast node containing the static import details\n     */\n    private void processStaticImport(DetailAST ast) {\n        final FullIdent name =\n            FullIdent.createFullIdent(\n                ast.getFirstChild().getNextSibling());\n        if (!name.getText().endsWith(STAR_IMPORT_SUFFIX)) {\n            imports.add(name);\n        }\n    }\n\n    /**\n     * Collects references made in Javadoc comments.\n     *\n     * @param ast node to inspect for Javadoc\n     */\n    private void collectReferencesFromJavadoc(DetailAST ast) {\n        final FileContents contents = getFileContents();\n        final int lineNo = ast.getLineNo();\n        final TextBlock textBlock = contents.getJavadocBefore(lineNo);\n        if (textBlock != null) {\n            currentFrame.addReferencedTypes(collectReferencesFromJavadoc(textBlock));\n        }\n    }\n\n    /**\n     * Process a javadoc {@link TextBlock} and return the set of classes\n     * referenced within.\n     *\n     * @param textBlock The javadoc block to parse\n     * @return a set of classes referenced in the javadoc block\n     */\n    private static Set<String> collectReferencesFromJavadoc(TextBlock textBlock) {\n        final List<JavadocTag> tags = new ArrayList<>();\n        // gather all the inline tags, like @link\n        // INLINE tags inside BLOCKs get hidden when using ALL\n        tags.addAll(getValidTags(textBlock, JavadocUtil.JavadocTagType.INLINE));\n        // gather all the block-level tags, like @throws and @see\n        tags.addAll(getValidTags(textBlock, JavadocUtil.JavadocTagType.BLOCK));\n\n        final Set<String> references = new HashSet<>();\n\n        tags.stream()\n            .filter(JavadocTag::canReferenceImports)\n            .forEach(tag -> references.addAll(processJavadocTag(tag)));\n        return references;\n    }\n\n    /**\n     * Returns the list of valid tags found in a javadoc {@link TextBlock}.\n     *\n     * @param cmt The javadoc block to parse\n     * @param tagType The type of tags we're interested in\n     * @return the list of tags\n     */\n    private static List<JavadocTag> getValidTags(TextBlock cmt,\n            JavadocUtil.JavadocTagType tagType) {\n        return JavadocUtil.getJavadocTags(cmt, tagType).getValidTags();\n    }\n\n    /**\n     * Returns a list of references found in a javadoc {@link JavadocTag}.\n     *\n     * @param tag The javadoc tag to parse\n     * @return A list of references found in this tag\n     */\n    private static Set<String> processJavadocTag(JavadocTag tag) {\n        final Set<String> references = new HashSet<>();\n        final String identifier = tag.getFirstArg().trim();\n        for (Pattern pattern : new Pattern[]\n        {FIRST_CLASS_NAME, ARGUMENT_NAME}) {\n            references.addAll(matchPattern(identifier, pattern));\n        }\n        return references;\n    }\n\n    /**\n     * Extracts a list of texts matching a {@link Pattern} from a\n     * {@link String}.\n     *\n     * @param identifier The String to match the pattern against\n     * @param pattern The Pattern used to extract the texts\n     * @return A list of texts which matched the pattern\n     */\n    private static Set<String> matchPattern(String identifier, Pattern pattern) {\n        final Set<String> references = new HashSet<>();\n        final Matcher matcher = pattern.matcher(identifier);\n        while (matcher.find()) {\n            references.add(topLevelType(matcher.group(1)));\n        }\n        return references;\n    }\n\n    /**\n     * If the given type string contains \".\" (e.g. \"Map.Entry\"), returns the\n     * top level type (e.g. \"Map\"), as that is what must be imported for the\n     * type to resolve. Otherwise, returns the type as-is.\n     *\n     * @param type A possibly qualified type name\n     * @return The simple name of the top level type\n     */\n    private static String topLevelType(String type) {\n        final String topLevelType;\n        final int dotIndex = type.indexOf('.');\n        if (dotIndex == -1) {\n            topLevelType = type;\n        }\n        else {\n            topLevelType = type.substring(0, dotIndex);\n        }\n        return topLevelType;\n    }\n\n    /**\n     * Holds the names of referenced types and names of declared inner types.\n     */\n    private static final class Frame {\n\n        /** Parent frame. */\n        private final Frame parent;\n\n        /** Nested types declared in the current scope. */\n        private final Set<String> declaredTypes;\n\n        /** Set of references - possibly to imports or locally declared types. */\n        private final Set<String> referencedTypes;\n\n        /**\n         * Private constructor. Use {@link #compilationUnit()} to create a new top-level frame.\n         *\n         * @param parent the parent frame\n         */\n        private Frame(Frame parent) {\n            this.parent = parent;\n            declaredTypes = new HashSet<>();\n            referencedTypes = new HashSet<>();\n        }\n\n        /**\n         * Adds new inner type.\n         *\n         * @param type the type name\n         */\n        public void addDeclaredType(String type) {\n            declaredTypes.add(type);\n        }\n\n        /**\n         * Adds new type reference to the current frame.\n         *\n         * @param type the type name\n         */\n        public void addReferencedType(String type) {\n            referencedTypes.add(type);\n        }\n\n        /**\n         * Adds new inner types.\n         *\n         * @param types the type names\n         */\n        public void addReferencedTypes(Collection<String> types) {\n            referencedTypes.addAll(types);\n        }\n\n        /**\n         * Filters out all references to locally defined types.\n         *\n         */\n        public void finish() {\n            referencedTypes.removeAll(declaredTypes);\n        }\n\n        /**\n         * Creates new inner frame.\n         *\n         * @return a new frame.\n         */\n        public Frame push() {\n            return new Frame(this);\n        }\n\n        /**\n         * Pulls all referenced types up, except those that are declared in this scope.\n         *\n         * @return the parent frame\n         */\n        public Frame pop() {\n            finish();\n            parent.addReferencedTypes(referencedTypes);\n            return parent;\n        }\n\n        /**\n         * Checks whether this type name is used in this frame.\n         *\n         * @param type the type name\n         * @return {@code true} if the type is used\n         */\n        public boolean isReferencedType(String type) {\n            return referencedTypes.contains(type);\n        }\n\n        /**\n         * Creates a new top-level frame for the compilation unit.\n         *\n         * @return a new frame.\n         */\n        public static Frame compilationUnit() {\n            return new Frame(null);\n        }\n\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n         * Adds new inner type.\n         *\n         * @param type the type name\n         */\n        public void addDeclaredType(String type) {\n            declaredTypes.add(type);\n        }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Collects references made by IDENT.\n     *\n     * @param ast the IDENT node to process\n     */\n    private void processIdent(DetailAST ast) {\n        final DetailAST parent = ast.getParent();\n        final int parentType = parent.getType();\n        if (TokenUtil.isTypeDeclaration(parentType)) {\n            currentFrame.addDeclaredType(ast.getText());\n        }\n        else if (parentType != TokenTypes.DOT && parentType != TokenTypes.METHOD_DEF\n                || parentType == TokenTypes.DOT && ast.getNextSibling() != null) {\n            currentFrame.addReferencedType(ast.getText());\n        }\n    }\n/**\n         * Adds new inner type.\n         *\n         * @param type the type name\n         */\n        public void addDeclaredType(String type) {\n            declaredTypes.add(type);\n        }", "diffSourceCode": "-  240:     /**\n-  241:      * Collects references made by IDENT.\n-  242:      *\n-  243:      * @param ast the IDENT node to process\n-  244:      */\n-  245:     private void processIdent(DetailAST ast) {\n-  246:         final DetailAST parent = ast.getParent();\n-  247:         final int parentType = parent.getType();\n-  248:         if (parentType != TokenTypes.DOT\n-  249:             && parentType != TokenTypes.METHOD_DEF\n-  250:             || parentType == TokenTypes.DOT\n-  251:                 && ast.getNextSibling() != null) {\n-  252:             referenced.add(ast.getText());\n-  253:         }\n-  254:     }\n-  262:         final FullIdent name = FullIdent.createFullIdentBelow(ast);\n-  263:         if (!name.getText().endsWith(STAR_IMPORT_SUFFIX)) {\n-  264:             imports.add(name);\n-  265:         }\n-  266:     }\n-  267: \n-  268:     /**\n-  269:      * Collects the details of static imports.\n-  270:      *\n-  271:      * @param ast node containing the static import details\n-  272:      */\n-  273:     private void processStaticImport(DetailAST ast) {\n-  274:         final FullIdent name =\n-  275:             FullIdent.createFullIdent(\n-  276:                 ast.getFirstChild().getNextSibling());\n-  277:         if (!name.getText().endsWith(STAR_IMPORT_SUFFIX)) {\n+  240:         }\n+  241:     }\n+  242: \n+  243:     @Override\n+  244:     public void leaveToken(DetailAST ast) {\n+  245:         if (TokenUtil.isOfType(ast, TokenTypes.OBJBLOCK, TokenTypes.SLIST)) {\n+  246:             currentFrame = currentFrame.pop();\n+  247:         }\n+  248:     }\n+  249: \n+  250:     /**\n+  251:      * Checks whether an import is unused.\n+  252:      *\n+  253:      * @param imprt an import.\n+  254:      * @return true if an import is unused.\n+  262:     /**\n+  263:      * Collects references made by IDENT.\n+  264:      *\n+  265:      * @param ast the IDENT node to process\n+  266:      */\n+  267:     private void processIdent(DetailAST ast) {\n+  268:         final DetailAST parent = ast.getParent();\n+  269:         final int parentType = parent.getType();\n+  270:         if (TokenUtil.isTypeDeclaration(parentType)) {\n+  271:             currentFrame.addDeclaredType(ast.getText());\n+  272:         }\n+  273:         else if (parentType != TokenTypes.DOT && parentType != TokenTypes.METHOD_DEF\n+  274:                 || parentType == TokenTypes.DOT && ast.getNextSibling() != null) {\n+  275:             currentFrame.addReferencedType(ast.getText());\n+  276:         }\n+  277:     }\n+  432:         /**\n+  433:          * Adds new inner type.\n+  434:          *\n+  435:          * @param type the type name\n+  436:          */\n+  437:         public void addDeclaredType(String type) {\n+  438:             declaredTypes.add(type);\n+  439:         }\n", "uniqueId": "ba76f3e4f33194b0a1d687e95a58395bd9590321_240_254_432_439_262_277", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 25}, "BRANCH": {"missed": 0, "covered": 8}, "LINE": {"missed": 0, "covered": 6}, "COMPLEXITY": {"missed": 0, "covered": 5}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "##########################\nsrc/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java\n##########################\n/**\n * If the given type string contains \".\" (e.g. \"Map.Entry\"), returns the\n * top level type (e.g. \"Map\"), as that is what must be imported for the\n * type to resolve. Otherwise, returns the type as-is.\n *\n * @param type A possibly qualified type name\n * @return The simple name of the top level type\n */\npublic static String topLevelType(String type) {\n    final String topLevelType;\n    final int dotIndex = type.indexOf('.');\n    if (dotIndex == -1) {\n        topLevelType = type;\n    } else {\n        topLevelType = type.substring(0, dotIndex);\n    }\n    return topLevelType;\n}\n##########################\n/**\n * Collects references made by IDENT.\n *\n * @param ast the IDENT node to process\n */\nprivate void processIdent(DetailAST ast) {\n    final DetailAST parent = ast.getParent();\n    final int parentType = parent.getType();\n    if (parentType != TokenTypes.DOT\n        && parentType != TokenTypes.METHOD_DEF\n        || parentType == TokenTypes.DOT\n            && ast.getNextSibling() != null) {\n        referenced.add(CommonUtil.topLevelType(ast.getText()));\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Collects references made by IDENT.\n     *\n     * @param ast the IDENT node to process\n     */\n    private void processIdent(DetailAST ast) {\n        final DetailAST parent = ast.getParent();\n        final int parentType = parent.getType();\n        if (parentType != TokenTypes.DOT\n            && parentType != TokenTypes.METHOD_DEF\n            || parentType == TokenTypes.DOT\n                && ast.getNextSibling() != null) {\n            referenced.add(ast.getText());\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.imports;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FileContents;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TextBlock;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.checks.javadoc.JavadocTag;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.JavadocUtil;\n\n/**\n * <p>\n * Checks for unused import statements. Checkstyle uses a simple but very\n * reliable algorithm to report on unused import statements. An import statement\n * is considered unused if:\n * </p>\n * <ul>\n * <li>\n * It is not referenced in the file. The algorithm does not support wild-card\n * imports like {@code import java.io.*;}. Most IDE's provide very sophisticated\n * checks for imports that handle wild-card imports.\n * </li>\n * <li>\n * It is a duplicate of another import. This is when a class is imported more\n * than once.\n * </li>\n * <li>\n * The class imported is from the {@code java.lang} package. For example\n * importing {@code java.lang.String}.\n * </li>\n * <li>\n * The class imported is from the same package.\n * </li>\n * <li>\n * <b>Optionally:</b> it is referenced in Javadoc comments. This check is on by\n * default, but it is considered bad practice to introduce a compile time\n * dependency for documentation purposes only. As an example, the import\n * {@code java.util.List} would be considered referenced with the Javadoc\n * comment {@code {@link List}}. The alternative to avoid introducing a compile\n * time dependency would be to write the Javadoc comment as {@code {&#64;link java.util.List}}.\n * </li>\n * </ul>\n * <p>\n * The main limitation of this check is handling the case where an imported type\n * has the same name as a declaration, such as a member variable.\n * </p>\n * <p>\n * For example, in the following case the import {@code java.awt.Component}\n * will not be flagged as unused:\n * </p>\n * <pre>\n * import java.awt.Component;\n * class FooBar {\n *   private Object Component; // a bad practice in my opinion\n *   ...\n * }\n * </pre>\n * <ul>\n * <li>\n * Property {@code processJavadoc} - Control whether to process Javadoc comments.\n * Type is {@code boolean}.\n * Default value is {@code true}.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=\"UnusedImports\"/&gt;\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code import.unused}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@FileStatefulCheck\npublic class UnusedImportsCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY = \"import.unused\";\n\n    /** Regex to match class names. */\n    private static final Pattern CLASS_NAME = CommonUtil.createPattern(\n           \"((:?[\\\\p{L}_$][\\\\p{L}\\\\p{N}_$]*\\\\.)*[\\\\p{L}_$][\\\\p{L}\\\\p{N}_$]*)\");\n    /** Regex to match the first class name. */\n    private static final Pattern FIRST_CLASS_NAME = CommonUtil.createPattern(\n           \"^\" + CLASS_NAME);\n    /** Regex to match argument names. */\n    private static final Pattern ARGUMENT_NAME = CommonUtil.createPattern(\n           \"[(,]\\\\s*\" + CLASS_NAME.pattern());\n\n    /** Regexp pattern to match java.lang package. */\n    private static final Pattern JAVA_LANG_PACKAGE_PATTERN =\n        CommonUtil.createPattern(\"^java\\\\.lang\\\\.[a-zA-Z]+$\");\n\n    /** Suffix for the star import. */\n    private static final String STAR_IMPORT_SUFFIX = \".*\";\n\n    /** Set of the imports. */\n    private final Set<FullIdent> imports = new HashSet<>();\n\n    /** Set of references - possibly to imports or other things. */\n    private final Set<String> referenced = new HashSet<>();\n\n    /** Flag to indicate when time to start collecting references. */\n    private boolean collect;\n    /** Control whether to process Javadoc comments. */\n    private boolean processJavadoc = true;\n\n    /**\n     * Setter to control whether to process Javadoc comments.\n     *\n     * @param value Flag for processing Javadoc comments.\n     */\n    public void setProcessJavadoc(boolean value) {\n        processJavadoc = value;\n    }\n\n    @Override\n    public void beginTree(DetailAST rootAST) {\n        collect = false;\n        imports.clear();\n        referenced.clear();\n    }\n\n    @Override\n    public void finishTree(DetailAST rootAST) {\n        // loop over all the imports to see if referenced.\n        imports.stream()\n            .filter(imprt -> isUnusedImport(imprt.getText()))\n            .forEach(imprt -> log(imprt.getDetailAst(), MSG_KEY, imprt.getText()));\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return new int[] {\n            TokenTypes.IDENT,\n            TokenTypes.IMPORT,\n            TokenTypes.STATIC_IMPORT,\n            // Definitions that may contain Javadoc...\n            TokenTypes.PACKAGE_DEF,\n            TokenTypes.ANNOTATION_DEF,\n            TokenTypes.ANNOTATION_FIELD_DEF,\n            TokenTypes.ENUM_DEF,\n            TokenTypes.ENUM_CONSTANT_DEF,\n            TokenTypes.CLASS_DEF,\n            TokenTypes.INTERFACE_DEF,\n            TokenTypes.METHOD_DEF,\n            TokenTypes.CTOR_DEF,\n            TokenTypes.VARIABLE_DEF,\n            TokenTypes.RECORD_DEF,\n            TokenTypes.COMPACT_CTOR_DEF,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return getRequiredTokens();\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        if (ast.getType() == TokenTypes.IDENT) {\n            if (collect) {\n                processIdent(ast);\n            }\n        }\n        else if (ast.getType() == TokenTypes.IMPORT) {\n            processImport(ast);\n        }\n        else if (ast.getType() == TokenTypes.STATIC_IMPORT) {\n            processStaticImport(ast);\n        }\n        else {\n            collect = true;\n            if (processJavadoc) {\n                collectReferencesFromJavadoc(ast);\n            }\n        }\n    }\n\n    /**\n     * Checks whether an import is unused.\n     *\n     * @param imprt an import.\n     * @return true if an import is unused.\n     */\n    private boolean isUnusedImport(String imprt) {\n        final Matcher javaLangPackageMatcher = JAVA_LANG_PACKAGE_PATTERN.matcher(imprt);\n        return !referenced.contains(CommonUtil.baseClassName(imprt))\n            || javaLangPackageMatcher.matches();\n    }\n\n    /**\n     * Collects references made by IDENT.\n     *\n     * @param ast the IDENT node to process\n     */\n    private void processIdent(DetailAST ast) {\n        final DetailAST parent = ast.getParent();\n        final int parentType = parent.getType();\n        if (parentType != TokenTypes.DOT\n            && parentType != TokenTypes.METHOD_DEF\n            || parentType == TokenTypes.DOT\n                && ast.getNextSibling() != null) {\n            referenced.add(ast.getText());\n        }\n    }\n\n    /**\n     * Collects the details of imports.\n     *\n     * @param ast node containing the import details\n     */\n    private void processImport(DetailAST ast) {\n        final FullIdent name = FullIdent.createFullIdentBelow(ast);\n        if (!name.getText().endsWith(STAR_IMPORT_SUFFIX)) {\n            imports.add(name);\n        }\n    }\n\n    /**\n     * Collects the details of static imports.\n     *\n     * @param ast node containing the static import details\n     */\n    private void processStaticImport(DetailAST ast) {\n        final FullIdent name =\n            FullIdent.createFullIdent(\n                ast.getFirstChild().getNextSibling());\n        if (!name.getText().endsWith(STAR_IMPORT_SUFFIX)) {\n            imports.add(name);\n        }\n    }\n\n    /**\n     * Collects references made in Javadoc comments.\n     *\n     * @param ast node to inspect for Javadoc\n     */\n    private void collectReferencesFromJavadoc(DetailAST ast) {\n        final FileContents contents = getFileContents();\n        final int lineNo = ast.getLineNo();\n        final TextBlock textBlock = contents.getJavadocBefore(lineNo);\n        if (textBlock != null) {\n            referenced.addAll(collectReferencesFromJavadoc(textBlock));\n        }\n    }\n\n    /**\n     * Process a javadoc {@link TextBlock} and return the set of classes\n     * referenced within.\n     *\n     * @param textBlock The javadoc block to parse\n     * @return a set of classes referenced in the javadoc block\n     */\n    private static Set<String> collectReferencesFromJavadoc(TextBlock textBlock) {\n        final List<JavadocTag> tags = new ArrayList<>();\n        // gather all the inline tags, like @link\n        // INLINE tags inside BLOCKs get hidden when using ALL\n        tags.addAll(getValidTags(textBlock, JavadocUtil.JavadocTagType.INLINE));\n        // gather all the block-level tags, like @throws and @see\n        tags.addAll(getValidTags(textBlock, JavadocUtil.JavadocTagType.BLOCK));\n\n        final Set<String> references = new HashSet<>();\n\n        tags.stream()\n            .filter(JavadocTag::canReferenceImports)\n            .forEach(tag -> references.addAll(processJavadocTag(tag)));\n        return references;\n    }\n\n    /**\n     * Returns the list of valid tags found in a javadoc {@link TextBlock}.\n     *\n     * @param cmt The javadoc block to parse\n     * @param tagType The type of tags we're interested in\n     * @return the list of tags\n     */\n    private static List<JavadocTag> getValidTags(TextBlock cmt,\n            JavadocUtil.JavadocTagType tagType) {\n        return JavadocUtil.getJavadocTags(cmt, tagType).getValidTags();\n    }\n\n    /**\n     * Returns a list of references found in a javadoc {@link JavadocTag}.\n     *\n     * @param tag The javadoc tag to parse\n     * @return A list of references found in this tag\n     */\n    private static Set<String> processJavadocTag(JavadocTag tag) {\n        final Set<String> references = new HashSet<>();\n        final String identifier = tag.getFirstArg().trim();\n        for (Pattern pattern : new Pattern[]\n        {FIRST_CLASS_NAME, ARGUMENT_NAME}) {\n            references.addAll(matchPattern(identifier, pattern));\n        }\n        return references;\n    }\n\n    /**\n     * Extracts a list of texts matching a {@link Pattern} from a\n     * {@link String}.\n     *\n     * @param identifier The String to match the pattern against\n     * @param pattern The Pattern used to extract the texts\n     * @return A list of texts which matched the pattern\n     */\n    private static Set<String> matchPattern(String identifier, Pattern pattern) {\n        final Set<String> references = new HashSet<>();\n        final Matcher matcher = pattern.matcher(identifier);\n        while (matcher.find()) {\n            references.add(topLevelType(matcher.group(1)));\n        }\n        return references;\n    }\n\n    /**\n     * If the given type string contains \".\" (e.g. \"Map.Entry\"), returns the\n     * top level type (e.g. \"Map\"), as that is what must be imported for the\n     * type to resolve. Otherwise, returns the type as-is.\n     *\n     * @param type A possibly qualified type name\n     * @return The simple name of the top level type\n     */\n    private static String topLevelType(String type) {\n        final String topLevelType;\n        final int dotIndex = type.indexOf('.');\n        if (dotIndex == -1) {\n            topLevelType = type;\n        }\n        else {\n            topLevelType = type.substring(0, dotIndex);\n        }\n        return topLevelType;\n    }\n\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['src/main/java/com/puppycrawl/tools/checkstyle/AstTreeStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/AuditEventDefaultFormatter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/AuditEventFormatter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Checker.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultContext.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Definitions.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DetailAstImpl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DetailNodeTreeStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/FileStatefulCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/GlobalStatefulCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavaParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavadocPropertiesGenerator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Main.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ModuleFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PackageNamesLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertiesExpander.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertyResolver.java', 'src/main/java/com/puppycrawl/tools/checkstyle/StatelessCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/SuppressionsStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ThreadModeSettings.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalkerAuditEvent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalkerFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XMLLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XmlLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAstFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAuditListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ant/CheckstyleAntTask.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ant/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractFileSetCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractViolationReporter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AuditEvent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AuditListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AutomaticBean.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilterSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/CheckstyleException.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Comment.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Configurable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Configuration.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Context.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Contextualizable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/DetailNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/ExternalResourceHolder.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileContents.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileSetCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Filter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FilterSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FullIdent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/JavadocTokenTypes.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/LineColumn.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/LocalizedMessage.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/MessageDispatcher.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/RootModule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Scope.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/SeverityLevel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/SeverityLevelCounter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/TextBlock.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/TokenTypes.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/ArrayTypeStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/FinalParametersCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/LineSeparatorOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/NoCodeInFileCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/OrderedPropertiesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/OuterTypeFilenameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TodoCommentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UniquePropertiesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UpperEllCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationOnSameLineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingDeprecatedCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingOverrideCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/PackageAnnotationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/AvoidNestedBlocksCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/BlockOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyBlockCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AbstractSuperCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ArrayTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidDoubleBraceInitializationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidInlineConditionalsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidNoArgumentSuperConstructorCallCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/CovariantEqualsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DefaultComesLastCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EmptyStatementCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsHashCodeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ExplicitInitializationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/HiddenFieldCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalCatchCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenTextCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MagicNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MatchXpathCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingCtorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingSwitchDefaultCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ModifiedControlVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleVariableDeclarationsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedForDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedIfDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedTryDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoArrayTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoCloneCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoEnumTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoFinalizerCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/PackageDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ReturnCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanExpressionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanReturnCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/StringLiteralEqualityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperCloneCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperFinalizeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterOuterTypeDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterTypeMemberDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInEnumerationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInTryWithResourcesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/HideUtilityClassConstructorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/InnerTypeLastCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/InterfaceIsTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/OneTopLevelClassCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/ThrowsCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/HeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AbstractImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AbstractImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AccessResult.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStarImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStaticImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ClassImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/FileImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/IllegalImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/MismatchStrategy.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/RedundantImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AbstractExpressionHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AnnotationArrayInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ArrayInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/BlockParentHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CaseHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CatchHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/DetailAstSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/DoWhileHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ElseHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/FinallyHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ForHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IfHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ImportHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentLevel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndexHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LabelHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LambdaHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MemberDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodCallHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/NewHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ObjectBlockHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/PackageDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/PrimordialHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SlistHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/StaticInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SwitchHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SwitchRuleHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SynchronizedHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/TryHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/WhileHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/YieldHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AtclauseOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/HtmlTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocPositionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocBlockTagLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMissingLeadingAsteriskCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMissingWhitespaceAfterAsteriskCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocNodeImpl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocPackageCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocParagraphCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagContinuationIndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagInfo.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTags.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocMethodCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocPackageCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/NonEmptyAtclauseDescriptionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/RequireEmptyLineBeforeBlockTagGroupCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SingleLineJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/WriteTagCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/BlockTagUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/InlineTagUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/TagInfo.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassDataAbstractionCouplingCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassFanOutComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/CyclomaticComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/JavaNCSSCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ClassMemberImpliedModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/InterfaceMemberImpliedModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ModifierOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbbreviationAsWordInNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractAccessControlNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AccessModifierOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/CatchParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ClassTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ConstantNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/IllegalIdentifierNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/InterfaceTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LambdaParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalFinalVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MemberNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/PackageNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/PatternVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/RecordTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/StaticVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/TypeNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/CommentSuppressor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/DetectorOptions.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/MatchSuppressor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/MultilineDetector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/NeverSuppress.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpMultilineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpOnFilenameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineJavaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/SinglelineDetector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/AnonInnerLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/ExecutableStatementCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/FileLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/LambdaBodyLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/LineLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/OuterTypeNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/ParameterNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/RecordComponentNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/AbstractParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForInitializerPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForIteratorPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/FileTabCharacterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/MethodParamPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoLineWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/OperatorWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/PadOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SeparatorWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SingleSpaceSeparatorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/TypecastParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAfterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WrapOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filefilters/BeforeExecutionExclusionFileFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filefilters/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/CsvFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntMatchFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntRangeFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SeverityMatchFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWarningsFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithPlainTextCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionSingleFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathSingleFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionsLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/XpathFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/CommentListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/BaseCellEditor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/CodeSelector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/CodeSelectorPresentation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ListToTreeSelectionModelWrapper.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/Main.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/MainFrame.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/MainFrameModel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTableModel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTablePresentation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTableCellRenderer.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTableModelAdapter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModuleDetails.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModulePropertyDetails.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModuleType.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaReader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaWriter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/AnnotationUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/BlockCommentPosition.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/FilterUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ModuleReflectionUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ScopeUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/TokenUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/XpathUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/AbstractNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/AttributeNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/ElementNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/RootNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/XpathQueryGenerator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/package-info.java']\n\nFile Path Before Refactoring:\nsrc/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getMetaFileName(file Path) : String extracted from public generateMetadataFiles() : void in class com.puppycrawl.tools.checkstyle.meta.MetadataGeneratorUtilTest", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorUtilTest.java", "startLine": 45, "endLine": 78, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorUtilTest.java", "startLine": 45, "endLine": 68, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorUtilTest.java", "startLine": 70, "endLine": 86, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void generateMetadataFiles() throws Exception {\n        MetadataGeneratorUtil.generate(System.getProperty(\"user.dir\")\n                + \"/src/main/java/com/puppycrawl/tools/checkstyle\");\n        final Set<String> metaFiles;\n\n        try (Stream<Path> fileStream = Files.walk(\n                Paths.get(System.getProperty(\"user.dir\") + \"/src/main/resources/com/puppycrawl\"\n                        + \"/tools/checkstyle/meta\"))) {\n            metaFiles = fileStream\n                    .filter(Files::isRegularFile)\n                    .map(file -> {\n                        final String fileName = file.getFileName().toString();\n                        final int lengthToOmit;\n                        if (fileName.contains(\"Check\")) {\n                            lengthToOmit = \"Check.xml\".length();\n                        }\n                        else {\n                            lengthToOmit = \".xml\".length();\n                        }\n                        return fileName.substring(0, fileName.length() - lengthToOmit);\n                    })\n                    .sorted()\n                    .collect(Collectors.toCollection(LinkedHashSet::new));\n        }\n        final Set<String> checkstyleModules =\n                CheckUtil.getSimpleNames(CheckUtil.getCheckstyleModules())\n                .stream()\n                .sorted()\n                .collect(Collectors.toCollection(LinkedHashSet::new));\n        checkstyleModules.removeAll(modulesContainingNoMetadataFile);\n        assertEquals(\"Number of generated metadata files dont match with number of checkstyle \"\n                        + \"module\", checkstyleModules, metaFiles);\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorUtilTest.java", "isPureRefactoring": true, "commitId": "3c2249b239cbfe002af3649f1f7c1f9ae61df3b1", "packageNameBefore": "com.puppycrawl.tools.checkstyle.meta", "classNameBefore": "com.puppycrawl.tools.checkstyle.meta.MetadataGeneratorUtilTest", "methodNameBefore": "com.puppycrawl.tools.checkstyle.meta.MetadataGeneratorUtilTest#generateMetadataFiles", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.PropertyCacheFile#get\n methodBody: public String get(String name) {\nreturn details.getProperty(name);\n}", "classSignatureBefore": "public final class MetadataGeneratorUtilTest ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.meta.MetadataGeneratorUtilTest#generateMetadataFiles"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.meta.MetadataGeneratorUtilTest"], "classSignatureBeforeSet": ["public final class MetadataGeneratorUtilTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.meta;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\n\npublic final class MetadataGeneratorUtilTest {\n    private final List<String> modulesContainingNoMetadataFile = Arrays.asList(\n            \"Checker\",\n            \"TreeWalker\",\n            \"JavadocMetadataScraper\"\n    );\n\n    @Test\n    public void generateMetadataFiles() throws Exception {\n        MetadataGeneratorUtil.generate(System.getProperty(\"user.dir\")\n                + \"/src/main/java/com/puppycrawl/tools/checkstyle\");\n        final Set<String> metaFiles;\n\n        try (Stream<Path> fileStream = Files.walk(\n                Paths.get(System.getProperty(\"user.dir\") + \"/src/main/resources/com/puppycrawl\"\n                        + \"/tools/checkstyle/meta\"))) {\n            metaFiles = fileStream\n                    .filter(Files::isRegularFile)\n                    .map(file -> {\n                        final String fileName = file.getFileName().toString();\n                        final int lengthToOmit;\n                        if (fileName.contains(\"Check\")) {\n                            lengthToOmit = \"Check.xml\".length();\n                        }\n                        else {\n                            lengthToOmit = \".xml\".length();\n                        }\n                        return fileName.substring(0, fileName.length() - lengthToOmit);\n                    })\n                    .sorted()\n                    .collect(Collectors.toCollection(LinkedHashSet::new));\n        }\n        final Set<String> checkstyleModules =\n                CheckUtil.getSimpleNames(CheckUtil.getCheckstyleModules())\n                .stream()\n                .sorted()\n                .collect(Collectors.toCollection(LinkedHashSet::new));\n        checkstyleModules.removeAll(modulesContainingNoMetadataFile);\n        assertEquals(\"Number of generated metadata files dont match with number of checkstyle \"\n                        + \"module\", checkstyleModules, metaFiles);\n    }\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorUtilTest.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.meta;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\n\npublic final class MetadataGeneratorUtilTest {\n    private final List<String> modulesContainingNoMetadataFile = Arrays.asList(\n            \"Checker\",\n            \"TreeWalker\",\n            \"JavadocMetadataScraper\"\n    );\n\n    @Test\n    public void generateMetadataFiles() throws Exception {\n        MetadataGeneratorUtil.generate(System.getProperty(\"user.dir\")\n                + \"/src/main/java/com/puppycrawl/tools/checkstyle\");\n        final Set<String> metaFiles;\n\n        try (Stream<Path> fileStream = Files.walk(\n                Paths.get(System.getProperty(\"user.dir\") + \"/src/main/resources/com/puppycrawl\"\n                        + \"/tools/checkstyle/meta\"))) {\n            metaFiles = fileStream\n                    .filter(Files::isRegularFile)\n                    .map(MetadataGeneratorUtilTest::getMetaFileName)\n                    .sorted()\n                    .collect(Collectors.toCollection(LinkedHashSet::new));\n        }\n        final Set<String> checkstyleModules =\n                CheckUtil.getSimpleNames(CheckUtil.getCheckstyleModules())\n                .stream()\n                .sorted()\n                .collect(Collectors.toCollection(LinkedHashSet::new));\n        checkstyleModules.removeAll(modulesContainingNoMetadataFile);\n        assertEquals(\"Number of generated metadata files dont match with number of checkstyle \"\n                        + \"module\", checkstyleModules, metaFiles);\n    }\n\n    /**\n     * Get meta file name from full file name.\n     *\n     * @param file file to process\n     * @return meta file name\n     */\n    private static String getMetaFileName(Path file) {\n        final String fileName = file.getFileName().toString();\n        final int lengthToOmit;\n        if (fileName.contains(\"Check\")) {\n            lengthToOmit = \"Check.xml\".length();\n        }\n        else {\n            lengthToOmit = \".xml\".length();\n        }\n        return fileName.substring(0, fileName.length() - lengthToOmit);\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Get meta file name from full file name.\n     *\n     * @param file file to process\n     * @return meta file name\n     */\n    private static String getMetaFileName(Path file) {\n        final String fileName = file.getFileName().toString();\n        final int lengthToOmit;\n        if (fileName.contains(\"Check\")) {\n            lengthToOmit = \"Check.xml\".length();\n        }\n        else {\n            lengthToOmit = \".xml\".length();\n        }\n        return fileName.substring(0, fileName.length() - lengthToOmit);\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.PropertyCacheFile#get\n methodBody: public String get(String name) {\nreturn details.getProperty(name);\n}"], "sourceCodeAfterRefactoring": "@Test\n    public void generateMetadataFiles() throws Exception {\n        MetadataGeneratorUtil.generate(System.getProperty(\"user.dir\")\n                + \"/src/main/java/com/puppycrawl/tools/checkstyle\");\n        final Set<String> metaFiles;\n\n        try (Stream<Path> fileStream = Files.walk(\n                Paths.get(System.getProperty(\"user.dir\") + \"/src/main/resources/com/puppycrawl\"\n                        + \"/tools/checkstyle/meta\"))) {\n            metaFiles = fileStream\n                    .filter(Files::isRegularFile)\n                    .map(MetadataGeneratorUtilTest::getMetaFileName)\n                    .sorted()\n                    .collect(Collectors.toCollection(LinkedHashSet::new));\n        }\n        final Set<String> checkstyleModules =\n                CheckUtil.getSimpleNames(CheckUtil.getCheckstyleModules())\n                .stream()\n                .sorted()\n                .collect(Collectors.toCollection(LinkedHashSet::new));\n        checkstyleModules.removeAll(modulesContainingNoMetadataFile);\n        assertEquals(\"Number of generated metadata files dont match with number of checkstyle \"\n                        + \"module\", checkstyleModules, metaFiles);\n    }\n/**\n     * Get meta file name from full file name.\n     *\n     * @param file file to process\n     * @return meta file name\n     */\n    private static String getMetaFileName(Path file) {\n        final String fileName = file.getFileName().toString();\n        final int lengthToOmit;\n        if (fileName.contains(\"Check\")) {\n            lengthToOmit = \"Check.xml\".length();\n        }\n        else {\n            lengthToOmit = \".xml\".length();\n        }\n        return fileName.substring(0, fileName.length() - lengthToOmit);\n    }", "diffSourceCode": "    45:     @Test\n    46:     public void generateMetadataFiles() throws Exception {\n    47:         MetadataGeneratorUtil.generate(System.getProperty(\"user.dir\")\n    48:                 + \"/src/main/java/com/puppycrawl/tools/checkstyle\");\n    49:         final Set<String> metaFiles;\n    50: \n    51:         try (Stream<Path> fileStream = Files.walk(\n    52:                 Paths.get(System.getProperty(\"user.dir\") + \"/src/main/resources/com/puppycrawl\"\n    53:                         + \"/tools/checkstyle/meta\"))) {\n    54:             metaFiles = fileStream\n    55:                     .filter(Files::isRegularFile)\n-   56:                     .map(file -> {\n-   57:                         final String fileName = file.getFileName().toString();\n-   58:                         final int lengthToOmit;\n-   59:                         if (fileName.contains(\"Check\")) {\n-   60:                             lengthToOmit = \"Check.xml\".length();\n-   61:                         }\n-   62:                         else {\n-   63:                             lengthToOmit = \".xml\".length();\n-   64:                         }\n-   65:                         return fileName.substring(0, fileName.length() - lengthToOmit);\n-   66:                     })\n-   67:                     .sorted()\n-   68:                     .collect(Collectors.toCollection(LinkedHashSet::new));\n-   69:         }\n-   70:         final Set<String> checkstyleModules =\n-   71:                 CheckUtil.getSimpleNames(CheckUtil.getCheckstyleModules())\n-   72:                 .stream()\n-   73:                 .sorted()\n-   74:                 .collect(Collectors.toCollection(LinkedHashSet::new));\n-   75:         checkstyleModules.removeAll(modulesContainingNoMetadataFile);\n-   76:         assertEquals(\"Number of generated metadata files dont match with number of checkstyle \"\n-   77:                         + \"module\", checkstyleModules, metaFiles);\n-   78:     }\n-   79: }\n+   56:                     .map(MetadataGeneratorUtilTest::getMetaFileName)\n+   57:                     .sorted()\n+   58:                     .collect(Collectors.toCollection(LinkedHashSet::new));\n+   59:         }\n+   60:         final Set<String> checkstyleModules =\n+   61:                 CheckUtil.getSimpleNames(CheckUtil.getCheckstyleModules())\n+   62:                 .stream()\n+   63:                 .sorted()\n+   64:                 .collect(Collectors.toCollection(LinkedHashSet::new));\n+   65:         checkstyleModules.removeAll(modulesContainingNoMetadataFile);\n+   66:         assertEquals(\"Number of generated metadata files dont match with number of checkstyle \"\n+   67:                         + \"module\", checkstyleModules, metaFiles);\n+   68:     }\n+   69: \n+   70:     /**\n+   71:      * Get meta file name from full file name.\n+   72:      *\n+   73:      * @param file file to process\n+   74:      * @return meta file name\n+   75:      */\n+   76:     private static String getMetaFileName(Path file) {\n+   77:         final String fileName = file.getFileName().toString();\n+   78:         final int lengthToOmit;\n+   79:         if (fileName.contains(\"Check\")) {\n+   80:             lengthToOmit = \"Check.xml\".length();\n+   81:         }\n+   82:         else {\n+   83:             lengthToOmit = \".xml\".length();\n+   84:         }\n+   85:         return fileName.substring(0, fileName.length() - lengthToOmit);\n+   86:     }\n", "uniqueId": "3c2249b239cbfe002af3649f1f7c1f9ae61df3b1_45_78_70_86_45_68", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "##########################\nprivate Set<String> extractMetaFiles(Stream<Path> fileStream) {\n    return fileStream\n            .filter(Files::isRegularFile)\n            .map(file -> {\n                final String fileName = file.getFileName().toString();\n                final int lengthToOmit;\n                if (fileName.contains(\"Check\")) {\n                    lengthToOmit = \"Check.xml\".length();\n                }\n                else {\n                    lengthToOmit = \".xml\".length();\n                }\n                return fileName.substring(0, fileName.length() - lengthToOmit);\n            })\n            .sorted()\n            .collect(Collectors.toCollection(LinkedHashSet::new));\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Test\n    public void generateMetadataFiles() throws Exception {\n        MetadataGeneratorUtil.generate(System.getProperty(\"user.dir\")\n                + \"/src/main/java/com/puppycrawl/tools/checkstyle\");\n        final Set<String> metaFiles;\n\n        try (Stream<Path> fileStream = Files.walk(\n                Paths.get(System.getProperty(\"user.dir\") + \"/src/main/resources/com/puppycrawl\"\n                        + \"/tools/checkstyle/meta\"))) {\n            metaFiles = fileStream\n                    .filter(Files::isRegularFile)\n                    .map(file -> {\n                        final String fileName = file.getFileName().toString();\n                        final int lengthToOmit;\n                        if (fileName.contains(\"Check\")) {\n                            lengthToOmit = \"Check.xml\".length();\n                        }\n                        else {\n                            lengthToOmit = \".xml\".length();\n                        }\n                        return fileName.substring(0, fileName.length() - lengthToOmit);\n                    })\n                    .sorted()\n                    .collect(Collectors.toCollection(LinkedHashSet::new));\n        }\n        final Set<String> checkstyleModules =\n                CheckUtil.getSimpleNames(CheckUtil.getCheckstyleModules())\n                .stream()\n                .sorted()\n                .collect(Collectors.toCollection(LinkedHashSet::new));\n        checkstyleModules.removeAll(modulesContainingNoMetadataFile);\n        assertEquals(\"Number of generated metadata files dont match with number of checkstyle \"\n                        + \"module\", checkstyleModules, metaFiles);\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.meta;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.junit.jupiter.api.Test;\n\nimport com.puppycrawl.tools.checkstyle.internal.utils.CheckUtil;\n\npublic final class MetadataGeneratorUtilTest {\n    private final List<String> modulesContainingNoMetadataFile = Arrays.asList(\n            \"Checker\",\n            \"TreeWalker\",\n            \"JavadocMetadataScraper\"\n    );\n\n    @Test\n    public void generateMetadataFiles() throws Exception {\n        MetadataGeneratorUtil.generate(System.getProperty(\"user.dir\")\n                + \"/src/main/java/com/puppycrawl/tools/checkstyle\");\n        final Set<String> metaFiles;\n\n        try (Stream<Path> fileStream = Files.walk(\n                Paths.get(System.getProperty(\"user.dir\") + \"/src/main/resources/com/puppycrawl\"\n                        + \"/tools/checkstyle/meta\"))) {\n            metaFiles = fileStream\n                    .filter(Files::isRegularFile)\n                    .map(file -> {\n                        final String fileName = file.getFileName().toString();\n                        final int lengthToOmit;\n                        if (fileName.contains(\"Check\")) {\n                            lengthToOmit = \"Check.xml\".length();\n                        }\n                        else {\n                            lengthToOmit = \".xml\".length();\n                        }\n                        return fileName.substring(0, fileName.length() - lengthToOmit);\n                    })\n                    .sorted()\n                    .collect(Collectors.toCollection(LinkedHashSet::new));\n        }\n        final Set<String> checkstyleModules =\n                CheckUtil.getSimpleNames(CheckUtil.getCheckstyleModules())\n                .stream()\n                .sorted()\n                .collect(Collectors.toCollection(LinkedHashSet::new));\n        checkstyleModules.removeAll(modulesContainingNoMetadataFile);\n        assertEquals(\"Number of generated metadata files dont match with number of checkstyle \"\n                        + \"module\", checkstyleModules, metaFiles);\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate isFilenamesEqual(expected Node, actual Node) : boolean extracted from public testLogOutput() : void in class com.puppycrawl.tools.checkstyle.checks.TranslationCheckTest", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheckTest.java", "startLine": 171, "endLine": 211, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheckTest.java", "startLine": 172, "endLine": 204, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheckTest.java", "startLine": 610, "endLine": 627, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void testLogOutput() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja,de\");\n        checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n        final Checker checker = createChecker(checkConfig);\n        checker.setBasedir(getPath(\"\"));\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final XMLLogger logger = new XMLLogger(out, AutomaticBean.OutputStreamOptions.NONE);\n        checker.addListener(logger);\n\n        final String defaultProps = getPath(\"InputTranslationCheckFireErrors.properties\");\n        final String translationProps = getPath(\"InputTranslationCheckFireErrors_de.properties\");\n\n        final File[] propertyFiles = {\n            new File(defaultProps),\n            new File(translationProps),\n        };\n\n        final String line = \"1: \";\n        final String firstErrorMessage = getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                \"InputTranslationCheckFireErrors_ja.properties\");\n        final String secondErrorMessage = getCheckMessage(MSG_KEY, \"anotherKey\");\n\n        verify(checker, propertyFiles, ImmutableMap.of(\n            \":1\", Collections.singletonList(\" \" + firstErrorMessage),\n            \"InputTranslationCheckFireErrors_de.properties\",\n                Collections.singletonList(line + secondErrorMessage)));\n\n        verifyXml(getPath(\"ExpectedTranslationLog.xml\"), out, (expected, actual) -> {\n            // order is not always maintained here for an unknown reason.\n            // File names can appear in different orders depending on the OS and VM.\n            // This ensures we pick up the correct file based on its name and the\n            // number of children it has.\n            return !\"file\".equals(expected.getNodeName())\n                    || XmlUtil.getNameAttributeOfNode(expected)\n                        .equals(XmlUtil.getNameAttributeOfNode(actual))\n                    && XmlUtil.getChildrenElements(expected).size() == XmlUtil\n                            .getChildrenElements(actual).size();\n        }, firstErrorMessage, secondErrorMessage);\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheckTest.java", "isPureRefactoring": true, "commitId": "3c2249b239cbfe002af3649f1f7c1f9ae61df3b1", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.TranslationCheckTest", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.TranslationCheckTest#testLogOutput", "classSignatureBefore": "public class TranslationCheckTest extends AbstractXmlTestSupport ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.TranslationCheckTest#testLogOutput"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.TranslationCheckTest"], "classSignatureBeforeSet": ["public class TranslationCheckTest extends AbstractXmlTestSupport "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks;\n\nimport static com.puppycrawl.tools.checkstyle.checks.TranslationCheck.MSG_KEY;\nimport static com.puppycrawl.tools.checkstyle.checks.TranslationCheck.MSG_KEY_MISSING_TRANSLATION_FILE;\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.endsWith;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.powermock.reflect.Whitebox;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.puppycrawl.tools.checkstyle.AbstractXmlTestSupport;\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.DefaultConfiguration;\nimport com.puppycrawl.tools.checkstyle.Definitions;\nimport com.puppycrawl.tools.checkstyle.XMLLogger;\nimport com.puppycrawl.tools.checkstyle.api.AutomaticBean;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.FileText;\nimport com.puppycrawl.tools.checkstyle.api.LocalizedMessage;\nimport com.puppycrawl.tools.checkstyle.api.MessageDispatcher;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\npublic class TranslationCheckTest extends AbstractXmlTestSupport {\n\n    @TempDir\n    public File temporaryFolder;\n\n    @Override\n    protected String getPackageLocation() {\n        return \"com/puppycrawl/tools/checkstyle/checks/translation\";\n    }\n\n    @Test\n    public void testTranslation() throws Exception {\n        final Configuration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY, \"only.english\"),\n        };\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_test_de.properties\")),\n            new File(getPath(\"messages_test.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"messages_test_de.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testDifferentBases() throws Exception {\n        final Configuration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY, \"only.english\"),\n        };\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_test_de.properties\")),\n            new File(getPath(\"messages_test.properties\")),\n            new File(getPath(\"messages_translation.properties\")),\n            new File(getPath(\"messages_translation_de.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"messages_test_de.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testDifferentPaths() throws Exception {\n        final File file = new File(temporaryFolder, \"messages_test_de.properties\");\n        try (Writer writer = Files.newBufferedWriter(file.toPath(), StandardCharsets.UTF_8)) {\n            final String content = \"hello=Hello\\ncancel=Cancel\";\n            writer.write(content);\n        }\n        final Configuration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_test.properties\"),\n        };\n        final File[] propertyFiles = {\n            file,\n            new File(getPath(\"messages_test.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            file.getParent(),\n            expected);\n    }\n\n    /**\n     * Even when we pass several files to AbstractModuleTestSupport#verify,\n     * the check processes it during one run, so we cannot reproduce situation\n     * when TranslationCheck#beginProcessing called several times during single run.\n     * So, we have to use reflection to check this particular case.\n     *\n     * @throws Exception when code tested throws exception\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testStateIsCleared() throws Exception {\n        final File fileToProcess = new File(\n                getPath(\"InputTranslationCheckFireErrors_de.properties\")\n        );\n        final String charset = StandardCharsets.UTF_8.name();\n        final TranslationCheck check = new TranslationCheck();\n        check.beginProcessing(charset);\n        check.processFiltered(fileToProcess, new FileText(fileToProcess, charset));\n        check.beginProcessing(charset);\n        final Field field = check.getClass().getDeclaredField(\"filesToProcess\");\n        field.setAccessible(true);\n\n        assertTrue(((Collection<File>) field.get(check)).isEmpty(),\n                \"Stateful field is not cleared on beginProcessing\");\n    }\n\n    @Test\n    public void testFileExtension() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        final File[] propertyFiles = {\n            new File(getPath(\"InputTranslation_de.txt\")),\n        };\n        verify(createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"InputTranslation_de.txt\"),\n            expected);\n    }\n\n    @Test\n    public void testLogOutput() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja,de\");\n        checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n        final Checker checker = createChecker(checkConfig);\n        checker.setBasedir(getPath(\"\"));\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final XMLLogger logger = new XMLLogger(out, AutomaticBean.OutputStreamOptions.NONE);\n        checker.addListener(logger);\n\n        final String defaultProps = getPath(\"InputTranslationCheckFireErrors.properties\");\n        final String translationProps = getPath(\"InputTranslationCheckFireErrors_de.properties\");\n\n        final File[] propertyFiles = {\n            new File(defaultProps),\n            new File(translationProps),\n        };\n\n        final String line = \"1: \";\n        final String firstErrorMessage = getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                \"InputTranslationCheckFireErrors_ja.properties\");\n        final String secondErrorMessage = getCheckMessage(MSG_KEY, \"anotherKey\");\n\n        verify(checker, propertyFiles, ImmutableMap.of(\n            \":1\", Collections.singletonList(\" \" + firstErrorMessage),\n            \"InputTranslationCheckFireErrors_de.properties\",\n                Collections.singletonList(line + secondErrorMessage)));\n\n        verifyXml(getPath(\"ExpectedTranslationLog.xml\"), out, (expected, actual) -> {\n            // order is not always maintained here for an unknown reason.\n            // File names can appear in different orders depending on the OS and VM.\n            // This ensures we pick up the correct file based on its name and the\n            // number of children it has.\n            return !\"file\".equals(expected.getNodeName())\n                    || XmlUtil.getNameAttributeOfNode(expected)\n                        .equals(XmlUtil.getNameAttributeOfNode(actual))\n                    && XmlUtil.getChildrenElements(expected).size() == XmlUtil\n                            .getChildrenElements(actual).size();\n        }, firstErrorMessage, secondErrorMessage);\n    }\n\n    @Test\n    public void testOnePropertyFileSet() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        final File[] propertyFiles = {\n            new File(getPath(\"app-dev.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"app-dev.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testLogIoExceptionFileNotFound() throws Exception {\n        // I can't put wrong file here. Checkstyle fails before check started.\n        // I saw some usage of file or handling of wrong file in Checker, or somewhere\n        // in checks running part. So I had to do it with reflection to improve coverage.\n        final TranslationCheck check = new TranslationCheck();\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        final TestMessageDispatcher dispatcher = new TestMessageDispatcher();\n        check.configure(checkConfig);\n        check.setMessageDispatcher(dispatcher);\n\n        final Set<String> keys = Whitebox.invokeMethod(check, \"getTranslationKeys\",\n                new File(\".no.such.file\"));\n        assertTrue(keys.isEmpty(), \"Translation keys should be empty when File is not found\");\n\n        assertEquals(1, dispatcher.savedErrors.size(), \"expected number of errors to fire\");\n        final LocalizedMessage localizedMessage = new LocalizedMessage(1,\n                Definitions.CHECKSTYLE_BUNDLE, \"general.fileNotFound\",\n                null, null, getClass(), null);\n        assertEquals(localizedMessage.getMessage(),\n                dispatcher.savedErrors.iterator().next().getMessage(), \"Invalid message\");\n    }\n\n    @Test\n    public void testLogIoException() throws Exception {\n        // I can't put wrong file here. Checkstyle fails before check started.\n        // I saw some usage of file or handling of wrong file in Checker, or somewhere\n        // in checks running part. So I had to do it with reflection to improve coverage.\n        final TranslationCheck check = new TranslationCheck();\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        final TestMessageDispatcher dispatcher = new TestMessageDispatcher();\n        check.configure(checkConfig);\n        check.setMessageDispatcher(dispatcher);\n\n        final Exception exception = new IOException(\"test exception\");\n        Whitebox.invokeMethod(check, \"logException\", exception, new File(\"\"));\n\n        assertEquals(1, dispatcher.savedErrors.size(), \"expected number of errors to fire\");\n        final LocalizedMessage localizedMessage = new LocalizedMessage(1,\n                Definitions.CHECKSTYLE_BUNDLE, \"general.exception\",\n                new String[] {exception.getMessage()}, null, getClass(), null);\n        assertEquals(localizedMessage.getMessage(),\n                dispatcher.savedErrors.iterator().next().getMessage(), \"Invalid message\");\n    }\n\n    @Test\n    public void testLogIllegalArgumentException() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"baseName\", \"^bad.*$\");\n        final String[] expected = {\n            \"0: \" + new LocalizedMessage(1, Definitions.CHECKSTYLE_BUNDLE, \"general.exception\",\n                new String[] {\"Malformed \\\\uxxxx encoding.\" }, null, getClass(), null).getMessage(),\n            \"1: \" + getCheckMessage(MSG_KEY, \"test\"),\n        };\n        final File[] propertyFiles = {\n            new File(getPath(\"bad.properties\")),\n            new File(getPath(\"bad_es.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"bad.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testDefaultTranslationFileIsMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja,,, de, ja\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_translation_de.properties\")),\n            new File(getPath(\"messages_translation_ja.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_translation.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testTranslationFilesAreMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja, de\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_translation.properties\")),\n            new File(getPath(\"messages_translation_ja.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_translation_de.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBaseNameWithSeparatorDefaultTranslationIsMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"fr\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages-translation_fr.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages-translation.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBaseNameWithSeparatorTranslationsAreMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"fr, tr\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages-translation.properties\")),\n            new File(getPath(\"messages-translation_fr.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages-translation_tr.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testIsNotMessagesBundle() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"app-dev.properties\")),\n            new File(getPath(\"app-stage.properties\")),\n        };\n\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"app-dev.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testTranslationFileWithLanguageCountryVariantIsMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"es, de\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_home.properties\")),\n            new File(getPath(\"messages_home_es_US.properties\")),\n            new File(getPath(\"messages_home_fr_CA_UNIX.properties\")),\n            };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_home_de.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testTranslationFileWithLanguageCountryVariantArePresent() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"es, fr\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_home.properties\")),\n            new File(getPath(\"messages_home_es_US.properties\")),\n            new File(getPath(\"messages_home_fr_CA_UNIX.properties\")),\n            };\n\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBaseNameOption() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.properties\")),\n            new File(getPath(\"messages_home.properties\")),\n            new File(getPath(\"messages_home_es_US.properties\")),\n            new File(getPath(\"messages_home_fr_CA_UNIX.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_ja.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testFileExtensions() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties,translation\");\n        checkConfig.addAttribute(\"baseName\", \"^.*(Titles|Labels)$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.properties\")),\n            new File(getPath(\"PageTitles.translation\")),\n            new File(getPath(\"PageTitles_de.translation\")),\n            new File(getPath(\"PageTitles_es.translation\")),\n            new File(getPath(\"PageTitles_fr.translation\")),\n            new File(getPath(\"PageTitles_ja.translation\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_ja.properties\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testEqualBaseNamesButDifferentExtensions() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties,translations\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.properties\")),\n            new File(getPath(\"ButtonLabels.translations\")),\n            new File(getPath(\"ButtonLabels_ja.translations\")),\n            new File(getPath(\"ButtonLabels_es.translations\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.translations\")),\n            new File(getPath(\"ButtonLabels_de.translations\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_ja.properties\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testEqualBaseNamesButDifferentExtensions2() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties, translations\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_ja.translations\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels.translations\"),\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_de.translations\"),\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_es.translations\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testRegexpToMatchPartOfBaseName() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties,translations\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels.*\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"MyLabelsI18.properties\")),\n            new File(getPath(\"MyLabelsI18_de.properties\")),\n            new File(getPath(\"MyLabelsI18_es.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE, \"MyLabelsI18_fr.properties\"),\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE, \"MyLabelsI18_ja.properties\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBundlesWithSameNameButDifferentPaths() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels.*\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"MyLabelsI18.properties\")),\n            new File(getPath(\"MyLabelsI18_de.properties\")),\n            new File(getNonCompilablePath(\"MyLabelsI18.properties\")),\n            new File(getNonCompilablePath(\"MyLabelsI18_de.properties\")),\n        };\n\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testWrongUserSpecifiedLanguageCodes() {\n        final TranslationCheck check = new TranslationCheck();\n        try {\n            check.setRequiredTranslations(\"11\");\n            fail(\"IllegalArgumentException is expected. Specified language code is incorrect.\");\n        }\n        catch (IllegalArgumentException ex) {\n            final String exceptionMessage = ex.getMessage();\n            assertThat(\"Error message is unexpected\",\n                    exceptionMessage, containsString(\"11\"));\n            assertThat(\"Error message is unexpected\",\n                    exceptionMessage, endsWith(\"[TranslationCheck]\"));\n        }\n    }\n\n    private static class TestMessageDispatcher implements MessageDispatcher {\n\n        private Set<LocalizedMessage> savedErrors;\n\n        @Override\n        public void fireFileStarted(String fileName) {\n            throw new IllegalStateException(fileName);\n        }\n\n        @Override\n        public void fireFileFinished(String fileName) {\n            throw new IllegalStateException(fileName);\n        }\n\n        @Override\n        public void fireErrors(String fileName, SortedSet<LocalizedMessage> errors) {\n            savedErrors = new TreeSet<>(errors);\n        }\n\n    }\n\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheckTest.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks;\n\nimport static com.puppycrawl.tools.checkstyle.checks.TranslationCheck.MSG_KEY;\nimport static com.puppycrawl.tools.checkstyle.checks.TranslationCheck.MSG_KEY_MISSING_TRANSLATION_FILE;\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.endsWith;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.powermock.reflect.Whitebox;\nimport org.w3c.dom.Node;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.puppycrawl.tools.checkstyle.AbstractXmlTestSupport;\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.DefaultConfiguration;\nimport com.puppycrawl.tools.checkstyle.Definitions;\nimport com.puppycrawl.tools.checkstyle.XMLLogger;\nimport com.puppycrawl.tools.checkstyle.api.AutomaticBean;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.FileText;\nimport com.puppycrawl.tools.checkstyle.api.LocalizedMessage;\nimport com.puppycrawl.tools.checkstyle.api.MessageDispatcher;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\npublic class TranslationCheckTest extends AbstractXmlTestSupport {\n\n    @TempDir\n    public File temporaryFolder;\n\n    @Override\n    protected String getPackageLocation() {\n        return \"com/puppycrawl/tools/checkstyle/checks/translation\";\n    }\n\n    @Test\n    public void testTranslation() throws Exception {\n        final Configuration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY, \"only.english\"),\n        };\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_test_de.properties\")),\n            new File(getPath(\"messages_test.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"messages_test_de.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testDifferentBases() throws Exception {\n        final Configuration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY, \"only.english\"),\n        };\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_test_de.properties\")),\n            new File(getPath(\"messages_test.properties\")),\n            new File(getPath(\"messages_translation.properties\")),\n            new File(getPath(\"messages_translation_de.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"messages_test_de.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testDifferentPaths() throws Exception {\n        final File file = new File(temporaryFolder, \"messages_test_de.properties\");\n        try (Writer writer = Files.newBufferedWriter(file.toPath(), StandardCharsets.UTF_8)) {\n            final String content = \"hello=Hello\\ncancel=Cancel\";\n            writer.write(content);\n        }\n        final Configuration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_test.properties\"),\n        };\n        final File[] propertyFiles = {\n            file,\n            new File(getPath(\"messages_test.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            file.getParent(),\n            expected);\n    }\n\n    /**\n     * Even when we pass several files to AbstractModuleTestSupport#verify,\n     * the check processes it during one run, so we cannot reproduce situation\n     * when TranslationCheck#beginProcessing called several times during single run.\n     * So, we have to use reflection to check this particular case.\n     *\n     * @throws Exception when code tested throws exception\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testStateIsCleared() throws Exception {\n        final File fileToProcess = new File(\n                getPath(\"InputTranslationCheckFireErrors_de.properties\")\n        );\n        final String charset = StandardCharsets.UTF_8.name();\n        final TranslationCheck check = new TranslationCheck();\n        check.beginProcessing(charset);\n        check.processFiltered(fileToProcess, new FileText(fileToProcess, charset));\n        check.beginProcessing(charset);\n        final Field field = check.getClass().getDeclaredField(\"filesToProcess\");\n        field.setAccessible(true);\n\n        assertTrue(((Collection<File>) field.get(check)).isEmpty(),\n                \"Stateful field is not cleared on beginProcessing\");\n    }\n\n    @Test\n    public void testFileExtension() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        final File[] propertyFiles = {\n            new File(getPath(\"InputTranslation_de.txt\")),\n        };\n        verify(createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"InputTranslation_de.txt\"),\n            expected);\n    }\n\n    @Test\n    public void testLogOutput() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja,de\");\n        checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n        final Checker checker = createChecker(checkConfig);\n        checker.setBasedir(getPath(\"\"));\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final XMLLogger logger = new XMLLogger(out, AutomaticBean.OutputStreamOptions.NONE);\n        checker.addListener(logger);\n\n        final String defaultProps = getPath(\"InputTranslationCheckFireErrors.properties\");\n        final String translationProps = getPath(\"InputTranslationCheckFireErrors_de.properties\");\n\n        final File[] propertyFiles = {\n            new File(defaultProps),\n            new File(translationProps),\n        };\n\n        final String line = \"1: \";\n        final String firstErrorMessage = getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                \"InputTranslationCheckFireErrors_ja.properties\");\n        final String secondErrorMessage = getCheckMessage(MSG_KEY, \"anotherKey\");\n\n        verify(checker, propertyFiles, ImmutableMap.of(\n            \":1\", Collections.singletonList(\" \" + firstErrorMessage),\n            \"InputTranslationCheckFireErrors_de.properties\",\n                Collections.singletonList(line + secondErrorMessage)));\n\n        verifyXml(getPath(\"ExpectedTranslationLog.xml\"), out,\n            TranslationCheckTest::isFilenamesEqual,\n            firstErrorMessage, secondErrorMessage);\n    }\n\n    @Test\n    public void testOnePropertyFileSet() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        final File[] propertyFiles = {\n            new File(getPath(\"app-dev.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"app-dev.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testLogIoExceptionFileNotFound() throws Exception {\n        // I can't put wrong file here. Checkstyle fails before check started.\n        // I saw some usage of file or handling of wrong file in Checker, or somewhere\n        // in checks running part. So I had to do it with reflection to improve coverage.\n        final TranslationCheck check = new TranslationCheck();\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        final TestMessageDispatcher dispatcher = new TestMessageDispatcher();\n        check.configure(checkConfig);\n        check.setMessageDispatcher(dispatcher);\n\n        final Set<String> keys = Whitebox.invokeMethod(check, \"getTranslationKeys\",\n                new File(\".no.such.file\"));\n        assertTrue(keys.isEmpty(), \"Translation keys should be empty when File is not found\");\n\n        assertEquals(1, dispatcher.savedErrors.size(), \"expected number of errors to fire\");\n        final LocalizedMessage localizedMessage = new LocalizedMessage(1,\n                Definitions.CHECKSTYLE_BUNDLE, \"general.fileNotFound\",\n                null, null, getClass(), null);\n        assertEquals(localizedMessage.getMessage(),\n                dispatcher.savedErrors.iterator().next().getMessage(), \"Invalid message\");\n    }\n\n    @Test\n    public void testLogIoException() throws Exception {\n        // I can't put wrong file here. Checkstyle fails before check started.\n        // I saw some usage of file or handling of wrong file in Checker, or somewhere\n        // in checks running part. So I had to do it with reflection to improve coverage.\n        final TranslationCheck check = new TranslationCheck();\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        final TestMessageDispatcher dispatcher = new TestMessageDispatcher();\n        check.configure(checkConfig);\n        check.setMessageDispatcher(dispatcher);\n\n        final Exception exception = new IOException(\"test exception\");\n        Whitebox.invokeMethod(check, \"logException\", exception, new File(\"\"));\n\n        assertEquals(1, dispatcher.savedErrors.size(), \"expected number of errors to fire\");\n        final LocalizedMessage localizedMessage = new LocalizedMessage(1,\n                Definitions.CHECKSTYLE_BUNDLE, \"general.exception\",\n                new String[] {exception.getMessage()}, null, getClass(), null);\n        assertEquals(localizedMessage.getMessage(),\n                dispatcher.savedErrors.iterator().next().getMessage(), \"Invalid message\");\n    }\n\n    @Test\n    public void testLogIllegalArgumentException() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"baseName\", \"^bad.*$\");\n        final String[] expected = {\n            \"0: \" + new LocalizedMessage(1, Definitions.CHECKSTYLE_BUNDLE, \"general.exception\",\n                new String[] {\"Malformed \\\\uxxxx encoding.\" }, null, getClass(), null).getMessage(),\n            \"1: \" + getCheckMessage(MSG_KEY, \"test\"),\n        };\n        final File[] propertyFiles = {\n            new File(getPath(\"bad.properties\")),\n            new File(getPath(\"bad_es.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"bad.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testDefaultTranslationFileIsMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja,,, de, ja\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_translation_de.properties\")),\n            new File(getPath(\"messages_translation_ja.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_translation.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testTranslationFilesAreMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja, de\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_translation.properties\")),\n            new File(getPath(\"messages_translation_ja.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_translation_de.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBaseNameWithSeparatorDefaultTranslationIsMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"fr\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages-translation_fr.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages-translation.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBaseNameWithSeparatorTranslationsAreMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"fr, tr\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages-translation.properties\")),\n            new File(getPath(\"messages-translation_fr.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages-translation_tr.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testIsNotMessagesBundle() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"app-dev.properties\")),\n            new File(getPath(\"app-stage.properties\")),\n        };\n\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"app-dev.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testTranslationFileWithLanguageCountryVariantIsMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"es, de\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_home.properties\")),\n            new File(getPath(\"messages_home_es_US.properties\")),\n            new File(getPath(\"messages_home_fr_CA_UNIX.properties\")),\n            };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_home_de.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testTranslationFileWithLanguageCountryVariantArePresent() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"es, fr\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_home.properties\")),\n            new File(getPath(\"messages_home_es_US.properties\")),\n            new File(getPath(\"messages_home_fr_CA_UNIX.properties\")),\n            };\n\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBaseNameOption() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.properties\")),\n            new File(getPath(\"messages_home.properties\")),\n            new File(getPath(\"messages_home_es_US.properties\")),\n            new File(getPath(\"messages_home_fr_CA_UNIX.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_ja.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testFileExtensions() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties,translation\");\n        checkConfig.addAttribute(\"baseName\", \"^.*(Titles|Labels)$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.properties\")),\n            new File(getPath(\"PageTitles.translation\")),\n            new File(getPath(\"PageTitles_de.translation\")),\n            new File(getPath(\"PageTitles_es.translation\")),\n            new File(getPath(\"PageTitles_fr.translation\")),\n            new File(getPath(\"PageTitles_ja.translation\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_ja.properties\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testEqualBaseNamesButDifferentExtensions() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties,translations\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.properties\")),\n            new File(getPath(\"ButtonLabels.translations\")),\n            new File(getPath(\"ButtonLabels_ja.translations\")),\n            new File(getPath(\"ButtonLabels_es.translations\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.translations\")),\n            new File(getPath(\"ButtonLabels_de.translations\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_ja.properties\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testEqualBaseNamesButDifferentExtensions2() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties, translations\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_ja.translations\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels.translations\"),\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_de.translations\"),\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_es.translations\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testRegexpToMatchPartOfBaseName() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties,translations\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels.*\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"MyLabelsI18.properties\")),\n            new File(getPath(\"MyLabelsI18_de.properties\")),\n            new File(getPath(\"MyLabelsI18_es.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE, \"MyLabelsI18_fr.properties\"),\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE, \"MyLabelsI18_ja.properties\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBundlesWithSameNameButDifferentPaths() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels.*\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"MyLabelsI18.properties\")),\n            new File(getPath(\"MyLabelsI18_de.properties\")),\n            new File(getNonCompilablePath(\"MyLabelsI18.properties\")),\n            new File(getNonCompilablePath(\"MyLabelsI18_de.properties\")),\n        };\n\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testWrongUserSpecifiedLanguageCodes() {\n        final TranslationCheck check = new TranslationCheck();\n        try {\n            check.setRequiredTranslations(\"11\");\n            fail(\"IllegalArgumentException is expected. Specified language code is incorrect.\");\n        }\n        catch (IllegalArgumentException ex) {\n            final String exceptionMessage = ex.getMessage();\n            assertThat(\"Error message is unexpected\",\n                    exceptionMessage, containsString(\"11\"));\n            assertThat(\"Error message is unexpected\",\n                    exceptionMessage, endsWith(\"[TranslationCheck]\"));\n        }\n    }\n\n    /**\n     * Compare two file names.\n     *\n     * @param expected expected node\n     * @param actual actual node\n     * @return true if file names match\n     */\n    private static boolean isFilenamesEqual(Node expected, Node actual) {\n        // order is not always maintained here for an unknown reason.\n        // File names can appear in different orders depending on the OS and VM.\n        // This ensures we pick up the correct file based on its name and the\n        // number of children it has.\n        return !\"file\".equals(expected.getNodeName())\n            || XmlUtil.getNameAttributeOfNode(expected)\n            .equals(XmlUtil.getNameAttributeOfNode(actual))\n            && XmlUtil.getChildrenElements(expected).size() == XmlUtil\n            .getChildrenElements(actual).size();\n    }\n\n    private static class TestMessageDispatcher implements MessageDispatcher {\n\n        private Set<LocalizedMessage> savedErrors;\n\n        @Override\n        public void fireFileStarted(String fileName) {\n            throw new IllegalStateException(fileName);\n        }\n\n        @Override\n        public void fireFileFinished(String fileName) {\n            throw new IllegalStateException(fileName);\n        }\n\n        @Override\n        public void fireErrors(String fileName, SortedSet<LocalizedMessage> errors) {\n            savedErrors = new TreeSet<>(errors);\n        }\n\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Compare two file names.\n     *\n     * @param expected expected node\n     * @param actual actual node\n     * @return true if file names match\n     */\n    private static boolean isFilenamesEqual(Node expected, Node actual) {\n        // order is not always maintained here for an unknown reason.\n        // File names can appear in different orders depending on the OS and VM.\n        // This ensures we pick up the correct file based on its name and the\n        // number of children it has.\n        return !\"file\".equals(expected.getNodeName())\n            || XmlUtil.getNameAttributeOfNode(expected)\n            .equals(XmlUtil.getNameAttributeOfNode(actual))\n            && XmlUtil.getChildrenElements(expected).size() == XmlUtil\n            .getChildrenElements(actual).size();\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    public void testLogOutput() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja,de\");\n        checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n        final Checker checker = createChecker(checkConfig);\n        checker.setBasedir(getPath(\"\"));\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final XMLLogger logger = new XMLLogger(out, AutomaticBean.OutputStreamOptions.NONE);\n        checker.addListener(logger);\n\n        final String defaultProps = getPath(\"InputTranslationCheckFireErrors.properties\");\n        final String translationProps = getPath(\"InputTranslationCheckFireErrors_de.properties\");\n\n        final File[] propertyFiles = {\n            new File(defaultProps),\n            new File(translationProps),\n        };\n\n        final String line = \"1: \";\n        final String firstErrorMessage = getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                \"InputTranslationCheckFireErrors_ja.properties\");\n        final String secondErrorMessage = getCheckMessage(MSG_KEY, \"anotherKey\");\n\n        verify(checker, propertyFiles, ImmutableMap.of(\n            \":1\", Collections.singletonList(\" \" + firstErrorMessage),\n            \"InputTranslationCheckFireErrors_de.properties\",\n                Collections.singletonList(line + secondErrorMessage)));\n\n        verifyXml(getPath(\"ExpectedTranslationLog.xml\"), out,\n            TranslationCheckTest::isFilenamesEqual,\n            firstErrorMessage, secondErrorMessage);\n    }\n/**\n     * Compare two file names.\n     *\n     * @param expected expected node\n     * @param actual actual node\n     * @return true if file names match\n     */\n    private static boolean isFilenamesEqual(Node expected, Node actual) {\n        // order is not always maintained here for an unknown reason.\n        // File names can appear in different orders depending on the OS and VM.\n        // This ensures we pick up the correct file based on its name and the\n        // number of children it has.\n        return !\"file\".equals(expected.getNodeName())\n            || XmlUtil.getNameAttributeOfNode(expected)\n            .equals(XmlUtil.getNameAttributeOfNode(actual))\n            && XmlUtil.getChildrenElements(expected).size() == XmlUtil\n            .getChildrenElements(actual).size();\n    }", "diffSourceCode": "-  171:     @Test\n-  172:     public void testLogOutput() throws Exception {\n-  173:         final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n-  174:         checkConfig.addAttribute(\"requiredTranslations\", \"ja,de\");\n-  175:         checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n-  176:         final Checker checker = createChecker(checkConfig);\n-  177:         checker.setBasedir(getPath(\"\"));\n-  178:         final ByteArrayOutputStream out = new ByteArrayOutputStream();\n-  179:         final XMLLogger logger = new XMLLogger(out, AutomaticBean.OutputStreamOptions.NONE);\n-  180:         checker.addListener(logger);\n-  181: \n-  182:         final String defaultProps = getPath(\"InputTranslationCheckFireErrors.properties\");\n-  183:         final String translationProps = getPath(\"InputTranslationCheckFireErrors_de.properties\");\n-  184: \n-  185:         final File[] propertyFiles = {\n-  186:             new File(defaultProps),\n-  187:             new File(translationProps),\n-  188:         };\n-  189: \n-  190:         final String line = \"1: \";\n-  191:         final String firstErrorMessage = getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n-  192:                 \"InputTranslationCheckFireErrors_ja.properties\");\n-  193:         final String secondErrorMessage = getCheckMessage(MSG_KEY, \"anotherKey\");\n-  194: \n-  195:         verify(checker, propertyFiles, ImmutableMap.of(\n-  196:             \":1\", Collections.singletonList(\" \" + firstErrorMessage),\n-  197:             \"InputTranslationCheckFireErrors_de.properties\",\n-  198:                 Collections.singletonList(line + secondErrorMessage)));\n-  199: \n-  200:         verifyXml(getPath(\"ExpectedTranslationLog.xml\"), out, (expected, actual) -> {\n-  201:             // order is not always maintained here for an unknown reason.\n-  202:             // File names can appear in different orders depending on the OS and VM.\n-  203:             // This ensures we pick up the correct file based on its name and the\n-  204:             // number of children it has.\n-  205:             return !\"file\".equals(expected.getNodeName())\n-  206:                     || XmlUtil.getNameAttributeOfNode(expected)\n-  207:                         .equals(XmlUtil.getNameAttributeOfNode(actual))\n-  208:                     && XmlUtil.getChildrenElements(expected).size() == XmlUtil\n-  209:                             .getChildrenElements(actual).size();\n-  210:         }, firstErrorMessage, secondErrorMessage);\n-  211:     }\n-  610:             assertThat(\"Error message is unexpected\",\n-  611:                     exceptionMessage, containsString(\"11\"));\n-  612:             assertThat(\"Error message is unexpected\",\n-  613:                     exceptionMessage, endsWith(\"[TranslationCheck]\"));\n-  614:         }\n-  615:     }\n-  616: \n-  617:     private static class TestMessageDispatcher implements MessageDispatcher {\n-  618: \n-  619:         private Set<LocalizedMessage> savedErrors;\n-  620: \n-  621:         @Override\n-  622:         public void fireFileStarted(String fileName) {\n-  623:             throw new IllegalStateException(fileName);\n-  624:         }\n-  625: \n-  626:         @Override\n-  627:         public void fireFileFinished(String fileName) {\n+  171: \n+  172:     @Test\n+  173:     public void testLogOutput() throws Exception {\n+  174:         final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n+  175:         checkConfig.addAttribute(\"requiredTranslations\", \"ja,de\");\n+  176:         checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n+  177:         final Checker checker = createChecker(checkConfig);\n+  178:         checker.setBasedir(getPath(\"\"));\n+  179:         final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+  180:         final XMLLogger logger = new XMLLogger(out, AutomaticBean.OutputStreamOptions.NONE);\n+  181:         checker.addListener(logger);\n+  182: \n+  183:         final String defaultProps = getPath(\"InputTranslationCheckFireErrors.properties\");\n+  184:         final String translationProps = getPath(\"InputTranslationCheckFireErrors_de.properties\");\n+  185: \n+  186:         final File[] propertyFiles = {\n+  187:             new File(defaultProps),\n+  188:             new File(translationProps),\n+  189:         };\n+  190: \n+  191:         final String line = \"1: \";\n+  192:         final String firstErrorMessage = getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n+  193:                 \"InputTranslationCheckFireErrors_ja.properties\");\n+  194:         final String secondErrorMessage = getCheckMessage(MSG_KEY, \"anotherKey\");\n+  195: \n+  196:         verify(checker, propertyFiles, ImmutableMap.of(\n+  197:             \":1\", Collections.singletonList(\" \" + firstErrorMessage),\n+  198:             \"InputTranslationCheckFireErrors_de.properties\",\n+  199:                 Collections.singletonList(line + secondErrorMessage)));\n+  200: \n+  201:         verifyXml(getPath(\"ExpectedTranslationLog.xml\"), out,\n+  202:             TranslationCheckTest::isFilenamesEqual,\n+  203:             firstErrorMessage, secondErrorMessage);\n+  204:     }\n+  205: \n+  206:     @Test\n+  207:     public void testOnePropertyFileSet() throws Exception {\n+  208:         final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n+  209:         final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n+  210:         final File[] propertyFiles = {\n+  211:             new File(getPath(\"app-dev.properties\")),\n+  610:     /**\n+  611:      * Compare two file names.\n+  612:      *\n+  613:      * @param expected expected node\n+  614:      * @param actual actual node\n+  615:      * @return true if file names match\n+  616:      */\n+  617:     private static boolean isFilenamesEqual(Node expected, Node actual) {\n+  618:         // order is not always maintained here for an unknown reason.\n+  619:         // File names can appear in different orders depending on the OS and VM.\n+  620:         // This ensures we pick up the correct file based on its name and the\n+  621:         // number of children it has.\n+  622:         return !\"file\".equals(expected.getNodeName())\n+  623:             || XmlUtil.getNameAttributeOfNode(expected)\n+  624:             .equals(XmlUtil.getNameAttributeOfNode(actual))\n+  625:             && XmlUtil.getChildrenElements(expected).size() == XmlUtil\n+  626:             .getChildrenElements(actual).size();\n+  627:     }\n", "uniqueId": "3c2249b239cbfe002af3649f1f7c1f9ae61df3b1_171_211_610_627_172_204", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nRefactored Method Code:\n\nprivate void setupCheckerAndLogger() {\n    final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n    checkConfig.addAttribute(\"requiredTranslations\", \"ja,de\");\n    checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n    final Checker checker = createChecker(checkConfig);\n    checker.setBasedir(getPath(\"\"));\n    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n    final XMLLogger logger = new XMLLogger(out, AutomaticBean.OutputStreamOptions.NONE);\n    checker.addListener(logger);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Test\n    public void testLogOutput() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja,de\");\n        checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n        final Checker checker = createChecker(checkConfig);\n        checker.setBasedir(getPath(\"\"));\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final XMLLogger logger = new XMLLogger(out, AutomaticBean.OutputStreamOptions.NONE);\n        checker.addListener(logger);\n\n        final String defaultProps = getPath(\"InputTranslationCheckFireErrors.properties\");\n        final String translationProps = getPath(\"InputTranslationCheckFireErrors_de.properties\");\n\n        final File[] propertyFiles = {\n            new File(defaultProps),\n            new File(translationProps),\n        };\n\n        final String line = \"1: \";\n        final String firstErrorMessage = getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                \"InputTranslationCheckFireErrors_ja.properties\");\n        final String secondErrorMessage = getCheckMessage(MSG_KEY, \"anotherKey\");\n\n        verify(checker, propertyFiles, ImmutableMap.of(\n            \":1\", Collections.singletonList(\" \" + firstErrorMessage),\n            \"InputTranslationCheckFireErrors_de.properties\",\n                Collections.singletonList(line + secondErrorMessage)));\n\n        verifyXml(getPath(\"ExpectedTranslationLog.xml\"), out, (expected, actual) -> {\n            // order is not always maintained here for an unknown reason.\n            // File names can appear in different orders depending on the OS and VM.\n            // This ensures we pick up the correct file based on its name and the\n            // number of children it has.\n            return !\"file\".equals(expected.getNodeName())\n                    || XmlUtil.getNameAttributeOfNode(expected)\n                        .equals(XmlUtil.getNameAttributeOfNode(actual))\n                    && XmlUtil.getChildrenElements(expected).size() == XmlUtil\n                            .getChildrenElements(actual).size();\n        }, firstErrorMessage, secondErrorMessage);\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks;\n\nimport static com.puppycrawl.tools.checkstyle.checks.TranslationCheck.MSG_KEY;\nimport static com.puppycrawl.tools.checkstyle.checks.TranslationCheck.MSG_KEY_MISSING_TRANSLATION_FILE;\nimport static org.hamcrest.CoreMatchers.containsString;\nimport static org.hamcrest.CoreMatchers.endsWith;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.lang.reflect.Field;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\nimport org.powermock.reflect.Whitebox;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.puppycrawl.tools.checkstyle.AbstractXmlTestSupport;\nimport com.puppycrawl.tools.checkstyle.Checker;\nimport com.puppycrawl.tools.checkstyle.DefaultConfiguration;\nimport com.puppycrawl.tools.checkstyle.Definitions;\nimport com.puppycrawl.tools.checkstyle.XMLLogger;\nimport com.puppycrawl.tools.checkstyle.api.AutomaticBean;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.api.FileText;\nimport com.puppycrawl.tools.checkstyle.api.LocalizedMessage;\nimport com.puppycrawl.tools.checkstyle.api.MessageDispatcher;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\npublic class TranslationCheckTest extends AbstractXmlTestSupport {\n\n    @TempDir\n    public File temporaryFolder;\n\n    @Override\n    protected String getPackageLocation() {\n        return \"com/puppycrawl/tools/checkstyle/checks/translation\";\n    }\n\n    @Test\n    public void testTranslation() throws Exception {\n        final Configuration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY, \"only.english\"),\n        };\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_test_de.properties\")),\n            new File(getPath(\"messages_test.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"messages_test_de.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testDifferentBases() throws Exception {\n        final Configuration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY, \"only.english\"),\n        };\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_test_de.properties\")),\n            new File(getPath(\"messages_test.properties\")),\n            new File(getPath(\"messages_translation.properties\")),\n            new File(getPath(\"messages_translation_de.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"messages_test_de.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testDifferentPaths() throws Exception {\n        final File file = new File(temporaryFolder, \"messages_test_de.properties\");\n        try (Writer writer = Files.newBufferedWriter(file.toPath(), StandardCharsets.UTF_8)) {\n            final String content = \"hello=Hello\\ncancel=Cancel\";\n            writer.write(content);\n        }\n        final Configuration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_test.properties\"),\n        };\n        final File[] propertyFiles = {\n            file,\n            new File(getPath(\"messages_test.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            file.getParent(),\n            expected);\n    }\n\n    /**\n     * Even when we pass several files to AbstractModuleTestSupport#verify,\n     * the check processes it during one run, so we cannot reproduce situation\n     * when TranslationCheck#beginProcessing called several times during single run.\n     * So, we have to use reflection to check this particular case.\n     *\n     * @throws Exception when code tested throws exception\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testStateIsCleared() throws Exception {\n        final File fileToProcess = new File(\n                getPath(\"InputTranslationCheckFireErrors_de.properties\")\n        );\n        final String charset = StandardCharsets.UTF_8.name();\n        final TranslationCheck check = new TranslationCheck();\n        check.beginProcessing(charset);\n        check.processFiltered(fileToProcess, new FileText(fileToProcess, charset));\n        check.beginProcessing(charset);\n        final Field field = check.getClass().getDeclaredField(\"filesToProcess\");\n        field.setAccessible(true);\n\n        assertTrue(((Collection<File>) field.get(check)).isEmpty(),\n                \"Stateful field is not cleared on beginProcessing\");\n    }\n\n    @Test\n    public void testFileExtension() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        final File[] propertyFiles = {\n            new File(getPath(\"InputTranslation_de.txt\")),\n        };\n        verify(createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"InputTranslation_de.txt\"),\n            expected);\n    }\n\n    @Test\n    public void testLogOutput() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja,de\");\n        checkConfig.addAttribute(\"baseName\", \"^InputTranslation.*$\");\n        final Checker checker = createChecker(checkConfig);\n        checker.setBasedir(getPath(\"\"));\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        final XMLLogger logger = new XMLLogger(out, AutomaticBean.OutputStreamOptions.NONE);\n        checker.addListener(logger);\n\n        final String defaultProps = getPath(\"InputTranslationCheckFireErrors.properties\");\n        final String translationProps = getPath(\"InputTranslationCheckFireErrors_de.properties\");\n\n        final File[] propertyFiles = {\n            new File(defaultProps),\n            new File(translationProps),\n        };\n\n        final String line = \"1: \";\n        final String firstErrorMessage = getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                \"InputTranslationCheckFireErrors_ja.properties\");\n        final String secondErrorMessage = getCheckMessage(MSG_KEY, \"anotherKey\");\n\n        verify(checker, propertyFiles, ImmutableMap.of(\n            \":1\", Collections.singletonList(\" \" + firstErrorMessage),\n            \"InputTranslationCheckFireErrors_de.properties\",\n                Collections.singletonList(line + secondErrorMessage)));\n\n        verifyXml(getPath(\"ExpectedTranslationLog.xml\"), out, (expected, actual) -> {\n            // order is not always maintained here for an unknown reason.\n            // File names can appear in different orders depending on the OS and VM.\n            // This ensures we pick up the correct file based on its name and the\n            // number of children it has.\n            return !\"file\".equals(expected.getNodeName())\n                    || XmlUtil.getNameAttributeOfNode(expected)\n                        .equals(XmlUtil.getNameAttributeOfNode(actual))\n                    && XmlUtil.getChildrenElements(expected).size() == XmlUtil\n                            .getChildrenElements(actual).size();\n        }, firstErrorMessage, secondErrorMessage);\n    }\n\n    @Test\n    public void testOnePropertyFileSet() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        final File[] propertyFiles = {\n            new File(getPath(\"app-dev.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"app-dev.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testLogIoExceptionFileNotFound() throws Exception {\n        // I can't put wrong file here. Checkstyle fails before check started.\n        // I saw some usage of file or handling of wrong file in Checker, or somewhere\n        // in checks running part. So I had to do it with reflection to improve coverage.\n        final TranslationCheck check = new TranslationCheck();\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        final TestMessageDispatcher dispatcher = new TestMessageDispatcher();\n        check.configure(checkConfig);\n        check.setMessageDispatcher(dispatcher);\n\n        final Set<String> keys = Whitebox.invokeMethod(check, \"getTranslationKeys\",\n                new File(\".no.such.file\"));\n        assertTrue(keys.isEmpty(), \"Translation keys should be empty when File is not found\");\n\n        assertEquals(1, dispatcher.savedErrors.size(), \"expected number of errors to fire\");\n        final LocalizedMessage localizedMessage = new LocalizedMessage(1,\n                Definitions.CHECKSTYLE_BUNDLE, \"general.fileNotFound\",\n                null, null, getClass(), null);\n        assertEquals(localizedMessage.getMessage(),\n                dispatcher.savedErrors.iterator().next().getMessage(), \"Invalid message\");\n    }\n\n    @Test\n    public void testLogIoException() throws Exception {\n        // I can't put wrong file here. Checkstyle fails before check started.\n        // I saw some usage of file or handling of wrong file in Checker, or somewhere\n        // in checks running part. So I had to do it with reflection to improve coverage.\n        final TranslationCheck check = new TranslationCheck();\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        final TestMessageDispatcher dispatcher = new TestMessageDispatcher();\n        check.configure(checkConfig);\n        check.setMessageDispatcher(dispatcher);\n\n        final Exception exception = new IOException(\"test exception\");\n        Whitebox.invokeMethod(check, \"logException\", exception, new File(\"\"));\n\n        assertEquals(1, dispatcher.savedErrors.size(), \"expected number of errors to fire\");\n        final LocalizedMessage localizedMessage = new LocalizedMessage(1,\n                Definitions.CHECKSTYLE_BUNDLE, \"general.exception\",\n                new String[] {exception.getMessage()}, null, getClass(), null);\n        assertEquals(localizedMessage.getMessage(),\n                dispatcher.savedErrors.iterator().next().getMessage(), \"Invalid message\");\n    }\n\n    @Test\n    public void testLogIllegalArgumentException() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"baseName\", \"^bad.*$\");\n        final String[] expected = {\n            \"0: \" + new LocalizedMessage(1, Definitions.CHECKSTYLE_BUNDLE, \"general.exception\",\n                new String[] {\"Malformed \\\\uxxxx encoding.\" }, null, getClass(), null).getMessage(),\n            \"1: \" + getCheckMessage(MSG_KEY, \"test\"),\n        };\n        final File[] propertyFiles = {\n            new File(getPath(\"bad.properties\")),\n            new File(getPath(\"bad_es.properties\")),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"bad.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testDefaultTranslationFileIsMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja,,, de, ja\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_translation_de.properties\")),\n            new File(getPath(\"messages_translation_ja.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_translation.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testTranslationFilesAreMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"ja, de\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_translation.properties\")),\n            new File(getPath(\"messages_translation_ja.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_translation_de.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBaseNameWithSeparatorDefaultTranslationIsMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"fr\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages-translation_fr.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages-translation.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBaseNameWithSeparatorTranslationsAreMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"fr, tr\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages-translation.properties\")),\n            new File(getPath(\"messages-translation_fr.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages-translation_tr.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testIsNotMessagesBundle() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"app-dev.properties\")),\n            new File(getPath(\"app-stage.properties\")),\n        };\n\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"app-dev.properties\"),\n            expected);\n    }\n\n    @Test\n    public void testTranslationFileWithLanguageCountryVariantIsMissing() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"es, de\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_home.properties\")),\n            new File(getPath(\"messages_home_es_US.properties\")),\n            new File(getPath(\"messages_home_fr_CA_UNIX.properties\")),\n            };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"messages_home_de.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testTranslationFileWithLanguageCountryVariantArePresent() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"es, fr\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"messages_home.properties\")),\n            new File(getPath(\"messages_home_es_US.properties\")),\n            new File(getPath(\"messages_home_fr_CA_UNIX.properties\")),\n            };\n\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBaseNameOption() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.properties\")),\n            new File(getPath(\"messages_home.properties\")),\n            new File(getPath(\"messages_home_es_US.properties\")),\n            new File(getPath(\"messages_home_fr_CA_UNIX.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_ja.properties\"),\n        };\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testFileExtensions() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties,translation\");\n        checkConfig.addAttribute(\"baseName\", \"^.*(Titles|Labels)$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.properties\")),\n            new File(getPath(\"PageTitles.translation\")),\n            new File(getPath(\"PageTitles_de.translation\")),\n            new File(getPath(\"PageTitles_es.translation\")),\n            new File(getPath(\"PageTitles_fr.translation\")),\n            new File(getPath(\"PageTitles_ja.translation\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_ja.properties\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testEqualBaseNamesButDifferentExtensions() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties,translations\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.properties\")),\n            new File(getPath(\"ButtonLabels.translations\")),\n            new File(getPath(\"ButtonLabels_ja.translations\")),\n            new File(getPath(\"ButtonLabels_es.translations\")),\n            new File(getPath(\"ButtonLabels_fr_CA_UNIX.translations\")),\n            new File(getPath(\"ButtonLabels_de.translations\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_ja.properties\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testEqualBaseNamesButDifferentExtensions2() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties, translations\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels$\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"ButtonLabels.properties\")),\n            new File(getPath(\"ButtonLabels_de.properties\")),\n            new File(getPath(\"ButtonLabels_es.properties\")),\n            new File(getPath(\"ButtonLabels_ja.translations\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels.translations\"),\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_de.translations\"),\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE,\n                    \"ButtonLabels_es.translations\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testRegexpToMatchPartOfBaseName() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de, es, fr, ja\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties,translations\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels.*\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"MyLabelsI18.properties\")),\n            new File(getPath(\"MyLabelsI18_de.properties\")),\n            new File(getPath(\"MyLabelsI18_es.properties\")),\n        };\n\n        final String[] expected = {\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE, \"MyLabelsI18_fr.properties\"),\n            \"1: \" + getCheckMessage(MSG_KEY_MISSING_TRANSLATION_FILE, \"MyLabelsI18_ja.properties\"),\n        };\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testBundlesWithSameNameButDifferentPaths() throws Exception {\n        final DefaultConfiguration checkConfig = createModuleConfig(TranslationCheck.class);\n        checkConfig.addAttribute(\"requiredTranslations\", \"de\");\n        checkConfig.addAttribute(\"fileExtensions\", \"properties\");\n        checkConfig.addAttribute(\"baseName\", \"^.*Labels.*\");\n\n        final File[] propertyFiles = {\n            new File(getPath(\"MyLabelsI18.properties\")),\n            new File(getPath(\"MyLabelsI18_de.properties\")),\n            new File(getNonCompilablePath(\"MyLabelsI18.properties\")),\n            new File(getNonCompilablePath(\"MyLabelsI18_de.properties\")),\n        };\n\n        final String[] expected = CommonUtil.EMPTY_STRING_ARRAY;\n\n        verify(\n            createChecker(checkConfig),\n            propertyFiles,\n            getPath(\"\"),\n            expected);\n    }\n\n    @Test\n    public void testWrongUserSpecifiedLanguageCodes() {\n        final TranslationCheck check = new TranslationCheck();\n        try {\n            check.setRequiredTranslations(\"11\");\n            fail(\"IllegalArgumentException is expected. Specified language code is incorrect.\");\n        }\n        catch (IllegalArgumentException ex) {\n            final String exceptionMessage = ex.getMessage();\n            assertThat(\"Error message is unexpected\",\n                    exceptionMessage, containsString(\"11\"));\n            assertThat(\"Error message is unexpected\",\n                    exceptionMessage, endsWith(\"[TranslationCheck]\"));\n        }\n    }\n\n    private static class TestMessageDispatcher implements MessageDispatcher {\n\n        private Set<LocalizedMessage> savedErrors;\n\n        @Override\n        public void fireFileStarted(String fileName) {\n            throw new IllegalStateException(fileName);\n        }\n\n        @Override\n        public void fireFileFinished(String fileName) {\n            throw new IllegalStateException(fileName);\n        }\n\n        @Override\n        public void fireErrors(String fileName, SortedSet<LocalizedMessage> errors) {\n            savedErrors = new TreeSet<>(errors);\n        }\n\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate isResourceChanged(resource ExternalResource) : boolean extracted from private areExternalResourcesChanged(resources Set<ExternalResource>) : boolean in class com.puppycrawl.tools.checkstyle.PropertyCacheFile", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java", "startLine": 327, "endLine": 348, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java", "startLine": 327, "endLine": 335, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java", "startLine": 337, "endLine": 356, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks whether the contents of external configuration resources were changed.\n     *\n     * @param resources a set of {@link ExternalResource}.\n     * @return true if the contents of external configuration resources were changed.\n     */\n    private boolean areExternalResourcesChanged(Set<ExternalResource> resources) {\n        return resources.stream().anyMatch(resource -> {\n            boolean changed = false;\n            if (isResourceLocationInCache(resource.location)) {\n                final String contentHashSum = resource.contentHashSum;\n                final String cachedHashSum = details.getProperty(resource.location);\n                if (!cachedHashSum.equals(contentHashSum)) {\n                    changed = true;\n                }\n            }\n            else {\n                changed = true;\n            }\n            return changed;\n        });\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java", "isPureRefactoring": true, "commitId": "3c2249b239cbfe002af3649f1f7c1f9ae61df3b1", "packageNameBefore": "com.puppycrawl.tools.checkstyle", "classNameBefore": "com.puppycrawl.tools.checkstyle.PropertyCacheFile", "methodNameBefore": "com.puppycrawl.tools.checkstyle.PropertyCacheFile#areExternalResourcesChanged", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.PropertyCacheFile#isResourceLocationInCache\n methodBody: private boolean isResourceLocationInCache(String location) {\nfinal String cachedHashSum=details.getProperty(location);\nreturn cachedHashSum != null;\n}", "classSignatureBefore": "public final class PropertyCacheFile ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.PropertyCacheFile#areExternalResourcesChanged"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.PropertyCacheFile"], "classSignatureBeforeSet": ["public final class PropertyCacheFile "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * This class maintains a persistent(on file-system) store of the files\n * that have checked ok(no validation events) and their associated\n * timestamp. It is used to optimize Checkstyle between few launches.\n * It is mostly useful for plugin and extensions of Checkstyle.\n * It uses a property file\n * for storage.  A hashcode of the Configuration is stored in the\n * cache file to ensure the cache is invalidated when the\n * configuration has changed.\n *\n */\npublic final class PropertyCacheFile {\n\n    /**\n     * The property key to use for storing the hashcode of the\n     * configuration. To avoid name clashes with the files that are\n     * checked the key is chosen in such a way that it cannot be a\n     * valid file name.\n     */\n    public static final String CONFIG_HASH_KEY = \"configuration*?\";\n\n    /**\n     * The property prefix to use for storing the hashcode of an\n     * external resource. To avoid name clashes with the files that are\n     * checked the prefix is chosen in such a way that it cannot be a\n     * valid file name and makes it clear it is a resource.\n     */\n    public static final String EXTERNAL_RESOURCE_KEY_PREFIX = \"module-resource*?:\";\n\n    /** Size of default byte array for buffer. */\n    private static final int BUFFER_SIZE = 1024;\n\n    /** Default buffer for reading from streams. */\n    private static final byte[] BUFFER = new byte[BUFFER_SIZE];\n\n    /** Default number for base 16 encoding. */\n    private static final int BASE_16 = 16;\n\n    /** The details on files. **/\n    private final Properties details = new Properties();\n\n    /** Configuration object. **/\n    private final Configuration config;\n\n    /** File name of cache. **/\n    private final String fileName;\n\n    /** Generated configuration hash. **/\n    private String configHash;\n\n    /**\n     * Creates a new {@code PropertyCacheFile} instance.\n     *\n     * @param config the current configuration, not null\n     * @param fileName the cache file\n     * @throws IllegalArgumentException when either arguments are null\n     */\n    public PropertyCacheFile(Configuration config, String fileName) {\n        if (config == null) {\n            throw new IllegalArgumentException(\"config can not be null\");\n        }\n        if (fileName == null) {\n            throw new IllegalArgumentException(\"fileName can not be null\");\n        }\n        this.config = config;\n        this.fileName = fileName;\n    }\n\n    /**\n     * Load cached values from file.\n     *\n     * @throws IOException when there is a problems with file read\n     */\n    public void load() throws IOException {\n        // get the current config so if the file isn't found\n        // the first time the hash will be added to output file\n        configHash = getHashCodeBasedOnObjectContent(config);\n        final File file = new File(fileName);\n        if (file.exists()) {\n            try (InputStream inStream = Files.newInputStream(file.toPath())) {\n                details.load(inStream);\n                final String cachedConfigHash = details.getProperty(CONFIG_HASH_KEY);\n                if (!configHash.equals(cachedConfigHash)) {\n                    // Detected configuration change - clear cache\n                    reset();\n                }\n            }\n        }\n        else {\n            // put the hash in the file if the file is going to be created\n            reset();\n        }\n    }\n\n    /**\n     * Cleans up the object and updates the cache file.\n     *\n     * @throws IOException  when there is a problems with file save\n     */\n    public void persist() throws IOException {\n        final Path path = Paths.get(fileName);\n        final Path directory = path.getParent();\n        if (directory != null) {\n            Files.createDirectories(directory);\n        }\n        try (OutputStream out = Files.newOutputStream(path)) {\n            details.store(out, null);\n        }\n    }\n\n    /**\n     * Resets the cache to be empty except for the configuration hash.\n     */\n    public void reset() {\n        details.clear();\n        details.setProperty(CONFIG_HASH_KEY, configHash);\n    }\n\n    /**\n     * Checks that file is in cache.\n     *\n     * @param uncheckedFileName the file to check\n     * @param timestamp the timestamp of the file to check\n     * @return whether the specified file has already been checked ok\n     */\n    public boolean isInCache(String uncheckedFileName, long timestamp) {\n        final String lastChecked = details.getProperty(uncheckedFileName);\n        return Objects.equals(lastChecked, Long.toString(timestamp));\n    }\n\n    /**\n     * Records that a file checked ok.\n     *\n     * @param checkedFileName name of the file that checked ok\n     * @param timestamp the timestamp of the file\n     */\n    public void put(String checkedFileName, long timestamp) {\n        details.setProperty(checkedFileName, Long.toString(timestamp));\n    }\n\n    /**\n     * Retrieves the hash of a specific file.\n     *\n     * @param name The name of the file to retrieve.\n     * @return The has of the file or {@code null}.\n     */\n    public String get(String name) {\n        return details.getProperty(name);\n    }\n\n    /**\n     * Removed a specific file from the cache.\n     *\n     * @param checkedFileName The name of the file to remove.\n     */\n    public void remove(String checkedFileName) {\n        details.remove(checkedFileName);\n    }\n\n    /**\n     * Calculates the hashcode for the serializable object based on its content.\n     *\n     * @param object serializable object.\n     * @return the hashcode for serializable object.\n     * @throws IllegalStateException when some unexpected happened.\n     */\n    private static String getHashCodeBasedOnObjectContent(Serializable object) {\n        try {\n            final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            // in-memory serialization of Configuration\n            serialize(object, outputStream);\n            // Instead of hexEncoding outputStream.toByteArray() directly we\n            // use a message digest here to keep the length of the\n            // hashcode reasonable\n\n            final MessageDigest digest = MessageDigest.getInstance(\"SHA-1\");\n            digest.update(outputStream.toByteArray());\n\n            return new BigInteger(1, digest.digest()).toString(BASE_16).toUpperCase(Locale.ROOT);\n        }\n        catch (final IOException | NoSuchAlgorithmException ex) {\n            // rethrow as unchecked exception\n            throw new IllegalStateException(\"Unable to calculate hashcode.\", ex);\n        }\n    }\n\n    /**\n     * Serializes object to output stream.\n     *\n     * @param object object to be serialized\n     * @param outputStream serialization stream\n     * @throws IOException if an error occurs\n     */\n    private static void serialize(Serializable object,\n                                  OutputStream outputStream) throws IOException {\n        try (ObjectOutputStream oos = new ObjectOutputStream(outputStream)) {\n            oos.writeObject(object);\n        }\n    }\n\n    /**\n     * Puts external resources in cache.\n     * If at least one external resource changed, clears the cache.\n     *\n     * @param locations locations of external resources.\n     */\n    public void putExternalResources(Set<String> locations) {\n        final Set<ExternalResource> resources = loadExternalResources(locations);\n        if (areExternalResourcesChanged(resources)) {\n            reset();\n            fillCacheWithExternalResources(resources);\n        }\n    }\n\n    /**\n     * Loads a set of {@link ExternalResource} based on their locations.\n     *\n     * @param resourceLocations locations of external configuration resources.\n     * @return a set of {@link ExternalResource}.\n     */\n    private static Set<ExternalResource> loadExternalResources(Set<String> resourceLocations) {\n        final Set<ExternalResource> resources = new HashSet<>();\n        for (String location : resourceLocations) {\n            try {\n                final byte[] content = loadExternalResource(location);\n                final String contentHashSum = getHashCodeBasedOnObjectContent(content);\n                resources.add(new ExternalResource(EXTERNAL_RESOURCE_KEY_PREFIX + location,\n                        contentHashSum));\n            }\n            catch (CheckstyleException | IOException ex) {\n                // if exception happened (configuration resource was not found, connection is not\n                // available, resource is broken, etc), we need to calculate hash sum based on\n                // exception object content in order to check whether problem is resolved later\n                // and/or the configuration is changed.\n                final String contentHashSum = getHashCodeBasedOnObjectContent(ex);\n                resources.add(new ExternalResource(EXTERNAL_RESOURCE_KEY_PREFIX + location,\n                        contentHashSum));\n            }\n        }\n        return resources;\n    }\n\n    /**\n     * Loads the content of external resource.\n     *\n     * @param location external resource location.\n     * @return array of bytes which represents the content of external resource in binary form.\n     * @throws IOException if error while loading occurs.\n     * @throws CheckstyleException if error while loading occurs.\n     */\n    private static byte[] loadExternalResource(String location)\n            throws IOException, CheckstyleException {\n        final URI uri = CommonUtil.getUriByFilename(location);\n\n        try (InputStream is = uri.toURL().openStream()) {\n            return toByteArray(is);\n        }\n    }\n\n    /**\n     * Reads all the contents of an input stream and returns it as a byte array.\n     *\n     * @param stream The input stream to read from.\n     * @return The resulting byte array of the stream.\n     * @throws IOException if there is an error reading the input stream.\n     */\n    private static byte[] toByteArray(InputStream stream) throws IOException {\n        final ByteArrayOutputStream content = new ByteArrayOutputStream();\n\n        while (true) {\n            final int size = stream.read(BUFFER);\n            if (size == -1) {\n                break;\n            }\n\n            content.write(BUFFER, 0, size);\n        }\n\n        return content.toByteArray();\n    }\n\n    /**\n     * Checks whether the contents of external configuration resources were changed.\n     *\n     * @param resources a set of {@link ExternalResource}.\n     * @return true if the contents of external configuration resources were changed.\n     */\n    private boolean areExternalResourcesChanged(Set<ExternalResource> resources) {\n        return resources.stream().anyMatch(resource -> {\n            boolean changed = false;\n            if (isResourceLocationInCache(resource.location)) {\n                final String contentHashSum = resource.contentHashSum;\n                final String cachedHashSum = details.getProperty(resource.location);\n                if (!cachedHashSum.equals(contentHashSum)) {\n                    changed = true;\n                }\n            }\n            else {\n                changed = true;\n            }\n            return changed;\n        });\n    }\n\n    /**\n     * Fills cache with a set of {@link ExternalResource}.\n     * If external resource from the set is already in cache, it will be skipped.\n     *\n     * @param externalResources a set of {@link ExternalResource}.\n     */\n    private void fillCacheWithExternalResources(Set<ExternalResource> externalResources) {\n        externalResources\n            .forEach(resource -> details.setProperty(resource.location, resource.contentHashSum));\n    }\n\n    /**\n     * Checks whether resource location is in cache.\n     *\n     * @param location resource location.\n     * @return true if resource location is in cache.\n     */\n    private boolean isResourceLocationInCache(String location) {\n        final String cachedHashSum = details.getProperty(location);\n        return cachedHashSum != null;\n    }\n\n    /**\n     * Class which represents external resource.\n     */\n    private static class ExternalResource {\n\n        /** Location of resource. */\n        private final String location;\n        /** Hash sum which is calculated based on resource content. */\n        private final String contentHashSum;\n\n        /**\n         * Creates an instance.\n         *\n         * @param location resource location.\n         * @param contentHashSum content hash sum.\n         */\n        /* package */ ExternalResource(String location, String contentHashSum) {\n            this.location = location;\n            this.contentHashSum = contentHashSum;\n        }\n\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * This class maintains a persistent(on file-system) store of the files\n * that have checked ok(no validation events) and their associated\n * timestamp. It is used to optimize Checkstyle between few launches.\n * It is mostly useful for plugin and extensions of Checkstyle.\n * It uses a property file\n * for storage.  A hashcode of the Configuration is stored in the\n * cache file to ensure the cache is invalidated when the\n * configuration has changed.\n *\n */\npublic final class PropertyCacheFile {\n\n    /**\n     * The property key to use for storing the hashcode of the\n     * configuration. To avoid name clashes with the files that are\n     * checked the key is chosen in such a way that it cannot be a\n     * valid file name.\n     */\n    public static final String CONFIG_HASH_KEY = \"configuration*?\";\n\n    /**\n     * The property prefix to use for storing the hashcode of an\n     * external resource. To avoid name clashes with the files that are\n     * checked the prefix is chosen in such a way that it cannot be a\n     * valid file name and makes it clear it is a resource.\n     */\n    public static final String EXTERNAL_RESOURCE_KEY_PREFIX = \"module-resource*?:\";\n\n    /** Size of default byte array for buffer. */\n    private static final int BUFFER_SIZE = 1024;\n\n    /** Default buffer for reading from streams. */\n    private static final byte[] BUFFER = new byte[BUFFER_SIZE];\n\n    /** Default number for base 16 encoding. */\n    private static final int BASE_16 = 16;\n\n    /** The details on files. **/\n    private final Properties details = new Properties();\n\n    /** Configuration object. **/\n    private final Configuration config;\n\n    /** File name of cache. **/\n    private final String fileName;\n\n    /** Generated configuration hash. **/\n    private String configHash;\n\n    /**\n     * Creates a new {@code PropertyCacheFile} instance.\n     *\n     * @param config the current configuration, not null\n     * @param fileName the cache file\n     * @throws IllegalArgumentException when either arguments are null\n     */\n    public PropertyCacheFile(Configuration config, String fileName) {\n        if (config == null) {\n            throw new IllegalArgumentException(\"config can not be null\");\n        }\n        if (fileName == null) {\n            throw new IllegalArgumentException(\"fileName can not be null\");\n        }\n        this.config = config;\n        this.fileName = fileName;\n    }\n\n    /**\n     * Load cached values from file.\n     *\n     * @throws IOException when there is a problems with file read\n     */\n    public void load() throws IOException {\n        // get the current config so if the file isn't found\n        // the first time the hash will be added to output file\n        configHash = getHashCodeBasedOnObjectContent(config);\n        final File file = new File(fileName);\n        if (file.exists()) {\n            try (InputStream inStream = Files.newInputStream(file.toPath())) {\n                details.load(inStream);\n                final String cachedConfigHash = details.getProperty(CONFIG_HASH_KEY);\n                if (!configHash.equals(cachedConfigHash)) {\n                    // Detected configuration change - clear cache\n                    reset();\n                }\n            }\n        }\n        else {\n            // put the hash in the file if the file is going to be created\n            reset();\n        }\n    }\n\n    /**\n     * Cleans up the object and updates the cache file.\n     *\n     * @throws IOException  when there is a problems with file save\n     */\n    public void persist() throws IOException {\n        final Path path = Paths.get(fileName);\n        final Path directory = path.getParent();\n        if (directory != null) {\n            Files.createDirectories(directory);\n        }\n        try (OutputStream out = Files.newOutputStream(path)) {\n            details.store(out, null);\n        }\n    }\n\n    /**\n     * Resets the cache to be empty except for the configuration hash.\n     */\n    public void reset() {\n        details.clear();\n        details.setProperty(CONFIG_HASH_KEY, configHash);\n    }\n\n    /**\n     * Checks that file is in cache.\n     *\n     * @param uncheckedFileName the file to check\n     * @param timestamp the timestamp of the file to check\n     * @return whether the specified file has already been checked ok\n     */\n    public boolean isInCache(String uncheckedFileName, long timestamp) {\n        final String lastChecked = details.getProperty(uncheckedFileName);\n        return Objects.equals(lastChecked, Long.toString(timestamp));\n    }\n\n    /**\n     * Records that a file checked ok.\n     *\n     * @param checkedFileName name of the file that checked ok\n     * @param timestamp the timestamp of the file\n     */\n    public void put(String checkedFileName, long timestamp) {\n        details.setProperty(checkedFileName, Long.toString(timestamp));\n    }\n\n    /**\n     * Retrieves the hash of a specific file.\n     *\n     * @param name The name of the file to retrieve.\n     * @return The has of the file or {@code null}.\n     */\n    public String get(String name) {\n        return details.getProperty(name);\n    }\n\n    /**\n     * Removed a specific file from the cache.\n     *\n     * @param checkedFileName The name of the file to remove.\n     */\n    public void remove(String checkedFileName) {\n        details.remove(checkedFileName);\n    }\n\n    /**\n     * Calculates the hashcode for the serializable object based on its content.\n     *\n     * @param object serializable object.\n     * @return the hashcode for serializable object.\n     * @throws IllegalStateException when some unexpected happened.\n     */\n    private static String getHashCodeBasedOnObjectContent(Serializable object) {\n        try {\n            final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            // in-memory serialization of Configuration\n            serialize(object, outputStream);\n            // Instead of hexEncoding outputStream.toByteArray() directly we\n            // use a message digest here to keep the length of the\n            // hashcode reasonable\n\n            final MessageDigest digest = MessageDigest.getInstance(\"SHA-1\");\n            digest.update(outputStream.toByteArray());\n\n            return new BigInteger(1, digest.digest()).toString(BASE_16).toUpperCase(Locale.ROOT);\n        }\n        catch (final IOException | NoSuchAlgorithmException ex) {\n            // rethrow as unchecked exception\n            throw new IllegalStateException(\"Unable to calculate hashcode.\", ex);\n        }\n    }\n\n    /**\n     * Serializes object to output stream.\n     *\n     * @param object object to be serialized\n     * @param outputStream serialization stream\n     * @throws IOException if an error occurs\n     */\n    private static void serialize(Serializable object,\n                                  OutputStream outputStream) throws IOException {\n        try (ObjectOutputStream oos = new ObjectOutputStream(outputStream)) {\n            oos.writeObject(object);\n        }\n    }\n\n    /**\n     * Puts external resources in cache.\n     * If at least one external resource changed, clears the cache.\n     *\n     * @param locations locations of external resources.\n     */\n    public void putExternalResources(Set<String> locations) {\n        final Set<ExternalResource> resources = loadExternalResources(locations);\n        if (areExternalResourcesChanged(resources)) {\n            reset();\n            fillCacheWithExternalResources(resources);\n        }\n    }\n\n    /**\n     * Loads a set of {@link ExternalResource} based on their locations.\n     *\n     * @param resourceLocations locations of external configuration resources.\n     * @return a set of {@link ExternalResource}.\n     */\n    private static Set<ExternalResource> loadExternalResources(Set<String> resourceLocations) {\n        final Set<ExternalResource> resources = new HashSet<>();\n        for (String location : resourceLocations) {\n            try {\n                final byte[] content = loadExternalResource(location);\n                final String contentHashSum = getHashCodeBasedOnObjectContent(content);\n                resources.add(new ExternalResource(EXTERNAL_RESOURCE_KEY_PREFIX + location,\n                        contentHashSum));\n            }\n            catch (CheckstyleException | IOException ex) {\n                // if exception happened (configuration resource was not found, connection is not\n                // available, resource is broken, etc), we need to calculate hash sum based on\n                // exception object content in order to check whether problem is resolved later\n                // and/or the configuration is changed.\n                final String contentHashSum = getHashCodeBasedOnObjectContent(ex);\n                resources.add(new ExternalResource(EXTERNAL_RESOURCE_KEY_PREFIX + location,\n                        contentHashSum));\n            }\n        }\n        return resources;\n    }\n\n    /**\n     * Loads the content of external resource.\n     *\n     * @param location external resource location.\n     * @return array of bytes which represents the content of external resource in binary form.\n     * @throws IOException if error while loading occurs.\n     * @throws CheckstyleException if error while loading occurs.\n     */\n    private static byte[] loadExternalResource(String location)\n            throws IOException, CheckstyleException {\n        final URI uri = CommonUtil.getUriByFilename(location);\n\n        try (InputStream is = uri.toURL().openStream()) {\n            return toByteArray(is);\n        }\n    }\n\n    /**\n     * Reads all the contents of an input stream and returns it as a byte array.\n     *\n     * @param stream The input stream to read from.\n     * @return The resulting byte array of the stream.\n     * @throws IOException if there is an error reading the input stream.\n     */\n    private static byte[] toByteArray(InputStream stream) throws IOException {\n        final ByteArrayOutputStream content = new ByteArrayOutputStream();\n\n        while (true) {\n            final int size = stream.read(BUFFER);\n            if (size == -1) {\n                break;\n            }\n\n            content.write(BUFFER, 0, size);\n        }\n\n        return content.toByteArray();\n    }\n\n    /**\n     * Checks whether the contents of external configuration resources were changed.\n     *\n     * @param resources a set of {@link ExternalResource}.\n     * @return true if the contents of external configuration resources were changed.\n     */\n    private boolean areExternalResourcesChanged(Set<ExternalResource> resources) {\n        return resources.stream().anyMatch(this::isResourceChanged);\n    }\n\n    /**\n     * Checks whether the resource is changed.\n     *\n     * @param resource resource to check.\n     * @return true if resource is changed.\n     */\n    private boolean isResourceChanged(ExternalResource resource) {\n        boolean changed = false;\n        if (isResourceLocationInCache(resource.location)) {\n            final String contentHashSum = resource.contentHashSum;\n            final String cachedHashSum = details.getProperty(resource.location);\n            if (!cachedHashSum.equals(contentHashSum)) {\n                changed = true;\n            }\n        }\n        else {\n            changed = true;\n        }\n        return changed;\n    }\n\n    /**\n     * Fills cache with a set of {@link ExternalResource}.\n     * If external resource from the set is already in cache, it will be skipped.\n     *\n     * @param externalResources a set of {@link ExternalResource}.\n     */\n    private void fillCacheWithExternalResources(Set<ExternalResource> externalResources) {\n        externalResources\n            .forEach(resource -> details.setProperty(resource.location, resource.contentHashSum));\n    }\n\n    /**\n     * Checks whether resource location is in cache.\n     *\n     * @param location resource location.\n     * @return true if resource location is in cache.\n     */\n    private boolean isResourceLocationInCache(String location) {\n        final String cachedHashSum = details.getProperty(location);\n        return cachedHashSum != null;\n    }\n\n    /**\n     * Class which represents external resource.\n     */\n    private static class ExternalResource {\n\n        /** Location of resource. */\n        private final String location;\n        /** Hash sum which is calculated based on resource content. */\n        private final String contentHashSum;\n\n        /**\n         * Creates an instance.\n         *\n         * @param location resource location.\n         * @param contentHashSum content hash sum.\n         */\n        /* package */ ExternalResource(String location, String contentHashSum) {\n            this.location = location;\n            this.contentHashSum = contentHashSum;\n        }\n\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Checks whether the resource is changed.\n     *\n     * @param resource resource to check.\n     * @return true if resource is changed.\n     */\n    private boolean isResourceChanged(ExternalResource resource) {\n        boolean changed = false;\n        if (isResourceLocationInCache(resource.location)) {\n            final String contentHashSum = resource.contentHashSum;\n            final String cachedHashSum = details.getProperty(resource.location);\n            if (!cachedHashSum.equals(contentHashSum)) {\n                changed = true;\n            }\n        }\n        else {\n            changed = true;\n        }\n        return changed;\n    }"], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.PropertyCacheFile#isResourceLocationInCache\n methodBody: private boolean isResourceLocationInCache(String location) {\nfinal String cachedHashSum=details.getProperty(location);\nreturn cachedHashSum != null;\n}"], "sourceCodeAfterRefactoring": "/**\n     * Checks whether the contents of external configuration resources were changed.\n     *\n     * @param resources a set of {@link ExternalResource}.\n     * @return true if the contents of external configuration resources were changed.\n     */\n    private boolean areExternalResourcesChanged(Set<ExternalResource> resources) {\n        return resources.stream().anyMatch(this::isResourceChanged);\n    }\n/**\n     * Checks whether the resource is changed.\n     *\n     * @param resource resource to check.\n     * @return true if resource is changed.\n     */\n    private boolean isResourceChanged(ExternalResource resource) {\n        boolean changed = false;\n        if (isResourceLocationInCache(resource.location)) {\n            final String contentHashSum = resource.contentHashSum;\n            final String cachedHashSum = details.getProperty(resource.location);\n            if (!cachedHashSum.equals(contentHashSum)) {\n                changed = true;\n            }\n        }\n        else {\n            changed = true;\n        }\n        return changed;\n    }", "diffSourceCode": "   327:     /**\n   328:      * Checks whether the contents of external configuration resources were changed.\n   329:      *\n   330:      * @param resources a set of {@link ExternalResource}.\n   331:      * @return true if the contents of external configuration resources were changed.\n   332:      */\n   333:     private boolean areExternalResourcesChanged(Set<ExternalResource> resources) {\n-  334:         return resources.stream().anyMatch(resource -> {\n-  335:             boolean changed = false;\n-  336:             if (isResourceLocationInCache(resource.location)) {\n-  337:                 final String contentHashSum = resource.contentHashSum;\n-  338:                 final String cachedHashSum = details.getProperty(resource.location);\n-  339:                 if (!cachedHashSum.equals(contentHashSum)) {\n-  340:                     changed = true;\n-  341:                 }\n-  342:             }\n-  343:             else {\n-  344:                 changed = true;\n-  345:             }\n-  346:             return changed;\n-  347:         });\n-  348:     }\n-  349: \n-  350:     /**\n-  351:      * Fills cache with a set of {@link ExternalResource}.\n-  352:      * If external resource from the set is already in cache, it will be skipped.\n-  353:      *\n-  354:      * @param externalResources a set of {@link ExternalResource}.\n-  355:      */\n-  356:     private void fillCacheWithExternalResources(Set<ExternalResource> externalResources) {\n+  334:         return resources.stream().anyMatch(this::isResourceChanged);\n+  335:     }\n+  336: \n+  337:     /**\n+  338:      * Checks whether the resource is changed.\n+  339:      *\n+  340:      * @param resource resource to check.\n+  341:      * @return true if resource is changed.\n+  342:      */\n+  343:     private boolean isResourceChanged(ExternalResource resource) {\n+  344:         boolean changed = false;\n+  345:         if (isResourceLocationInCache(resource.location)) {\n+  346:             final String contentHashSum = resource.contentHashSum;\n+  347:             final String cachedHashSum = details.getProperty(resource.location);\n+  348:             if (!cachedHashSum.equals(contentHashSum)) {\n+  349:                 changed = true;\n+  350:             }\n+  351:         }\n+  352:         else {\n+  353:             changed = true;\n+  354:         }\n+  355:         return changed;\n+  356:     }\n", "uniqueId": "3c2249b239cbfe002af3649f1f7c1f9ae61df3b1_327_348_337_356_327_335", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 6}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nprivate boolean isResourceChanged(ExternalResource resource) {\n    if (isResourceLocationInCache(resource.location)) {\n        final String contentHashSum = resource.contentHashSum;\n        final String cachedHashSum = details.getProperty(resource.location);\n        return !cachedHashSum.equals(contentHashSum);\n    } else {\n        return true;\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Checks whether the contents of external configuration resources were changed.\n     *\n     * @param resources a set of {@link ExternalResource}.\n     * @return true if the contents of external configuration resources were changed.\n     */\n    private boolean areExternalResourcesChanged(Set<ExternalResource> resources) {\n        return resources.stream().anyMatch(resource -> {\n            boolean changed = false;\n            if (isResourceLocationInCache(resource.location)) {\n                final String contentHashSum = resource.contentHashSum;\n                final String cachedHashSum = details.getProperty(resource.location);\n                if (!cachedHashSum.equals(contentHashSum)) {\n                    changed = true;\n                }\n            }\n            else {\n                changed = true;\n            }\n            return changed;\n        });\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Objects;\nimport java.util.Properties;\nimport java.util.Set;\n\nimport com.puppycrawl.tools.checkstyle.api.CheckstyleException;\nimport com.puppycrawl.tools.checkstyle.api.Configuration;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\n\n/**\n * This class maintains a persistent(on file-system) store of the files\n * that have checked ok(no validation events) and their associated\n * timestamp. It is used to optimize Checkstyle between few launches.\n * It is mostly useful for plugin and extensions of Checkstyle.\n * It uses a property file\n * for storage.  A hashcode of the Configuration is stored in the\n * cache file to ensure the cache is invalidated when the\n * configuration has changed.\n *\n */\npublic final class PropertyCacheFile {\n\n    /**\n     * The property key to use for storing the hashcode of the\n     * configuration. To avoid name clashes with the files that are\n     * checked the key is chosen in such a way that it cannot be a\n     * valid file name.\n     */\n    public static final String CONFIG_HASH_KEY = \"configuration*?\";\n\n    /**\n     * The property prefix to use for storing the hashcode of an\n     * external resource. To avoid name clashes with the files that are\n     * checked the prefix is chosen in such a way that it cannot be a\n     * valid file name and makes it clear it is a resource.\n     */\n    public static final String EXTERNAL_RESOURCE_KEY_PREFIX = \"module-resource*?:\";\n\n    /** Size of default byte array for buffer. */\n    private static final int BUFFER_SIZE = 1024;\n\n    /** Default buffer for reading from streams. */\n    private static final byte[] BUFFER = new byte[BUFFER_SIZE];\n\n    /** Default number for base 16 encoding. */\n    private static final int BASE_16 = 16;\n\n    /** The details on files. **/\n    private final Properties details = new Properties();\n\n    /** Configuration object. **/\n    private final Configuration config;\n\n    /** File name of cache. **/\n    private final String fileName;\n\n    /** Generated configuration hash. **/\n    private String configHash;\n\n    /**\n     * Creates a new {@code PropertyCacheFile} instance.\n     *\n     * @param config the current configuration, not null\n     * @param fileName the cache file\n     * @throws IllegalArgumentException when either arguments are null\n     */\n    public PropertyCacheFile(Configuration config, String fileName) {\n        if (config == null) {\n            throw new IllegalArgumentException(\"config can not be null\");\n        }\n        if (fileName == null) {\n            throw new IllegalArgumentException(\"fileName can not be null\");\n        }\n        this.config = config;\n        this.fileName = fileName;\n    }\n\n    /**\n     * Load cached values from file.\n     *\n     * @throws IOException when there is a problems with file read\n     */\n    public void load() throws IOException {\n        // get the current config so if the file isn't found\n        // the first time the hash will be added to output file\n        configHash = getHashCodeBasedOnObjectContent(config);\n        final File file = new File(fileName);\n        if (file.exists()) {\n            try (InputStream inStream = Files.newInputStream(file.toPath())) {\n                details.load(inStream);\n                final String cachedConfigHash = details.getProperty(CONFIG_HASH_KEY);\n                if (!configHash.equals(cachedConfigHash)) {\n                    // Detected configuration change - clear cache\n                    reset();\n                }\n            }\n        }\n        else {\n            // put the hash in the file if the file is going to be created\n            reset();\n        }\n    }\n\n    /**\n     * Cleans up the object and updates the cache file.\n     *\n     * @throws IOException  when there is a problems with file save\n     */\n    public void persist() throws IOException {\n        final Path path = Paths.get(fileName);\n        final Path directory = path.getParent();\n        if (directory != null) {\n            Files.createDirectories(directory);\n        }\n        try (OutputStream out = Files.newOutputStream(path)) {\n            details.store(out, null);\n        }\n    }\n\n    /**\n     * Resets the cache to be empty except for the configuration hash.\n     */\n    public void reset() {\n        details.clear();\n        details.setProperty(CONFIG_HASH_KEY, configHash);\n    }\n\n    /**\n     * Checks that file is in cache.\n     *\n     * @param uncheckedFileName the file to check\n     * @param timestamp the timestamp of the file to check\n     * @return whether the specified file has already been checked ok\n     */\n    public boolean isInCache(String uncheckedFileName, long timestamp) {\n        final String lastChecked = details.getProperty(uncheckedFileName);\n        return Objects.equals(lastChecked, Long.toString(timestamp));\n    }\n\n    /**\n     * Records that a file checked ok.\n     *\n     * @param checkedFileName name of the file that checked ok\n     * @param timestamp the timestamp of the file\n     */\n    public void put(String checkedFileName, long timestamp) {\n        details.setProperty(checkedFileName, Long.toString(timestamp));\n    }\n\n    /**\n     * Retrieves the hash of a specific file.\n     *\n     * @param name The name of the file to retrieve.\n     * @return The has of the file or {@code null}.\n     */\n    public String get(String name) {\n        return details.getProperty(name);\n    }\n\n    /**\n     * Removed a specific file from the cache.\n     *\n     * @param checkedFileName The name of the file to remove.\n     */\n    public void remove(String checkedFileName) {\n        details.remove(checkedFileName);\n    }\n\n    /**\n     * Calculates the hashcode for the serializable object based on its content.\n     *\n     * @param object serializable object.\n     * @return the hashcode for serializable object.\n     * @throws IllegalStateException when some unexpected happened.\n     */\n    private static String getHashCodeBasedOnObjectContent(Serializable object) {\n        try {\n            final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            // in-memory serialization of Configuration\n            serialize(object, outputStream);\n            // Instead of hexEncoding outputStream.toByteArray() directly we\n            // use a message digest here to keep the length of the\n            // hashcode reasonable\n\n            final MessageDigest digest = MessageDigest.getInstance(\"SHA-1\");\n            digest.update(outputStream.toByteArray());\n\n            return new BigInteger(1, digest.digest()).toString(BASE_16).toUpperCase(Locale.ROOT);\n        }\n        catch (final IOException | NoSuchAlgorithmException ex) {\n            // rethrow as unchecked exception\n            throw new IllegalStateException(\"Unable to calculate hashcode.\", ex);\n        }\n    }\n\n    /**\n     * Serializes object to output stream.\n     *\n     * @param object object to be serialized\n     * @param outputStream serialization stream\n     * @throws IOException if an error occurs\n     */\n    private static void serialize(Serializable object,\n                                  OutputStream outputStream) throws IOException {\n        try (ObjectOutputStream oos = new ObjectOutputStream(outputStream)) {\n            oos.writeObject(object);\n        }\n    }\n\n    /**\n     * Puts external resources in cache.\n     * If at least one external resource changed, clears the cache.\n     *\n     * @param locations locations of external resources.\n     */\n    public void putExternalResources(Set<String> locations) {\n        final Set<ExternalResource> resources = loadExternalResources(locations);\n        if (areExternalResourcesChanged(resources)) {\n            reset();\n            fillCacheWithExternalResources(resources);\n        }\n    }\n\n    /**\n     * Loads a set of {@link ExternalResource} based on their locations.\n     *\n     * @param resourceLocations locations of external configuration resources.\n     * @return a set of {@link ExternalResource}.\n     */\n    private static Set<ExternalResource> loadExternalResources(Set<String> resourceLocations) {\n        final Set<ExternalResource> resources = new HashSet<>();\n        for (String location : resourceLocations) {\n            try {\n                final byte[] content = loadExternalResource(location);\n                final String contentHashSum = getHashCodeBasedOnObjectContent(content);\n                resources.add(new ExternalResource(EXTERNAL_RESOURCE_KEY_PREFIX + location,\n                        contentHashSum));\n            }\n            catch (CheckstyleException | IOException ex) {\n                // if exception happened (configuration resource was not found, connection is not\n                // available, resource is broken, etc), we need to calculate hash sum based on\n                // exception object content in order to check whether problem is resolved later\n                // and/or the configuration is changed.\n                final String contentHashSum = getHashCodeBasedOnObjectContent(ex);\n                resources.add(new ExternalResource(EXTERNAL_RESOURCE_KEY_PREFIX + location,\n                        contentHashSum));\n            }\n        }\n        return resources;\n    }\n\n    /**\n     * Loads the content of external resource.\n     *\n     * @param location external resource location.\n     * @return array of bytes which represents the content of external resource in binary form.\n     * @throws IOException if error while loading occurs.\n     * @throws CheckstyleException if error while loading occurs.\n     */\n    private static byte[] loadExternalResource(String location)\n            throws IOException, CheckstyleException {\n        final URI uri = CommonUtil.getUriByFilename(location);\n\n        try (InputStream is = uri.toURL().openStream()) {\n            return toByteArray(is);\n        }\n    }\n\n    /**\n     * Reads all the contents of an input stream and returns it as a byte array.\n     *\n     * @param stream The input stream to read from.\n     * @return The resulting byte array of the stream.\n     * @throws IOException if there is an error reading the input stream.\n     */\n    private static byte[] toByteArray(InputStream stream) throws IOException {\n        final ByteArrayOutputStream content = new ByteArrayOutputStream();\n\n        while (true) {\n            final int size = stream.read(BUFFER);\n            if (size == -1) {\n                break;\n            }\n\n            content.write(BUFFER, 0, size);\n        }\n\n        return content.toByteArray();\n    }\n\n    /**\n     * Checks whether the contents of external configuration resources were changed.\n     *\n     * @param resources a set of {@link ExternalResource}.\n     * @return true if the contents of external configuration resources were changed.\n     */\n    private boolean areExternalResourcesChanged(Set<ExternalResource> resources) {\n        return resources.stream().anyMatch(resource -> {\n            boolean changed = false;\n            if (isResourceLocationInCache(resource.location)) {\n                final String contentHashSum = resource.contentHashSum;\n                final String cachedHashSum = details.getProperty(resource.location);\n                if (!cachedHashSum.equals(contentHashSum)) {\n                    changed = true;\n                }\n            }\n            else {\n                changed = true;\n            }\n            return changed;\n        });\n    }\n\n    /**\n     * Fills cache with a set of {@link ExternalResource}.\n     * If external resource from the set is already in cache, it will be skipped.\n     *\n     * @param externalResources a set of {@link ExternalResource}.\n     */\n    private void fillCacheWithExternalResources(Set<ExternalResource> externalResources) {\n        externalResources\n            .forEach(resource -> details.setProperty(resource.location, resource.contentHashSum));\n    }\n\n    /**\n     * Checks whether resource location is in cache.\n     *\n     * @param location resource location.\n     * @return true if resource location is in cache.\n     */\n    private boolean isResourceLocationInCache(String location) {\n        final String cachedHashSum = details.getProperty(location);\n        return cachedHashSum != null;\n    }\n\n    /**\n     * Class which represents external resource.\n     */\n    private static class ExternalResource {\n\n        /** Location of resource. */\n        private final String location;\n        /** Hash sum which is calculated based on resource content. */\n        private final String contentHashSum;\n\n        /**\n         * Creates an instance.\n         *\n         * @param location resource location.\n         * @param contentHashSum content hash sum.\n         */\n        /* package */ ExternalResource(String location, String contentHashSum) {\n            this.location = location;\n            this.contentHashSum = contentHashSum;\n        }\n\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate isSingleLineCaseGroup(ast DetailAST) : boolean extracted from private isSingleLineSwitchMember(ast DetailAST) : boolean in class com.puppycrawl.tools.checkstyle.checks.blocks.NeedBracesCheck", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java", "startLine": 478, "endLine": 499, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java", "startLine": 537, "endLine": 554, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java", "startLine": 556, "endLine": 579, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks if switch member (case or default statement) is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * case 1: doSomeStuff(); break;\n     * case 2: doSomeStuff(); break;\n     * case 3: ;\n     * default: doSomeStuff();break;\n     * }\n     * </p>\n     *\n     * @param ast {@link TokenTypes#LITERAL_CASE case statement} or\n     * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n     * @return true if current switch member is single-line statement.\n     */\n    private static boolean isSingleLineSwitchMember(DetailAST ast) {\n        return Optional.of(ast)\n                .map(DetailAST::getNextSibling)\n                .map(DetailAST::getLastChild)\n                .map(lastToken -> TokenUtil.areOnSameLine(ast, lastToken))\n                .orElse(true);\n    }", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java", "isPureRefactoring": true, "commitId": "ea5b4e6ce5f98c6fc4758d6d38f881c82468344f", "packageNameBefore": "com.puppycrawl.tools.checkstyle.checks.blocks", "classNameBefore": "com.puppycrawl.tools.checkstyle.checks.blocks.NeedBracesCheck", "methodNameBefore": "com.puppycrawl.tools.checkstyle.checks.blocks.NeedBracesCheck#isSingleLineSwitchMember", "classSignatureBefore": "public class NeedBracesCheck extends AbstractCheck ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.blocks.NeedBracesCheck#isSingleLineSwitchMember"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.checks.blocks.NeedBracesCheck"], "classSignatureBeforeSet": ["public class NeedBracesCheck extends AbstractCheck "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.blocks;\n\nimport java.util.Optional;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * <p>\n * Checks for braces around code blocks.\n * </p>\n * <ul>\n * <li>\n * Property {@code allowSingleLineStatement} - allow single-line statements without braces.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code allowEmptyLoopBody} - allow loops with empty bodies.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code tokens} - tokens to check\n * Type is {@code java.lang.String[]}.\n * Validation type is {@code tokenSet}.\n * Default value is:\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_DO\">\n * LITERAL_DO</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_ELSE\">\n * LITERAL_ELSE</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_FOR\">\n * LITERAL_FOR</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_IF\">\n * LITERAL_IF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_WHILE\">\n * LITERAL_WHILE</a>.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=\"NeedBraces\"/&gt;\n * </pre>\n * <p>\n * To configure the check for {@code if} and {@code else} blocks:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_IF, LITERAL_ELSE&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * To configure the check to allow single-line statements\n * ({@code if, while, do-while, for}) without braces:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;allowSingleLineStatement&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Next statements won't be violated by check:\n * </p>\n * <pre>\n * if (obj.isValid()) return true; // OK\n * while (obj.isValid()) return true; // OK\n * do this.notify(); while (o != null); // OK\n * for (int i = 0; ; ) this.notify(); // OK\n * </pre>\n * <p>\n * To configure the check to allow {@code case, default} single-line statements without braces:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_CASE, LITERAL_DEFAULT&quot;/&gt;\n *   &lt;property name=&quot;allowSingleLineStatement&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Next statements won't be violated by check:\n * </p>\n * <pre>\n * switch (num) {\n *   case 1: counter++; break; // OK\n *   case 6: counter += 10; break; // OK\n *   default: counter = 100; break; // OK\n * }\n * </pre>\n * <p>\n * To configure the check to allow loops ({@code while, for}) with empty bodies:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;allowEmptyLoopBody&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Next statements won't be violated by check:\n * </p>\n * <pre>\n * while (value.incrementValue() &lt; 5); // OK\n * for(int i = 0; i &lt; 10; value.incrementValue()); // OK\n * </pre>\n * <p>\n * To configure the check to lambdas:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;LAMBDA&quot;/&gt;\n *   &lt;property name=&quot;allowSingleLineStatement&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Results in following:\n * </p>\n * <pre>\n * allowedFuture.addCallback(result -&gt; assertEquals(\"Invalid response\",\n *   EnumSet.of(HttpMethod.GET, HttpMethod.OPTIONS), result), // violation, lambda spans 2 lines\n *   ex -&gt; fail(ex.getMessage())); // OK\n *\n * allowedFuture.addCallback(result -&gt; {\n *   return assertEquals(\"Invalid response\",\n *     EnumSet.of(HttpMethod.GET, HttpMethod.OPTIONS), result);\n *   }, // OK\n *   ex -&gt; fail(ex.getMessage()));\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code needBraces}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@StatelessCheck\npublic class NeedBracesCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY_NEED_BRACES = \"needBraces\";\n\n    /**\n     * Allow single-line statements without braces.\n     */\n    private boolean allowSingleLineStatement;\n\n    /**\n     * Allow loops with empty bodies.\n     */\n    private boolean allowEmptyLoopBody;\n\n    /**\n     * Setter to allow single-line statements without braces.\n     *\n     * @param allowSingleLineStatement Check's option for skipping single-line statements\n     */\n    public void setAllowSingleLineStatement(boolean allowSingleLineStatement) {\n        this.allowSingleLineStatement = allowSingleLineStatement;\n    }\n\n    /**\n     * Setter to allow loops with empty bodies.\n     *\n     * @param allowEmptyLoopBody Check's option for allowing loops with empty body.\n     */\n    public void setAllowEmptyLoopBody(boolean allowEmptyLoopBody) {\n        this.allowEmptyLoopBody = allowEmptyLoopBody;\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.LITERAL_DO,\n            TokenTypes.LITERAL_ELSE,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.LITERAL_IF,\n            TokenTypes.LITERAL_WHILE,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.LITERAL_DO,\n            TokenTypes.LITERAL_ELSE,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.LITERAL_IF,\n            TokenTypes.LITERAL_WHILE,\n            TokenTypes.LITERAL_CASE,\n            TokenTypes.LITERAL_DEFAULT,\n            TokenTypes.LAMBDA,\n        };\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return CommonUtil.EMPTY_INT_ARRAY;\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final boolean hasNoSlist = ast.findFirstToken(TokenTypes.SLIST) == null;\n        if (hasNoSlist && !isSkipStatement(ast) && isBracesNeeded(ast)) {\n            log(ast, MSG_KEY_NEED_BRACES, ast.getText());\n        }\n    }\n\n    /**\n     * Checks if token needs braces.\n     * Some tokens have additional conditions:\n     * <ul>\n     *     <li>{@link TokenTypes#LITERAL_FOR}</li>\n     *     <li>{@link TokenTypes#LITERAL_WHILE}</li>\n     *     <li>{@link TokenTypes#LITERAL_CASE}</li>\n     *     <li>{@link TokenTypes#LITERAL_DEFAULT}</li>\n     *     <li>{@link TokenTypes#LITERAL_ELSE}</li>\n     * </ul>\n     * For all others default value {@code true} is returned.\n     *\n     * @param ast token to check\n     * @return result of additional checks for specific token types,\n     * {@code true} if there is no additional checks for token\n     */\n    private boolean isBracesNeeded(DetailAST ast) {\n        final boolean result;\n        switch (ast.getType()) {\n            case TokenTypes.LITERAL_FOR:\n            case TokenTypes.LITERAL_WHILE:\n                result = !isEmptyLoopBodyAllowed(ast);\n                break;\n            case TokenTypes.LITERAL_CASE:\n            case TokenTypes.LITERAL_DEFAULT:\n                result = hasUnbracedStatements(ast);\n                break;\n            case TokenTypes.LITERAL_ELSE:\n                result = ast.findFirstToken(TokenTypes.LITERAL_IF) == null;\n                break;\n            default:\n                result = true;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current loop has empty body and can be skipped by this check.\n     *\n     * @param ast for, while statements.\n     * @return true if current loop can be skipped by check.\n     */\n    private boolean isEmptyLoopBodyAllowed(DetailAST ast) {\n        return allowEmptyLoopBody && ast.findFirstToken(TokenTypes.EMPTY_STAT) != null;\n    }\n\n    /**\n     * Checks if switch member (case, default statements) has statements without curly braces.\n     *\n     * @param ast case, default statements.\n     * @return true if switch member has unbraced statements, false otherwise.\n     */\n    private static boolean hasUnbracedStatements(DetailAST ast) {\n        final DetailAST nextSibling = ast.getNextSibling();\n        return nextSibling != null\n            && nextSibling.getType() == TokenTypes.SLIST\n            && nextSibling.getFirstChild().getType() != TokenTypes.SLIST;\n    }\n\n    /**\n     * Checks if current statement can be skipped by \"need braces\" warning.\n     *\n     * @param statement if, for, while, do-while, lambda, else, case, default statements.\n     * @return true if current statement can be skipped by Check.\n     */\n    private boolean isSkipStatement(DetailAST statement) {\n        return allowSingleLineStatement && isSingleLineStatement(statement);\n    }\n\n    /**\n     * Checks if current statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * if (obj.isValid()) return true;\n     * }\n     * </p>\n     * <p>\n     * {@code\n     * while (obj.isValid()) return true;\n     * }\n     * </p>\n     *\n     * @param statement if, for, while, do-while, lambda, else, case, default statements.\n     * @return true if current statement is single-line statement.\n     */\n    private static boolean isSingleLineStatement(DetailAST statement) {\n        final boolean result;\n\n        switch (statement.getType()) {\n            case TokenTypes.LITERAL_IF:\n                result = isSingleLineIf(statement);\n                break;\n            case TokenTypes.LITERAL_FOR:\n                result = isSingleLineFor(statement);\n                break;\n            case TokenTypes.LITERAL_DO:\n                result = isSingleLineDoWhile(statement);\n                break;\n            case TokenTypes.LITERAL_WHILE:\n                result = isSingleLineWhile(statement);\n                break;\n            case TokenTypes.LAMBDA:\n                result = isSingleLineLambda(statement);\n                break;\n            case TokenTypes.LITERAL_CASE:\n            case TokenTypes.LITERAL_DEFAULT:\n                result = isSingleLineSwitchMember(statement);\n                break;\n            default:\n                result = isSingleLineElse(statement);\n                break;\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if current while statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * while (obj.isValid()) return true;\n     * }\n     * </p>\n     *\n     * @param literalWhile {@link TokenTypes#LITERAL_WHILE while statement}.\n     * @return true if current while statement is single-line statement.\n     */\n    private static boolean isSingleLineWhile(DetailAST literalWhile) {\n        boolean result = false;\n        if (literalWhile.getParent().getType() == TokenTypes.SLIST) {\n            final DetailAST block = literalWhile.getLastChild().getPreviousSibling();\n            result = TokenUtil.areOnSameLine(literalWhile, block);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current do-while statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * do this.notify(); while (o != null);\n     * }\n     * </p>\n     *\n     * @param literalDo {@link TokenTypes#LITERAL_DO do-while statement}.\n     * @return true if current do-while statement is single-line statement.\n     */\n    private static boolean isSingleLineDoWhile(DetailAST literalDo) {\n        boolean result = false;\n        if (literalDo.getParent().getType() == TokenTypes.SLIST) {\n            final DetailAST block = literalDo.getFirstChild();\n            result = TokenUtil.areOnSameLine(block, literalDo);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current for statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * for (int i = 0; ; ) this.notify();\n     * }\n     * </p>\n     *\n     * @param literalFor {@link TokenTypes#LITERAL_FOR for statement}.\n     * @return true if current for statement is single-line statement.\n     */\n    private static boolean isSingleLineFor(DetailAST literalFor) {\n        boolean result = false;\n        if (literalFor.getLastChild().getType() == TokenTypes.EMPTY_STAT) {\n            result = true;\n        }\n        else if (literalFor.getParent().getType() == TokenTypes.SLIST) {\n            result = TokenUtil.areOnSameLine(literalFor, literalFor.getLastChild());\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current if statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * if (obj.isValid()) return true;\n     * }\n     * </p>\n     *\n     * @param literalIf {@link TokenTypes#LITERAL_IF if statement}.\n     * @return true if current if statement is single-line statement.\n     */\n    private static boolean isSingleLineIf(DetailAST literalIf) {\n        boolean result = false;\n        if (literalIf.getParent().getType() == TokenTypes.SLIST) {\n            final DetailAST literalIfLastChild = literalIf.getLastChild();\n            final DetailAST block;\n            if (literalIfLastChild.getType() == TokenTypes.LITERAL_ELSE) {\n                block = literalIfLastChild.getPreviousSibling();\n            }\n            else {\n                block = literalIfLastChild;\n            }\n            final DetailAST ifCondition = literalIf.findFirstToken(TokenTypes.EXPR);\n            result = TokenUtil.areOnSameLine(ifCondition, block);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current lambda statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * Runnable r = () -> System.out.println(\"Hello, world!\");\n     * }\n     * </p>\n     *\n     * @param lambda {@link TokenTypes#LAMBDA lambda statement}.\n     * @return true if current lambda statement is single-line statement.\n     */\n    private static boolean isSingleLineLambda(DetailAST lambda) {\n        final DetailAST lastLambdaToken = getLastLambdaToken(lambda);\n        return TokenUtil.areOnSameLine(lambda, lastLambdaToken);\n    }\n\n    /**\n     * Looks for the last token in lambda.\n     *\n     * @param lambda token to check.\n     * @return last token in lambda\n     */\n    private static DetailAST getLastLambdaToken(DetailAST lambda) {\n        DetailAST node = lambda;\n        do {\n            node = node.getLastChild();\n        } while (node.getLastChild() != null);\n        return node;\n    }\n\n    /**\n     * Checks if switch member (case or default statement) is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * case 1: doSomeStuff(); break;\n     * case 2: doSomeStuff(); break;\n     * case 3: ;\n     * default: doSomeStuff();break;\n     * }\n     * </p>\n     *\n     * @param ast {@link TokenTypes#LITERAL_CASE case statement} or\n     * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n     * @return true if current switch member is single-line statement.\n     */\n    private static boolean isSingleLineSwitchMember(DetailAST ast) {\n        return Optional.of(ast)\n                .map(DetailAST::getNextSibling)\n                .map(DetailAST::getLastChild)\n                .map(lastToken -> TokenUtil.areOnSameLine(ast, lastToken))\n                .orElse(true);\n    }\n\n    /**\n     * Checks if current else statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * else doSomeStuff();\n     * }\n     * </p>\n     *\n     * @param literalElse {@link TokenTypes#LITERAL_ELSE else statement}.\n     * @return true if current else statement is single-line statement.\n     */\n    private static boolean isSingleLineElse(DetailAST literalElse) {\n        final DetailAST block = literalElse.getFirstChild();\n        return TokenUtil.areOnSameLine(literalElse, block);\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.blocks;\n\nimport java.util.Optional;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * <p>\n * Checks for braces around code blocks.\n * </p>\n * <ul>\n * <li>\n * Property {@code allowSingleLineStatement} - allow single-line statements without braces.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code allowEmptyLoopBody} - allow loops with empty bodies.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code tokens} - tokens to check\n * Type is {@code java.lang.String[]}.\n * Validation type is {@code tokenSet}.\n * Default value is:\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_DO\">\n * LITERAL_DO</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_ELSE\">\n * LITERAL_ELSE</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_FOR\">\n * LITERAL_FOR</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_IF\">\n * LITERAL_IF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_WHILE\">\n * LITERAL_WHILE</a>.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=\"NeedBraces\"/&gt;\n * </pre>\n * <p>\n * To configure the check for {@code if} and {@code else} blocks:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_IF, LITERAL_ELSE&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * To configure the check to allow single-line statements\n * ({@code if, while, do-while, for}) without braces:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;allowSingleLineStatement&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Next statements won't be violated by check:\n * </p>\n * <pre>\n * if (obj.isValid()) return true; // OK\n * while (obj.isValid()) return true; // OK\n * do this.notify(); while (o != null); // OK\n * for (int i = 0; ; ) this.notify(); // OK\n * </pre>\n * <p>\n * To configure the check to allow {@code case, default} single-line statements without braces:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_CASE, LITERAL_DEFAULT&quot;/&gt;\n *   &lt;property name=&quot;allowSingleLineStatement&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Next statements won't be violated by check:\n * </p>\n * <pre>\n * switch (num) {\n *   case 1: counter++; break; // OK\n *   case 6: counter += 10; break; // OK\n *   default: counter = 100; break; // OK\n * }\n * </pre>\n * <p>\n * To configure the check to allow loops ({@code while, for}) with empty bodies:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;allowEmptyLoopBody&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Next statements won't be violated by check:\n * </p>\n * <pre>\n * while (value.incrementValue() &lt; 5); // OK\n * for(int i = 0; i &lt; 10; value.incrementValue()); // OK\n * </pre>\n * <p>\n * To configure the check to lambdas:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;LAMBDA&quot;/&gt;\n *   &lt;property name=&quot;allowSingleLineStatement&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Results in following:\n * </p>\n * <pre>\n * allowedFuture.addCallback(result -&gt; assertEquals(\"Invalid response\",\n *   EnumSet.of(HttpMethod.GET, HttpMethod.OPTIONS), result), // violation, lambda spans 2 lines\n *   ex -&gt; fail(ex.getMessage())); // OK\n *\n * allowedFuture.addCallback(result -&gt; {\n *   return assertEquals(\"Invalid response\",\n *     EnumSet.of(HttpMethod.GET, HttpMethod.OPTIONS), result);\n *   }, // OK\n *   ex -&gt; fail(ex.getMessage()));\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code needBraces}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@StatelessCheck\npublic class NeedBracesCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY_NEED_BRACES = \"needBraces\";\n\n    /**\n     * Allow single-line statements without braces.\n     */\n    private boolean allowSingleLineStatement;\n\n    /**\n     * Allow loops with empty bodies.\n     */\n    private boolean allowEmptyLoopBody;\n\n    /**\n     * Setter to allow single-line statements without braces.\n     *\n     * @param allowSingleLineStatement Check's option for skipping single-line statements\n     */\n    public void setAllowSingleLineStatement(boolean allowSingleLineStatement) {\n        this.allowSingleLineStatement = allowSingleLineStatement;\n    }\n\n    /**\n     * Setter to allow loops with empty bodies.\n     *\n     * @param allowEmptyLoopBody Check's option for allowing loops with empty body.\n     */\n    public void setAllowEmptyLoopBody(boolean allowEmptyLoopBody) {\n        this.allowEmptyLoopBody = allowEmptyLoopBody;\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.LITERAL_DO,\n            TokenTypes.LITERAL_ELSE,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.LITERAL_IF,\n            TokenTypes.LITERAL_WHILE,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.LITERAL_DO,\n            TokenTypes.LITERAL_ELSE,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.LITERAL_IF,\n            TokenTypes.LITERAL_WHILE,\n            TokenTypes.LITERAL_CASE,\n            TokenTypes.LITERAL_DEFAULT,\n            TokenTypes.LAMBDA,\n        };\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return CommonUtil.EMPTY_INT_ARRAY;\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final boolean hasNoSlist = ast.findFirstToken(TokenTypes.SLIST) == null;\n        if (hasNoSlist && !isSkipStatement(ast) && isBracesNeeded(ast)) {\n            log(ast, MSG_KEY_NEED_BRACES, ast.getText());\n        }\n    }\n\n    /**\n     * Checks if token needs braces.\n     * Some tokens have additional conditions:\n     * <ul>\n     *     <li>{@link TokenTypes#LITERAL_FOR}</li>\n     *     <li>{@link TokenTypes#LITERAL_WHILE}</li>\n     *     <li>{@link TokenTypes#LITERAL_CASE}</li>\n     *     <li>{@link TokenTypes#LITERAL_DEFAULT}</li>\n     *     <li>{@link TokenTypes#LITERAL_ELSE}</li>\n     *     <li>{@link TokenTypes#LAMBDA}</li>\n     * </ul>\n     * For all others default value {@code true} is returned.\n     *\n     * @param ast token to check\n     * @return result of additional checks for specific token types,\n     * {@code true} if there is no additional checks for token\n     */\n    private boolean isBracesNeeded(DetailAST ast) {\n        final boolean result;\n        switch (ast.getType()) {\n            case TokenTypes.LITERAL_FOR:\n            case TokenTypes.LITERAL_WHILE:\n                result = !isEmptyLoopBodyAllowed(ast);\n                break;\n            case TokenTypes.LITERAL_CASE:\n            case TokenTypes.LITERAL_DEFAULT:\n                result = hasUnbracedStatements(ast)\n                    && !isSwitchLabeledExpression(ast);\n                break;\n            case TokenTypes.LITERAL_ELSE:\n                result = ast.findFirstToken(TokenTypes.LITERAL_IF) == null;\n                break;\n            case TokenTypes.LAMBDA:\n                result = !isInSwitchRule(ast);\n                break;\n            default:\n                result = true;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current loop has empty body and can be skipped by this check.\n     *\n     * @param ast for, while statements.\n     * @return true if current loop can be skipped by check.\n     */\n    private boolean isEmptyLoopBodyAllowed(DetailAST ast) {\n        return allowEmptyLoopBody && ast.findFirstToken(TokenTypes.EMPTY_STAT) != null;\n    }\n\n    /**\n     * Checks if switch member (case, default statements) has statements without curly braces.\n     *\n     * @param ast case, default statements.\n     * @return true if switch member has unbraced statements, false otherwise.\n     */\n    private static boolean hasUnbracedStatements(DetailAST ast) {\n        final DetailAST nextSibling = ast.getNextSibling();\n        boolean result = false;\n\n        if (isInSwitchRule(ast)) {\n            final DetailAST parent = ast.getParent();\n            result = parent.getLastChild().getType() != TokenTypes.SLIST;\n        }\n        else if (nextSibling != null\n            && nextSibling.getType() == TokenTypes.SLIST\n            && nextSibling.getFirstChild().getType() != TokenTypes.SLIST) {\n            result = true;\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current statement can be skipped by \"need braces\" warning.\n     *\n     * @param statement if, for, while, do-while, lambda, else, case, default statements.\n     * @return true if current statement can be skipped by Check.\n     */\n    private boolean isSkipStatement(DetailAST statement) {\n        return allowSingleLineStatement && isSingleLineStatement(statement);\n    }\n\n    /**\n     * Checks if current statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * if (obj.isValid()) return true;\n     * }\n     * </p>\n     * <p>\n     * {@code\n     * while (obj.isValid()) return true;\n     * }\n     * </p>\n     *\n     * @param statement if, for, while, do-while, lambda, else, case, default statements.\n     * @return true if current statement is single-line statement.\n     */\n    private static boolean isSingleLineStatement(DetailAST statement) {\n        final boolean result;\n\n        switch (statement.getType()) {\n            case TokenTypes.LITERAL_IF:\n                result = isSingleLineIf(statement);\n                break;\n            case TokenTypes.LITERAL_FOR:\n                result = isSingleLineFor(statement);\n                break;\n            case TokenTypes.LITERAL_DO:\n                result = isSingleLineDoWhile(statement);\n                break;\n            case TokenTypes.LITERAL_WHILE:\n                result = isSingleLineWhile(statement);\n                break;\n            case TokenTypes.LAMBDA:\n                result = !isInSwitchRule(statement)\n                    && isSingleLineLambda(statement);\n                break;\n            case TokenTypes.LITERAL_CASE:\n            case TokenTypes.LITERAL_DEFAULT:\n                result = isSingleLineSwitchMember(statement);\n                break;\n            default:\n                result = isSingleLineElse(statement);\n                break;\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if current while statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * while (obj.isValid()) return true;\n     * }\n     * </p>\n     *\n     * @param literalWhile {@link TokenTypes#LITERAL_WHILE while statement}.\n     * @return true if current while statement is single-line statement.\n     */\n    private static boolean isSingleLineWhile(DetailAST literalWhile) {\n        boolean result = false;\n        if (literalWhile.getParent().getType() == TokenTypes.SLIST) {\n            final DetailAST block = literalWhile.getLastChild().getPreviousSibling();\n            result = TokenUtil.areOnSameLine(literalWhile, block);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current do-while statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * do this.notify(); while (o != null);\n     * }\n     * </p>\n     *\n     * @param literalDo {@link TokenTypes#LITERAL_DO do-while statement}.\n     * @return true if current do-while statement is single-line statement.\n     */\n    private static boolean isSingleLineDoWhile(DetailAST literalDo) {\n        boolean result = false;\n        if (literalDo.getParent().getType() == TokenTypes.SLIST) {\n            final DetailAST block = literalDo.getFirstChild();\n            result = TokenUtil.areOnSameLine(block, literalDo);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current for statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * for (int i = 0; ; ) this.notify();\n     * }\n     * </p>\n     *\n     * @param literalFor {@link TokenTypes#LITERAL_FOR for statement}.\n     * @return true if current for statement is single-line statement.\n     */\n    private static boolean isSingleLineFor(DetailAST literalFor) {\n        boolean result = false;\n        if (literalFor.getLastChild().getType() == TokenTypes.EMPTY_STAT) {\n            result = true;\n        }\n        else if (literalFor.getParent().getType() == TokenTypes.SLIST) {\n            result = TokenUtil.areOnSameLine(literalFor, literalFor.getLastChild());\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current if statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * if (obj.isValid()) return true;\n     * }\n     * </p>\n     *\n     * @param literalIf {@link TokenTypes#LITERAL_IF if statement}.\n     * @return true if current if statement is single-line statement.\n     */\n    private static boolean isSingleLineIf(DetailAST literalIf) {\n        boolean result = false;\n        if (literalIf.getParent().getType() == TokenTypes.SLIST) {\n            final DetailAST literalIfLastChild = literalIf.getLastChild();\n            final DetailAST block;\n            if (literalIfLastChild.getType() == TokenTypes.LITERAL_ELSE) {\n                block = literalIfLastChild.getPreviousSibling();\n            }\n            else {\n                block = literalIfLastChild;\n            }\n            final DetailAST ifCondition = literalIf.findFirstToken(TokenTypes.EXPR);\n            result = TokenUtil.areOnSameLine(ifCondition, block);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current lambda statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * Runnable r = () -> System.out.println(\"Hello, world!\");\n     * }\n     * </p>\n     *\n     * @param lambda {@link TokenTypes#LAMBDA lambda statement}.\n     * @return true if current lambda statement is single-line statement.\n     */\n    private static boolean isSingleLineLambda(DetailAST lambda) {\n        final DetailAST lastLambdaToken = getLastLambdaToken(lambda);\n        return TokenUtil.areOnSameLine(lambda, lastLambdaToken);\n    }\n\n    /**\n     * Looks for the last token in lambda.\n     *\n     * @param lambda token to check.\n     * @return last token in lambda\n     */\n    private static DetailAST getLastLambdaToken(DetailAST lambda) {\n        DetailAST node = lambda;\n        do {\n            node = node.getLastChild();\n        } while (node.getLastChild() != null);\n        return node;\n    }\n\n    /**\n     * Checks if current ast's parent is a switch rule, e.g.:\n     * <p>\n     * {@code\n     * case 1 ->  monthString = \"January\";\n     * }\n     * </p>\n     *\n     * @param ast the ast to check.\n     * @return true if current ast belongs to a switch rule.\n     */\n    private static boolean isInSwitchRule(DetailAST ast) {\n        return ast.getParent().getType() == TokenTypes.SWITCH_RULE;\n    }\n\n    /**\n     * Checks if current expression is a switch labeled expression. If so,\n     * braces are not allowed e.g.:\n     * <p>\n     * {@code\n     * case 1 -> 4;\n     * }\n     * </p>\n     *\n     * @param ast the ast to check\n     * @return true if current expression is a switch labeled expression.\n     */\n    private static boolean isSwitchLabeledExpression(DetailAST ast) {\n        final DetailAST parent = ast.getParent();\n        return switchRuleHasSingleExpression(parent);\n    }\n\n    /**\n     * Checks if current switch labeled expression contains only a single expression.\n     *\n     * @param switchRule {@link TokenTypes#SWITCH_RULE}.\n     * @return true if current switch rule has a single expression.\n     */\n    private static boolean switchRuleHasSingleExpression(DetailAST switchRule) {\n        final DetailAST possibleExpression = switchRule.findFirstToken(TokenTypes.EXPR);\n        return possibleExpression != null\n                && possibleExpression.getFirstChild().getFirstChild() == null;\n    }\n\n    /**\n     * Checks if switch member (case or default statement) in a switch rule or\n     * case group is on a single line.\n     *\n     * @param statement {@link TokenTypes#LITERAL_CASE case statement} or\n     * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n     * @return true if current switch member is single-line statement.\n     */\n    private static boolean isSingleLineSwitchMember(DetailAST statement) {\n        final boolean result;\n        if (isInSwitchRule(statement)) {\n            result = isSingleLineSwitchRule(statement);\n        }\n        else {\n            result = isSingleLineCaseGroup(statement);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if switch member in case group (case or default statement)\n     * is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * case 1: System.out.println(\"case one\"); break;\n     * case 2: System.out.println(\"case two\"); break;\n     * case 3: ;\n     * default: System.out.println(\"default\"); break;\n     * }\n     * </p>\n     *\n     *\n     * @param ast {@link TokenTypes#LITERAL_CASE case statement} or\n     * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n     * @return true if current switch member is single-line statement.\n     */\n    private static boolean isSingleLineCaseGroup(DetailAST ast) {\n        return Optional.of(ast)\n            .map(DetailAST::getNextSibling)\n            .map(DetailAST::getLastChild)\n            .map(lastToken -> TokenUtil.areOnSameLine(ast, lastToken))\n            .orElse(true);\n    }\n\n    /**\n     * Checks if switch member in switch rule (case or default statement) is\n     * single-line statement, e.g.:\n     * <p>\n     * {@code\n     * case 1 -> System.out.println(\"case one\");\n     * case 2 -> System.out.println(\"case two\");\n     * default -> System.out.println(\"default\");\n     * }\n     * </p>\n     *\n     * @param ast {@link TokenTypes#LITERAL_CASE case statement} or\n     *            {@link TokenTypes#LITERAL_DEFAULT default statement}.\n     * @return true if current switch label is single-line statement.\n     */\n    private static boolean isSingleLineSwitchRule(DetailAST ast) {\n        final DetailAST lastSibling = ast.getParent().getLastChild();\n        return TokenUtil.areOnSameLine(ast, lastSibling);\n    }\n\n    /**\n     * Checks if current else statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * else doSomeStuff();\n     * }\n     * </p>\n     *\n     * @param literalElse {@link TokenTypes#LITERAL_ELSE else statement}.\n     * @return true if current else statement is single-line statement.\n     */\n    private static boolean isSingleLineElse(DetailAST literalElse) {\n        final DetailAST block = literalElse.getFirstChild();\n        return TokenUtil.areOnSameLine(literalElse, block);\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Checks if switch member in case group (case or default statement)\n     * is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * case 1: System.out.println(\"case one\"); break;\n     * case 2: System.out.println(\"case two\"); break;\n     * case 3: ;\n     * default: System.out.println(\"default\"); break;\n     * }\n     * </p>\n     *\n     *\n     * @param ast {@link TokenTypes#LITERAL_CASE case statement} or\n     * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n     * @return true if current switch member is single-line statement.\n     */\n    private static boolean isSingleLineCaseGroup(DetailAST ast) {\n        return Optional.of(ast)\n            .map(DetailAST::getNextSibling)\n            .map(DetailAST::getLastChild)\n            .map(lastToken -> TokenUtil.areOnSameLine(ast, lastToken))\n            .orElse(true);\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Checks if switch member (case or default statement) in a switch rule or\n     * case group is on a single line.\n     *\n     * @param statement {@link TokenTypes#LITERAL_CASE case statement} or\n     * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n     * @return true if current switch member is single-line statement.\n     */\n    private static boolean isSingleLineSwitchMember(DetailAST statement) {\n        final boolean result;\n        if (isInSwitchRule(statement)) {\n            result = isSingleLineSwitchRule(statement);\n        }\n        else {\n            result = isSingleLineCaseGroup(statement);\n        }\n        return result;\n    }\n/**\n     * Checks if switch member in case group (case or default statement)\n     * is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * case 1: System.out.println(\"case one\"); break;\n     * case 2: System.out.println(\"case two\"); break;\n     * case 3: ;\n     * default: System.out.println(\"default\"); break;\n     * }\n     * </p>\n     *\n     *\n     * @param ast {@link TokenTypes#LITERAL_CASE case statement} or\n     * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n     * @return true if current switch member is single-line statement.\n     */\n    private static boolean isSingleLineCaseGroup(DetailAST ast) {\n        return Optional.of(ast)\n            .map(DetailAST::getNextSibling)\n            .map(DetailAST::getLastChild)\n            .map(lastToken -> TokenUtil.areOnSameLine(ast, lastToken))\n            .orElse(true);\n    }", "diffSourceCode": "-  478:     /**\n-  479:      * Checks if switch member (case or default statement) is single-line statement, e.g.:\n-  480:      * <p>\n-  481:      * {@code\n-  482:      * case 1: doSomeStuff(); break;\n-  483:      * case 2: doSomeStuff(); break;\n-  484:      * case 3: ;\n-  485:      * default: doSomeStuff();break;\n-  486:      * }\n-  487:      * </p>\n-  488:      *\n-  489:      * @param ast {@link TokenTypes#LITERAL_CASE case statement} or\n-  490:      * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n-  491:      * @return true if current switch member is single-line statement.\n-  492:      */\n-  493:     private static boolean isSingleLineSwitchMember(DetailAST ast) {\n-  494:         return Optional.of(ast)\n-  495:                 .map(DetailAST::getNextSibling)\n-  496:                 .map(DetailAST::getLastChild)\n-  497:                 .map(lastToken -> TokenUtil.areOnSameLine(ast, lastToken))\n-  498:                 .orElse(true);\n-  499:     }\n+  478: \n+  479:     /**\n+  480:      * Looks for the last token in lambda.\n+  481:      *\n+  482:      * @param lambda token to check.\n+  483:      * @return last token in lambda\n+  484:      */\n+  485:     private static DetailAST getLastLambdaToken(DetailAST lambda) {\n+  486:         DetailAST node = lambda;\n+  487:         do {\n+  488:             node = node.getLastChild();\n+  489:         } while (node.getLastChild() != null);\n+  490:         return node;\n+  491:     }\n+  492: \n+  493:     /**\n+  494:      * Checks if current ast's parent is a switch rule, e.g.:\n+  495:      * <p>\n+  496:      * {@code\n+  497:      * case 1 ->  monthString = \"January\";\n+  498:      * }\n+  499:      * </p>\n+  537:     /**\n+  538:      * Checks if switch member (case or default statement) in a switch rule or\n+  539:      * case group is on a single line.\n+  540:      *\n+  541:      * @param statement {@link TokenTypes#LITERAL_CASE case statement} or\n+  542:      * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n+  543:      * @return true if current switch member is single-line statement.\n+  544:      */\n+  545:     private static boolean isSingleLineSwitchMember(DetailAST statement) {\n+  546:         final boolean result;\n+  547:         if (isInSwitchRule(statement)) {\n+  548:             result = isSingleLineSwitchRule(statement);\n+  549:         }\n+  550:         else {\n+  551:             result = isSingleLineCaseGroup(statement);\n+  552:         }\n+  553:         return result;\n+  554:     }\n+  556:     /**\n+  557:      * Checks if switch member in case group (case or default statement)\n+  558:      * is single-line statement, e.g.:\n+  559:      * <p>\n+  560:      * {@code\n+  561:      * case 1: System.out.println(\"case one\"); break;\n+  562:      * case 2: System.out.println(\"case two\"); break;\n+  563:      * case 3: ;\n+  564:      * default: System.out.println(\"default\"); break;\n+  565:      * }\n+  566:      * </p>\n+  567:      *\n+  568:      *\n+  569:      * @param ast {@link TokenTypes#LITERAL_CASE case statement} or\n+  570:      * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n+  571:      * @return true if current switch member is single-line statement.\n+  572:      */\n+  573:     private static boolean isSingleLineCaseGroup(DetailAST ast) {\n+  574:         return Optional.of(ast)\n+  575:             .map(DetailAST::getNextSibling)\n+  576:             .map(DetailAST::getLastChild)\n+  577:             .map(lastToken -> TokenUtil.areOnSameLine(ast, lastToken))\n+  578:             .orElse(true);\n+  579:     }\n", "uniqueId": "ea5b4e6ce5f98c6fc4758d6d38f881c82468344f_478_499_556_579_537_554", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 15}, "LINE": {"missed": 0, "covered": 5}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "##########################\nprivate static boolean isSingleLineSwitchMember(DetailAST ast) {\n    return Optional.of(ast)\n            .map(DetailAST::getNextSibling)\n            .map(DetailAST::getLastChild)\n            .map(lastToken -> TokenUtil.areOnSameLine(ast, lastToken))\n            .orElse(true);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n/**\n     * Checks if switch member (case or default statement) is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * case 1: doSomeStuff(); break;\n     * case 2: doSomeStuff(); break;\n     * case 3: ;\n     * default: doSomeStuff();break;\n     * }\n     * </p>\n     *\n     * @param ast {@link TokenTypes#LITERAL_CASE case statement} or\n     * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n     * @return true if current switch member is single-line statement.\n     */\n    private static boolean isSingleLineSwitchMember(DetailAST ast) {\n        return Optional.of(ast)\n                .map(DetailAST::getNextSibling)\n                .map(DetailAST::getLastChild)\n                .map(lastToken -> TokenUtil.areOnSameLine(ast, lastToken))\n                .orElse(true);\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.blocks;\n\nimport java.util.Optional;\n\nimport com.puppycrawl.tools.checkstyle.StatelessCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * <p>\n * Checks for braces around code blocks.\n * </p>\n * <ul>\n * <li>\n * Property {@code allowSingleLineStatement} - allow single-line statements without braces.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code allowEmptyLoopBody} - allow loops with empty bodies.\n * Type is {@code boolean}.\n * Default value is {@code false}.\n * </li>\n * <li>\n * Property {@code tokens} - tokens to check\n * Type is {@code java.lang.String[]}.\n * Validation type is {@code tokenSet}.\n * Default value is:\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_DO\">\n * LITERAL_DO</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_ELSE\">\n * LITERAL_ELSE</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_FOR\">\n * LITERAL_FOR</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_IF\">\n * LITERAL_IF</a>,\n * <a href=\"https://checkstyle.org/apidocs/com/puppycrawl/tools/checkstyle/api/TokenTypes.html#LITERAL_WHILE\">\n * LITERAL_WHILE</a>.\n * </li>\n * </ul>\n * <p>\n * To configure the check:\n * </p>\n * <pre>\n * &lt;module name=\"NeedBraces\"/&gt;\n * </pre>\n * <p>\n * To configure the check for {@code if} and {@code else} blocks:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_IF, LITERAL_ELSE&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * To configure the check to allow single-line statements\n * ({@code if, while, do-while, for}) without braces:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;allowSingleLineStatement&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Next statements won't be violated by check:\n * </p>\n * <pre>\n * if (obj.isValid()) return true; // OK\n * while (obj.isValid()) return true; // OK\n * do this.notify(); while (o != null); // OK\n * for (int i = 0; ; ) this.notify(); // OK\n * </pre>\n * <p>\n * To configure the check to allow {@code case, default} single-line statements without braces:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;LITERAL_CASE, LITERAL_DEFAULT&quot;/&gt;\n *   &lt;property name=&quot;allowSingleLineStatement&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Next statements won't be violated by check:\n * </p>\n * <pre>\n * switch (num) {\n *   case 1: counter++; break; // OK\n *   case 6: counter += 10; break; // OK\n *   default: counter = 100; break; // OK\n * }\n * </pre>\n * <p>\n * To configure the check to allow loops ({@code while, for}) with empty bodies:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;allowEmptyLoopBody&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Next statements won't be violated by check:\n * </p>\n * <pre>\n * while (value.incrementValue() &lt; 5); // OK\n * for(int i = 0; i &lt; 10; value.incrementValue()); // OK\n * </pre>\n * <p>\n * To configure the check to lambdas:\n * </p>\n * <pre>\n * &lt;module name=&quot;NeedBraces&quot;&gt;\n *   &lt;property name=&quot;tokens&quot; value=&quot;LAMBDA&quot;/&gt;\n *   &lt;property name=&quot;allowSingleLineStatement&quot; value=&quot;true&quot;/&gt;\n * &lt;/module&gt;\n * </pre>\n * <p>\n * Results in following:\n * </p>\n * <pre>\n * allowedFuture.addCallback(result -&gt; assertEquals(\"Invalid response\",\n *   EnumSet.of(HttpMethod.GET, HttpMethod.OPTIONS), result), // violation, lambda spans 2 lines\n *   ex -&gt; fail(ex.getMessage())); // OK\n *\n * allowedFuture.addCallback(result -&gt; {\n *   return assertEquals(\"Invalid response\",\n *     EnumSet.of(HttpMethod.GET, HttpMethod.OPTIONS), result);\n *   }, // OK\n *   ex -&gt; fail(ex.getMessage()));\n * </pre>\n * <p>\n * Parent is {@code com.puppycrawl.tools.checkstyle.TreeWalker}\n * </p>\n * <p>\n * Violation Message Keys:\n * </p>\n * <ul>\n * <li>\n * {@code needBraces}\n * </li>\n * </ul>\n *\n * @since 3.0\n */\n@StatelessCheck\npublic class NeedBracesCheck extends AbstractCheck {\n\n    /**\n     * A key is pointing to the warning message text in \"messages.properties\"\n     * file.\n     */\n    public static final String MSG_KEY_NEED_BRACES = \"needBraces\";\n\n    /**\n     * Allow single-line statements without braces.\n     */\n    private boolean allowSingleLineStatement;\n\n    /**\n     * Allow loops with empty bodies.\n     */\n    private boolean allowEmptyLoopBody;\n\n    /**\n     * Setter to allow single-line statements without braces.\n     *\n     * @param allowSingleLineStatement Check's option for skipping single-line statements\n     */\n    public void setAllowSingleLineStatement(boolean allowSingleLineStatement) {\n        this.allowSingleLineStatement = allowSingleLineStatement;\n    }\n\n    /**\n     * Setter to allow loops with empty bodies.\n     *\n     * @param allowEmptyLoopBody Check's option for allowing loops with empty body.\n     */\n    public void setAllowEmptyLoopBody(boolean allowEmptyLoopBody) {\n        this.allowEmptyLoopBody = allowEmptyLoopBody;\n    }\n\n    @Override\n    public int[] getDefaultTokens() {\n        return new int[] {\n            TokenTypes.LITERAL_DO,\n            TokenTypes.LITERAL_ELSE,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.LITERAL_IF,\n            TokenTypes.LITERAL_WHILE,\n        };\n    }\n\n    @Override\n    public int[] getAcceptableTokens() {\n        return new int[] {\n            TokenTypes.LITERAL_DO,\n            TokenTypes.LITERAL_ELSE,\n            TokenTypes.LITERAL_FOR,\n            TokenTypes.LITERAL_IF,\n            TokenTypes.LITERAL_WHILE,\n            TokenTypes.LITERAL_CASE,\n            TokenTypes.LITERAL_DEFAULT,\n            TokenTypes.LAMBDA,\n        };\n    }\n\n    @Override\n    public int[] getRequiredTokens() {\n        return CommonUtil.EMPTY_INT_ARRAY;\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        final boolean hasNoSlist = ast.findFirstToken(TokenTypes.SLIST) == null;\n        if (hasNoSlist && !isSkipStatement(ast) && isBracesNeeded(ast)) {\n            log(ast, MSG_KEY_NEED_BRACES, ast.getText());\n        }\n    }\n\n    /**\n     * Checks if token needs braces.\n     * Some tokens have additional conditions:\n     * <ul>\n     *     <li>{@link TokenTypes#LITERAL_FOR}</li>\n     *     <li>{@link TokenTypes#LITERAL_WHILE}</li>\n     *     <li>{@link TokenTypes#LITERAL_CASE}</li>\n     *     <li>{@link TokenTypes#LITERAL_DEFAULT}</li>\n     *     <li>{@link TokenTypes#LITERAL_ELSE}</li>\n     * </ul>\n     * For all others default value {@code true} is returned.\n     *\n     * @param ast token to check\n     * @return result of additional checks for specific token types,\n     * {@code true} if there is no additional checks for token\n     */\n    private boolean isBracesNeeded(DetailAST ast) {\n        final boolean result;\n        switch (ast.getType()) {\n            case TokenTypes.LITERAL_FOR:\n            case TokenTypes.LITERAL_WHILE:\n                result = !isEmptyLoopBodyAllowed(ast);\n                break;\n            case TokenTypes.LITERAL_CASE:\n            case TokenTypes.LITERAL_DEFAULT:\n                result = hasUnbracedStatements(ast);\n                break;\n            case TokenTypes.LITERAL_ELSE:\n                result = ast.findFirstToken(TokenTypes.LITERAL_IF) == null;\n                break;\n            default:\n                result = true;\n                break;\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current loop has empty body and can be skipped by this check.\n     *\n     * @param ast for, while statements.\n     * @return true if current loop can be skipped by check.\n     */\n    private boolean isEmptyLoopBodyAllowed(DetailAST ast) {\n        return allowEmptyLoopBody && ast.findFirstToken(TokenTypes.EMPTY_STAT) != null;\n    }\n\n    /**\n     * Checks if switch member (case, default statements) has statements without curly braces.\n     *\n     * @param ast case, default statements.\n     * @return true if switch member has unbraced statements, false otherwise.\n     */\n    private static boolean hasUnbracedStatements(DetailAST ast) {\n        final DetailAST nextSibling = ast.getNextSibling();\n        return nextSibling != null\n            && nextSibling.getType() == TokenTypes.SLIST\n            && nextSibling.getFirstChild().getType() != TokenTypes.SLIST;\n    }\n\n    /**\n     * Checks if current statement can be skipped by \"need braces\" warning.\n     *\n     * @param statement if, for, while, do-while, lambda, else, case, default statements.\n     * @return true if current statement can be skipped by Check.\n     */\n    private boolean isSkipStatement(DetailAST statement) {\n        return allowSingleLineStatement && isSingleLineStatement(statement);\n    }\n\n    /**\n     * Checks if current statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * if (obj.isValid()) return true;\n     * }\n     * </p>\n     * <p>\n     * {@code\n     * while (obj.isValid()) return true;\n     * }\n     * </p>\n     *\n     * @param statement if, for, while, do-while, lambda, else, case, default statements.\n     * @return true if current statement is single-line statement.\n     */\n    private static boolean isSingleLineStatement(DetailAST statement) {\n        final boolean result;\n\n        switch (statement.getType()) {\n            case TokenTypes.LITERAL_IF:\n                result = isSingleLineIf(statement);\n                break;\n            case TokenTypes.LITERAL_FOR:\n                result = isSingleLineFor(statement);\n                break;\n            case TokenTypes.LITERAL_DO:\n                result = isSingleLineDoWhile(statement);\n                break;\n            case TokenTypes.LITERAL_WHILE:\n                result = isSingleLineWhile(statement);\n                break;\n            case TokenTypes.LAMBDA:\n                result = isSingleLineLambda(statement);\n                break;\n            case TokenTypes.LITERAL_CASE:\n            case TokenTypes.LITERAL_DEFAULT:\n                result = isSingleLineSwitchMember(statement);\n                break;\n            default:\n                result = isSingleLineElse(statement);\n                break;\n        }\n\n        return result;\n    }\n\n    /**\n     * Checks if current while statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * while (obj.isValid()) return true;\n     * }\n     * </p>\n     *\n     * @param literalWhile {@link TokenTypes#LITERAL_WHILE while statement}.\n     * @return true if current while statement is single-line statement.\n     */\n    private static boolean isSingleLineWhile(DetailAST literalWhile) {\n        boolean result = false;\n        if (literalWhile.getParent().getType() == TokenTypes.SLIST) {\n            final DetailAST block = literalWhile.getLastChild().getPreviousSibling();\n            result = TokenUtil.areOnSameLine(literalWhile, block);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current do-while statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * do this.notify(); while (o != null);\n     * }\n     * </p>\n     *\n     * @param literalDo {@link TokenTypes#LITERAL_DO do-while statement}.\n     * @return true if current do-while statement is single-line statement.\n     */\n    private static boolean isSingleLineDoWhile(DetailAST literalDo) {\n        boolean result = false;\n        if (literalDo.getParent().getType() == TokenTypes.SLIST) {\n            final DetailAST block = literalDo.getFirstChild();\n            result = TokenUtil.areOnSameLine(block, literalDo);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current for statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * for (int i = 0; ; ) this.notify();\n     * }\n     * </p>\n     *\n     * @param literalFor {@link TokenTypes#LITERAL_FOR for statement}.\n     * @return true if current for statement is single-line statement.\n     */\n    private static boolean isSingleLineFor(DetailAST literalFor) {\n        boolean result = false;\n        if (literalFor.getLastChild().getType() == TokenTypes.EMPTY_STAT) {\n            result = true;\n        }\n        else if (literalFor.getParent().getType() == TokenTypes.SLIST) {\n            result = TokenUtil.areOnSameLine(literalFor, literalFor.getLastChild());\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current if statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * if (obj.isValid()) return true;\n     * }\n     * </p>\n     *\n     * @param literalIf {@link TokenTypes#LITERAL_IF if statement}.\n     * @return true if current if statement is single-line statement.\n     */\n    private static boolean isSingleLineIf(DetailAST literalIf) {\n        boolean result = false;\n        if (literalIf.getParent().getType() == TokenTypes.SLIST) {\n            final DetailAST literalIfLastChild = literalIf.getLastChild();\n            final DetailAST block;\n            if (literalIfLastChild.getType() == TokenTypes.LITERAL_ELSE) {\n                block = literalIfLastChild.getPreviousSibling();\n            }\n            else {\n                block = literalIfLastChild;\n            }\n            final DetailAST ifCondition = literalIf.findFirstToken(TokenTypes.EXPR);\n            result = TokenUtil.areOnSameLine(ifCondition, block);\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current lambda statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * Runnable r = () -> System.out.println(\"Hello, world!\");\n     * }\n     * </p>\n     *\n     * @param lambda {@link TokenTypes#LAMBDA lambda statement}.\n     * @return true if current lambda statement is single-line statement.\n     */\n    private static boolean isSingleLineLambda(DetailAST lambda) {\n        final DetailAST lastLambdaToken = getLastLambdaToken(lambda);\n        return TokenUtil.areOnSameLine(lambda, lastLambdaToken);\n    }\n\n    /**\n     * Looks for the last token in lambda.\n     *\n     * @param lambda token to check.\n     * @return last token in lambda\n     */\n    private static DetailAST getLastLambdaToken(DetailAST lambda) {\n        DetailAST node = lambda;\n        do {\n            node = node.getLastChild();\n        } while (node.getLastChild() != null);\n        return node;\n    }\n\n    /**\n     * Checks if switch member (case or default statement) is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * case 1: doSomeStuff(); break;\n     * case 2: doSomeStuff(); break;\n     * case 3: ;\n     * default: doSomeStuff();break;\n     * }\n     * </p>\n     *\n     * @param ast {@link TokenTypes#LITERAL_CASE case statement} or\n     * {@link TokenTypes#LITERAL_DEFAULT default statement}.\n     * @return true if current switch member is single-line statement.\n     */\n    private static boolean isSingleLineSwitchMember(DetailAST ast) {\n        return Optional.of(ast)\n                .map(DetailAST::getNextSibling)\n                .map(DetailAST::getLastChild)\n                .map(lastToken -> TokenUtil.areOnSameLine(ast, lastToken))\n                .orElse(true);\n    }\n\n    /**\n     * Checks if current else statement is single-line statement, e.g.:\n     * <p>\n     * {@code\n     * else doSomeStuff();\n     * }\n     * </p>\n     *\n     * @param literalElse {@link TokenTypes#LITERAL_ELSE else statement}.\n     * @return true if current else statement is single-line statement.\n     */\n    private static boolean isSingleLineElse(DetailAST literalElse) {\n        final DetailAST block = literalElse.getFirstChild();\n        return TokenUtil.areOnSameLine(literalElse, block);\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic getNameAttributeOfNode(node Node) : String extracted from public testAllCheckSectionMobileWrapper() : void in class com.puppycrawl.tools.checkstyle.internal.XdocsMobileWrapperTest & moved to class com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil", "diffLocations": [{"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsMobileWrapperTest.java", "startLine": 54, "endLine": 77, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsMobileWrapperTest.java", "startLine": 54, "endLine": 76, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsMobileWrapperTest.java", "startLine": 135, "endLine": 143, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void testAllCheckSectionMobileWrapper() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final File file = path.toFile();\n            final String fileName = file.getName();\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            assertNotEquals(\"\", input, fileName + \": input file cannot be empty\");\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = section.getAttributes().getNamedItem(\"name\")\n                        .getNodeValue();\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    continue;\n                }\n\n                iterateNode(section, fileName, sectionName);\n            }\n        }\n    }", "filePathBefore": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsMobileWrapperTest.java", "isPureRefactoring": true, "commitId": "1a6443b724a3539b000bcaa2ed9f8016b6bb4f38", "packageNameBefore": "com.puppycrawl.tools.checkstyle.internal", "classNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsMobileWrapperTest", "methodNameBefore": "com.puppycrawl.tools.checkstyle.internal.XdocsMobileWrapperTest#testAllCheckSectionMobileWrapper", "invokedMethod": "methodSignature: com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil#getRawXml\n methodBody: public static Document getRawXml(String fileName, String code, String unserializedSource)\n            throws ParserConfigurationException {\nDocument rawXml=null;\ntryfinal DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();\nfactory.setValidating(false);\nfactory.setFeature(XmlLoader.LoadExternalDtdFeatureProvider.EXTERNAL_GENERAL_ENTITIES,false);\nfactory.setFeature(XmlLoader.LoadExternalDtdFeatureProvider.LOAD_EXTERNAL_DTD,false);\nfinal DocumentBuilder builder=factory.newDocumentBuilder();\nrawXml=builder.parse(new InputSource(new StringReader(code)));\ncatch(IOException|SAXException ex)fail(fileName + \" has invalid xml (\" + ex.getMessage() + \"): \" + unserializedSource);\nreturn rawXml;\n}\nmethodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsMobileWrapperTest#iterateNode\n methodBody: private static void iterateNode(Node node, String fileName, String sectionName) {\nfor(Node child: XmlUtil.getChildrenElements(node)){if(NODES_TO_WRAP.contains(child.getNodeName())){final String wrapperMessage=fileName + \"/\" + sectionName + \": Tag '\" + child.getNodeName() + \"' in '\" + node.getNodeName() + \"' needs a wrapping <span> or <div> with the class 'wrapper'.\";\nassertTrue(\"div\".equals(node.getNodeName()) || \"span\".equals(node.getNodeName()),wrapperMessage);\nassertTrue(node.hasAttributes(),wrapperMessage);\nassertNotNull(node.getAttributes().getNamedItem(\"class\"),wrapperMessage);\nassertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),wrapperMessage);\nif(\"table\".equals(child.getNodeName())){iterateNode(child,fileName,sectionName);\n}if(\"img\".equals(child.getNodeName())){final String dataImageInlineMessage=fileName + \"/\" + sectionName + \": img \" + \"needs the additional class inline if it should be displayed inline \" + \"or block if scrolling in mobile view should be enabled.\";\nassertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue().matches(\".*(block|inline).*\"),dataImageInlineMessage);\n}}{iterateNode(child,fileName,sectionName);\n}}}", "classSignatureBefore": "public class XdocsMobileWrapperTest ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsMobileWrapperTest#testAllCheckSectionMobileWrapper"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.internal.XdocsMobileWrapperTest"], "classSignatureBeforeSet": ["public class XdocsMobileWrapperTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\n\npublic class XdocsMobileWrapperTest {\n\n    private static final List<String> NODES_TO_WRAP = new ArrayList<>();\n\n    @BeforeEach\n    public void setUp() {\n        NODES_TO_WRAP.add(\"pre\");\n        NODES_TO_WRAP.add(\"table\");\n        NODES_TO_WRAP.add(\"svg\");\n        NODES_TO_WRAP.add(\"img\");\n    }\n\n    @Test\n    public void testAllCheckSectionMobileWrapper() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final File file = path.toFile();\n            final String fileName = file.getName();\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            assertNotEquals(\"\", input, fileName + \": input file cannot be empty\");\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = section.getAttributes().getNamedItem(\"name\")\n                        .getNodeValue();\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    continue;\n                }\n\n                iterateNode(section, fileName, sectionName);\n            }\n        }\n    }\n\n    private static void iterateNode(Node node, String fileName, String sectionName) {\n        for (Node child : XmlUtil.getChildrenElements(node)) {\n            if (NODES_TO_WRAP.contains(child.getNodeName())) {\n                final String wrapperMessage = fileName + \"/\" + sectionName + \": Tag '\"\n                        + child.getNodeName() + \"' in '\" + node.getNodeName()\n                        + \"' needs a wrapping <span> or <div> with the class 'wrapper'.\";\n                assertTrue(\"div\".equals(node.getNodeName())\n                        || \"span\".equals(node.getNodeName()), wrapperMessage);\n                assertTrue(node.hasAttributes(), wrapperMessage);\n                assertNotNull(node.getAttributes().getNamedItem(\"class\"), wrapperMessage);\n                assertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue()\n                                .contains(\"wrapper\"), wrapperMessage);\n\n                if (\"table\".equals(child.getNodeName())) {\n                    iterateNode(child, fileName, sectionName);\n                }\n                if (\"img\".equals(child.getNodeName())) {\n                    final String dataImageInlineMessage = fileName + \"/\" + sectionName + \": img \"\n                            + \"needs the additional class inline if it should be displayed inline \"\n                            + \"or block if scrolling in mobile view should be enabled.\";\n                    assertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue()\n                                    .matches(\".*(block|inline).*\"), dataImageInlineMessage);\n                }\n            }\n            else {\n                iterateNode(child, fileName, sectionName);\n            }\n        }\n    }\n}\n", "filePathAfter": "src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsMobileWrapperTest.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\n\npublic class XdocsMobileWrapperTest {\n\n    private static final List<String> NODES_TO_WRAP = new ArrayList<>();\n\n    @BeforeEach\n    public void setUp() {\n        NODES_TO_WRAP.add(\"pre\");\n        NODES_TO_WRAP.add(\"table\");\n        NODES_TO_WRAP.add(\"svg\");\n        NODES_TO_WRAP.add(\"img\");\n    }\n\n    @Test\n    public void testAllCheckSectionMobileWrapper() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final File file = path.toFile();\n            final String fileName = file.getName();\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            assertNotEquals(\"\", input, fileName + \": input file cannot be empty\");\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    continue;\n                }\n\n                iterateNode(section, fileName, sectionName);\n            }\n        }\n    }\n\n    private static void iterateNode(Node node, String fileName, String sectionName) {\n        for (Node child : XmlUtil.getChildrenElements(node)) {\n            if (NODES_TO_WRAP.contains(child.getNodeName())) {\n                final String wrapperMessage = fileName + \"/\" + sectionName + \": Tag '\"\n                        + child.getNodeName() + \"' in '\" + node.getNodeName()\n                        + \"' needs a wrapping <span> or <div> with the class 'wrapper'.\";\n                assertTrue(\"div\".equals(node.getNodeName())\n                        || \"span\".equals(node.getNodeName()), wrapperMessage);\n                assertTrue(node.hasAttributes(), wrapperMessage);\n                assertNotNull(node.getAttributes().getNamedItem(\"class\"), wrapperMessage);\n                assertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue()\n                                .contains(\"wrapper\"), wrapperMessage);\n\n                if (\"table\".equals(child.getNodeName())) {\n                    iterateNode(child, fileName, sectionName);\n                }\n                if (\"img\".equals(child.getNodeName())) {\n                    final String dataImageInlineMessage = fileName + \"/\" + sectionName + \": img \"\n                            + \"needs the additional class inline if it should be displayed inline \"\n                            + \"or block if scrolling in mobile view should be enabled.\";\n                    assertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue()\n                                    .matches(\".*(block|inline).*\"), dataImageInlineMessage);\n                }\n            }\n            else {\n                iterateNode(child, fileName, sectionName);\n            }\n        }\n    }\n}\n", "diffSourceCodeSet": [""], "invokedMethodSet": ["methodSignature: com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil#getRawXml\n methodBody: public static Document getRawXml(String fileName, String code, String unserializedSource)\n            throws ParserConfigurationException {\nDocument rawXml=null;\ntryfinal DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance();\nfactory.setValidating(false);\nfactory.setFeature(XmlLoader.LoadExternalDtdFeatureProvider.EXTERNAL_GENERAL_ENTITIES,false);\nfactory.setFeature(XmlLoader.LoadExternalDtdFeatureProvider.LOAD_EXTERNAL_DTD,false);\nfinal DocumentBuilder builder=factory.newDocumentBuilder();\nrawXml=builder.parse(new InputSource(new StringReader(code)));\ncatch(IOException|SAXException ex)fail(fileName + \" has invalid xml (\" + ex.getMessage() + \"): \" + unserializedSource);\nreturn rawXml;\n}", "methodSignature: com.puppycrawl.tools.checkstyle.internal.XdocsMobileWrapperTest#iterateNode\n methodBody: private static void iterateNode(Node node, String fileName, String sectionName) {\nfor(Node child: XmlUtil.getChildrenElements(node)){if(NODES_TO_WRAP.contains(child.getNodeName())){final String wrapperMessage=fileName + \"/\" + sectionName + \": Tag '\" + child.getNodeName() + \"' in '\" + node.getNodeName() + \"' needs a wrapping <span> or <div> with the class 'wrapper'.\";\nassertTrue(\"div\".equals(node.getNodeName()) || \"span\".equals(node.getNodeName()),wrapperMessage);\nassertTrue(node.hasAttributes(),wrapperMessage);\nassertNotNull(node.getAttributes().getNamedItem(\"class\"),wrapperMessage);\nassertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue().contains(\"wrapper\"),wrapperMessage);\nif(\"table\".equals(child.getNodeName())){iterateNode(child,fileName,sectionName);\n}if(\"img\".equals(child.getNodeName())){final String dataImageInlineMessage=fileName + \"/\" + sectionName + \": img \" + \"needs the additional class inline if it should be displayed inline \" + \"or block if scrolling in mobile view should be enabled.\";\nassertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue().matches(\".*(block|inline).*\"),dataImageInlineMessage);\n}}{iterateNode(child,fileName,sectionName);\n}}}"], "sourceCodeAfterRefactoring": "@Test\n    public void testAllCheckSectionMobileWrapper() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final File file = path.toFile();\n            final String fileName = file.getName();\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            assertNotEquals(\"\", input, fileName + \": input file cannot be empty\");\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    continue;\n                }\n\n                iterateNode(section, fileName, sectionName);\n            }\n        }\n    }\n", "diffSourceCode": "    54:     @Test\n    55:     public void testAllCheckSectionMobileWrapper() throws Exception {\n    56:         for (Path path : XdocUtil.getXdocsFilePaths()) {\n    57:             final File file = path.toFile();\n    58:             final String fileName = file.getName();\n    59: \n    60:             final String input = new String(Files.readAllBytes(path), UTF_8);\n    61:             assertNotEquals(\"\", input, fileName + \": input file cannot be empty\");\n    62:             final Document document = XmlUtil.getRawXml(fileName, input, input);\n    63:             final NodeList sources = document.getElementsByTagName(\"section\");\n    64: \n    65:             for (int position = 0; position < sources.getLength(); position++) {\n    66:                 final Node section = sources.item(position);\n-   67:                 final String sectionName = section.getAttributes().getNamedItem(\"name\")\n-   68:                         .getNodeValue();\n-   69: \n-   70:                 if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n-   71:                     continue;\n-   72:                 }\n-   73: \n-   74:                 iterateNode(section, fileName, sectionName);\n-   75:             }\n-   76:         }\n-   77:     }\n+   67:                 final String sectionName = XmlUtil.getNameAttributeOfNode(section);\n+   68: \n+   69:                 if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n+   70:                     continue;\n+   71:                 }\n+   72: \n+   73:                 iterateNode(section, fileName, sectionName);\n+   74:             }\n+   75:         }\n+   76:     }\n+   77: \n", "uniqueId": "1a6443b724a3539b000bcaa2ed9f8016b6bb4f38_54_77_135_143_54_76", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "##########################\nsrc/test/java/com/puppycrawl/tools/checkstyle/internal/utils/XmlUtil.java\n##########################\npublic static void iterateNode(Node node, String fileName, String sectionName) {\n    for (Node child : XmlUtil.getChildrenElements(node)) {\n        if (NODES_TO_WRAP.contains(child.getNodeName())) {\n            final String wrapperMessage = fileName + \"/\" + sectionName + \": Tag '\"\n                    + child.getNodeName() + \"' in '\" + node.getNodeName()\n                    + \"' needs a wrapping <span> or <div> with the class 'wrapper'.\";\n            assertTrue(\"div\".equals(node.getNodeName())\n                    || \"span\".equals(node.getNodeName()), wrapperMessage);\n            assertTrue(node.hasAttributes(), wrapperMessage);\n            assertNotNull(node.getAttributes().getNamedItem(\"class\"), wrapperMessage);\n            assertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue()\n                            .contains(\"wrapper\"), wrapperMessage);\n\n            if (\"table\".equals(child.getNodeName())) {\n                iterateNode(child, fileName, sectionName);\n            }\n            if (\"img\".equals(child.getNodeName())) {\n                final String dataImageInlineMessage = fileName + \"/\" + sectionName + \": img \"\n                        + \"needs the additional class inline if it should be displayed inline \"\n                        + \"or block if scrolling in mobile view should be enabled.\";\n                assertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue()\n                                .matches(\".*(block|inline).*\"), dataImageInlineMessage);\n            }\n        }\n        else {\n            iterateNode(child, fileName, sectionName);\n        }\n    }\n}\n##########################\nfor (Path path : XdocUtil.getXdocsFilePaths()) {\n    final File file = path.toFile();\n    final String fileName = file.getName();\n\n    final String input = new String(Files.readAllBytes(path), UTF_8);\n    assertNotEquals(\"\", input, fileName + \": input file cannot be empty\");\n    final Document document = XmlUtil.getRawXml(fileName, input, input);\n    final NodeList sources = document.getElementsByTagName(\"section\");\n\n    for (int position = 0; position < sources.getLength(); position++) {\n        final Node section = sources.item(position);\n        final String sectionName = section.getAttributes().getNamedItem(\"name\")\n                .getNodeValue();\n\n        if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n            continue;\n        }\n\n        XmlUtil.iterateNode(section, fileName, sectionName);\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n@Test\n    public void testAllCheckSectionMobileWrapper() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final File file = path.toFile();\n            final String fileName = file.getName();\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            assertNotEquals(\"\", input, fileName + \": input file cannot be empty\");\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = section.getAttributes().getNamedItem(\"name\")\n                        .getNodeValue();\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    continue;\n                }\n\n                iterateNode(section, fileName, sectionName);\n            }\n        }\n    }\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2020 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.internal;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport com.puppycrawl.tools.checkstyle.internal.utils.XdocUtil;\nimport com.puppycrawl.tools.checkstyle.internal.utils.XmlUtil;\n\npublic class XdocsMobileWrapperTest {\n\n    private static final List<String> NODES_TO_WRAP = new ArrayList<>();\n\n    @BeforeEach\n    public void setUp() {\n        NODES_TO_WRAP.add(\"pre\");\n        NODES_TO_WRAP.add(\"table\");\n        NODES_TO_WRAP.add(\"svg\");\n        NODES_TO_WRAP.add(\"img\");\n    }\n\n    @Test\n    public void testAllCheckSectionMobileWrapper() throws Exception {\n        for (Path path : XdocUtil.getXdocsFilePaths()) {\n            final File file = path.toFile();\n            final String fileName = file.getName();\n\n            final String input = new String(Files.readAllBytes(path), UTF_8);\n            assertNotEquals(\"\", input, fileName + \": input file cannot be empty\");\n            final Document document = XmlUtil.getRawXml(fileName, input, input);\n            final NodeList sources = document.getElementsByTagName(\"section\");\n\n            for (int position = 0; position < sources.getLength(); position++) {\n                final Node section = sources.item(position);\n                final String sectionName = section.getAttributes().getNamedItem(\"name\")\n                        .getNodeValue();\n\n                if (\"Content\".equals(sectionName) || \"Overview\".equals(sectionName)) {\n                    continue;\n                }\n\n                iterateNode(section, fileName, sectionName);\n            }\n        }\n    }\n\n    private static void iterateNode(Node node, String fileName, String sectionName) {\n        for (Node child : XmlUtil.getChildrenElements(node)) {\n            if (NODES_TO_WRAP.contains(child.getNodeName())) {\n                final String wrapperMessage = fileName + \"/\" + sectionName + \": Tag '\"\n                        + child.getNodeName() + \"' in '\" + node.getNodeName()\n                        + \"' needs a wrapping <span> or <div> with the class 'wrapper'.\";\n                assertTrue(\"div\".equals(node.getNodeName())\n                        || \"span\".equals(node.getNodeName()), wrapperMessage);\n                assertTrue(node.hasAttributes(), wrapperMessage);\n                assertNotNull(node.getAttributes().getNamedItem(\"class\"), wrapperMessage);\n                assertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue()\n                                .contains(\"wrapper\"), wrapperMessage);\n\n                if (\"table\".equals(child.getNodeName())) {\n                    iterateNode(child, fileName, sectionName);\n                }\n                if (\"img\".equals(child.getNodeName())) {\n                    final String dataImageInlineMessage = fileName + \"/\" + sectionName + \": img \"\n                            + \"needs the additional class inline if it should be displayed inline \"\n                            + \"or block if scrolling in mobile view should be enabled.\";\n                    assertTrue(node.getAttributes().getNamedItem(\"class\").getNodeValue()\n                                    .matches(\".*(block|inline).*\"), dataImageInlineMessage);\n                }\n            }\n            else {\n                iterateNode(child, fileName, sectionName);\n            }\n        }\n    }\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['src/test/java/com/puppycrawl/tools/checkstyle/AbstractModuleTestSupport.java', 'src/test/java/com/puppycrawl/tools/checkstyle/AbstractPathTestSupport.java', 'src/test/java/com/puppycrawl/tools/checkstyle/AbstractTreeTestSupport.java', 'src/test/java/com/puppycrawl/tools/checkstyle/AbstractXmlTestSupport.java', 'src/test/java/com/puppycrawl/tools/checkstyle/AstTreeStringPrinterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/AuditEventDefaultFormatterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/CheckerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/ConfigurationLoaderTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/DefaultConfigurationTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/DefaultLoggerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/DefinitionsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/DetailAstImplTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/DetailNodeTreeStringPrinterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/JavaParserTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParserTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/JavadocPropertiesGeneratorTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/MainTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/PackageNamesLoaderTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/PackageObjectFactoryTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/PropertiesExpanderTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/PropertyCacheFileTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/SuppressionsStringPrinterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/ThreadModeSettingsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/TreeWalkerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/XMLLoggerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/XmlLoaderTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAstFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAuditListenerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/ant/CheckstyleAntTaskTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/AbstractCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/AbstractFileSetCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/AbstractViolationReporterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/AuditEventTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/AutomaticBeanTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilterSetTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/CommentTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/FileContentsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/FileSetCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/FileTextTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/FilterSetTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/FullIdentTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/JavadocTokenTypesTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/LineColumnTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/LocalizedMessageTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/ScopeTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/SeverityLevelCounterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/SeverityLevelTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/api/TokenTypesTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/ArrayTypeStyleCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/FinalParametersCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/OrderedPropertiesCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/OuterTypeFilenameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolderTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/TodoCommentCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/UniquePropertiesCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/UpperEllCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationOnSameLineCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingDeprecatedCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingOverrideCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/annotation/PackageAnnotationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/blocks/AvoidNestedBlocksCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyBlockCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/ArrayTrailingCommaCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidInlineConditionalsCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/CovariantEqualsCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/DefaultComesLastCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/EmptyStatementCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsHashCodeCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/ExplicitInitializationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/HiddenFieldCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalCatchCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenTextCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/MagicNumberCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingCtorCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingSwitchDefaultCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/ModifiedControlVariableCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleVariableDeclarationsCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedForDepthCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedIfDepthCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedTryDepthCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/NoArrayTrailingCommaCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/NoCloneCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/NoEnumTrailingCommaCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/NoFinalizerCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/PackageDeclarationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/ReturnCountCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanExpressionCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanReturnCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/StringLiteralEqualityCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperCloneCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperFinalizeCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterTypeMemberDeclarationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInEnumerationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInTryWithResourcesCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/design/HideUtilityClassConstructorCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/design/InnerTypeLastCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/design/InterfaceIsTypeCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/design/OneTopLevelClassCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/design/ThrowsCountCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/header/HeaderCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/AccessResultTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStarImportCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStaticImportCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/ClassImportRuleTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/FileImportControlTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/IllegalImportCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlLoaderTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportControlTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportRuleTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/RedundantImportCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineSetTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AtclauseOrderCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocPositionCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocBlockTagLocationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocNodeImplTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocPackageCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocParagraphCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagContinuationIndentationCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagInfoTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocVariableCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocMethodCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocPackageCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocTypeCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/NonEmptyAtclauseDescriptionCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SingleLineJavadocCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/WriteTagCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/BlockTagUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/InlineTagUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassDataAbstractionCouplingCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassFanOutComplexityCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/metrics/CyclomaticComplexityCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/metrics/JavaNCSSCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/modifier/ClassMemberImpliedModifierCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/modifier/InterfaceMemberImpliedModifierCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/modifier/ModifierOrderCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/AbbreviationAsWordInNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/CatchParameterNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/ClassTypeParameterNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/ConstantNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/InterfaceTypeParameterNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/LambdaParameterNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalFinalVariableNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalVariableNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/MemberNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodTypeParameterNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/PackageNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/ParameterNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/StaticVariableNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/naming/TypeNameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpMultilineCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpOnFilenameCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineJavaCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/sizes/AnonInnerLengthCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/sizes/ExecutableStatementCountCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/sizes/FileLengthCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/sizes/LineLengthCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodLengthCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/sizes/OuterTypeNumberCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/sizes/ParameterNumberCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForInitializerPadCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForIteratorPadCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/FileTabCharacterCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/MethodParamPadCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoLineWrapCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/OperatorWrapCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SeparatorWrapCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SingleSpaceSeparatorCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/TypecastParenPadCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAfterCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheckTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filefilters/BeforeExecutionExclusionFileFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/CsvFilterElementTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/IntMatchFilterElementTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/IntRangeFilterElementTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SeverityMatchFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SuppressFilterElementTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SuppressWarningsFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithPlainTextCommentFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SuppressionFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SuppressionSingleFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathSingleFilterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/SuppressionsLoaderTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/filters/XpathFilterElementTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/AstRegressionTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/EmbeddedNullCharTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/GeneratedJava14LexerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/GeneratedJavaTokenTypesTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/HexFloatsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/Java7DiamondTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/Java7MultiCatchTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/Java7NumericalLiteralsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/Java7StringSwitchTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/Java7TryWithResourcesTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/Java9TryWithResourcesTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/LineCommentAtTheEndOfFileTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/MultiDimensionalArraysInGenericsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/UnicodeEscapeTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/VarargTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/comments/AllBlockCommentsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/comments/AllSinglelineCommentsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/comments/CommentsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/java8/AnnotationTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/java8/AnnotationsOnArrayTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/java8/DefaultMethodsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/java8/LambdaTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/java8/MethodReferencesTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/java8/ReceiverParameterTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/java8/TypeUseAnnotationsOnQualifiedTypesTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/javadoc/GeneratedJavadocTokenTypesTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/grammar/javadoc/JavadocParseTreeTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/gui/CodeSelectorPresentationTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/gui/MainFrameModelTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTablePresentationTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/AllChecksTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/AllTestsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/CommitValidationTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsJavaDocsTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsMobileWrapperTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsPagesTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/XpathRegressionTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/AuditEventDefaultFormatterPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/CheckstyleAntTaskPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/CommonUtilPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/ConfigurationLoaderPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/DefaultLoggerPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/HeaderCheckPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/ImportControlLoaderPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/JavadocPackageCheckPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/MainFrameModelPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/MainPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/PackageObjectFactoryPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/PropertyCacheFilePowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/RegexpOnFilenameCheckPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/powermock/TreeWalkerPowerTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/testmodules/CheckerStub.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/testmodules/DebugAuditAdapter.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/testmodules/DebugFilter.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/testmodules/TestBeforeExecutionFileFilter.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/testmodules/TestFileSetCheck.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/testmodules/TestLoggingReporter.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/testmodules/TestRootModuleChecker.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/utils/AuditEventUtFormatter.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/utils/BriefUtLogger.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/utils/CheckUtil.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/utils/CloseAndFlushTestByteArrayOutputStream.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/utils/ConfigurationUtil.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/utils/TestUtil.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/utils/XdocUtil.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/utils/XmlUtil.java', 'src/test/java/com/puppycrawl/tools/checkstyle/internal/utils/XpathUtil.java', 'src/test/java/com/puppycrawl/tools/checkstyle/utils/AnnotationUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/utils/BlockCommentPositionTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/utils/CheckUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/utils/CommonUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/utils/FilterUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/utils/ModuleReflectionUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/utils/ScopeUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/utils/TokenUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/utils/XpathUtilTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/xpath/AttributeNodeTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/xpath/ElementNodeTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/xpath/RootNodeTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/xpath/XpathMapperTest.java', 'src/test/java/com/puppycrawl/tools/checkstyle/xpath/XpathQueryGeneratorTest.java']\n\nFile Path Before Refactoring:\nsrc/test/java/com/puppycrawl/tools/checkstyle/internal/XdocsMobileWrapperTest.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Move And Inline Method", "description": "Move And Inline Method\tpublic createFullType(typeAST DetailAST) : FullIdent moved from class com.puppycrawl.tools.checkstyle.utils.CheckUtil to class com.puppycrawl.tools.checkstyle.checks.metrics.AbstractClassCouplingCheck.ClassContext & inlined to public visitType(ast DetailAST) : void", "diffLocations": [{"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java", "startLine": 373, "endLine": 383, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java", "startLine": 372, "endLine": 388, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java", "startLine": 79, "endLine": 87, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "\"Override\", \"Deprecated\", \"SafeVarargs\", \"SuppressWarnings\", \"FunctionalInterface\",\n            \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\",\n            \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\",\n            // java.util.stream.*\n            \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\",\n        }).collect(Collectors.toSet()));\n\n    /** Package names to ignore. */\n    private static final Set<String> DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();", "filePathBefore": "src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java", "isPureRefactoring": true, "commitId": "e2c6e148a92e01b3c6037b33440ee7006f742793", "packageNameBefore": "com.puppycrawl.tools.checkstyle.utils", "classNameBefore": "com.puppycrawl.tools.checkstyle.utils.CheckUtil", "methodNameBefore": "com.puppycrawl.tools.checkstyle.utils.CheckUtil#createFullType", "classSignatureBefore": "public final class CheckUtil ", "methodNameBeforeSet": ["com.puppycrawl.tools.checkstyle.utils.CheckUtil#createFullType"], "classNameBeforeSet": ["com.puppycrawl.tools.checkstyle.utils.CheckUtil"], "classSignatureBeforeSet": ["public final class CheckUtil "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.metrics;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * Base class for coupling calculation.\n *\n */\n@FileStatefulCheck\npublic abstract class AbstractClassCouplingCheck extends AbstractCheck {\n\n    /** A package separator - \".\" */\n    private static final String DOT = \".\";\n\n    /** Class names to ignore. */\n    private static final Set<String> DEFAULT_EXCLUDED_CLASSES = Collections.unmodifiableSet(\n        Arrays.stream(new String[] {\n            // reserved type name\n            \"var\",\n            // primitives\n            \"boolean\", \"byte\", \"char\", \"double\", \"float\", \"int\",\n            \"long\", \"short\", \"void\",\n            // wrappers\n            \"Boolean\", \"Byte\", \"Character\", \"Double\", \"Float\",\n            \"Integer\", \"Long\", \"Short\", \"Void\",\n            // java.lang.*\n            \"Object\", \"Class\",\n            \"String\", \"StringBuffer\", \"StringBuilder\",\n            // Exceptions\n            \"ArrayIndexOutOfBoundsException\", \"Exception\",\n            \"RuntimeException\", \"IllegalArgumentException\",\n            \"IllegalStateException\", \"IndexOutOfBoundsException\",\n            \"NullPointerException\", \"Throwable\", \"SecurityException\",\n            \"UnsupportedOperationException\",\n            // java.util.*\n            \"List\", \"ArrayList\", \"Deque\", \"Queue\", \"LinkedList\",\n            \"Set\", \"HashSet\", \"SortedSet\", \"TreeSet\",\n            \"Map\", \"HashMap\", \"SortedMap\", \"TreeMap\",\n            \"Override\", \"Deprecated\", \"SafeVarargs\", \"SuppressWarnings\", \"FunctionalInterface\",\n            \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\",\n            \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\",\n            // java.util.stream.*\n            \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\",\n        }).collect(Collectors.toSet()));\n\n    /** Package names to ignore. */\n    private static final Set<String> DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();\n\n    /** Pattern to match brackets in a full type name. */\n    private static final Pattern BRACKET_PATTERN = Pattern.compile(\"\\\\[[^]]*]\");\n\n    /** Specify user-configured regular expressions to ignore classes. */\n    private final List<Pattern> excludeClassesRegexps = new ArrayList<>();\n\n    /** A map of (imported class name -&gt; class name with package) pairs. */\n    private final Map<String, String> importedClassPackages = new HashMap<>();\n\n    /** Stack of class contexts. */\n    private final Deque<ClassContext> classesContexts = new ArrayDeque<>();\n\n    /** Specify user-configured class names to ignore. */\n    private Set<String> excludedClasses = DEFAULT_EXCLUDED_CLASSES;\n\n    /**\n     * Specify user-configured packages to ignore. All excluded packages\n     * should end with a period, so it also appends a dot to a package name.\n     */\n    private Set<String> excludedPackages = DEFAULT_EXCLUDED_PACKAGES;\n\n    /** Specify the maximum threshold allowed. */\n    private int max;\n\n    /** Current file package. */\n    private String packageName;\n\n    /**\n     * Creates new instance of the check.\n     *\n     * @param defaultMax default value for allowed complexity.\n     */\n    protected AbstractClassCouplingCheck(int defaultMax) {\n        max = defaultMax;\n        excludeClassesRegexps.add(CommonUtil.createPattern(\"^$\"));\n    }\n\n    /**\n     * Returns message key we use for log violations.\n     *\n     * @return message key we use for log violations.\n     */\n    protected abstract String getLogMessageId();\n\n    @Override\n    public final int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    /**\n     * Setter to specify the maximum threshold allowed.\n     *\n     * @param max allowed complexity.\n     */\n    public final void setMax(int max) {\n        this.max = max;\n    }\n\n    /**\n     * Setter to specify user-configured class names to ignore.\n     *\n     * @param excludedClasses the list of classes to ignore.\n     */\n    public final void setExcludedClasses(String... excludedClasses) {\n        this.excludedClasses =\n            Collections.unmodifiableSet(Arrays.stream(excludedClasses).collect(Collectors.toSet()));\n    }\n\n    /**\n     * Setter to specify user-configured regular expressions to ignore classes.\n     *\n     * @param from array representing regular expressions of classes to ignore.\n     */\n    public void setExcludeClassesRegexps(String... from) {\n        excludeClassesRegexps.addAll(Arrays.stream(from.clone())\n                .map(CommonUtil::createPattern)\n                .collect(Collectors.toSet()));\n    }\n\n    /**\n     * Setter to specify user-configured packages to ignore. All excluded packages\n     * should end with a period, so it also appends a dot to a package name.\n     *\n     * @param excludedPackages the list of packages to ignore.\n     * @throws IllegalArgumentException if there are invalid identifiers among the packages.\n     */\n    public final void setExcludedPackages(String... excludedPackages) {\n        final List<String> invalidIdentifiers = Arrays.stream(excludedPackages)\n            .filter(excludedPackageName -> !CommonUtil.isName(excludedPackageName))\n            .collect(Collectors.toList());\n        if (!invalidIdentifiers.isEmpty()) {\n            throw new IllegalArgumentException(\n                \"the following values are not valid identifiers: \"\n                    + invalidIdentifiers.stream().collect(Collectors.joining(\", \", \"[\", \"]\")));\n        }\n\n        this.excludedPackages = Collections.unmodifiableSet(\n            Arrays.stream(excludedPackages).collect(Collectors.toSet()));\n    }\n\n    @Override\n    public final void beginTree(DetailAST ast) {\n        importedClassPackages.clear();\n        classesContexts.clear();\n        classesContexts.push(new ClassContext(\"\", null));\n        packageName = \"\";\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                visitPackageDef(ast);\n                break;\n            case TokenTypes.IMPORT:\n                registerImport(ast);\n                break;\n            case TokenTypes.CLASS_DEF:\n            case TokenTypes.INTERFACE_DEF:\n            case TokenTypes.ANNOTATION_DEF:\n            case TokenTypes.ENUM_DEF:\n            case TokenTypes.RECORD_DEF:\n                visitClassDef(ast);\n                break;\n            case TokenTypes.EXTENDS_CLAUSE:\n            case TokenTypes.IMPLEMENTS_CLAUSE:\n            case TokenTypes.TYPE:\n                visitType(ast);\n                break;\n            case TokenTypes.LITERAL_NEW:\n                visitLiteralNew(ast);\n                break;\n            case TokenTypes.LITERAL_THROWS:\n                visitLiteralThrows(ast);\n                break;\n            case TokenTypes.ANNOTATION:\n                visitAnnotationType(ast);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown type: \" + ast);\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (TokenUtil.isTypeDeclaration(ast.getType())) {\n            leaveClassDef();\n        }\n    }\n\n    /**\n     * Stores package of current class we check.\n     *\n     * @param pkg package definition.\n     */\n    private void visitPackageDef(DetailAST pkg) {\n        final FullIdent ident = FullIdent.createFullIdent(pkg.getLastChild().getPreviousSibling());\n        packageName = ident.getText();\n    }\n\n    /**\n     * Creates new context for a given class.\n     *\n     * @param classDef class definition node.\n     */\n    private void visitClassDef(DetailAST classDef) {\n        final String className = classDef.findFirstToken(TokenTypes.IDENT).getText();\n        createNewClassContext(className, classDef);\n    }\n\n    /** Restores previous context. */\n    private void leaveClassDef() {\n        checkCurrentClassAndRestorePrevious();\n    }\n\n    /**\n     * Registers given import. This allows us to track imported classes.\n     *\n     * @param imp import definition.\n     */\n    private void registerImport(DetailAST imp) {\n        final FullIdent ident = FullIdent.createFullIdent(\n            imp.getLastChild().getPreviousSibling());\n        final String fullName = ident.getText();\n        final int lastDot = fullName.lastIndexOf(DOT);\n        importedClassPackages.put(fullName.substring(lastDot + 1), fullName);\n    }\n\n    /**\n     * Creates new inner class context with given name and location.\n     *\n     * @param className The class name.\n     * @param ast The class ast.\n     */\n    private void createNewClassContext(String className, DetailAST ast) {\n        classesContexts.push(new ClassContext(className, ast));\n    }\n\n    /** Restores previous context. */\n    private void checkCurrentClassAndRestorePrevious() {\n        classesContexts.pop().checkCoupling();\n    }\n\n    /**\n     * Visits type token for the current class context.\n     *\n     * @param ast TYPE token.\n     */\n    private void visitType(DetailAST ast) {\n        classesContexts.peek().visitType(ast);\n    }\n\n    /**\n     * Visits NEW token for the current class context.\n     *\n     * @param ast NEW token.\n     */\n    private void visitLiteralNew(DetailAST ast) {\n        classesContexts.peek().visitLiteralNew(ast);\n    }\n\n    /**\n     * Visits THROWS token for the current class context.\n     *\n     * @param ast THROWS token.\n     */\n    private void visitLiteralThrows(DetailAST ast) {\n        classesContexts.peek().visitLiteralThrows(ast);\n    }\n\n    /**\n     * Visit ANNOTATION literal and get its type to referenced classes of context.\n     *\n     * @param annotationAST Annotation ast.\n     */\n    private void visitAnnotationType(DetailAST annotationAST) {\n        final DetailAST children = annotationAST.getFirstChild();\n        final DetailAST type = children.getNextSibling();\n        classesContexts.peek().addReferencedClassName(type.getText());\n    }\n\n    /**\n     * Encapsulates information about class coupling.\n     *\n     */\n    private class ClassContext {\n\n        /**\n         * Set of referenced classes.\n         * Sorted by name for predictable violation messages in unit tests.\n         */\n        private final Set<String> referencedClassNames = new TreeSet<>();\n        /** Own class name. */\n        private final String className;\n        /* Location of own class. (Used to log violations) */\n        /** AST of class definition. */\n        private final DetailAST classAst;\n\n        /**\n         * Create new context associated with given class.\n         *\n         * @param className name of the given class.\n         * @param ast ast of class definition.\n         */\n        /* package */ ClassContext(String className, DetailAST ast) {\n            this.className = className;\n            classAst = ast;\n        }\n\n        /**\n         * Visits throws clause and collects all exceptions we throw.\n         *\n         * @param literalThrows throws to process.\n         */\n        public void visitLiteralThrows(DetailAST literalThrows) {\n            for (DetailAST childAST = literalThrows.getFirstChild();\n                 childAST != null;\n                 childAST = childAST.getNextSibling()) {\n                if (childAST.getType() != TokenTypes.COMMA) {\n                    addReferencedClassName(childAST);\n                }\n            }\n        }\n\n        /**\n         * Visits type.\n         *\n         * @param ast type to process.\n         */\n        public void visitType(DetailAST ast) {\n            final String fullTypeName = CheckUtil.createFullType(ast).getText();\n            final String trimmed = BRACKET_PATTERN\n                    .matcher(fullTypeName).replaceAll(\"\");\n            addReferencedClassName(trimmed);\n        }\n\n        /**\n         * Visits NEW.\n         *\n         * @param ast NEW to process.\n         */\n        public void visitLiteralNew(DetailAST ast) {\n            addReferencedClassName(ast.getFirstChild());\n        }\n\n        /**\n         * Adds new referenced class.\n         *\n         * @param ast a node which represents referenced class.\n         */\n        private void addReferencedClassName(DetailAST ast) {\n            final String fullIdentName = FullIdent.createFullIdent(ast).getText();\n            final String trimmed = BRACKET_PATTERN\n                    .matcher(fullIdentName).replaceAll(\"\");\n            addReferencedClassName(trimmed);\n        }\n\n        /**\n         * Adds new referenced class.\n         *\n         * @param referencedClassName class name of the referenced class.\n         */\n        private void addReferencedClassName(String referencedClassName) {\n            if (isSignificant(referencedClassName)) {\n                referencedClassNames.add(referencedClassName);\n            }\n        }\n\n        /** Checks if coupling less than allowed or not. */\n        public void checkCoupling() {\n            referencedClassNames.remove(className);\n            referencedClassNames.remove(packageName + DOT + className);\n\n            if (referencedClassNames.size() > max) {\n                log(classAst, getLogMessageId(),\n                        referencedClassNames.size(), max,\n                        referencedClassNames.toString());\n            }\n        }\n\n        /**\n         * Checks if given class shouldn't be ignored and not from java.lang.\n         *\n         * @param candidateClassName class to check.\n         * @return true if we should count this class.\n         */\n        private boolean isSignificant(String candidateClassName) {\n            return !excludedClasses.contains(candidateClassName)\n                && !isFromExcludedPackage(candidateClassName)\n                && !isExcludedClassRegexp(candidateClassName);\n        }\n\n        /**\n         * Checks if given class should be ignored as it belongs to excluded package.\n         *\n         * @param candidateClassName class to check\n         * @return true if we should not count this class.\n         */\n        private boolean isFromExcludedPackage(String candidateClassName) {\n            String classNameWithPackage = candidateClassName;\n            if (!candidateClassName.contains(DOT)) {\n                classNameWithPackage = getClassNameWithPackage(candidateClassName)\n                    .orElse(\"\");\n            }\n            boolean isFromExcludedPackage = false;\n            if (classNameWithPackage.contains(DOT)) {\n                final int lastDotIndex = classNameWithPackage.lastIndexOf(DOT);\n                final String candidatePackageName =\n                    classNameWithPackage.substring(0, lastDotIndex);\n                isFromExcludedPackage = candidatePackageName.startsWith(\"java.lang\")\n                    || excludedPackages.contains(candidatePackageName);\n            }\n            return isFromExcludedPackage;\n        }\n\n        /**\n         * Retrieves class name with packages. Uses previously registered imports to\n         * get the full class name.\n         *\n         * @param examineClassName Class name to be retrieved.\n         * @return Class name with package name, if found, {@link Optional#empty()} otherwise.\n         */\n        private Optional<String> getClassNameWithPackage(String examineClassName) {\n            return Optional.ofNullable(importedClassPackages.get(examineClassName));\n        }\n\n        /**\n         * Checks if given class should be ignored as it belongs to excluded class regexp.\n         *\n         * @param candidateClassName class to check.\n         * @return true if we should not count this class.\n         */\n        private boolean isExcludedClassRegexp(String candidateClassName) {\n            boolean result = false;\n            for (Pattern pattern : excludeClassesRegexps) {\n                if (pattern.matcher(candidateClassName).matches()) {\n                    result = true;\n                    break;\n                }\n            }\n            return result;\n        }\n\n    }\n\n}\n", "filePathAfter": "src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java", "sourceCodeAfterForWhole": "////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.metrics;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * Base class for coupling calculation.\n *\n */\n@FileStatefulCheck\npublic abstract class AbstractClassCouplingCheck extends AbstractCheck {\n\n    /** A package separator - \".\" */\n    private static final String DOT = \".\";\n\n    /** Class names to ignore. */\n    private static final Set<String> DEFAULT_EXCLUDED_CLASSES = Collections.unmodifiableSet(\n        Arrays.stream(new String[] {\n            // reserved type name\n            \"var\",\n            // primitives\n            \"boolean\", \"byte\", \"char\", \"double\", \"float\", \"int\",\n            \"long\", \"short\", \"void\",\n            // wrappers\n            \"Boolean\", \"Byte\", \"Character\", \"Double\", \"Float\",\n            \"Integer\", \"Long\", \"Short\", \"Void\",\n            // java.lang.*\n            \"Object\", \"Class\",\n            \"String\", \"StringBuffer\", \"StringBuilder\",\n            // Exceptions\n            \"ArrayIndexOutOfBoundsException\", \"Exception\",\n            \"RuntimeException\", \"IllegalArgumentException\",\n            \"IllegalStateException\", \"IndexOutOfBoundsException\",\n            \"NullPointerException\", \"Throwable\", \"SecurityException\",\n            \"UnsupportedOperationException\",\n            // java.util.*\n            \"List\", \"ArrayList\", \"Deque\", \"Queue\", \"LinkedList\",\n            \"Set\", \"HashSet\", \"SortedSet\", \"TreeSet\",\n            \"Map\", \"HashMap\", \"SortedMap\", \"TreeMap\",\n            \"Override\", \"Deprecated\", \"SafeVarargs\", \"SuppressWarnings\", \"FunctionalInterface\",\n            \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\",\n            \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\",\n            // java.util.stream.*\n            \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\",\n        }).collect(Collectors.toSet()));\n\n    /** Package names to ignore. */\n    private static final Set<String> DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();\n\n    /** Pattern to match brackets in a full type name. */\n    private static final Pattern BRACKET_PATTERN = Pattern.compile(\"\\\\[[^]]*]\");\n\n    /** Specify user-configured regular expressions to ignore classes. */\n    private final List<Pattern> excludeClassesRegexps = new ArrayList<>();\n\n    /** A map of (imported class name -&gt; class name with package) pairs. */\n    private final Map<String, String> importedClassPackages = new HashMap<>();\n\n    /** Stack of class contexts. */\n    private final Deque<ClassContext> classesContexts = new ArrayDeque<>();\n\n    /** Specify user-configured class names to ignore. */\n    private Set<String> excludedClasses = DEFAULT_EXCLUDED_CLASSES;\n\n    /**\n     * Specify user-configured packages to ignore. All excluded packages\n     * should end with a period, so it also appends a dot to a package name.\n     */\n    private Set<String> excludedPackages = DEFAULT_EXCLUDED_PACKAGES;\n\n    /** Specify the maximum threshold allowed. */\n    private int max;\n\n    /** Current file package. */\n    private String packageName;\n\n    /**\n     * Creates new instance of the check.\n     *\n     * @param defaultMax default value for allowed complexity.\n     */\n    protected AbstractClassCouplingCheck(int defaultMax) {\n        max = defaultMax;\n        excludeClassesRegexps.add(CommonUtil.createPattern(\"^$\"));\n    }\n\n    /**\n     * Returns message key we use for log violations.\n     *\n     * @return message key we use for log violations.\n     */\n    protected abstract String getLogMessageId();\n\n    @Override\n    public final int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    /**\n     * Setter to specify the maximum threshold allowed.\n     *\n     * @param max allowed complexity.\n     */\n    public final void setMax(int max) {\n        this.max = max;\n    }\n\n    /**\n     * Setter to specify user-configured class names to ignore.\n     *\n     * @param excludedClasses the list of classes to ignore.\n     */\n    public final void setExcludedClasses(String... excludedClasses) {\n        this.excludedClasses =\n            Collections.unmodifiableSet(Arrays.stream(excludedClasses).collect(Collectors.toSet()));\n    }\n\n    /**\n     * Setter to specify user-configured regular expressions to ignore classes.\n     *\n     * @param from array representing regular expressions of classes to ignore.\n     */\n    public void setExcludeClassesRegexps(String... from) {\n        excludeClassesRegexps.addAll(Arrays.stream(from.clone())\n                .map(CommonUtil::createPattern)\n                .collect(Collectors.toSet()));\n    }\n\n    /**\n     * Setter to specify user-configured packages to ignore. All excluded packages\n     * should end with a period, so it also appends a dot to a package name.\n     *\n     * @param excludedPackages the list of packages to ignore.\n     * @throws IllegalArgumentException if there are invalid identifiers among the packages.\n     */\n    public final void setExcludedPackages(String... excludedPackages) {\n        final List<String> invalidIdentifiers = Arrays.stream(excludedPackages)\n            .filter(excludedPackageName -> !CommonUtil.isName(excludedPackageName))\n            .collect(Collectors.toList());\n        if (!invalidIdentifiers.isEmpty()) {\n            throw new IllegalArgumentException(\n                \"the following values are not valid identifiers: \"\n                    + invalidIdentifiers.stream().collect(Collectors.joining(\", \", \"[\", \"]\")));\n        }\n\n        this.excludedPackages = Collections.unmodifiableSet(\n            Arrays.stream(excludedPackages).collect(Collectors.toSet()));\n    }\n\n    @Override\n    public final void beginTree(DetailAST ast) {\n        importedClassPackages.clear();\n        classesContexts.clear();\n        classesContexts.push(new ClassContext(\"\", null));\n        packageName = \"\";\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                visitPackageDef(ast);\n                break;\n            case TokenTypes.IMPORT:\n                registerImport(ast);\n                break;\n            case TokenTypes.CLASS_DEF:\n            case TokenTypes.INTERFACE_DEF:\n            case TokenTypes.ANNOTATION_DEF:\n            case TokenTypes.ENUM_DEF:\n            case TokenTypes.RECORD_DEF:\n                visitClassDef(ast);\n                break;\n            case TokenTypes.EXTENDS_CLAUSE:\n            case TokenTypes.IMPLEMENTS_CLAUSE:\n            case TokenTypes.TYPE:\n                visitType(ast);\n                break;\n            case TokenTypes.LITERAL_NEW:\n                visitLiteralNew(ast);\n                break;\n            case TokenTypes.LITERAL_THROWS:\n                visitLiteralThrows(ast);\n                break;\n            case TokenTypes.ANNOTATION:\n                visitAnnotationType(ast);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown type: \" + ast);\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (TokenUtil.isTypeDeclaration(ast.getType())) {\n            leaveClassDef();\n        }\n    }\n\n    /**\n     * Stores package of current class we check.\n     *\n     * @param pkg package definition.\n     */\n    private void visitPackageDef(DetailAST pkg) {\n        final FullIdent ident = FullIdent.createFullIdent(pkg.getLastChild().getPreviousSibling());\n        packageName = ident.getText();\n    }\n\n    /**\n     * Creates new context for a given class.\n     *\n     * @param classDef class definition node.\n     */\n    private void visitClassDef(DetailAST classDef) {\n        final String className = classDef.findFirstToken(TokenTypes.IDENT).getText();\n        createNewClassContext(className, classDef);\n    }\n\n    /** Restores previous context. */\n    private void leaveClassDef() {\n        checkCurrentClassAndRestorePrevious();\n    }\n\n    /**\n     * Registers given import. This allows us to track imported classes.\n     *\n     * @param imp import definition.\n     */\n    private void registerImport(DetailAST imp) {\n        final FullIdent ident = FullIdent.createFullIdent(\n            imp.getLastChild().getPreviousSibling());\n        final String fullName = ident.getText();\n        final int lastDot = fullName.lastIndexOf(DOT);\n        importedClassPackages.put(fullName.substring(lastDot + 1), fullName);\n    }\n\n    /**\n     * Creates new inner class context with given name and location.\n     *\n     * @param className The class name.\n     * @param ast The class ast.\n     */\n    private void createNewClassContext(String className, DetailAST ast) {\n        classesContexts.push(new ClassContext(className, ast));\n    }\n\n    /** Restores previous context. */\n    private void checkCurrentClassAndRestorePrevious() {\n        classesContexts.pop().checkCoupling();\n    }\n\n    /**\n     * Visits type token for the current class context.\n     *\n     * @param ast TYPE token.\n     */\n    private void visitType(DetailAST ast) {\n        classesContexts.peek().visitType(ast);\n    }\n\n    /**\n     * Visits NEW token for the current class context.\n     *\n     * @param ast NEW token.\n     */\n    private void visitLiteralNew(DetailAST ast) {\n        classesContexts.peek().visitLiteralNew(ast);\n    }\n\n    /**\n     * Visits THROWS token for the current class context.\n     *\n     * @param ast THROWS token.\n     */\n    private void visitLiteralThrows(DetailAST ast) {\n        classesContexts.peek().visitLiteralThrows(ast);\n    }\n\n    /**\n     * Visit ANNOTATION literal and get its type to referenced classes of context.\n     *\n     * @param annotationAST Annotation ast.\n     */\n    private void visitAnnotationType(DetailAST annotationAST) {\n        final DetailAST children = annotationAST.getFirstChild();\n        final DetailAST type = children.getNextSibling();\n        classesContexts.peek().addReferencedClassName(type.getText());\n    }\n\n    /**\n     * Encapsulates information about class coupling.\n     *\n     */\n    private class ClassContext {\n\n        /**\n         * Set of referenced classes.\n         * Sorted by name for predictable violation messages in unit tests.\n         */\n        private final Set<String> referencedClassNames = new TreeSet<>();\n        /** Own class name. */\n        private final String className;\n        /* Location of own class. (Used to log violations) */\n        /** AST of class definition. */\n        private final DetailAST classAst;\n\n        /**\n         * Create new context associated with given class.\n         *\n         * @param className name of the given class.\n         * @param ast ast of class definition.\n         */\n        /* package */ ClassContext(String className, DetailAST ast) {\n            this.className = className;\n            classAst = ast;\n        }\n\n        /**\n         * Visits throws clause and collects all exceptions we throw.\n         *\n         * @param literalThrows throws to process.\n         */\n        public void visitLiteralThrows(DetailAST literalThrows) {\n            for (DetailAST childAST = literalThrows.getFirstChild();\n                 childAST != null;\n                 childAST = childAST.getNextSibling()) {\n                if (childAST.getType() != TokenTypes.COMMA) {\n                    addReferencedClassName(childAST);\n                }\n            }\n        }\n\n        /**\n         * Visits type.\n         *\n         * @param ast type to process.\n         */\n        public void visitType(DetailAST ast) {\n            DetailAST child = ast.getFirstChild();\n            while (child != null) {\n                if (TokenUtil.isOfType(child, TokenTypes.IDENT, TokenTypes.DOT)) {\n                    final String fullTypeName = FullIdent.createFullIdent(child).getText();\n                    final String trimmed = BRACKET_PATTERN\n                            .matcher(fullTypeName).replaceAll(\"\");\n                    addReferencedClassName(trimmed);\n                }\n                child = child.getNextSibling();\n            }\n        }\n\n        /**\n         * Visits NEW.\n         *\n         * @param ast NEW to process.\n         */\n        public void visitLiteralNew(DetailAST ast) {\n            addReferencedClassName(ast.getFirstChild());\n        }\n\n        /**\n         * Adds new referenced class.\n         *\n         * @param ast a node which represents referenced class.\n         */\n        private void addReferencedClassName(DetailAST ast) {\n            final String fullIdentName = FullIdent.createFullIdent(ast).getText();\n            final String trimmed = BRACKET_PATTERN\n                    .matcher(fullIdentName).replaceAll(\"\");\n            addReferencedClassName(trimmed);\n        }\n\n        /**\n         * Adds new referenced class.\n         *\n         * @param referencedClassName class name of the referenced class.\n         */\n        private void addReferencedClassName(String referencedClassName) {\n            if (isSignificant(referencedClassName)) {\n                referencedClassNames.add(referencedClassName);\n            }\n        }\n\n        /** Checks if coupling less than allowed or not. */\n        public void checkCoupling() {\n            referencedClassNames.remove(className);\n            referencedClassNames.remove(packageName + DOT + className);\n\n            if (referencedClassNames.size() > max) {\n                log(classAst, getLogMessageId(),\n                        referencedClassNames.size(), max,\n                        referencedClassNames.toString());\n            }\n        }\n\n        /**\n         * Checks if given class shouldn't be ignored and not from java.lang.\n         *\n         * @param candidateClassName class to check.\n         * @return true if we should count this class.\n         */\n        private boolean isSignificant(String candidateClassName) {\n            return !excludedClasses.contains(candidateClassName)\n                && !isFromExcludedPackage(candidateClassName)\n                && !isExcludedClassRegexp(candidateClassName);\n        }\n\n        /**\n         * Checks if given class should be ignored as it belongs to excluded package.\n         *\n         * @param candidateClassName class to check\n         * @return true if we should not count this class.\n         */\n        private boolean isFromExcludedPackage(String candidateClassName) {\n            String classNameWithPackage = candidateClassName;\n            if (!candidateClassName.contains(DOT)) {\n                classNameWithPackage = getClassNameWithPackage(candidateClassName)\n                    .orElse(\"\");\n            }\n            boolean isFromExcludedPackage = false;\n            if (classNameWithPackage.contains(DOT)) {\n                final int lastDotIndex = classNameWithPackage.lastIndexOf(DOT);\n                final String candidatePackageName =\n                    classNameWithPackage.substring(0, lastDotIndex);\n                isFromExcludedPackage = candidatePackageName.startsWith(\"java.lang\")\n                    || excludedPackages.contains(candidatePackageName);\n            }\n            return isFromExcludedPackage;\n        }\n\n        /**\n         * Retrieves class name with packages. Uses previously registered imports to\n         * get the full class name.\n         *\n         * @param examineClassName Class name to be retrieved.\n         * @return Class name with package name, if found, {@link Optional#empty()} otherwise.\n         */\n        private Optional<String> getClassNameWithPackage(String examineClassName) {\n            return Optional.ofNullable(importedClassPackages.get(examineClassName));\n        }\n\n        /**\n         * Checks if given class should be ignored as it belongs to excluded class regexp.\n         *\n         * @param candidateClassName class to check.\n         * @return true if we should not count this class.\n         */\n        private boolean isExcludedClassRegexp(String candidateClassName) {\n            boolean result = false;\n            for (Pattern pattern : excludeClassesRegexps) {\n                if (pattern.matcher(candidateClassName).matches()) {\n                    result = true;\n                    break;\n                }\n            }\n            return result;\n        }\n\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n         * Visits type.\n         *\n         * @param ast type to process.\n         */\n        public void visitType(DetailAST ast) {\n            DetailAST child = ast.getFirstChild();\n            while (child != null) {\n                if (TokenUtil.isOfType(child, TokenTypes.IDENT, TokenTypes.DOT)) {\n                    final String fullTypeName = FullIdent.createFullIdent(child).getText();\n                    final String trimmed = BRACKET_PATTERN\n                            .matcher(fullTypeName).replaceAll(\"\");\n                    addReferencedClassName(trimmed);\n                }\n                child = child.getNextSibling();\n            }\n        }", "diffSourceCode": "-   79:             \"Override\", \"Deprecated\", \"SafeVarargs\", \"SuppressWarnings\", \"FunctionalInterface\",\n-   80:             \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\",\n-   81:             \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\",\n-   82:             // java.util.stream.*\n-   83:             \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\",\n-   84:         }).collect(Collectors.toSet()));\n-   85: \n-   86:     /** Package names to ignore. */\n-   87:     private static final Set<String> DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();\n-  372: \n-  373:         /**\n-  374:          * Visits type.\n-  375:          *\n-  376:          * @param ast type to process.\n-  377:          */\n-  378:         public void visitType(DetailAST ast) {\n-  379:             final String fullTypeName = CheckUtil.createFullType(ast).getText();\n-  380:             final String trimmed = BRACKET_PATTERN\n-  381:                     .matcher(fullTypeName).replaceAll(\"\");\n-  382:             addReferencedClassName(trimmed);\n-  383:         }\n-  384: \n-  385:         /**\n-  386:          * Visits NEW.\n-  387:          *\n-  388:          * @param ast NEW to process.\n+   79:             \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\",\n+   80:             \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\",\n+   81:             // java.util.stream.*\n+   82:             \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\",\n+   83:         }).collect(Collectors.toSet()));\n+   84: \n+   85:     /** Package names to ignore. */\n+   86:     private static final Set<String> DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();\n+   87: \n+  372:         /**\n+  373:          * Visits type.\n+  374:          *\n+  375:          * @param ast type to process.\n+  376:          */\n+  377:         public void visitType(DetailAST ast) {\n+  378:             DetailAST child = ast.getFirstChild();\n+  379:             while (child != null) {\n+  380:                 if (TokenUtil.isOfType(child, TokenTypes.IDENT, TokenTypes.DOT)) {\n+  381:                     final String fullTypeName = FullIdent.createFullIdent(child).getText();\n+  382:                     final String trimmed = BRACKET_PATTERN\n+  383:                             .matcher(fullTypeName).replaceAll(\"\");\n+  384:                     addReferencedClassName(trimmed);\n+  385:                 }\n+  386:                 child = child.getNextSibling();\n+  387:             }\n+  388:         }\n", "uniqueId": "e2c6e148a92e01b3c6037b33440ee7006f742793_373_383__372_388_79_87", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "$target_file_path$:\nsrc/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java:\n\n```java\n// AbstractClassCouplingCheck.java\n\npackage com.puppycrawl.tools.checkstyle.checks.metrics;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * Base class for coupling calculation.\n *\n */\n@FileStatefulCheck\npublic abstract class AbstractClassCouplingCheck extends AbstractCheck {\n\n    /** A package separator - \".\" */\n    private static final String DOT = \".\";\n\n    /** Class names to ignore. */\n    private static final Set<String> DEFAULT_EXCLUDED_CLASSES = Collections.unmodifiableSet(\n        Arrays.stream(new String[] {\n            // reserved type name\n            \"var\",\n            // primitives\n            \"boolean\", \"byte\", \"char\", \"double\", \"float\", \"int\",\n            \"long\", \"short\", \"void\",\n            // wrappers\n            \"Boolean\", \"Byte\", \"Character\", \"Double\", \"Float\",\n            \"Integer\", \"Long\", \"Short\", \"Void\",\n            // java.lang.*\n            \"Object\", \"Class\",\n            \"String\", \"StringBuffer\", \"StringBuilder\",\n            // Exceptions\n            \"ArrayIndexOutOfBoundsException\", \"Exception\",\n            \"RuntimeException\", \"IllegalArgumentException\",\n            \"IllegalStateException\", \"IndexOutOfBoundsException\",\n            \"NullPointerException\", \"Throwable\", \"SecurityException\",\n            \"UnsupportedOperationException\",\n            // java.util.*\n            \"List\", \"ArrayList\", \"Deque\", \"Queue\", \"LinkedList\",\n            \"Set\", \"HashSet\", \"SortedSet\", \"TreeSet\",\n            \"Map\", \"HashMap\", \"SortedMap\", \"TreeMap\",\n            \"Override\", \"Deprecated\", \"SafeVarargs\", \"SuppressWarnings\", \"FunctionalInterface\",\n            \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\",\n            \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\",\n            // java.util.stream.*\n            \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\",\n        }).collect(Collectors.toSet()));\n\n    /** Package names to ignore. */\n    private static final Set<String> DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();\n\n    /** Pattern to match brackets in a full type name. */\n    private static final Pattern BRACKET_PATTERN = Pattern.compile(\"\\\\[[^]]*]\");\n\n    /** Specify user-configured regular expressions to ignore classes. */\n    private final List<Pattern> excludeClassesRegexps = new ArrayList<>();\n\n    /** A map of (imported class name -&gt; class name with package) pairs. */\n    private final Map<String, String> importedClassPackages = new HashMap<>();\n\n    /** Stack of class contexts. */\n    private final Deque<ClassContext> classesContexts = new ArrayDeque<>();\n\n    /** Specify user-configured class names to ignore. */\n    private Set<String> excludedClasses = DEFAULT_EXCLUDED_CLASSES;\n\n    /**\n     * Specify user-configured packages to ignore. All excluded packages\n     * should end with a period, so it also appends a dot to a package name.\n     */\n    private Set<String> excludedPackages = DEFAULT_EXCLUDED_PACKAGES;\n\n    /** Specify the maximum threshold allowed. */\n    private int max;\n\n    /** Current file package. */\n    private String packageName;\n\n    /**\n     * Creates new instance of the check.\n     *\n     * @param defaultMax default value for allowed complexity.\n     */\n    protected AbstractClassCouplingCheck(int defaultMax) {\n        max = defaultMax;\n        excludeClassesRegexps.add(CommonUtil.createPattern(\"^$\"));\n    }\n\n    /**\n     * Returns message key we use for log violations.\n     *\n     * @return message key we use for log violations.\n     */\n    protected abstract String getLogMessageId();\n\n    @Override\n    public final int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    /**\n     * Setter to specify the maximum threshold allowed.\n     *\n     * @param max allowed complexity.\n     */\n    public final void setMax(int max) {\n        this.max = max;\n    }\n\n    /**\n     * Setter to specify user-configured class names to ignore.\n     *\n     * @param excludedClasses the list of classes to ignore.\n     */\n    public final void setExcludedClasses(String... excludedClasses) {\n        this.excludedClasses =\n            Collections.unmodifiableSet(Arrays.stream(excludedClasses).collect(Collectors.toSet()));\n    }\n\n    /**\n     * Setter to specify user-configured regular expressions to ignore classes.\n     *\n     * @param from array representing regular expressions of classes to ignore.\n     */\n    public void setExcludeClassesRegexps(String... from) {\n        excludeClassesRegexps.addAll(Arrays.stream(from.clone())\n                .map(CommonUtil::createPattern)\n                .collect(Collectors.toSet()));\n    }\n\n    /**\n     * Setter to specify user-configured packages to ignore. All excluded packages\n     * should end with a period, so it also appends a dot to a package name.\n     *\n     * @param excludedPackages the list of packages to ignore.\n     * @throws IllegalArgumentException if there are invalid identifiers among the packages.\n     */\n    public final void setExcludedPackages(String... excludedPackages) {\n        final List<String> invalidIdentifiers = Arrays.stream(excludedPackages)\n            .filter(excludedPackageName -> !CommonUtil.isName(excludedPackageName))\n            .collect(Collectors.toList());\n        if (!invalidIdentifiers.isEmpty()) {\n            throw new IllegalArgumentException(\n                \"the following values are not valid identifiers: \"\n                    + invalidIdentifiers.stream().collect(Collectors.joining(\", \", \"[\", \"]\")));\n        }\n\n        this.excludedPackages = Collections.unmodifiableSet(\n            Arrays.stream(excludedPackages).collect(Collectors.toSet()));\n    }\n\n    @Override\n    public final void beginTree(DetailAST ast) {\n        importedClassPackages.clear();\n        classesContexts.clear();\n        classesContexts.push(new ClassContext(\"\", null));\n        packageName = \"\";\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                visitPackageDef(ast);\n                break;\n            case TokenTypes.IMPORT:\n                registerImport(ast);\n                break;\n            case TokenTypes.CLASS_DEF:\n            case TokenTypes.INTERFACE_DEF:\n            case TokenTypes.ANNOTATION_DEF:\n            case TokenTypes.ENUM_DEF:\n            case TokenTypes.RECORD_DEF:\n                visitClassDef(ast);\n                break;\n            case TokenTypes.EXTENDS_CLAUSE:\n            case TokenTypes.IMPLEMENTS_CLAUSE:\n            case TokenTypes.TYPE:\n                visitType(ast);\n                break;\n            case TokenTypes.LITERAL_NEW:\n                visitLiteralNew(ast);\n                break;\n            case TokenTypes.LITERAL_THROWS:\n                visitLiteralThrows(ast);\n                break;\n            case TokenTypes.ANNOTATION:\n                visitAnnotationType(ast);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown type: \" + ast);\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (TokenUtil.isTypeDeclaration(ast.getType())) {\n            leaveClassDef();\n        }\n    }\n\n    /**\n     * Stores package of current class we check.\n     *\n     * @param pkg package definition.\n     */\n    private void visitPackageDef(DetailAST pkg) {\n        final FullIdent ident = FullIdent.createFullIdent(pkg.getLastChild().getPreviousSibling());\n        packageName = ident.getText();\n    }\n\n    /**\n     * Creates new context for a given class.\n     *\n     * @param classDef class definition node.\n     */\n    private void visitClassDef(DetailAST classDef) {\n        final String className = classDef.findFirstToken(TokenTypes.IDENT).getText();\n        createNewClassContext(className, classDef);\n    }\n\n    /** Restores previous context. */\n    private void leaveClassDef() {\n        checkCurrentClassAndRestorePrevious();\n    }\n\n    /**\n     * Registers given import. This allows us to track imported classes.\n     *\n     * @param imp import definition.\n     */\n    private void registerImport(DetailAST imp) {\n        final FullIdent ident = FullIdent.createFullIdent(\n            imp.getLastChild().getPreviousSibling());\n        final String fullName = ident.getText();\n        final int lastDot = fullName.lastIndexOf(DOT);\n        importedClassPackages.put(fullName.substring(lastDot + 1), fullName);\n    }\n\n    /**\n     * Creates new inner class context with given name and location.\n     *\n     * @param className The class name.\n     * @param ast The class ast.\n     */\n    private void createNewClassContext(String className, DetailAST ast) {\n        classesContexts.push(new ClassContext(className, ast));\n    }\n\n    /** Restores previous context. */\n    private void checkCurrentClassAndRestorePrevious() {\n        classesContexts.pop().checkCoupling();\n    }\n\n    /**\n     * Visits type token for the current class context.\n     *\n     * @param ast TYPE token.\n     */\n    private void visitType(DetailAST ast) {\n        classesContexts.peek().visitType(ast);\n    }\n\n    /**\n     * Visits NEW token for the current class context.\n     *\n     * @param ast NEW token.\n     */\n    private void visitLiteralNew(DetailAST ast) {\n        classesContexts.peek().visitLiteralNew(ast);\n    }\n\n    /**\n     * Visits THROWS token for the current class context.\n     *\n     * @param ast THROWS token.\n     */\n    private void visitLiteralThrows(DetailAST ast) {\n        classesContexts.peek().visitLiteralThrows(ast);\n    }\n\n    /**\n     * Visit ANNOTATION literal and get its type to referenced classes of context.\n     *\n     * @param annotationAST Annotation ast.\n     */\n    private void visitAnnotationType(DetailAST annotationAST) {\n        final DetailAST children = annotationAST.getFirstChild();\n        final DetailAST type = children.getNextSibling();\n        classesContexts.peek().addReferencedClassName(type.getText());\n    }\n\n    /**\n     * Encapsulates information about class coupling.\n     *\n     */\n    private class ClassContext {\n\n        /**\n         * Set of referenced classes.\n         * Sorted by name for predictable violation messages in unit tests.\n         */\n        private final Set<String> referencedClassNames = new TreeSet<>();\n        /** Own class name. */\n        private final String className;\n        /* Location of own class. (Used to log violations) */\n        /** AST of class definition. */\n        private final DetailAST classAst;\n\n        /**\n         * Create new context associated with given class.\n         *\n         * @param className name of the given class.\n         * @param ast ast of class definition.\n         */\n        /* package */ ClassContext(String className, DetailAST ast) {\n            this.className = className;\n            classAst = ast;\n        }\n\n        /**\n         * Visits throws clause and collects all exceptions we throw.\n         *\n         * @param literalThrows throws to process.\n         */\n        public void visitLiteralThrows(DetailAST literalThrows) {\n            for (DetailAST childAST = literalThrows.getFirstChild();\n                 childAST != null;\n                 childAST = childAST.getNextSibling()) {\n                if (childAST.getType() != TokenTypes.COMMA) {\n                    addReferencedClassName(childAST);\n                }\n            }\n        }\n\n        /**\n         * Visits type.\n         *\n         * @param ast type to process.\n         */\n        public void visitType(DetailAST ast) {\n            final String fullTypeName = CheckUtil.createFullType(ast).getText();\n            final String trimmed = BRACKET_PATTERN\n                    .matcher(fullTypeName).replaceAll(\"\");\n            addReferencedClassName(trimmed);\n        }\n\n        /**\n         * Visits NEW.\n         *\n         * @param ast NEW to process.\n         */\n        public void visitLiteralNew(DetailAST ast) {\n            addReferencedClassName(ast.getFirstChild());\n        }\n\n        /**\n         * Adds new referenced class.\n         *\n         * @param ast a node which represents referenced class.\n         */\n        private void addReferencedClassName(DetailAST ast) {\n            final String fullIdentName = FullIdent.createFullIdent(ast).getText();\n            final String trimmed = BRACKET_PATTERN\n                    .matcher(fullIdentName).replaceAll(\"\");\n            addReferencedClassName(trimmed);\n        }\n\n        /**\n         * Adds new referenced class.\n         *\n         * @param referencedClassName class name of the referenced class.\n         */\n        private void addReferencedClassName(String referencedClassName) {\n            if (isSignificant(referencedClassName)) {\n                referencedClassNames.add(referencedClassName);\n            }\n        }\n\n        /** Checks if coupling less than allowed or not. */\n        public void checkCoupling() {\n            referencedClassNames.remove(className);\n            referencedClassNames.remove(packageName + DOT + className);\n\n            if (referencedClassNames.size() > max) {\n                log(classAst, getLogMessageId(),\n                        referencedClassNames.size(), max,\n                        referencedClassNames.toString());\n            }\n        }\n\n        /**\n         * Checks if given class shouldn't be ignored and not from java.lang.\n         *\n         * @param candidateClassName class to check.\n         * @return true if we should count this class.\n         */\n        private boolean isSignificant(String candidateClassName) {\n            return !excludedClasses.contains(candidateClassName)\n                && !isFromExcludedPackage(candidateClassName)\n                && !isExcludedClassRegexp(candidateClassName);\n        }\n\n        /**\n         * Checks if given class should be ignored as it belongs to excluded package.\n         *\n         * @param candidateClassName class to check\n         * @return true if we should not count this class.\n         */\n        private boolean isFromExcludedPackage(String candidateClassName) {\n            String classNameWithPackage = candidateClassName;\n            if (!candidateClassName.contains(DOT)) {\n                classNameWithPackage = getClassNameWithPackage(candidateClassName)\n                    .orElse(\"\");\n            }\n            boolean isFromExcludedPackage = false;\n            if (classNameWithPackage.contains(DOT)) {\n                final int lastDotIndex = classNameWithPackage.lastIndexOf(DOT);\n                final String candidatePackageName =\n                    classNameWithPackage.substring(0, lastDotIndex);\n                isFromExcludedPackage = candidatePackageName.startsWith(\"java.lang\")\n                    || excludedPackages.contains(candidatePackageName);\n            }\n            return isFromExcludedPackage;\n        }\n\n        /**\n         * Retrieves class name with packages. Uses previously registered imports to\n         * get the full class name.\n         *\n         * @param examineClassName Class name to be retrieved.\n         * @return Class name with package name, if found, {@link Optional#empty()} otherwise.\n         */\n        private Optional<String> getClassNameWithPackage(String examineClassName) {\n            return Optional.ofNullable(importedClassPackages.get(examineClassName));\n        }\n\n        /**\n         * Checks if given class should be ignored as it belongs to excluded class regexp.\n         *\n         * @param candidateClassName class to check.\n         * @return true if we should not count this class.\n         */\n        private boolean isExcludedClassRegexp(String candidateClassName) {\n            boolean result = false;\n            for (Pattern pattern : excludeClassesRegexps) {\n                if (pattern.matcher(candidateClassName).matches()) {\n                    result = true;\n                    break;\n                }\n            }\n            return result;\n        }\n\n    }\n\n}\n```", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to Refactor:\n\"Override\", \"Deprecated\", \"SafeVarargs\", \"SuppressWarnings\", \"FunctionalInterface\",\n            \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\",\n            \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\",\n            // java.util.stream.*\n            \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\",\n        }).collect(Collectors.toSet()));\n\n    /** Package names to ignore. */\n    private static final Set<String> DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();\n\nClass content:\n////////////////////////////////////////////////////////////////////////////////\n// checkstyle: Checks Java source code for adherence to a set of rules.\n// Copyright (C) 2001-2021 the original author or authors.\n//\n// This library is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 2.1 of the License, or (at your option) any later version.\n//\n// This library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n////////////////////////////////////////////////////////////////////////////////\n\npackage com.puppycrawl.tools.checkstyle.checks.metrics;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\nimport com.puppycrawl.tools.checkstyle.FileStatefulCheck;\nimport com.puppycrawl.tools.checkstyle.api.AbstractCheck;\nimport com.puppycrawl.tools.checkstyle.api.DetailAST;\nimport com.puppycrawl.tools.checkstyle.api.FullIdent;\nimport com.puppycrawl.tools.checkstyle.api.TokenTypes;\nimport com.puppycrawl.tools.checkstyle.utils.CheckUtil;\nimport com.puppycrawl.tools.checkstyle.utils.CommonUtil;\nimport com.puppycrawl.tools.checkstyle.utils.TokenUtil;\n\n/**\n * Base class for coupling calculation.\n *\n */\n@FileStatefulCheck\npublic abstract class AbstractClassCouplingCheck extends AbstractCheck {\n\n    /** A package separator - \".\" */\n    private static final String DOT = \".\";\n\n    /** Class names to ignore. */\n    private static final Set<String> DEFAULT_EXCLUDED_CLASSES = Collections.unmodifiableSet(\n        Arrays.stream(new String[] {\n            // reserved type name\n            \"var\",\n            // primitives\n            \"boolean\", \"byte\", \"char\", \"double\", \"float\", \"int\",\n            \"long\", \"short\", \"void\",\n            // wrappers\n            \"Boolean\", \"Byte\", \"Character\", \"Double\", \"Float\",\n            \"Integer\", \"Long\", \"Short\", \"Void\",\n            // java.lang.*\n            \"Object\", \"Class\",\n            \"String\", \"StringBuffer\", \"StringBuilder\",\n            // Exceptions\n            \"ArrayIndexOutOfBoundsException\", \"Exception\",\n            \"RuntimeException\", \"IllegalArgumentException\",\n            \"IllegalStateException\", \"IndexOutOfBoundsException\",\n            \"NullPointerException\", \"Throwable\", \"SecurityException\",\n            \"UnsupportedOperationException\",\n            // java.util.*\n            \"List\", \"ArrayList\", \"Deque\", \"Queue\", \"LinkedList\",\n            \"Set\", \"HashSet\", \"SortedSet\", \"TreeSet\",\n            \"Map\", \"HashMap\", \"SortedMap\", \"TreeMap\",\n            \"Override\", \"Deprecated\", \"SafeVarargs\", \"SuppressWarnings\", \"FunctionalInterface\",\n            \"Collection\", \"EnumSet\", \"LinkedHashMap\", \"LinkedHashSet\", \"Optional\",\n            \"OptionalDouble\", \"OptionalInt\", \"OptionalLong\",\n            // java.util.stream.*\n            \"DoubleStream\", \"IntStream\", \"LongStream\", \"Stream\",\n        }).collect(Collectors.toSet()));\n\n    /** Package names to ignore. */\n    private static final Set<String> DEFAULT_EXCLUDED_PACKAGES = Collections.emptySet();\n\n    /** Pattern to match brackets in a full type name. */\n    private static final Pattern BRACKET_PATTERN = Pattern.compile(\"\\\\[[^]]*]\");\n\n    /** Specify user-configured regular expressions to ignore classes. */\n    private final List<Pattern> excludeClassesRegexps = new ArrayList<>();\n\n    /** A map of (imported class name -&gt; class name with package) pairs. */\n    private final Map<String, String> importedClassPackages = new HashMap<>();\n\n    /** Stack of class contexts. */\n    private final Deque<ClassContext> classesContexts = new ArrayDeque<>();\n\n    /** Specify user-configured class names to ignore. */\n    private Set<String> excludedClasses = DEFAULT_EXCLUDED_CLASSES;\n\n    /**\n     * Specify user-configured packages to ignore. All excluded packages\n     * should end with a period, so it also appends a dot to a package name.\n     */\n    private Set<String> excludedPackages = DEFAULT_EXCLUDED_PACKAGES;\n\n    /** Specify the maximum threshold allowed. */\n    private int max;\n\n    /** Current file package. */\n    private String packageName;\n\n    /**\n     * Creates new instance of the check.\n     *\n     * @param defaultMax default value for allowed complexity.\n     */\n    protected AbstractClassCouplingCheck(int defaultMax) {\n        max = defaultMax;\n        excludeClassesRegexps.add(CommonUtil.createPattern(\"^$\"));\n    }\n\n    /**\n     * Returns message key we use for log violations.\n     *\n     * @return message key we use for log violations.\n     */\n    protected abstract String getLogMessageId();\n\n    @Override\n    public final int[] getDefaultTokens() {\n        return getRequiredTokens();\n    }\n\n    /**\n     * Setter to specify the maximum threshold allowed.\n     *\n     * @param max allowed complexity.\n     */\n    public final void setMax(int max) {\n        this.max = max;\n    }\n\n    /**\n     * Setter to specify user-configured class names to ignore.\n     *\n     * @param excludedClasses the list of classes to ignore.\n     */\n    public final void setExcludedClasses(String... excludedClasses) {\n        this.excludedClasses =\n            Collections.unmodifiableSet(Arrays.stream(excludedClasses).collect(Collectors.toSet()));\n    }\n\n    /**\n     * Setter to specify user-configured regular expressions to ignore classes.\n     *\n     * @param from array representing regular expressions of classes to ignore.\n     */\n    public void setExcludeClassesRegexps(String... from) {\n        excludeClassesRegexps.addAll(Arrays.stream(from.clone())\n                .map(CommonUtil::createPattern)\n                .collect(Collectors.toSet()));\n    }\n\n    /**\n     * Setter to specify user-configured packages to ignore. All excluded packages\n     * should end with a period, so it also appends a dot to a package name.\n     *\n     * @param excludedPackages the list of packages to ignore.\n     * @throws IllegalArgumentException if there are invalid identifiers among the packages.\n     */\n    public final void setExcludedPackages(String... excludedPackages) {\n        final List<String> invalidIdentifiers = Arrays.stream(excludedPackages)\n            .filter(excludedPackageName -> !CommonUtil.isName(excludedPackageName))\n            .collect(Collectors.toList());\n        if (!invalidIdentifiers.isEmpty()) {\n            throw new IllegalArgumentException(\n                \"the following values are not valid identifiers: \"\n                    + invalidIdentifiers.stream().collect(Collectors.joining(\", \", \"[\", \"]\")));\n        }\n\n        this.excludedPackages = Collections.unmodifiableSet(\n            Arrays.stream(excludedPackages).collect(Collectors.toSet()));\n    }\n\n    @Override\n    public final void beginTree(DetailAST ast) {\n        importedClassPackages.clear();\n        classesContexts.clear();\n        classesContexts.push(new ClassContext(\"\", null));\n        packageName = \"\";\n    }\n\n    @Override\n    public void visitToken(DetailAST ast) {\n        switch (ast.getType()) {\n            case TokenTypes.PACKAGE_DEF:\n                visitPackageDef(ast);\n                break;\n            case TokenTypes.IMPORT:\n                registerImport(ast);\n                break;\n            case TokenTypes.CLASS_DEF:\n            case TokenTypes.INTERFACE_DEF:\n            case TokenTypes.ANNOTATION_DEF:\n            case TokenTypes.ENUM_DEF:\n            case TokenTypes.RECORD_DEF:\n                visitClassDef(ast);\n                break;\n            case TokenTypes.EXTENDS_CLAUSE:\n            case TokenTypes.IMPLEMENTS_CLAUSE:\n            case TokenTypes.TYPE:\n                visitType(ast);\n                break;\n            case TokenTypes.LITERAL_NEW:\n                visitLiteralNew(ast);\n                break;\n            case TokenTypes.LITERAL_THROWS:\n                visitLiteralThrows(ast);\n                break;\n            case TokenTypes.ANNOTATION:\n                visitAnnotationType(ast);\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unknown type: \" + ast);\n        }\n    }\n\n    @Override\n    public void leaveToken(DetailAST ast) {\n        if (TokenUtil.isTypeDeclaration(ast.getType())) {\n            leaveClassDef();\n        }\n    }\n\n    /**\n     * Stores package of current class we check.\n     *\n     * @param pkg package definition.\n     */\n    private void visitPackageDef(DetailAST pkg) {\n        final FullIdent ident = FullIdent.createFullIdent(pkg.getLastChild().getPreviousSibling());\n        packageName = ident.getText();\n    }\n\n    /**\n     * Creates new context for a given class.\n     *\n     * @param classDef class definition node.\n     */\n    private void visitClassDef(DetailAST classDef) {\n        final String className = classDef.findFirstToken(TokenTypes.IDENT).getText();\n        createNewClassContext(className, classDef);\n    }\n\n    /** Restores previous context. */\n    private void leaveClassDef() {\n        checkCurrentClassAndRestorePrevious();\n    }\n\n    /**\n     * Registers given import. This allows us to track imported classes.\n     *\n     * @param imp import definition.\n     */\n    private void registerImport(DetailAST imp) {\n        final FullIdent ident = FullIdent.createFullIdent(\n            imp.getLastChild().getPreviousSibling());\n        final String fullName = ident.getText();\n        final int lastDot = fullName.lastIndexOf(DOT);\n        importedClassPackages.put(fullName.substring(lastDot + 1), fullName);\n    }\n\n    /**\n     * Creates new inner class context with given name and location.\n     *\n     * @param className The class name.\n     * @param ast The class ast.\n     */\n    private void createNewClassContext(String className, DetailAST ast) {\n        classesContexts.push(new ClassContext(className, ast));\n    }\n\n    /** Restores previous context. */\n    private void checkCurrentClassAndRestorePrevious() {\n        classesContexts.pop().checkCoupling();\n    }\n\n    /**\n     * Visits type token for the current class context.\n     *\n     * @param ast TYPE token.\n     */\n    private void visitType(DetailAST ast) {\n        classesContexts.peek().visitType(ast);\n    }\n\n    /**\n     * Visits NEW token for the current class context.\n     *\n     * @param ast NEW token.\n     */\n    private void visitLiteralNew(DetailAST ast) {\n        classesContexts.peek().visitLiteralNew(ast);\n    }\n\n    /**\n     * Visits THROWS token for the current class context.\n     *\n     * @param ast THROWS token.\n     */\n    private void visitLiteralThrows(DetailAST ast) {\n        classesContexts.peek().visitLiteralThrows(ast);\n    }\n\n    /**\n     * Visit ANNOTATION literal and get its type to referenced classes of context.\n     *\n     * @param annotationAST Annotation ast.\n     */\n    private void visitAnnotationType(DetailAST annotationAST) {\n        final DetailAST children = annotationAST.getFirstChild();\n        final DetailAST type = children.getNextSibling();\n        classesContexts.peek().addReferencedClassName(type.getText());\n    }\n\n    /**\n     * Encapsulates information about class coupling.\n     *\n     */\n    private class ClassContext {\n\n        /**\n         * Set of referenced classes.\n         * Sorted by name for predictable violation messages in unit tests.\n         */\n        private final Set<String> referencedClassNames = new TreeSet<>();\n        /** Own class name. */\n        private final String className;\n        /* Location of own class. (Used to log violations) */\n        /** AST of class definition. */\n        private final DetailAST classAst;\n\n        /**\n         * Create new context associated with given class.\n         *\n         * @param className name of the given class.\n         * @param ast ast of class definition.\n         */\n        /* package */ ClassContext(String className, DetailAST ast) {\n            this.className = className;\n            classAst = ast;\n        }\n\n        /**\n         * Visits throws clause and collects all exceptions we throw.\n         *\n         * @param literalThrows throws to process.\n         */\n        public void visitLiteralThrows(DetailAST literalThrows) {\n            for (DetailAST childAST = literalThrows.getFirstChild();\n                 childAST != null;\n                 childAST = childAST.getNextSibling()) {\n                if (childAST.getType() != TokenTypes.COMMA) {\n                    addReferencedClassName(childAST);\n                }\n            }\n        }\n\n        /**\n         * Visits type.\n         *\n         * @param ast type to process.\n         */\n        public void visitType(DetailAST ast) {\n            final String fullTypeName = CheckUtil.createFullType(ast).getText();\n            final String trimmed = BRACKET_PATTERN\n                    .matcher(fullTypeName).replaceAll(\"\");\n            addReferencedClassName(trimmed);\n        }\n\n        /**\n         * Visits NEW.\n         *\n         * @param ast NEW to process.\n         */\n        public void visitLiteralNew(DetailAST ast) {\n            addReferencedClassName(ast.getFirstChild());\n        }\n\n        /**\n         * Adds new referenced class.\n         *\n         * @param ast a node which represents referenced class.\n         */\n        private void addReferencedClassName(DetailAST ast) {\n            final String fullIdentName = FullIdent.createFullIdent(ast).getText();\n            final String trimmed = BRACKET_PATTERN\n                    .matcher(fullIdentName).replaceAll(\"\");\n            addReferencedClassName(trimmed);\n        }\n\n        /**\n         * Adds new referenced class.\n         *\n         * @param referencedClassName class name of the referenced class.\n         */\n        private void addReferencedClassName(String referencedClassName) {\n            if (isSignificant(referencedClassName)) {\n                referencedClassNames.add(referencedClassName);\n            }\n        }\n\n        /** Checks if coupling less than allowed or not. */\n        public void checkCoupling() {\n            referencedClassNames.remove(className);\n            referencedClassNames.remove(packageName + DOT + className);\n\n            if (referencedClassNames.size() > max) {\n                log(classAst, getLogMessageId(),\n                        referencedClassNames.size(), max,\n                        referencedClassNames.toString());\n            }\n        }\n\n        /**\n         * Checks if given class shouldn't be ignored and not from java.lang.\n         *\n         * @param candidateClassName class to check.\n         * @return true if we should count this class.\n         */\n        private boolean isSignificant(String candidateClassName) {\n            return !excludedClasses.contains(candidateClassName)\n                && !isFromExcludedPackage(candidateClassName)\n                && !isExcludedClassRegexp(candidateClassName);\n        }\n\n        /**\n         * Checks if given class should be ignored as it belongs to excluded package.\n         *\n         * @param candidateClassName class to check\n         * @return true if we should not count this class.\n         */\n        private boolean isFromExcludedPackage(String candidateClassName) {\n            String classNameWithPackage = candidateClassName;\n            if (!candidateClassName.contains(DOT)) {\n                classNameWithPackage = getClassNameWithPackage(candidateClassName)\n                    .orElse(\"\");\n            }\n            boolean isFromExcludedPackage = false;\n            if (classNameWithPackage.contains(DOT)) {\n                final int lastDotIndex = classNameWithPackage.lastIndexOf(DOT);\n                final String candidatePackageName =\n                    classNameWithPackage.substring(0, lastDotIndex);\n                isFromExcludedPackage = candidatePackageName.startsWith(\"java.lang\")\n                    || excludedPackages.contains(candidatePackageName);\n            }\n            return isFromExcludedPackage;\n        }\n\n        /**\n         * Retrieves class name with packages. Uses previously registered imports to\n         * get the full class name.\n         *\n         * @param examineClassName Class name to be retrieved.\n         * @return Class name with package name, if found, {@link Optional#empty()} otherwise.\n         */\n        private Optional<String> getClassNameWithPackage(String examineClassName) {\n            return Optional.ofNullable(importedClassPackages.get(examineClassName));\n        }\n\n        /**\n         * Checks if given class should be ignored as it belongs to excluded class regexp.\n         *\n         * @param candidateClassName class to check.\n         * @return true if we should not count this class.\n         */\n        private boolean isExcludedClassRegexp(String candidateClassName) {\n            boolean result = false;\n            for (Pattern pattern : excludeClassesRegexps) {\n                if (pattern.matcher(candidateClassName).matches()) {\n                    result = true;\n                    break;\n                }\n            }\n            return result;\n        }\n\n    }\n\n}\n\nRefactoring Operation:\nMove And Inline Method\n\nProject Structure:\n['src/main/java/com/puppycrawl/tools/checkstyle/AstTreeStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/AuditEventDefaultFormatter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/AuditEventFormatter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Checker.java', 'src/main/java/com/puppycrawl/tools/checkstyle/CheckstyleParserErrorStrategy.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ConfigurationLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultConfiguration.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultContext.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DefaultLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Definitions.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DetailAstImpl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/DetailNodeTreeStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/FileStatefulCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/GlobalStatefulCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavaAstVisitor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavaParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavadocDetailNodeParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/JavadocPropertiesGenerator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/Main.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ModuleFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PackageNamesLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PackageObjectFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertiesExpander.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertyCacheFile.java', 'src/main/java/com/puppycrawl/tools/checkstyle/PropertyResolver.java', 'src/main/java/com/puppycrawl/tools/checkstyle/SarifLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/StatelessCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/SuppressionsStringPrinter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ThreadModeSettings.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalker.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalkerAuditEvent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/TreeWalkerFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XMLLogger.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XmlLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAstFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/XpathFileGeneratorAuditListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ant/CheckstyleAntTask.java', 'src/main/java/com/puppycrawl/tools/checkstyle/ant/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractFileSetCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AbstractViolationReporter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AuditEvent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AuditListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/AutomaticBean.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/BeforeExecutionFileFilterSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/CheckstyleException.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Comment.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Configurable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Configuration.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Context.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Contextualizable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/DetailAST.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/DetailNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/ExternalResourceHolder.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileContents.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileSetCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FileText.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Filter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FilterSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/FullIdent.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/JavadocTokenTypes.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/LineColumn.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/MessageDispatcher.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/RootModule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Scope.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/SeverityLevel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/SeverityLevelCounter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/TextBlock.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/TokenTypes.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/Violation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/api/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/ArrayTypeStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/AvoidEscapedUnicodeCharactersCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/DescendantTokenCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/FinalParametersCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/LineSeparatorOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/NewlineAtEndOfFileCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/NoCodeInFileCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/OrderedPropertiesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/OuterTypeFilenameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/SuppressWarningsHolder.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TodoCommentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TrailingCommentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/TranslationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UncommentedMainCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UniquePropertiesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/UpperEllCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationOnSameLineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/AnnotationUseStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingDeprecatedCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/MissingOverrideCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/PackageAnnotationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/SuppressWarningsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/annotation/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/AvoidNestedBlocksCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/BlockOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyBlockCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/EmptyCatchBlockCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/LeftCurlyOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/NeedBracesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/RightCurlyOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/blocks/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AbstractSuperCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ArrayTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidDoubleBraceInitializationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidInlineConditionalsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/AvoidNoArgumentSuperConstructorCallCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/CovariantEqualsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DeclarationOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/DefaultComesLastCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EmptyStatementCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsAvoidNullCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/EqualsHashCodeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ExplicitInitializationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FallThroughCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/FinalLocalVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/HiddenFieldCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalCatchCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalInstantiationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalThrowsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTokenTextCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/IllegalTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/InnerAssignmentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MagicNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MatchXpathCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingCtorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MissingSwitchDefaultCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ModifiedControlVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleStringLiteralsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/MultipleVariableDeclarationsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedForDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedIfDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NestedTryDepthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoArrayTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoCloneCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoEnumTrailingCommaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/NoFinalizerCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OneStatementPerLineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/OverloadMethodsDeclarationOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/PackageDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ParameterAssignmentCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/RequireThisCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/ReturnCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanExpressionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SimplifyBooleanReturnCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/StringLiteralEqualityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperCloneCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/SuperFinalizeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessaryParenthesesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterOuterTypeDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonAfterTypeMemberDeclarationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInEnumerationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/UnnecessarySemicolonInTryWithResourcesCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/VariableDeclarationUsageDistanceCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/coding/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/DesignForExtensionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/FinalClassCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/HideUtilityClassConstructorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/InnerTypeLastCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/InterfaceIsTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/MutableExceptionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/OneTopLevelClassCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/ThrowsCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/VisibilityModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/design/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/AbstractHeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/HeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/RegexpHeaderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/header/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AbstractImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AbstractImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AccessResult.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStarImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/AvoidStaticImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ClassImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/CustomImportOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/FileImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/IllegalImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportControlLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/ImportOrderOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/MismatchStrategy.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportControl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/PkgImportRule.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/RedundantImportCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/UnusedImportsCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/imports/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AbstractExpressionHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/AnnotationArrayInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ArrayInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/BlockParentHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CaseHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CatchHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ClassDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/CommentsIndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/DetailAstSet.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/DoWhileHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ElseHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/FinallyHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ForHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/HandlerFactory.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IfHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ImportHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentLevel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/IndexHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LabelHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LambdaHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/LineWrappingHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MemberDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodCallHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/MethodDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/NewHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/ObjectBlockHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/PackageDefHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/PrimordialHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SlistHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/StaticInitHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SwitchHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SwitchRuleHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/SynchronizedHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/TryHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/WhileHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/YieldHandler.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/indentation/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AbstractJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/AtclauseOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/HtmlTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocPositionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/InvalidJavadocTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocBlockTagLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocContentLocationOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMethodCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMissingLeadingAsteriskCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocMissingWhitespaceAfterAsteriskCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocNodeImpl.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocPackageCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocParagraphCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocStyleCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTag.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagContinuationIndentationCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTagInfo.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTags.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/JavadocVariableCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocMethodCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocPackageCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/MissingJavadocTypeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/NonEmptyAtclauseDescriptionCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/RequireEmptyLineBeforeBlockTagGroupCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SingleLineJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/SummaryJavadocCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/TagParser.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/WriteTagCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/BlockTagUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/InlineTagUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/TagInfo.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/javadoc/utils/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/AbstractClassCouplingCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/BooleanExpressionComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassDataAbstractionCouplingCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/ClassFanOutComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/CyclomaticComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/JavaNCSSCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/NPathComplexityCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/metrics/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ClassMemberImpliedModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/InterfaceMemberImpliedModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/ModifierOrderCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/RedundantModifierCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/modifier/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbbreviationAsWordInNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractAccessControlNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractClassNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AbstractNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/AccessModifierOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/CatchParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ClassTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ConstantNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/IllegalIdentifierNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/InterfaceTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LambdaParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalFinalVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/LocalVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MemberNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/MethodTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/PackageNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/ParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/PatternVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/RecordComponentNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/RecordTypeParameterNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/StaticVariableNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/TypeNameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/naming/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/CommentSuppressor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/DetectorOptions.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/MatchSuppressor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/MultilineDetector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/NeverSuppress.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpMultilineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpOnFilenameCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/RegexpSinglelineJavaCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/SinglelineDetector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/regexp/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/AnonInnerLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/ExecutableStatementCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/FileLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/LambdaBodyLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/LineLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodCountCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/MethodLengthCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/OuterTypeNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/ParameterNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/RecordComponentNumberCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/sizes/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/AbstractParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForInitializerPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyForIteratorPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/EmptyLineSeparatorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/FileTabCharacterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/GenericWhitespaceCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/MethodParamPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoLineWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceAfterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCaseDefaultColonCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/NoWhitespaceBeforeCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/OperatorWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/PadOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/ParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SeparatorWrapCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/SingleSpaceSeparatorCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/TypecastParenPadCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAfterCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WhitespaceAroundCheck.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/WrapOption.java', 'src/main/java/com/puppycrawl/tools/checkstyle/checks/whitespace/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filefilters/BeforeExecutionExclusionFileFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filefilters/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/CsvFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntMatchFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/IntRangeFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SeverityMatchFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWarningsFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithNearbyCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressWithPlainTextCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionCommentFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionSingleFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionXpathSingleFilter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/SuppressionsLoader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/XpathFilterElement.java', 'src/main/java/com/puppycrawl/tools/checkstyle/filters/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/CommentListener.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/CrAwareLexerSimulator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/grammar/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/BaseCellEditor.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/CodeSelector.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/CodeSelectorPresentation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ListToTreeSelectionModelWrapper.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/Main.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/MainFrame.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/MainFrameModel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTableModel.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/ParseTreeTablePresentation.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTable.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTableCellRenderer.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/TreeTableModelAdapter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/gui/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/JavadocMetadataScraper.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/MetadataGenerationException.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/MetadataGeneratorUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModuleDetails.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModulePropertyDetails.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/ModuleType.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaReader.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/XmlMetaWriter.java', 'src/main/java/com/puppycrawl/tools/checkstyle/meta/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/AnnotationUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/BlockCommentPosition.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ChainedPropertyUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/CheckUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/CommonUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/FilterUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/JavadocUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ModuleReflectionUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ParserUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/ScopeUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/TokenUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/XpathUtil.java', 'src/main/java/com/puppycrawl/tools/checkstyle/utils/package-info.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/AbstractNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/AttributeNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/ElementNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/RootNode.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/XpathQueryGenerator.java', 'src/main/java/com/puppycrawl/tools/checkstyle/xpath/package-info.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, output the target file path.\n2. If refactoring is performed, output the refactored class code in the following format:\n$target_file_path$:\n$refactored_class_code$:\n\n\n"}]