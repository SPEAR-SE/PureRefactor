[{"type": "Extract Method", "description": "Extract Method\tprivate brokenObservableInputStream() : ObservableInputStream extracted from public testBrokenInputStreamRead() : void in class org.apache.commons.io.input.ObservableInputStreamTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java", "startLine": 130, "endLine": 135, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java", "startLine": 160, "endLine": 165, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java", "startLine": 131, "endLine": 133, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void testBrokenInputStreamRead() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {\n            assertThrows(IOException.class, ois::read);\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java", "isPureRefactoring": true, "commitId": "f448f97af45a5e4dcbb8937499076c1538f7c81d", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.ObservableInputStreamTest", "methodNameBefore": "org.apache.commons.io.input.ObservableInputStreamTest#testBrokenInputStreamRead", "classSignatureBefore": "public class ObservableInputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.input.ObservableInputStreamTest#testBrokenInputStreamRead"], "classNameBeforeSet": ["org.apache.commons.io.input.ObservableInputStreamTest"], "classSignatureBeforeSet": ["public class ObservableInputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.ObservableInputStream.Observer;\nimport org.apache.commons.io.output.NullOutputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ObservableInputStream}.\n */\npublic class ObservableInputStreamTest {\n\n    private static final class DataViewObserver extends MethodCountObserver {\n        private byte[] buffer;\n        private int lastValue = -1;\n        private int length = -1;\n        private int offset = -1;\n\n        @Override\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            this.buffer = buffer;\n            this.offset = offset;\n            this.length = length;\n        }\n\n        @Override\n        public void data(final int value) throws IOException {\n            super.data(value);\n            lastValue = value;\n        }\n    }\n\n    private static final class LengthObserver extends Observer {\n        private long total;\n\n        @Override\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            this.total += length;\n        }\n\n        @Override\n        public void data(final int value) throws IOException {\n            total++;\n        }\n\n        public long getTotal() {\n            return total;\n        }\n    }\n\n    private static class MethodCountObserver extends Observer {\n        private long closedCount;\n        private long dataBufferCount;\n        private long dataCount;\n        private long errorCount;\n        private long finishedCount;\n\n        @Override\n        public void closed() throws IOException {\n            closedCount++;\n        }\n\n        @Override\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            dataBufferCount++;\n        }\n\n        @Override\n        public void data(final int value) throws IOException {\n            dataCount++;\n        }\n\n        @Override\n        public void error(final IOException exception) throws IOException {\n            errorCount++;\n        }\n\n        @Override\n        public void finished() throws IOException {\n            finishedCount++;\n        }\n\n        public long getClosedCount() {\n            return closedCount;\n        }\n\n        public long getDataBufferCount() {\n            return dataBufferCount;\n        }\n\n        public long getDataCount() {\n            return dataCount;\n        }\n\n        public long getErrorCount() {\n            return errorCount;\n        }\n\n        public long getFinishedCount() {\n            return finishedCount;\n        }\n\n    }\n\n    @Test\n    public void testBrokenInputStreamRead() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {\n            assertThrows(IOException.class, ois::read);\n        }\n    }\n\n    @Test\n    public void testBrokenInputStreamReadBuffer() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {\n            assertThrows(IOException.class, () -> ois.read(new byte[1]));\n        }\n    }\n\n    @Test\n    public void testBrokenInputStreamReadSubBuffer() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {\n            assertThrows(IOException.class, () -> ois.read(new byte[2], 0, 1));\n        }\n    }\n\n    /**\n     * Tests that {@link Observer#data(int)} is called.\n     */\n    @Test\n    public void testDataByteCalled_add() throws Exception {\n        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);\n        final DataViewObserver lko = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer))) {\n            assertEquals(-1, lko.lastValue);\n            ois.read();\n            assertEquals(-1, lko.lastValue);\n            assertEquals(0, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            ois.add(lko);\n            for (int i = 1; i < buffer.length; i++) {\n                final int result = ois.read();\n                assertEquals((byte) result, buffer[i]);\n                assertEquals(result, lko.lastValue);\n                assertEquals(0, lko.getFinishedCount());\n                assertEquals(0, lko.getClosedCount());\n            }\n            final int result = ois.read();\n            assertEquals(-1, result);\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            ois.close();\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(1, lko.getClosedCount());\n        }\n    }\n\n    /**\n     * Tests that {@link Observer#data(int)} is called.\n     */\n    @Test\n    public void testDataByteCalled_ctor() throws Exception {\n        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);\n        final DataViewObserver lko = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer), lko)) {\n            assertEquals(-1, lko.lastValue);\n            ois.read();\n            assertNotEquals(-1, lko.lastValue);\n            assertEquals(0, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            for (int i = 1; i < buffer.length; i++) {\n                final int result = ois.read();\n                assertEquals((byte) result, buffer[i]);\n                assertEquals(result, lko.lastValue);\n                assertEquals(0, lko.getFinishedCount());\n                assertEquals(0, lko.getClosedCount());\n            }\n            final int result = ois.read();\n            assertEquals(-1, result);\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            ois.close();\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(1, lko.getClosedCount());\n        }\n    }\n\n    /**\n     * Tests that {@link Observer#data(byte[],int,int)} is called.\n     */\n    @Test\n    public void testDataBytesCalled() throws Exception {\n        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);\n        try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);\n                final ObservableInputStream ois = new ObservableInputStream(bais)) {\n            final DataViewObserver observer = new DataViewObserver();\n            final byte[] readBuffer = new byte[23];\n            assertNull(observer.buffer);\n            ois.read(readBuffer);\n            assertNull(observer.buffer);\n            ois.add(observer);\n            for (;;) {\n                if (bais.available() >= 2048) {\n                    final int result = ois.read(readBuffer);\n                    if (result == -1) {\n                        ois.close();\n                        break;\n                    }\n                    assertEquals(readBuffer, observer.buffer);\n                    assertEquals(0, observer.offset);\n                    assertEquals(readBuffer.length, observer.length);\n                } else {\n                    final int res = Math.min(11, bais.available());\n                    final int result = ois.read(readBuffer, 1, 11);\n                    if (result == -1) {\n                        ois.close();\n                        break;\n                    }\n                    assertEquals(readBuffer, observer.buffer);\n                    assertEquals(1, observer.offset);\n                    assertEquals(res, observer.length);\n                }\n            }\n        }\n    }\n\n    @Test\n    public void testGetObservers0() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream())) {\n            assertTrue(ois.getObservers().isEmpty());\n        }\n    }\n\n    @Test\n    public void testGetObservers1() throws IOException {\n        final DataViewObserver observer0 = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream(), observer0)) {\n            assertEquals(observer0, ois.getObservers().get(0));\n        }\n    }\n\n    @Test\n    public void testGetObserversOrder() throws IOException {\n        final DataViewObserver observer0 = new DataViewObserver();\n        final DataViewObserver observer1 = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream(), observer0, observer1)) {\n            assertEquals(observer0, ois.getObservers().get(0));\n            assertEquals(observer1, ois.getObservers().get(1));\n        }\n    }\n\n    private void testNotificationCallbacks(final int bufferSize) throws IOException {\n        final byte[] buffer = IOUtils.byteArray();\n        final LengthObserver lengthObserver = new LengthObserver();\n        final MethodCountObserver methodCountObserver = new MethodCountObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer),\n            lengthObserver, methodCountObserver)) {\n            assertEquals(IOUtils.DEFAULT_BUFFER_SIZE,\n                IOUtils.copy(ois, NullOutputStream.INSTANCE, bufferSize));\n        }\n        assertEquals(IOUtils.DEFAULT_BUFFER_SIZE, lengthObserver.getTotal());\n        assertEquals(1, methodCountObserver.getClosedCount());\n        assertEquals(1, methodCountObserver.getFinishedCount());\n        assertEquals(0, methodCountObserver.getErrorCount());\n        assertEquals(0, methodCountObserver.getDataCount());\n        assertEquals(buffer.length / bufferSize, methodCountObserver.getDataBufferCount());\n    }\n\n    @Test\n    public void testNotificationCallbacksBufferSize1() throws Exception {\n        testNotificationCallbacks(1);\n    }\n\n    @Test\n    public void testNotificationCallbacksBufferSize2() throws Exception {\n        testNotificationCallbacks(2);\n    }\n\n    @Test\n    public void testNotificationCallbacksBufferSizeDefault() throws Exception {\n        testNotificationCallbacks(IOUtils.DEFAULT_BUFFER_SIZE);\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.ObservableInputStream.Observer;\nimport org.apache.commons.io.output.NullOutputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ObservableInputStream}.\n */\npublic class ObservableInputStreamTest {\n\n    private static final class DataViewObserver extends MethodCountObserver {\n        private byte[] buffer;\n        private int lastValue = -1;\n        private int length = -1;\n        private int offset = -1;\n\n        @Override\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            this.buffer = buffer;\n            this.offset = offset;\n            this.length = length;\n        }\n\n        @Override\n        public void data(final int value) throws IOException {\n            super.data(value);\n            lastValue = value;\n        }\n    }\n\n    private static final class LengthObserver extends Observer {\n        private long total;\n\n        @Override\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            this.total += length;\n        }\n\n        @Override\n        public void data(final int value) throws IOException {\n            total++;\n        }\n\n        public long getTotal() {\n            return total;\n        }\n    }\n\n    private static class MethodCountObserver extends Observer {\n        private long closedCount;\n        private long dataBufferCount;\n        private long dataCount;\n        private long errorCount;\n        private long finishedCount;\n\n        @Override\n        public void closed() throws IOException {\n            closedCount++;\n        }\n\n        @Override\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            dataBufferCount++;\n        }\n\n        @Override\n        public void data(final int value) throws IOException {\n            dataCount++;\n        }\n\n        @Override\n        public void error(final IOException exception) throws IOException {\n            errorCount++;\n        }\n\n        @Override\n        public void finished() throws IOException {\n            finishedCount++;\n        }\n\n        public long getClosedCount() {\n            return closedCount;\n        }\n\n        public long getDataBufferCount() {\n            return dataBufferCount;\n        }\n\n        public long getDataCount() {\n            return dataCount;\n        }\n\n        public long getErrorCount() {\n            return errorCount;\n        }\n\n        public long getFinishedCount() {\n            return finishedCount;\n        }\n\n    }\n\n    private ObservableInputStream brokenObservableInputStream() {\n        return new ObservableInputStream(BrokenInputStream.INSTANCE);\n    }\n\n    private InputStream createInputStream() {\n        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);\n        return new ObservableInputStream(new ByteArrayInputStream(buffer));\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Test\n    public void testAvailableAfterClose() throws Exception {\n        final InputStream shadow;\n        try (InputStream in = createInputStream()) {\n            assertTrue(in.available() > 0);\n            shadow = in;\n        }\n        assertEquals(0, shadow.available());\n    }\n\n    @Test\n    public void testAvailableAfterOpen() throws Exception {\n        try (InputStream in = createInputStream()) {\n            assertTrue(in.available() > 0);\n            assertNotEquals(IOUtils.EOF, in.read());\n            assertTrue(in.available() > 0);\n        }\n    }\n\n    @Test\n    public void testBrokenInputStreamRead() throws IOException {\n        try (ObservableInputStream ois = brokenObservableInputStream()) {\n            assertThrows(IOException.class, ois::read);\n        }\n    }\n\n    @Test\n    public void testBrokenInputStreamReadBuffer() throws IOException {\n        try (ObservableInputStream ois = brokenObservableInputStream()) {\n            assertThrows(IOException.class, () -> ois.read(new byte[1]));\n        }\n    }\n\n    @Test\n    public void testBrokenInputStreamReadSubBuffer() throws IOException {\n        try (ObservableInputStream ois = brokenObservableInputStream()) {\n            assertThrows(IOException.class, () -> ois.read(new byte[2], 0, 1));\n        }\n    }\n\n    /**\n     * Tests that {@link Observer#data(int)} is called.\n     */\n    @Test\n    public void testDataByteCalled_add() throws Exception {\n        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);\n        final DataViewObserver lko = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer))) {\n            assertEquals(-1, lko.lastValue);\n            ois.read();\n            assertEquals(-1, lko.lastValue);\n            assertEquals(0, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            ois.add(lko);\n            for (int i = 1; i < buffer.length; i++) {\n                final int result = ois.read();\n                assertEquals((byte) result, buffer[i]);\n                assertEquals(result, lko.lastValue);\n                assertEquals(0, lko.getFinishedCount());\n                assertEquals(0, lko.getClosedCount());\n            }\n            final int result = ois.read();\n            assertEquals(-1, result);\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            ois.close();\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(1, lko.getClosedCount());\n        }\n    }\n\n    /**\n     * Tests that {@link Observer#data(int)} is called.\n     */\n    @Test\n    public void testDataByteCalled_ctor() throws Exception {\n        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);\n        final DataViewObserver lko = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer), lko)) {\n            assertEquals(-1, lko.lastValue);\n            ois.read();\n            assertNotEquals(-1, lko.lastValue);\n            assertEquals(0, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            for (int i = 1; i < buffer.length; i++) {\n                final int result = ois.read();\n                assertEquals((byte) result, buffer[i]);\n                assertEquals(result, lko.lastValue);\n                assertEquals(0, lko.getFinishedCount());\n                assertEquals(0, lko.getClosedCount());\n            }\n            final int result = ois.read();\n            assertEquals(-1, result);\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            ois.close();\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(1, lko.getClosedCount());\n        }\n    }\n\n    /**\n     * Tests that {@link Observer#data(byte[],int,int)} is called.\n     */\n    @Test\n    public void testDataBytesCalled() throws Exception {\n        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);\n        try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);\n                final ObservableInputStream ois = new ObservableInputStream(bais)) {\n            final DataViewObserver observer = new DataViewObserver();\n            final byte[] readBuffer = new byte[23];\n            assertNull(observer.buffer);\n            ois.read(readBuffer);\n            assertNull(observer.buffer);\n            ois.add(observer);\n            for (;;) {\n                if (bais.available() >= 2048) {\n                    final int result = ois.read(readBuffer);\n                    if (result == -1) {\n                        ois.close();\n                        break;\n                    }\n                    assertEquals(readBuffer, observer.buffer);\n                    assertEquals(0, observer.offset);\n                    assertEquals(readBuffer.length, observer.length);\n                } else {\n                    final int res = Math.min(11, bais.available());\n                    final int result = ois.read(readBuffer, 1, 11);\n                    if (result == -1) {\n                        ois.close();\n                        break;\n                    }\n                    assertEquals(readBuffer, observer.buffer);\n                    assertEquals(1, observer.offset);\n                    assertEquals(res, observer.length);\n                }\n            }\n        }\n    }\n\n    @Test\n    public void testGetObservers0() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream())) {\n            assertTrue(ois.getObservers().isEmpty());\n        }\n    }\n\n    @Test\n    public void testGetObservers1() throws IOException {\n        final DataViewObserver observer0 = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream(), observer0)) {\n            assertEquals(observer0, ois.getObservers().get(0));\n        }\n    }\n\n    @Test\n    public void testGetObserversOrder() throws IOException {\n        final DataViewObserver observer0 = new DataViewObserver();\n        final DataViewObserver observer1 = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream(), observer0, observer1)) {\n            assertEquals(observer0, ois.getObservers().get(0));\n            assertEquals(observer1, ois.getObservers().get(1));\n        }\n    }\n\n    private void testNotificationCallbacks(final int bufferSize) throws IOException {\n        final byte[] buffer = IOUtils.byteArray();\n        final LengthObserver lengthObserver = new LengthObserver();\n        final MethodCountObserver methodCountObserver = new MethodCountObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer), lengthObserver, methodCountObserver)) {\n            assertEquals(IOUtils.DEFAULT_BUFFER_SIZE, IOUtils.copy(ois, NullOutputStream.INSTANCE, bufferSize));\n        }\n        assertEquals(IOUtils.DEFAULT_BUFFER_SIZE, lengthObserver.getTotal());\n        assertEquals(1, methodCountObserver.getClosedCount());\n        assertEquals(1, methodCountObserver.getFinishedCount());\n        assertEquals(0, methodCountObserver.getErrorCount());\n        assertEquals(0, methodCountObserver.getDataCount());\n        assertEquals(buffer.length / bufferSize, methodCountObserver.getDataBufferCount());\n    }\n\n    @Test\n    public void testNotificationCallbacksBufferSize1() throws Exception {\n        testNotificationCallbacks(1);\n    }\n\n    @Test\n    public void testNotificationCallbacksBufferSize2() throws Exception {\n        testNotificationCallbacks(2);\n    }\n\n    @Test\n    public void testNotificationCallbacksBufferSizeDefault() throws Exception {\n        testNotificationCallbacks(IOUtils.DEFAULT_BUFFER_SIZE);\n    }\n}\n", "diffSourceCodeSet": ["private ObservableInputStream brokenObservableInputStream() {\n        return new ObservableInputStream(BrokenInputStream.INSTANCE);\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Test\n    public void testBrokenInputStreamRead() throws IOException {\n        try (ObservableInputStream ois = brokenObservableInputStream()) {\n            assertThrows(IOException.class, ois::read);\n        }\n    }\nprivate ObservableInputStream brokenObservableInputStream() {\n        return new ObservableInputStream(BrokenInputStream.INSTANCE);\n    }", "diffSourceCode": "-  130:     @Test\n-  131:     public void testBrokenInputStreamRead() throws IOException {\n-  132:         try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {\n-  133:             assertThrows(IOException.class, ois::read);\n-  134:         }\n-  135:     }\n-  160:             ois.read();\n-  161:             assertEquals(-1, lko.lastValue);\n-  162:             assertEquals(0, lko.getFinishedCount());\n-  163:             assertEquals(0, lko.getClosedCount());\n-  164:             ois.add(lko);\n-  165:             for (int i = 1; i < buffer.length; i++) {\n+  130: \n+  131:     private ObservableInputStream brokenObservableInputStream() {\n+  132:         return new ObservableInputStream(BrokenInputStream.INSTANCE);\n+  133:     }\n+  134: \n+  135:     private InputStream createInputStream() {\n+  160:     @Test\n+  161:     public void testBrokenInputStreamRead() throws IOException {\n+  162:         try (ObservableInputStream ois = brokenObservableInputStream()) {\n+  163:             assertThrows(IOException.class, ois::read);\n+  164:         }\n+  165:     }\n", "uniqueId": "f448f97af45a5e4dcbb8937499076c1538f7c81d_130_135_131_133_160_165", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `testBrokenInputStreamRead` method, we can extract the logic of creating the `ObservableInputStream` and asserting the exception into a separate method. This will make the test more concise and easier to understand.\n\nHere\u2019s the refactored code:\n\n##########################\n```java\n@Test\npublic void testBrokenInputStreamRead() throws IOException {\n    assertIOExceptionThrownByObservableInputStream(BrokenInputStream.INSTANCE, ois -> ois.read());\n}\n\nprivate void assertIOExceptionThrownByObservableInputStream(BrokenInputStream brokenInputStream, ThrowingConsumer<ObservableInputStream> action) throws IOException {\n    try (ObservableInputStream ois = new ObservableInputStream(brokenInputStream)) {\n        assertThrows(IOException.class, () -> action.accept(ois));\n    }\n}\n\n@FunctionalInterface\ninterface ThrowingConsumer<T> {\n    void accept(T t) throws IOException;\n}\n```\n##########################\n\nIn this refactored code:\n- We created a new method `assertIOExceptionThrownByObservableInputStream` that takes a `BrokenInputStream` and a functional interface `ThrowingConsumer` as parameters. This method encapsulates the logic of creating the `ObservableInputStream` and asserting that an `IOException` is thrown.\n- The original test method `testBrokenInputStreamRead` now simply calls this new method, making it cleaner and more focused on its purpose.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void testBrokenInputStreamRead() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {\n            assertThrows(IOException.class, ois::read);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.ObservableInputStream.Observer;\nimport org.apache.commons.io.output.NullOutputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link ObservableInputStream}.\n */\npublic class ObservableInputStreamTest {\n\n    private static final class DataViewObserver extends MethodCountObserver {\n        private byte[] buffer;\n        private int lastValue = -1;\n        private int length = -1;\n        private int offset = -1;\n\n        @Override\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            this.buffer = buffer;\n            this.offset = offset;\n            this.length = length;\n        }\n\n        @Override\n        public void data(final int value) throws IOException {\n            super.data(value);\n            lastValue = value;\n        }\n    }\n\n    private static final class LengthObserver extends Observer {\n        private long total;\n\n        @Override\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            this.total += length;\n        }\n\n        @Override\n        public void data(final int value) throws IOException {\n            total++;\n        }\n\n        public long getTotal() {\n            return total;\n        }\n    }\n\n    private static class MethodCountObserver extends Observer {\n        private long closedCount;\n        private long dataBufferCount;\n        private long dataCount;\n        private long errorCount;\n        private long finishedCount;\n\n        @Override\n        public void closed() throws IOException {\n            closedCount++;\n        }\n\n        @Override\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            dataBufferCount++;\n        }\n\n        @Override\n        public void data(final int value) throws IOException {\n            dataCount++;\n        }\n\n        @Override\n        public void error(final IOException exception) throws IOException {\n            errorCount++;\n        }\n\n        @Override\n        public void finished() throws IOException {\n            finishedCount++;\n        }\n\n        public long getClosedCount() {\n            return closedCount;\n        }\n\n        public long getDataBufferCount() {\n            return dataBufferCount;\n        }\n\n        public long getDataCount() {\n            return dataCount;\n        }\n\n        public long getErrorCount() {\n            return errorCount;\n        }\n\n        public long getFinishedCount() {\n            return finishedCount;\n        }\n\n    }\n\n    @Test\n    public void testBrokenInputStreamRead() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {\n            assertThrows(IOException.class, ois::read);\n        }\n    }\n\n    @Test\n    public void testBrokenInputStreamReadBuffer() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {\n            assertThrows(IOException.class, () -> ois.read(new byte[1]));\n        }\n    }\n\n    @Test\n    public void testBrokenInputStreamReadSubBuffer() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(BrokenInputStream.INSTANCE)) {\n            assertThrows(IOException.class, () -> ois.read(new byte[2], 0, 1));\n        }\n    }\n\n    /**\n     * Tests that {@link Observer#data(int)} is called.\n     */\n    @Test\n    public void testDataByteCalled_add() throws Exception {\n        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);\n        final DataViewObserver lko = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer))) {\n            assertEquals(-1, lko.lastValue);\n            ois.read();\n            assertEquals(-1, lko.lastValue);\n            assertEquals(0, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            ois.add(lko);\n            for (int i = 1; i < buffer.length; i++) {\n                final int result = ois.read();\n                assertEquals((byte) result, buffer[i]);\n                assertEquals(result, lko.lastValue);\n                assertEquals(0, lko.getFinishedCount());\n                assertEquals(0, lko.getClosedCount());\n            }\n            final int result = ois.read();\n            assertEquals(-1, result);\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            ois.close();\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(1, lko.getClosedCount());\n        }\n    }\n\n    /**\n     * Tests that {@link Observer#data(int)} is called.\n     */\n    @Test\n    public void testDataByteCalled_ctor() throws Exception {\n        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);\n        final DataViewObserver lko = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer), lko)) {\n            assertEquals(-1, lko.lastValue);\n            ois.read();\n            assertNotEquals(-1, lko.lastValue);\n            assertEquals(0, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            for (int i = 1; i < buffer.length; i++) {\n                final int result = ois.read();\n                assertEquals((byte) result, buffer[i]);\n                assertEquals(result, lko.lastValue);\n                assertEquals(0, lko.getFinishedCount());\n                assertEquals(0, lko.getClosedCount());\n            }\n            final int result = ois.read();\n            assertEquals(-1, result);\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(0, lko.getClosedCount());\n            ois.close();\n            assertEquals(1, lko.getFinishedCount());\n            assertEquals(1, lko.getClosedCount());\n        }\n    }\n\n    /**\n     * Tests that {@link Observer#data(byte[],int,int)} is called.\n     */\n    @Test\n    public void testDataBytesCalled() throws Exception {\n        final byte[] buffer = MessageDigestInputStreamTest.generateRandomByteStream(IOUtils.DEFAULT_BUFFER_SIZE);\n        try (ByteArrayInputStream bais = new ByteArrayInputStream(buffer);\n                final ObservableInputStream ois = new ObservableInputStream(bais)) {\n            final DataViewObserver observer = new DataViewObserver();\n            final byte[] readBuffer = new byte[23];\n            assertNull(observer.buffer);\n            ois.read(readBuffer);\n            assertNull(observer.buffer);\n            ois.add(observer);\n            for (;;) {\n                if (bais.available() >= 2048) {\n                    final int result = ois.read(readBuffer);\n                    if (result == -1) {\n                        ois.close();\n                        break;\n                    }\n                    assertEquals(readBuffer, observer.buffer);\n                    assertEquals(0, observer.offset);\n                    assertEquals(readBuffer.length, observer.length);\n                } else {\n                    final int res = Math.min(11, bais.available());\n                    final int result = ois.read(readBuffer, 1, 11);\n                    if (result == -1) {\n                        ois.close();\n                        break;\n                    }\n                    assertEquals(readBuffer, observer.buffer);\n                    assertEquals(1, observer.offset);\n                    assertEquals(res, observer.length);\n                }\n            }\n        }\n    }\n\n    @Test\n    public void testGetObservers0() throws IOException {\n        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream())) {\n            assertTrue(ois.getObservers().isEmpty());\n        }\n    }\n\n    @Test\n    public void testGetObservers1() throws IOException {\n        final DataViewObserver observer0 = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream(), observer0)) {\n            assertEquals(observer0, ois.getObservers().get(0));\n        }\n    }\n\n    @Test\n    public void testGetObserversOrder() throws IOException {\n        final DataViewObserver observer0 = new DataViewObserver();\n        final DataViewObserver observer1 = new DataViewObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new NullInputStream(), observer0, observer1)) {\n            assertEquals(observer0, ois.getObservers().get(0));\n            assertEquals(observer1, ois.getObservers().get(1));\n        }\n    }\n\n    private void testNotificationCallbacks(final int bufferSize) throws IOException {\n        final byte[] buffer = IOUtils.byteArray();\n        final LengthObserver lengthObserver = new LengthObserver();\n        final MethodCountObserver methodCountObserver = new MethodCountObserver();\n        try (ObservableInputStream ois = new ObservableInputStream(new ByteArrayInputStream(buffer),\n            lengthObserver, methodCountObserver)) {\n            assertEquals(IOUtils.DEFAULT_BUFFER_SIZE,\n                IOUtils.copy(ois, NullOutputStream.INSTANCE, bufferSize));\n        }\n        assertEquals(IOUtils.DEFAULT_BUFFER_SIZE, lengthObserver.getTotal());\n        assertEquals(1, methodCountObserver.getClosedCount());\n        assertEquals(1, methodCountObserver.getFinishedCount());\n        assertEquals(0, methodCountObserver.getErrorCount());\n        assertEquals(0, methodCountObserver.getDataCount());\n        assertEquals(buffer.length / bufferSize, methodCountObserver.getDataBufferCount());\n    }\n\n    @Test\n    public void testNotificationCallbacksBufferSize1() throws Exception {\n        testNotificationCallbacks(1);\n    }\n\n    @Test\n    public void testNotificationCallbacksBufferSize2() throws Exception {\n        testNotificationCallbacks(2);\n    }\n\n    @Test\n    public void testNotificationCallbacksBufferSizeDefault() throws Exception {\n        testNotificationCallbacks(IOUtils.DEFAULT_BUFFER_SIZE);\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic getUnchecked() : T extracted from public asSupplier() : Supplier<T> in class org.apache.commons.io.function.IOSupplier", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/function/IOSupplier.java", "startLine": 33, "endLine": 41, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/function/IOSupplier.java", "startLine": 36, "endLine": 44, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/function/IOSupplier.java", "startLine": 54, "endLine": 63, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Creates a {@link Supplier} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.\n     *\n     * @return an UncheckedIOException Supplier.\n     * @since 2.12.0\n     */\n    default Supplier<T> asSupplier() {\n        return () -> Uncheck.get(this);\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/function/IOSupplier.java", "isPureRefactoring": true, "commitId": "12dbeafe93f7d63512db1c07cbe7bd9bef985044", "packageNameBefore": "org.apache.commons.io.function", "classNameBefore": "org.apache.commons.io.function.IOSupplier", "methodNameBefore": "org.apache.commons.io.function.IOSupplier#asSupplier", "invokedMethod": "methodSignature: org.apache.commons.io.function.IOSupplier#get\n methodBody: T get() throws IOException;", "classSignatureBefore": "public interface IOSupplier<T> ", "methodNameBeforeSet": ["org.apache.commons.io.function.IOSupplier#asSupplier"], "classNameBeforeSet": ["org.apache.commons.io.function.IOSupplier"], "classSignatureBeforeSet": ["public interface IOSupplier<T> "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.function.Supplier;\n\n/**\n * Like {@link Supplier} but throws {@link IOException}.\n *\n * @param <T> the return type of the operations.\n * @since 2.7\n */\n@FunctionalInterface\npublic interface IOSupplier<T> {\n\n    /**\n     * Creates a {@link Supplier} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.\n     *\n     * @return an UncheckedIOException Supplier.\n     * @since 2.12.0\n     */\n    default Supplier<T> asSupplier() {\n        return () -> Uncheck.get(this);\n    }\n\n    /**\n     * Gets a result.\n     *\n     * @return a result\n     * @throws IOException if an I/O error occurs.\n     */\n    T get() throws IOException;\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/function/IOSupplier.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.function.Supplier;\n\n/**\n * Like {@link Supplier} but throws {@link IOException}.\n * <p>\n * Using an IOSupplier allows you to compose usage of checked and unchecked exceptions as you best see fit.\n * </p>\n *\n * @param <T> the return type of the operations.\n * @since 2.7\n */\n@FunctionalInterface\npublic interface IOSupplier<T> {\n\n    /**\n     * Creates a {@link Supplier} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.\n     *\n     * @return an UncheckedIOException Supplier.\n     * @since 2.12.0\n     */\n    default Supplier<T> asSupplier() {\n        return this::getUnchecked;\n    }\n\n    /**\n     * Gets a result.\n     *\n     * @return a result.\n     * @throws IOException if an I/O error occurs.\n     */\n    T get() throws IOException;\n\n    /**\n     * Gets a result.\n     *\n     * @return a result.\n     * @throws UncheckedIOException if an I/O error occurs.\n     * @since 2.17.0\n     */\n    default T getUnchecked() throws UncheckedIOException {\n        return Uncheck.get(this);\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Gets a result.\n     *\n     * @return a result.\n     * @throws UncheckedIOException if an I/O error occurs.\n     * @since 2.17.0\n     */\n    default T getUnchecked() throws UncheckedIOException {\n        return Uncheck.get(this);\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.function.IOSupplier#get\n methodBody: T get() throws IOException;"], "sourceCodeAfterRefactoring": "/**\n     * Creates a {@link Supplier} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.\n     *\n     * @return an UncheckedIOException Supplier.\n     * @since 2.12.0\n     */\n    default Supplier<T> asSupplier() {\n        return this::getUnchecked;\n    }\n/**\n     * Gets a result.\n     *\n     * @return a result.\n     * @throws UncheckedIOException if an I/O error occurs.\n     * @since 2.17.0\n     */\n    default T getUnchecked() throws UncheckedIOException {\n        return Uncheck.get(this);\n    }", "diffSourceCode": "-   33:     /**\n-   34:      * Creates a {@link Supplier} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.\n-   35:      *\n-   36:      * @return an UncheckedIOException Supplier.\n-   37:      * @since 2.12.0\n-   38:      */\n-   39:     default Supplier<T> asSupplier() {\n-   40:         return () -> Uncheck.get(this);\n-   41:     }\n-   42: \n-   43:     /**\n-   44:      * Gets a result.\n+   33: @FunctionalInterface\n+   34: public interface IOSupplier<T> {\n+   35: \n+   36:     /**\n+   37:      * Creates a {@link Supplier} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.\n+   38:      *\n+   39:      * @return an UncheckedIOException Supplier.\n+   40:      * @since 2.12.0\n+   41:      */\n+   42:     default Supplier<T> asSupplier() {\n+   43:         return this::getUnchecked;\n+   44:     }\n+   54:     /**\n+   55:      * Gets a result.\n+   56:      *\n+   57:      * @return a result.\n+   58:      * @throws UncheckedIOException if an I/O error occurs.\n+   59:      * @since 2.17.0\n+   60:      */\n+   61:     default T getUnchecked() throws UncheckedIOException {\n+   62:         return Uncheck.get(this);\n+   63:     }\n", "uniqueId": "12dbeafe93f7d63512db1c07cbe7bd9bef985044_33_41_54_63_36_44", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 3}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `asSupplier` method, we can extract the logic that handles the conversion of the `IOSupplier` to a `Supplier` into a separate method. This will make the `asSupplier` method cleaner and more focused on its primary responsibility.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\n    /**\n     * Creates a {@link Supplier} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.\n     *\n     * @return an UncheckedIOException Supplier.\n     * @since 2.12.0\n     */\n    default Supplier<T> asSupplier() {\n        return createUncheckedSupplier();\n    }\n\n    /**\n     * Creates a {@link Supplier} that wraps this instance and converts any {@link IOException} to {@link UncheckedIOException}.\n     *\n     * @return a Supplier that throws UncheckedIOException.\n     */\n    private Supplier<T> createUncheckedSupplier() {\n        return () -> Uncheck.get(this);\n    }\n##########################\n```\n\n### Changes Made:\n1. **Extracted Method**: The logic for creating the `Supplier` has been moved to a new private method called `createUncheckedSupplier()`.\n2. **Updated `asSupplier`**: The `asSupplier` method now simply calls the new method, improving its readability and clarity. \n\nThis refactoring enhances the modularity of the code, making it easier to understand and maintain.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Creates a {@link Supplier} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.\n     *\n     * @return an UncheckedIOException Supplier.\n     * @since 2.12.0\n     */\n    default Supplier<T> asSupplier() {\n        return () -> Uncheck.get(this);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.function.Supplier;\n\n/**\n * Like {@link Supplier} but throws {@link IOException}.\n *\n * @param <T> the return type of the operations.\n * @since 2.7\n */\n@FunctionalInterface\npublic interface IOSupplier<T> {\n\n    /**\n     * Creates a {@link Supplier} for this instance that throws {@link UncheckedIOException} instead of {@link IOException}.\n     *\n     * @return an UncheckedIOException Supplier.\n     * @since 2.12.0\n     */\n    default Supplier<T> asSupplier() {\n        return () -> Uncheck.get(this);\n    }\n\n    /**\n     * Gets a result.\n     *\n     * @return a result\n     * @throws IOException if an I/O error occurs.\n     */\n    T get() throws IOException;\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Inline Method", "description": "Inline Method\tprivate readWithUpdate() : int inlined to public read() : int in class org.apache.commons.io.input.WindowsLineEndingInputStream", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java", "startLine": 96, "endLine": 118, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java", "startLine": 96, "endLine": 123, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java", "startLine": 120, "endLine": 134, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Reads the next item from the target, updating internal flags in the process\n     *\n     * @return the next int read from the target stream\n     * @throws IOException upon error\n     */\n    private int readWithUpdate() throws IOException {\n        final int target = in.read();\n        atEos = target == EOF;\n        if (!atEos) {\n            atSlashCr = target == CR;\n            atSlashLf = target == LF;\n        }\n        return target;\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java", "isPureRefactoring": true, "commitId": "c28eff3be60085078fcd6bce5613b266c3907274", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.WindowsLineEndingInputStream", "methodNameBefore": "org.apache.commons.io.input.WindowsLineEndingInputStream#readWithUpdate", "invokedMethod": "methodSignature: org.apache.commons.io.input.WindowsLineEndingInputStream#read\n methodBody: public int read() throws IOException {\nif(atEos){return handleEos();\n}if(injectSlashLf){injectSlashLf=false;\nreturn LF;\n}final boolean prevWasSlashR=atSlashCr;\nfinal int target=readWithUpdate();\nif(atEos){return handleEos();\n}if(target == LF && !prevWasSlashR){injectSlashLf=true;\nreturn CR;\n}return target;\n}", "classSignatureBefore": "public class WindowsLineEndingInputStream extends InputStream ", "methodNameBeforeSet": ["org.apache.commons.io.input.WindowsLineEndingInputStream#readWithUpdate"], "classNameBeforeSet": ["org.apache.commons.io.input.WindowsLineEndingInputStream"], "classSignatureBeforeSet": ["public class WindowsLineEndingInputStream extends InputStream "], "purityCheckResultList": [{"isPure": true, "purityComment": " - Inline Method - ", "description": "Nested Inline Method or statements being mapped in other refactorings - non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.apache.commons.io.IOUtils.CR;\nimport static org.apache.commons.io.IOUtils.EOF;\nimport static org.apache.commons.io.IOUtils.LF;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A filtering input stream that ensures the content will have Windows line endings, CRLF.\n *\n * @since 2.5\n */\npublic class WindowsLineEndingInputStream extends InputStream {\n\n    private boolean atEos;\n\n    private boolean atSlashCr;\n\n    private boolean atSlashLf;\n\n    private final InputStream in;\n\n    private boolean injectSlashLf;\n\n    private final boolean lineFeedAtEndOfFile;\n\n    /**\n     * Constructs an input stream that filters another stream\n     *\n     * @param in                        The input stream to wrap\n     * @param ensureLineFeedAtEndOfFile true to ensure that the file ends with CRLF\n     */\n    public WindowsLineEndingInputStream(final InputStream in, final boolean ensureLineFeedAtEndOfFile) {\n        this.in = in;\n        this.lineFeedAtEndOfFile = ensureLineFeedAtEndOfFile;\n    }\n\n    /**\n     * Closes the stream. Also closes the underlying stream.\n     *\n     * @throws IOException upon error\n     */\n    @Override\n    public void close() throws IOException {\n        super.close();\n        in.close();\n    }\n\n    /**\n     * Handles the end of stream condition.\n     *\n     * @return The next char to output to the stream\n     */\n    private int handleEos() {\n        if (!lineFeedAtEndOfFile) {\n            return EOF;\n        }\n        if (!atSlashLf && !atSlashCr) {\n            atSlashCr = true;\n            return CR;\n        }\n        if (!atSlashLf) {\n            atSlashCr = false;\n            atSlashLf = true;\n            return LF;\n        }\n        return EOF;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public synchronized void mark(final int readLimit) {\n        throw UnsupportedOperationExceptions.mark();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int read() throws IOException {\n        if (atEos) {\n            return handleEos();\n        }\n        if (injectSlashLf) {\n            injectSlashLf = false;\n            return LF;\n        }\n        final boolean prevWasSlashR = atSlashCr;\n        final int target = readWithUpdate();\n        if (atEos) {\n            return handleEos();\n        }\n        if (target == LF && !prevWasSlashR) {\n            injectSlashLf = true;\n            return CR;\n        }\n        return target;\n    }\n\n    /**\n     * Reads the next item from the target, updating internal flags in the process\n     *\n     * @return the next int read from the target stream\n     * @throws IOException upon error\n     */\n    private int readWithUpdate() throws IOException {\n        final int target = in.read();\n        atEos = target == EOF;\n        if (!atEos) {\n            atSlashCr = target == CR;\n            atSlashLf = target == LF;\n        }\n        return target;\n    }\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.apache.commons.io.IOUtils.CR;\nimport static org.apache.commons.io.IOUtils.EOF;\nimport static org.apache.commons.io.IOUtils.LF;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A filtering input stream that ensures the content will have Windows line endings, CRLF.\n *\n * @since 2.5\n */\npublic class WindowsLineEndingInputStream extends InputStream {\n\n    private boolean atEos;\n\n    private boolean atSlashCr;\n\n    private boolean atSlashLf;\n\n    private final InputStream in;\n\n    private boolean injectSlashLf;\n\n    private final boolean lineFeedAtEos;\n\n    /**\n     * Constructs an input stream that filters another stream.\n     *\n     * @param in                        The input stream to wrap.\n     * @param lineFeedAtEos true to ensure that the stream ends with CRLF.\n     */\n    public WindowsLineEndingInputStream(final InputStream in, final boolean lineFeedAtEos) {\n        this.in = in;\n        this.lineFeedAtEos = lineFeedAtEos;\n    }\n\n    /**\n     * Closes the stream. Also closes the underlying stream.\n     *\n     * @throws IOException upon error\n     */\n    @Override\n    public void close() throws IOException {\n        super.close();\n        in.close();\n    }\n\n    /**\n     * Handles the end of stream condition.\n     *\n     * @return The next char to output to the stream.\n     */\n    private int handleEos() {\n        if (!lineFeedAtEos) {\n            return EOF;\n        }\n        if (!atSlashLf && !atSlashCr) {\n            atSlashCr = true;\n            return CR;\n        }\n        if (!atSlashLf) {\n            atSlashCr = false;\n            atSlashLf = true;\n            return LF;\n        }\n        return EOF;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public synchronized void mark(final int readLimit) {\n        throw UnsupportedOperationExceptions.mark();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int read() throws IOException {\n        if (atEos) {\n            return handleEos();\n        }\n        if (injectSlashLf) {\n            injectSlashLf = false;\n            return LF;\n        }\n        final boolean prevWasSlashR = atSlashCr;\n        final int target = in.read();\n        atEos = target == EOF;\n        if (!atEos) {\n            atSlashCr = target == CR;\n            atSlashLf = target == LF;\n        }\n        if (atEos) {\n            return handleEos();\n        }\n        if (target == LF && !prevWasSlashR) {\n            injectSlashLf = true;\n            return CR;\n        }\n        return target;\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.WindowsLineEndingInputStream#read\n methodBody: public int read() throws IOException {\nif(atEos){return handleEos();\n}if(injectSlashLf){injectSlashLf=false;\nreturn LF;\n}final boolean prevWasSlashR=atSlashCr;\nfinal int target=readWithUpdate();\nif(atEos){return handleEos();\n}if(target == LF && !prevWasSlashR){injectSlashLf=true;\nreturn CR;\n}return target;\n}"], "sourceCodeAfterRefactoring": "/**\n     * {@inheritDoc}\n     */\n    @Override\n    public int read() throws IOException {\n        if (atEos) {\n            return handleEos();\n        }\n        if (injectSlashLf) {\n            injectSlashLf = false;\n            return LF;\n        }\n        final boolean prevWasSlashR = atSlashCr;\n        final int target = in.read();\n        atEos = target == EOF;\n        if (!atEos) {\n            atSlashCr = target == CR;\n            atSlashLf = target == LF;\n        }\n        if (atEos) {\n            return handleEos();\n        }\n        if (target == LF && !prevWasSlashR) {\n            injectSlashLf = true;\n            return CR;\n        }\n        return target;\n    }", "diffSourceCode": "    96:     /**\n    97:      * {@inheritDoc}\n    98:      */\n    99:     @Override\n   100:     public int read() throws IOException {\n   101:         if (atEos) {\n   102:             return handleEos();\n   103:         }\n   104:         if (injectSlashLf) {\n   105:             injectSlashLf = false;\n   106:             return LF;\n   107:         }\n   108:         final boolean prevWasSlashR = atSlashCr;\n-  109:         final int target = readWithUpdate();\n-  110:         if (atEos) {\n-  111:             return handleEos();\n-  112:         }\n-  113:         if (target == LF && !prevWasSlashR) {\n-  114:             injectSlashLf = true;\n-  115:             return CR;\n-  116:         }\n-  117:         return target;\n-  118:     }\n-  119: \n-  120:     /**\n-  121:      * Reads the next item from the target, updating internal flags in the process\n-  122:      *\n-  123:      * @return the next int read from the target stream\n-  124:      * @throws IOException upon error\n-  125:      */\n-  126:     private int readWithUpdate() throws IOException {\n-  127:         final int target = in.read();\n-  128:         atEos = target == EOF;\n-  129:         if (!atEos) {\n-  130:             atSlashCr = target == CR;\n-  131:             atSlashLf = target == LF;\n-  132:         }\n-  133:         return target;\n-  134:     }\n+  109:         final int target = in.read();\n+  110:         atEos = target == EOF;\n+  111:         if (!atEos) {\n+  112:             atSlashCr = target == CR;\n+  113:             atSlashLf = target == LF;\n+  114:         }\n+  115:         if (atEos) {\n+  116:             return handleEos();\n+  117:         }\n+  118:         if (target == LF && !prevWasSlashR) {\n+  119:             injectSlashLf = true;\n+  120:             return CR;\n+  121:         }\n+  122:         return target;\n+  123:     }\n+  124: }\n", "uniqueId": "c28eff3be60085078fcd6bce5613b266c3907274_96_118__96_123_120_134", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 33}, "BRANCH": {"missed": 0, "covered": 8}, "LINE": {"missed": 0, "covered": 6}, "COMPLEXITY": {"missed": 0, "covered": 5}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To refactor the provided code by inlining the `readWithUpdate` method, we will replace the method call with its implementation directly in the `read` method. This will improve readability by reducing the number of method calls and making the logic more straightforward.\n\nHere is the refactored class code:\n\n##########################\n```java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.apache.commons.io.IOUtils.CR;\nimport static org.apache.commons.io.IOUtils.EOF;\nimport static org.apache.commons.io.IOUtils.LF;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A filtering input stream that ensures the content will have Windows line endings, CRLF.\n *\n * @since 2.5\n */\npublic class WindowsLineEndingInputStream extends InputStream {\n\n    private boolean atEos;\n\n    private boolean atSlashCr;\n\n    private boolean atSlashLf;\n\n    private final InputStream in;\n\n    private boolean injectSlashLf;\n\n    private final boolean lineFeedAtEndOfFile;\n\n    /**\n     * Constructs an input stream that filters another stream\n     *\n     * @param in                        The input stream to wrap\n     * @param ensureLineFeedAtEndOfFile true to ensure that the file ends with CRLF\n     */\n    public WindowsLineEndingInputStream(final InputStream in, final boolean ensureLineFeedAtEndOfFile) {\n        this.in = in;\n        this.lineFeedAtEndOfFile = ensureLineFeedAtEndOfFile;\n    }\n\n    /**\n     * Closes the stream. Also closes the underlying stream.\n     *\n     * @throws IOException upon error\n     */\n    @Override\n    public void close() throws IOException {\n        super.close();\n        in.close();\n    }\n\n    /**\n     * Handles the end of stream condition.\n     *\n     * @return The next char to output to the stream\n     */\n    private int handleEos() {\n        if (!lineFeedAtEndOfFile) {\n            return EOF;\n        }\n        if (!atSlashLf && !atSlashCr) {\n            atSlashCr = true;\n            return CR;\n        }\n        if (!atSlashLf) {\n            atSlashCr = false;\n            atSlashLf = true;\n            return LF;\n        }\n        return EOF;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public synchronized void mark(final int readLimit) {\n        throw UnsupportedOperationExceptions.mark();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int read() throws IOException {\n        if (atEos) {\n            return handleEos();\n        }\n        if (injectSlashLf) {\n            injectSlashLf = false;\n            return LF;\n        }\n        final boolean prevWasSlashR = atSlashCr;\n\n        // Inlined readWithUpdate logic\n        final int target = in.read();\n        atEos = target == EOF;\n        if (!atEos) {\n            atSlashCr = target == CR;\n            atSlashLf = target == LF;\n        }\n\n        if (atEos) {\n            return handleEos();\n        }\n        if (target == LF && !prevWasSlashR) {\n            injectSlashLf = true;\n            return CR;\n        }\n        return target;\n    }\n}\n```\n########################## \n\nIn this refactored code, the `readWithUpdate` method has been inlined into the `read` method, which simplifies the flow and makes it easier to understand how the internal flags are updated based on the input stream.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Reads the next item from the target, updating internal flags in the process\n     *\n     * @return the next int read from the target stream\n     * @throws IOException upon error\n     */\n    private int readWithUpdate() throws IOException {\n        final int target = in.read();\n        atEos = target == EOF;\n        if (!atEos) {\n            atSlashCr = target == CR;\n            atSlashLf = target == LF;\n        }\n        return target;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.apache.commons.io.IOUtils.CR;\nimport static org.apache.commons.io.IOUtils.EOF;\nimport static org.apache.commons.io.IOUtils.LF;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * A filtering input stream that ensures the content will have Windows line endings, CRLF.\n *\n * @since 2.5\n */\npublic class WindowsLineEndingInputStream extends InputStream {\n\n    private boolean atEos;\n\n    private boolean atSlashCr;\n\n    private boolean atSlashLf;\n\n    private final InputStream in;\n\n    private boolean injectSlashLf;\n\n    private final boolean lineFeedAtEndOfFile;\n\n    /**\n     * Constructs an input stream that filters another stream\n     *\n     * @param in                        The input stream to wrap\n     * @param ensureLineFeedAtEndOfFile true to ensure that the file ends with CRLF\n     */\n    public WindowsLineEndingInputStream(final InputStream in, final boolean ensureLineFeedAtEndOfFile) {\n        this.in = in;\n        this.lineFeedAtEndOfFile = ensureLineFeedAtEndOfFile;\n    }\n\n    /**\n     * Closes the stream. Also closes the underlying stream.\n     *\n     * @throws IOException upon error\n     */\n    @Override\n    public void close() throws IOException {\n        super.close();\n        in.close();\n    }\n\n    /**\n     * Handles the end of stream condition.\n     *\n     * @return The next char to output to the stream\n     */\n    private int handleEos() {\n        if (!lineFeedAtEndOfFile) {\n            return EOF;\n        }\n        if (!atSlashLf && !atSlashCr) {\n            atSlashCr = true;\n            return CR;\n        }\n        if (!atSlashLf) {\n            atSlashCr = false;\n            atSlashLf = true;\n            return LF;\n        }\n        return EOF;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public synchronized void mark(final int readLimit) {\n        throw UnsupportedOperationExceptions.mark();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int read() throws IOException {\n        if (atEos) {\n            return handleEos();\n        }\n        if (injectSlashLf) {\n            injectSlashLf = false;\n            return LF;\n        }\n        final boolean prevWasSlashR = atSlashCr;\n        final int target = readWithUpdate();\n        if (atEos) {\n            return handleEos();\n        }\n        if (target == LF && !prevWasSlashR) {\n            injectSlashLf = true;\n            return CR;\n        }\n        return target;\n    }\n\n    /**\n     * Reads the next item from the target, updating internal flags in the process\n     *\n     * @return the next int read from the target stream\n     * @throws IOException upon error\n     */\n    private int readWithUpdate() throws IOException {\n        final int target = in.read();\n        atEos = target == EOF;\n        if (!atEos) {\n            atSlashCr = target == CR;\n            atSlashLf = target == LF;\n        }\n        return target;\n    }\n}\n\nRefactoring Operation:\nInline Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\nrefactored_class_code\n##########################\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate exists(path Path, options LinkOption...) : boolean extracted from public fileContentEquals(path1 Path, path2 Path, linkOptions LinkOption[], openOptions OpenOption[]) : boolean in class org.apache.commons.io.file.PathUtils", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/file/PathUtils.java", "startLine": 612, "endLine": 666, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/file/PathUtils.java", "startLine": 616, "endLine": 670, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/file/PathUtils.java", "startLine": 595, "endLine": 597, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/file/PathUtils.java", "isPureRefactoring": true, "commitId": "1e73dd92a2224828dd45f47ae8e96a8c0cd2d3d8", "packageNameBefore": "org.apache.commons.io.file", "classNameBefore": "org.apache.commons.io.file.PathUtils", "methodNameBefore": "org.apache.commons.io.file.PathUtils#fileContentEquals", "invokedMethod": "methodSignature: org.apache.commons.io.FileUtils#isDirectory\n methodBody: public static boolean isDirectory(final File file, final LinkOption... options) {\nreturn file != null && Files.isDirectory(file.toPath(),options);\n}\nmethodSignature: org.apache.commons.io.FileUtils#contentEquals\n methodBody: public static boolean contentEquals(final File file1, final File file2) throws IOException {\nif(file1 == null && file2 == null){return true;\n}if(file1 == null || file2 == null){return false;\n}final boolean file1Exists=file1.exists();\nif(file1Exists != file2.exists()){return false;\n}if(!file1Exists){return true;\n}requireFile(file1,\"file1\");\nrequireFile(file2,\"file2\");\nif(file1.length() != file2.length()){return false;\n}if(file1.getCanonicalFile().equals(file2.getCanonicalFile())){return true;\n}try(InputStream input1=Files.newInputStream(file1.toPath()); InputStream input2=Files.newInputStream(file2.toPath()))return IOUtils.contentEquals(input1,input2);\n}\nmethodSignature: org.apache.commons.io.file.PathUtils#isDirectory\n methodBody: public static boolean isDirectory(final Path path, final LinkOption... options) {\nreturn path != null && Files.isDirectory(path,options);\n}", "classSignatureBefore": "public final class PathUtils ", "methodNameBeforeSet": ["org.apache.commons.io.file.PathUtils#fileContentEquals"], "classNameBeforeSet": ["org.apache.commons.io.file.PathUtils"], "classSignatureBeforeSet": ["public final class PathUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n", "description": "One of the overlapping cases - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.CopyOption;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.NotDirectoryException;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.chrono.ChronoZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOExceptionList;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.UncheckedIOExceptions;\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.IOFileFilter;\n\n/**\n * NIO Path utilities.\n *\n * @since 2.7\n */\npublic final class PathUtils {\n\n    /**\n     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative\n     * lists when comparing directories.\n     */\n    private static class RelativeSortedPaths {\n\n        final boolean equals;\n        // final List<Path> relativeDirList1; // might need later?\n        // final List<Path> relativeDirList2; // might need later?\n        final List<Path> relativeFileList1;\n        final List<Path> relativeFileList2;\n\n        /**\n         * Constructs and initializes a new instance by accumulating directory and file info.\n         *\n         * @param dir1 First directory to compare.\n         * @param dir2 Seconds directory to compare.\n         * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @param linkOptions Options indicating how symbolic links are handled.\n         * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @throws IOException if an I/O error is thrown by a visitor method.\n         */\n        private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,\n            final FileVisitOption[] fileVisitOptions) throws IOException {\n            final List<Path> tmpRelativeDirList1;\n            final List<Path> tmpRelativeDirList2;\n            List<Path> tmpRelativeFileList1 = null;\n            List<Path> tmpRelativeFileList2 = null;\n            if (dir1 == null && dir2 == null) {\n                equals = true;\n            } else if (dir1 == null ^ dir2 == null) {\n                equals = false;\n            } else {\n                final boolean parentDirNotExists1 = Files.notExists(dir1, linkOptions);\n                final boolean parentDirNotExists2 = Files.notExists(dir2, linkOptions);\n                if (parentDirNotExists1 || parentDirNotExists2) {\n                    equals = parentDirNotExists1 && parentDirNotExists2;\n                } else {\n                    final AccumulatorPathVisitor visitor1 = accumulate(dir1, maxDepth, fileVisitOptions);\n                    final AccumulatorPathVisitor visitor2 = accumulate(dir2, maxDepth, fileVisitOptions);\n                    if (visitor1.getDirList().size() != visitor2.getDirList().size() || visitor1.getFileList().size() != visitor2.getFileList().size()) {\n                        equals = false;\n                    } else {\n                        tmpRelativeDirList1 = visitor1.relativizeDirectories(dir1, true, null);\n                        tmpRelativeDirList2 = visitor2.relativizeDirectories(dir2, true, null);\n                        if (!tmpRelativeDirList1.equals(tmpRelativeDirList2)) {\n                            equals = false;\n                        } else {\n                            tmpRelativeFileList1 = visitor1.relativizeFiles(dir1, true, null);\n                            tmpRelativeFileList2 = visitor2.relativizeFiles(dir2, true, null);\n                            equals = tmpRelativeFileList1.equals(tmpRelativeFileList2);\n                        }\n                    }\n                }\n            }\n            // relativeDirList1 = tmpRelativeDirList1;\n            // relativeDirList2 = tmpRelativeDirList2;\n            relativeFileList1 = tmpRelativeFileList1;\n            relativeFileList2 = tmpRelativeFileList2;\n        }\n    }\n\n    /**\n     * Empty {@link CopyOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final CopyOption[] EMPTY_COPY_OPTIONS = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final DeleteOption[] EMPTY_DELETE_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link FileVisitOption} array.\n     */\n    public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     */\n    public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY = {};\n\n    /**\n     * {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n     *\n     * @since 2.9.0\n     */\n    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = {LinkOption.NOFOLLOW_LINKS};\n\n    /**\n     * Empty {@link OpenOption} array.\n     */\n    public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link Path} array.\n     *\n     * @since 2.9.0\n     */\n    public static final Path[] EMPTY_PATH_ARRAY = {};\n\n    /**\n     * Accumulates file tree information in a {@link AccumulatorPathVisitor}.\n     *\n     * @param directory The directory to accumulate information.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @return file tree information.\n     */\n    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return cleanDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Compares the specified {@code Path}'s last modified time to the given file time.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return See {@link FileTime#compareTo(FileTime)}\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     */\n    private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        return getLastModifiedTime(file, options).compareTo(fileTime);\n    }\n\n    /**\n     * Copies a directory to another directory.\n     *\n     * @param sourceDirectory The source directory.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path absoluteSource = sourceDirectory.toAbsolutePath();\n        return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)\n            .getPathCounters();\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetFile The target file.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetFile, copyOptions);\n            return targetFile;\n        }\n    }\n\n    /**\n     * Copies a file to a directory.\n     *\n     * @param sourceFile The source file.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(Path, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n            return targetDirectory;\n        }\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(CountingPathVisitor.withLongCounters(), directory).getPathCounters();\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.12.0\n     */\n    public static PathCounters countDirectoryAsBigInteger(final Path directory) throws IOException {\n        return visitFileTree(CountingPathVisitor.withBigIntegerCounters(), directory).getPathCounters();\n    }\n\n    /**\n     * Creates the parent directories for the given {@code path}.\n     *\n     * @param path The path to a file (or directory).\n     * @param attrs An optional list of file attributes to set atomically when creating the directories.\n     * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static Path createParentDirectories(final Path path, final FileAttribute<?>... attrs) throws IOException {\n        final Path parent = path.getParent();\n        return parent == null ? null : Files.createDirectories(parent, attrs);\n    }\n\n    /**\n     * Gets the current directory.\n     *\n     * @return the current directory.\n     *\n     * @since 2.9.0\n     */\n    public static Path current() {\n        return Paths.get(\"\");\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     */\n    public static PathCounters delete(final Path path) throws IOException {\n        return delete(path, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return deleteDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions), directory)\n            .getPathCounters();\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     */\n    public static PathCounters deleteFile(final Path file) throws IOException {\n        return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n        // Files.deleteIfExists() never follows links, so use LinkOption.NOFOLLOW_LINKS in other calls to Files.\n        return deleteFile(file, NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)\n        throws NoSuchFileException, IOException {\n        if (Files.isDirectory(file, linkOptions)) {\n            throw new NoSuchFileException(file.toString());\n        }\n        final PathCounters pathCounts = Counters.longPathCounters();\n        final boolean exists = Files.exists(file, linkOptions);\n        final long size = exists && !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n        if (overrideReadOnly(deleteOptions) && exists) {\n            setReadOnly(file, false, linkOptions);\n        }\n        if (Files.deleteIfExists(file)) {\n            pathCounts.getFileCounter().increment();\n            pathCounts.getByteCounter().add(size);\n        }\n        return pathCounts;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryAndFileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param linkOptions options to follow links.\n     * @param openOptions options to open files.\n     * @param fileVisitOption options to configure traversal.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,\n        final FileVisitOption[] fileVisitOption) throws IOException {\n        // First walk both file trees and gather normalized paths.\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        if (notExists(path1) && notExists(path2)) {\n            return true;\n        }\n        final RelativeSortedPaths relativeSortedPaths = new RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption);\n        // If the normalized path names and counts are not the same, no need to compare contents.\n        if (!relativeSortedPaths.equals) {\n            return false;\n        }\n        // Both visitors contain the same normalized paths, we can compare file contents.\n        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n        for (final Path path : fileList1) {\n            final int binarySearch = Collections.binarySearch(fileList2, path);\n            if (binarySearch <= -1) {\n                throw new IllegalStateException(\"Unexpected mismatch.\");\n            }\n            if (!fileContentEquals(path1.resolve(path), path2.resolve(path), linkOptions, openOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, EMPTY_LINK_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param linkOptions options to follow links.\n     * @param fileVisitOptions options to configure the traversal\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,\n        final FileVisitOption[] fileVisitOptions) throws IOException {\n        return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n        return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\n\n    /**\n     * <p>\n     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original\n     * file list that matches the provided filter.\n     * </p>\n     *\n     * <p>\n     * The {@link Set} returned by this method is not guaranteed to be thread safe.\n     * </p>\n     *\n     * <pre>\n     * Set&lt;File&gt; allFiles = ...\n     * Set&lt;File&gt; javaFiles = FileFilterUtils.filterSet(allFiles,\n     *     FileFilterUtils.suffixFileFilter(\".java\"));\n     * </pre>\n     *\n     * @param filter the filter to apply to the set of files.\n     * @param paths the array of files to apply the filter to.\n     *\n     * @return a subset of {@code files} that is accepted by the file filter.\n     * @throws IllegalArgumentException if the filter is {@code null} or {@code files} contains a {@code null} value.\n     *\n     * @since 2.9.0\n     */\n    public static Path[] filter(final PathFilter filter, final Path... paths) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (paths == null) {\n            return EMPTY_PATH_ARRAY;\n        }\n        return filterPaths(filter, Stream.of(paths), Collectors.toList()).toArray(EMPTY_PATH_ARRAY);\n    }\n\n    private static <R, A> R filterPaths(final PathFilter filter, final Stream<Path> stream, final Collector<? super Path, A, R> collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream == null) {\n            return Stream.<Path>empty().collect(collector);\n        }\n        return stream.filter(p -> {\n            try {\n                return p != null && filter.accept(p, readBasicFileAttributes(p)) == FileVisitResult.CONTINUE;\n            } catch (final IOException e) {\n                return false;\n            }\n        }).collect(collector);\n    }\n\n    /**\n     * Reads the access control list from a file attribute view.\n     *\n     * @param sourcePath the path to the file.\n     * @return a file attribute view of the specified type, or null if the attribute view type is not available.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOException {\n        final AclFileAttributeView fileAttributeView = Files.getFileAttributeView(sourcePath, AclFileAttributeView.class);\n        return fileAttributeView == null ? null : fileAttributeView.getAcl();\n    }\n\n    private static FileTime getLastModifiedTime(final Path path, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(Objects.requireNonNull(path, \"path\"), options);\n    }\n\n    /**\n     * Returns a {@link Path} representing the system temporary directory.\n     *\n     * @return the system temporary directory.\n     *\n     * @since 2.12.0\n     */\n    public static Path getTempDirectory() {\n        return Paths.get(FileUtils.getTempDirectoryPath());\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a directory or not. Implemented as a null-safe delegate to\n     * {@code Files.isDirectory(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a\n     *         directory, or it cannot be determined if the file is a directory or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isDirectory(final Path path, final LinkOption... options) {\n        return path != null && Files.isDirectory(path, options);\n    }\n\n    /**\n     * Tests whether the given file or directory is empty.\n     *\n     * @param path the file or directory to query.\n     * @return whether the file or directory is empty.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }\n\n    /**\n     * Tests whether the directory is empty.\n     *\n     * @param directory the directory to query.\n     * @return whether the directory is empty.\n     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <i>(optional\n     *         specific exception)</i>.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     */\n    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n            return !directoryStream.iterator().hasNext();\n        }\n    }\n\n    /**\n     * Tests whether the given file is empty.\n     *\n     * @param file the file to query.\n     * @return whether the file is empty.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, its\n     *         {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.\n     */\n    public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) <= 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param czdt the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final ChronoZonedDateTime<?> czdt, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(czdt, \"czdt\");\n        return isNewer(file, czdt.toInstant(), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) > 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.from(instant), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the reference {@code Path}.\n     *\n     * @param file      the {@code File} of which the modification date must be compared.\n     * @param reference the {@code File} of which the modification date is used.\n     * @return true if the {@code File} exists and has been modified more\n     * recently than the reference {@code File}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Path reference) throws IOException {\n        return isNewer(file, getLastModifiedTime(reference));\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared.\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified before the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) < 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared.\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isOlder(file, FileTime.from(instant), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified before the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isOlder(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the reference {@code Path}.\n     *\n     * @param file the {@code File} of which the modification date must be compared.\n     * @param reference the {@code File} of which the modification date is used.\n     * @return true if the {@code File} exists and has been modified before than the reference {@code File}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final Path reference) throws IOException {\n        return isOlder(file, getLastModifiedTime(reference));\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a regular file or not. Implemented as a null-safe delegate to\n     * {@code Files.isRegularFile(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is\n     *         not a directory, or it cannot be determined if the file is a regular file or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isRegularFile(final Path path, final LinkOption... options) {\n        return path != null && Files.isRegularFile(path, options);\n    }\n\n\n    /**\n     * Creates a new DirectoryStream for Paths rooted at the given directory.\n     *\n     * @param dir the path to the directory to stream.\n     * @param pathFilter the directory stream filter.\n     * @return a new instance.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n        return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n    }\n\n    /**\n     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes\n     * to the file.\n     *\n     * @param path the Path.\n     * @param append Whether or not to append.\n     *\n     * @return a new OutputStream.\n     * @throws IOException if an I/O error occurs.\n     * @see Files#newOutputStream(Path, OpenOption...)\n     * @since 2.12.0\n     */\n    public static OutputStream newOutputStream(final Path path, final boolean append) throws IOException {\n        // @formatter:off\n        return Files.newOutputStream(path, append ?\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.APPEND} :\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING});\n        // @formatter:on\n    }\n\n    private static boolean notExists(final Path file) {\n        return Files.notExists(Objects.requireNonNull(file, \"file\"));\n    }\n\n    /**\n     * Returns true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     *\n     * @param deleteOptions the array to test\n     * @return true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     */\n    private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n        if (deleteOptions == null) {\n            return false;\n        }\n        return Stream.of(deleteOptions).anyMatch(e -> e == StandardDeleteOption.OVERRIDE_READ_ONLY);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)}\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n        return Files.readAttributes(path, BasicFileAttributes.class);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)} while wrapping {@link IOException} as\n     * {@link UncheckedIOException}.\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws UncheckedIOException if an I/O error occurs\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n        try {\n            return readBasicFileAttributes(path);\n        } catch (final IOException e) {\n            throw UncheckedIOExceptions.create(path, e);\n        }\n    }\n\n    /**\n     * Reads the given path as a String.\n     *\n     * @param path The source path.\n     * @param charset How to convert bytes to a String, null uses the default Charset.\n     * @return a new String.\n     * @throws IOException if an I/O error occurs reading from the stream.\n     * @see Files#readAllBytes(Path)\n     * @since 2.12.0\n     */\n    public static String readString(final Path path, final Charset charset) throws IOException {\n        return new String(Files.readAllBytes(path), Charsets.toCharset(charset));\n    }\n\n    /**\n     * Relativizes all files in the given {@code collection} against a {@code parent}.\n     *\n     * @param collection The collection of paths to relativize.\n     * @param parent relativizes against this parent path.\n     * @param sort Whether to sort the result.\n     * @param comparator How to sort.\n     * @return A collection of relativized paths, optionally sorted.\n     */\n    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n        Stream<Path> stream = collection.stream().map(parent::relativize);\n        if (sort) {\n            stream = comparator == null ? stream.sorted() : stream.sorted(comparator);\n        }\n        return stream.collect(Collectors.toList());\n    }\n\n    /**\n     * Sets the last modified time of the given file path to now.\n     *\n     * @param path The file path to set.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path path) throws IOException {\n        Files.setLastModifiedTime(path, FileTime.from(Instant.now()));\n    }\n\n    /**\n     * Sets the given {@code targetFile}'s last modified time to the value from {@code sourceFile}.\n     *\n     * @param sourceFile The source path to query.\n     * @param targetFile The target path to set.\n     * @throws NullPointerException if sourceFile is {@code null}.\n     * @throws NullPointerException if targetFile is {@code null}.\n     * @throws IOException if setting the last-modified time failed.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path sourceFile, final Path targetFile) throws IOException {\n        Objects.requireNonNull(sourceFile, \"sourceFile\");\n        Files.setLastModifiedTime(targetFile, getLastModifiedTime(sourceFile));\n    }\n\n    /**\n     * Sets the given Path to the {@code readOnly} value.\n     * <p>\n     * This behavior is OS dependent.\n     * </p>\n     *\n     * @param path The path to set.\n     * @param readOnly true for read-only, false for not read-only.\n     * @param linkOptions options indicating how symbolic links are handled.\n     * @return The given path.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        final List<Exception> causeList = new ArrayList<>(2);\n        final DosFileAttributeView fileAttributeView = Files.getFileAttributeView(path, DosFileAttributeView.class, linkOptions);\n        if (fileAttributeView != null) {\n            try {\n                fileAttributeView.setReadOnly(readOnly);\n                return path;\n            } catch (final IOException e) {\n                // ignore for now, retry with PosixFileAttributeView\n                causeList.add(e);\n            }\n        }\n        final PosixFileAttributeView posixFileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class, linkOptions);\n        if (posixFileAttributeView != null) {\n            // Works on Windows but not on Ubuntu:\n            // Files.setAttribute(path, \"unix:readonly\", readOnly, options);\n            // java.lang.IllegalArgumentException: 'unix:readonly' not recognized\n            final PosixFileAttributes readAttributes = posixFileAttributeView.readAttributes();\n            final Set<PosixFilePermission> permissions = readAttributes.permissions();\n            permissions.remove(PosixFilePermission.OWNER_WRITE);\n            permissions.remove(PosixFilePermission.GROUP_WRITE);\n            permissions.remove(PosixFilePermission.OTHERS_WRITE);\n            try {\n                return Files.setPosixFilePermissions(path, permissions);\n            } catch (final IOException e) {\n                causeList.add(e);\n            }\n        }\n        if (!causeList.isEmpty()) {\n            throw new IOExceptionList(path.toString(), causeList);\n        }\n        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(linkOptions)));\n    }\n\n    /**\n     * Returns the size of the specified file or directory. If the provided {@link File} is a regular file, then the file's\n     * length is returned. If the argument is a directory, then the size of the directory is calculated recursively. If a\n     * directory or subdirectory is security restricted, its size will not be included.\n     * <p>\n     * Note that overflow is not detected, and the return value may be negative if overflow occurs. See\n     * {@link #sizeOfAsBigInteger(Path)} for an alternative method that does not overflow.\n     * </p>\n     *\n     * @param path the regular file or directory to return the size of (must not be {@code null}).\n     * @return the length of the file, or recursive size of the directory, provided (in bytes).\n     * @throws NullPointerException if the file is {@code null}.\n     * @throws IllegalArgumentException if the file does not exist.\n     * @throws IOException if an I/O error occurs.\n     *\n     * @since 2.12.0\n     */\n    public static long sizeOf(final Path path) throws IOException {\n        requireExists(path, \"path\");\n        return Files.isDirectory(path) ? sizeOfDirectory(path) : Files.size(path);\n    }\n\n    /**\n     * Returns the size of the specified file or directory. If the provided {@link Path} is a regular file, then the file's\n     * length is returned. If the argument is a directory, then the size of the directory is calculated recursively. If a\n     * directory or subdirectory is security restricted, its size will not be included.\n     *\n     * @param path the regular file or directory to return the size of (must not be {@code null}).\n     * @return the length of the file, or recursive size of the directory, provided (in bytes).\n     * @throws NullPointerException if the file is {@code null}.\n     * @throws IllegalArgumentException if the file does not exist.\n     * @throws IOException if an I/O error occurs.\n     *\n     * @since 2.12.0\n     */\n    public static BigInteger sizeOfAsBigInteger(final Path path) throws IOException {\n        requireExists(path, \"path\");\n        return Files.isDirectory(path) ? sizeOfDirectoryAsBigInteger(path) : BigInteger.valueOf(Files.size(path));\n    }\n\n    /**\n     * Counts the size of a directory recursively (sum of the length of all files).\n     * <p>\n     * Note that overflow is not detected, and the return value may be negative if overflow occurs. See\n     * {@link #sizeOfDirectoryAsBigInteger(Path)} for an alternative method that does not overflow.\n     * </p>\n     *\n     * @param directory directory to inspect, must not be {@code null}.\n     * @return size of directory in bytes, 0 if directory is security restricted, a negative number when the real total is\n     *         greater than {@link Long#MAX_VALUE}.\n     * @throws NullPointerException if the directory is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static long sizeOfDirectory(final Path directory) throws IOException {\n        return countDirectory(directory).getByteCounter().getLong();\n    }\n\n    /**\n     * Counts the size of a directory recursively (sum of the length of all files).\n     *\n     * @param directory directory to inspect, must not be {@code null}.\n     * @return size of directory in bytes, 0 if directory is security restricted.\n     * @throws NullPointerException if the directory is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static BigInteger sizeOfDirectoryAsBigInteger(final Path directory) throws IOException {\n        return countDirectoryAsBigInteger(directory).getByteCounter().getBigInteger();\n    }\n\n    /**\n     * Requires that the given {@code File} exists and throws an {@link IllegalArgumentException} if it doesn't.\n     *\n     * @param file The {@code File} to check.\n     * @param fileParamName The parameter name to use in the exception message in case of {@code null} input.\n     * @return the given file.\n     * @throws NullPointerException if the given {@code File} is {@code null}.\n     * @throws IllegalArgumentException if the given {@code File} does not exist.\n     */\n    private static Path requireExists(final Path file, final String fileParamName) {\n        Objects.requireNonNull(file, fileParamName);\n        if (!Files.exists(file)) {\n            throw new IllegalArgumentException(\"File system element for parameter '\" + fileParamName + \"' does not exist: '\" + file + \"'\");\n        }\n        return file;\n    }\n\n    /**\n     * Converts an array of {@link FileVisitOption} to a {@link Set}.\n     *\n     * @param fileVisitOptions input array.\n     * @return a new Set.\n     */\n    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n        return fileVisitOptions == null ? EnumSet.noneOf(FileVisitOption.class) : Stream.of(fileVisitOptions).collect(Collectors.toSet());\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n        requireExists(directory, \"directory\");\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param start See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param options See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param visitor See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options,\n        final int maxDepth) throws IOException {\n        Files.walkFileTree(start, options, maxDepth, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param first See {@link Paths#get(String,String[])}.\n     * @param more See {@link Paths#get(String,String[])}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param uri See {@link Paths#get(URI)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }\n\n    /**\n     * Waits for the file system to propagate a file creation, with a timeout.\n     * <p>\n     * This method repeatedly tests {@link Files#exists(Path,LinkOption...)} until it returns true up to the maximum time\n     * specified.\n     * </p>\n     *\n     * @param file the file to check, must not be {@code null}.\n     * @param timeout the maximum time to wait.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if file exists.\n     * @throws NullPointerException if the file is {@code null}.\n     * @since 2.12.0\n     */\n    public static boolean waitFor(final Path file, final Duration timeout, final LinkOption... options) {\n        Objects.requireNonNull(file, \"file\");\n        final Instant finishInstant = Instant.now().plus(timeout);\n        boolean interrupted = false;\n        final long minSleepMillis = 100;\n        try {\n            while (!Files.exists(file, options)) {\n                final Instant now = Instant.now();\n                if (now.isAfter(finishInstant)) {\n                    return false;\n                }\n                try {\n                    Thread.sleep(Math.min(minSleepMillis, finishInstant.minusMillis(now.toEpochMilli()).toEpochMilli()));\n                } catch (final InterruptedException ignore) {\n                    interrupted = true;\n                } catch (final Exception ex) {\n                    break;\n                }\n            }\n        } finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        return Files.exists(file, options);\n    }\n\n    /**\n     * Returns a stream of filtered paths.\n     *\n     * @param start the start path\n     * @param pathFilter the path filter\n     * @param maxDepth the maximum depth of directories to walk.\n     * @param readAttributes whether to call the filters with file attributes (false passes null).\n     * @param options the options to configure the walk.\n     * @return a filtered stream of paths.\n     * @throws IOException if an I/O error is thrown when accessing the starting file.\n     * @since 2.9.0\n     */\n    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,\n        final FileVisitOption... options) throws IOException {\n        return Files.walk(start, maxDepth, options)\n            .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n    }\n\n    /**\n     * Does allow to instantiate.\n     */\n    private PathUtils() {\n        // do not instantiate.\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/file/PathUtils.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.CopyOption;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.NotDirectoryException;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.chrono.ChronoZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOExceptionList;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.UncheckedIOExceptions;\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.IOFileFilter;\n\n/**\n * NIO Path utilities.\n *\n * @since 2.7\n */\npublic final class PathUtils {\n\n    /**\n     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative\n     * lists when comparing directories.\n     */\n    private static class RelativeSortedPaths {\n\n        final boolean equals;\n        // final List<Path> relativeDirList1; // might need later?\n        // final List<Path> relativeDirList2; // might need later?\n        final List<Path> relativeFileList1;\n        final List<Path> relativeFileList2;\n\n        /**\n         * Constructs and initializes a new instance by accumulating directory and file info.\n         *\n         * @param dir1 First directory to compare.\n         * @param dir2 Seconds directory to compare.\n         * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @param linkOptions Options indicating how symbolic links are handled.\n         * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @throws IOException if an I/O error is thrown by a visitor method.\n         */\n        private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,\n            final FileVisitOption[] fileVisitOptions) throws IOException {\n            final List<Path> tmpRelativeDirList1;\n            final List<Path> tmpRelativeDirList2;\n            List<Path> tmpRelativeFileList1 = null;\n            List<Path> tmpRelativeFileList2 = null;\n            if (dir1 == null && dir2 == null) {\n                equals = true;\n            } else if (dir1 == null ^ dir2 == null) {\n                equals = false;\n            } else {\n                final boolean parentDirNotExists1 = Files.notExists(dir1, linkOptions);\n                final boolean parentDirNotExists2 = Files.notExists(dir2, linkOptions);\n                if (parentDirNotExists1 || parentDirNotExists2) {\n                    equals = parentDirNotExists1 && parentDirNotExists2;\n                } else {\n                    final AccumulatorPathVisitor visitor1 = accumulate(dir1, maxDepth, fileVisitOptions);\n                    final AccumulatorPathVisitor visitor2 = accumulate(dir2, maxDepth, fileVisitOptions);\n                    if (visitor1.getDirList().size() != visitor2.getDirList().size() || visitor1.getFileList().size() != visitor2.getFileList().size()) {\n                        equals = false;\n                    } else {\n                        tmpRelativeDirList1 = visitor1.relativizeDirectories(dir1, true, null);\n                        tmpRelativeDirList2 = visitor2.relativizeDirectories(dir2, true, null);\n                        if (!tmpRelativeDirList1.equals(tmpRelativeDirList2)) {\n                            equals = false;\n                        } else {\n                            tmpRelativeFileList1 = visitor1.relativizeFiles(dir1, true, null);\n                            tmpRelativeFileList2 = visitor2.relativizeFiles(dir2, true, null);\n                            equals = tmpRelativeFileList1.equals(tmpRelativeFileList2);\n                        }\n                    }\n                }\n            }\n            // relativeDirList1 = tmpRelativeDirList1;\n            // relativeDirList2 = tmpRelativeDirList2;\n            relativeFileList1 = tmpRelativeFileList1;\n            relativeFileList2 = tmpRelativeFileList2;\n        }\n    }\n\n    /**\n     * Empty {@link CopyOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final CopyOption[] EMPTY_COPY_OPTIONS = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final DeleteOption[] EMPTY_DELETE_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link FileVisitOption} array.\n     */\n    public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     */\n    public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY = {};\n\n    /**\n     * {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n     *\n     * @since 2.9.0\n     */\n    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = {LinkOption.NOFOLLOW_LINKS};\n\n    /**\n     * Empty {@link OpenOption} array.\n     */\n    public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link Path} array.\n     *\n     * @since 2.9.0\n     */\n    public static final Path[] EMPTY_PATH_ARRAY = {};\n\n    /**\n     * Accumulates file tree information in a {@link AccumulatorPathVisitor}.\n     *\n     * @param directory The directory to accumulate information.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @return file tree information.\n     */\n    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return cleanDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Compares the specified {@code Path}'s last modified time to the given file time.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return See {@link FileTime#compareTo(FileTime)}\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     */\n    private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        return getLastModifiedTime(file, options).compareTo(fileTime);\n    }\n\n    /**\n     * Copies a directory to another directory.\n     *\n     * @param sourceDirectory The source directory.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path absoluteSource = sourceDirectory.toAbsolutePath();\n        return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)\n            .getPathCounters();\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetFile The target file.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetFile, copyOptions);\n            return targetFile;\n        }\n    }\n\n    /**\n     * Copies a file to a directory.\n     *\n     * @param sourceFile The source file.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(Path, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n            return targetDirectory;\n        }\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(CountingPathVisitor.withLongCounters(), directory).getPathCounters();\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.12.0\n     */\n    public static PathCounters countDirectoryAsBigInteger(final Path directory) throws IOException {\n        return visitFileTree(CountingPathVisitor.withBigIntegerCounters(), directory).getPathCounters();\n    }\n\n    /**\n     * Creates the parent directories for the given {@code path}.\n     *\n     * @param path The path to a file (or directory).\n     * @param attrs An optional list of file attributes to set atomically when creating the directories.\n     * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static Path createParentDirectories(final Path path, final FileAttribute<?>... attrs) throws IOException {\n        final Path parent = path.getParent();\n        return parent == null ? null : Files.createDirectories(parent, attrs);\n    }\n\n    /**\n     * Gets the current directory.\n     *\n     * @return the current directory.\n     *\n     * @since 2.9.0\n     */\n    public static Path current() {\n        return Paths.get(\"\");\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     */\n    public static PathCounters delete(final Path path) throws IOException {\n        return delete(path, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return deleteDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions), directory)\n            .getPathCounters();\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     */\n    public static PathCounters deleteFile(final Path file) throws IOException {\n        return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n        // Files.deleteIfExists() never follows links, so use LinkOption.NOFOLLOW_LINKS in other calls to Files.\n        return deleteFile(file, NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)\n        throws NoSuchFileException, IOException {\n        if (Files.isDirectory(file, linkOptions)) {\n            throw new NoSuchFileException(file.toString());\n        }\n        final PathCounters pathCounts = Counters.longPathCounters();\n        final boolean exists = exists(file, linkOptions);\n        final long size = exists && !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n        if (overrideReadOnly(deleteOptions) && exists) {\n            setReadOnly(file, false, linkOptions);\n        }\n        if (Files.deleteIfExists(file)) {\n            pathCounts.getFileCounter().increment();\n            pathCounts.getByteCounter().add(size);\n        }\n        return pathCounts;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryAndFileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param linkOptions options to follow links.\n     * @param openOptions options to open files.\n     * @param fileVisitOption options to configure traversal.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,\n        final FileVisitOption[] fileVisitOption) throws IOException {\n        // First walk both file trees and gather normalized paths.\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        if (notExists(path1) && notExists(path2)) {\n            return true;\n        }\n        final RelativeSortedPaths relativeSortedPaths = new RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption);\n        // If the normalized path names and counts are not the same, no need to compare contents.\n        if (!relativeSortedPaths.equals) {\n            return false;\n        }\n        // Both visitors contain the same normalized paths, we can compare file contents.\n        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n        for (final Path path : fileList1) {\n            final int binarySearch = Collections.binarySearch(fileList2, path);\n            if (binarySearch <= -1) {\n                throw new IllegalStateException(\"Unexpected mismatch.\");\n            }\n            if (!fileContentEquals(path1.resolve(path), path2.resolve(path), linkOptions, openOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, EMPTY_LINK_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param linkOptions options to follow links.\n     * @param fileVisitOptions options to configure the traversal\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,\n        final FileVisitOption[] fileVisitOptions) throws IOException {\n        return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;\n    }\n\n    private static boolean exists(final Path path, final LinkOption... options) {\n        return Files.exists(Objects.requireNonNull(path, \"path\"), options);\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n        return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = exists(nPath1, linkOptions);\n        if (path1Exists != exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\n\n    /**\n     * <p>\n     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original\n     * file list that matches the provided filter.\n     * </p>\n     *\n     * <p>\n     * The {@link Set} returned by this method is not guaranteed to be thread safe.\n     * </p>\n     *\n     * <pre>\n     * Set&lt;File&gt; allFiles = ...\n     * Set&lt;File&gt; javaFiles = FileFilterUtils.filterSet(allFiles,\n     *     FileFilterUtils.suffixFileFilter(\".java\"));\n     * </pre>\n     *\n     * @param filter the filter to apply to the set of files.\n     * @param paths the array of files to apply the filter to.\n     *\n     * @return a subset of {@code files} that is accepted by the file filter.\n     * @throws IllegalArgumentException if the filter is {@code null} or {@code files} contains a {@code null} value.\n     *\n     * @since 2.9.0\n     */\n    public static Path[] filter(final PathFilter filter, final Path... paths) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (paths == null) {\n            return EMPTY_PATH_ARRAY;\n        }\n        return filterPaths(filter, Stream.of(paths), Collectors.toList()).toArray(EMPTY_PATH_ARRAY);\n    }\n\n    private static <R, A> R filterPaths(final PathFilter filter, final Stream<Path> stream, final Collector<? super Path, A, R> collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream == null) {\n            return Stream.<Path>empty().collect(collector);\n        }\n        return stream.filter(p -> {\n            try {\n                return p != null && filter.accept(p, readBasicFileAttributes(p)) == FileVisitResult.CONTINUE;\n            } catch (final IOException e) {\n                return false;\n            }\n        }).collect(collector);\n    }\n\n    /**\n     * Reads the access control list from a file attribute view.\n     *\n     * @param sourcePath the path to the file.\n     * @return a file attribute view of the specified type, or null if the attribute view type is not available.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOException {\n        final AclFileAttributeView fileAttributeView = Files.getFileAttributeView(sourcePath, AclFileAttributeView.class);\n        return fileAttributeView == null ? null : fileAttributeView.getAcl();\n    }\n\n    private static FileTime getLastModifiedTime(final Path path, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(Objects.requireNonNull(path, \"path\"), options);\n    }\n\n    /**\n     * Returns a {@link Path} representing the system temporary directory.\n     *\n     * @return the system temporary directory.\n     *\n     * @since 2.12.0\n     */\n    public static Path getTempDirectory() {\n        return Paths.get(FileUtils.getTempDirectoryPath());\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a directory or not. Implemented as a null-safe delegate to\n     * {@code Files.isDirectory(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a\n     *         directory, or it cannot be determined if the file is a directory or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isDirectory(final Path path, final LinkOption... options) {\n        return path != null && Files.isDirectory(path, options);\n    }\n\n    /**\n     * Tests whether the given file or directory is empty.\n     *\n     * @param path the file or directory to query.\n     * @return whether the file or directory is empty.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }\n\n    /**\n     * Tests whether the directory is empty.\n     *\n     * @param directory the directory to query.\n     * @return whether the directory is empty.\n     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <i>(optional\n     *         specific exception)</i>.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     */\n    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n            return !directoryStream.iterator().hasNext();\n        }\n    }\n\n    /**\n     * Tests whether the given file is empty.\n     *\n     * @param file the file to query.\n     * @return whether the file is empty.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, its\n     *         {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.\n     */\n    public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) <= 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param czdt the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final ChronoZonedDateTime<?> czdt, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(czdt, \"czdt\");\n        return isNewer(file, czdt.toInstant(), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) > 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.from(instant), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the reference {@code Path}.\n     *\n     * @param file      the {@code File} of which the modification date must be compared.\n     * @param reference the {@code File} of which the modification date is used.\n     * @return true if the {@code File} exists and has been modified more\n     * recently than the reference {@code File}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Path reference) throws IOException {\n        return isNewer(file, getLastModifiedTime(reference));\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared.\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified before the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) < 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared.\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isOlder(file, FileTime.from(instant), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified before the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isOlder(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the reference {@code Path}.\n     *\n     * @param file the {@code File} of which the modification date must be compared.\n     * @param reference the {@code File} of which the modification date is used.\n     * @return true if the {@code File} exists and has been modified before than the reference {@code File}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final Path reference) throws IOException {\n        return isOlder(file, getLastModifiedTime(reference));\n    }\n\n\n    /**\n     * Tests whether the specified {@code Path} is a regular file or not. Implemented as a null-safe delegate to\n     * {@code Files.isRegularFile(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is\n     *         not a directory, or it cannot be determined if the file is a regular file or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isRegularFile(final Path path, final LinkOption... options) {\n        return path != null && Files.isRegularFile(path, options);\n    }\n\n    /**\n     * Creates a new DirectoryStream for Paths rooted at the given directory.\n     *\n     * @param dir the path to the directory to stream.\n     * @param pathFilter the directory stream filter.\n     * @return a new instance.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n        return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n    }\n\n    /**\n     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes\n     * to the file.\n     *\n     * @param path the Path.\n     * @param append Whether or not to append.\n     *\n     * @return a new OutputStream.\n     * @throws IOException if an I/O error occurs.\n     * @see Files#newOutputStream(Path, OpenOption...)\n     * @since 2.12.0\n     */\n    public static OutputStream newOutputStream(final Path path, final boolean append) throws IOException {\n        Objects.requireNonNull(path, \"path\");\n        if (exists(path)) {\n            // requireFile(path, \"path\");\n            // requireCanWrite(path, \"path\");\n        } else {\n            createParentDirectories(path);\n        }\n        // @formatter:off\n        return Files.newOutputStream(path, append ?\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.APPEND} :\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING});\n        // @formatter:on\n    }\n\n    private static boolean notExists(final Path path, final LinkOption... options) {\n        return Files.notExists(Objects.requireNonNull(path, \"path\"), options);\n    }\n\n    /**\n     * Returns true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     *\n     * @param deleteOptions the array to test\n     * @return true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     */\n    private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n        if (deleteOptions == null) {\n            return false;\n        }\n        return Stream.of(deleteOptions).anyMatch(e -> e == StandardDeleteOption.OVERRIDE_READ_ONLY);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)}\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n        return Files.readAttributes(path, BasicFileAttributes.class);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)} while wrapping {@link IOException} as\n     * {@link UncheckedIOException}.\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws UncheckedIOException if an I/O error occurs\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n        try {\n            return readBasicFileAttributes(path);\n        } catch (final IOException e) {\n            throw UncheckedIOExceptions.create(path, e);\n        }\n    }\n\n    /**\n     * Reads the given path as a String.\n     *\n     * @param path The source path.\n     * @param charset How to convert bytes to a String, null uses the default Charset.\n     * @return a new String.\n     * @throws IOException if an I/O error occurs reading from the stream.\n     * @see Files#readAllBytes(Path)\n     * @since 2.12.0\n     */\n    public static String readString(final Path path, final Charset charset) throws IOException {\n        return new String(Files.readAllBytes(path), Charsets.toCharset(charset));\n    }\n\n    /**\n     * Relativizes all files in the given {@code collection} against a {@code parent}.\n     *\n     * @param collection The collection of paths to relativize.\n     * @param parent relativizes against this parent path.\n     * @param sort Whether to sort the result.\n     * @param comparator How to sort.\n     * @return A collection of relativized paths, optionally sorted.\n     */\n    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n        Stream<Path> stream = collection.stream().map(parent::relativize);\n        if (sort) {\n            stream = comparator == null ? stream.sorted() : stream.sorted(comparator);\n        }\n        return stream.collect(Collectors.toList());\n    }\n\n    /**\n     * Throws an {@link IllegalArgumentException} if the file is not writable. This provides a more precise exception\n     * message than a plain access denied.\n     *\n     * @param file The file to test.\n     * @param name The parameter name to use in the exception message.\n     * @throws NullPointerException if the given {@code Path} is {@code null}.\n     * @throws IllegalArgumentException if the file is not writable.\n     */\n    private static void requireCanWrite(final Path file, final String name) {\n        Objects.requireNonNull(file, \"file\");\n        if (!Files.isWritable(file)) {\n            throw new IllegalArgumentException(\"File parameter '\" + name + \" is not writable: '\" + file + \"'\");\n        }\n    }\n\n    /**\n     * Requires that the given {@code File} exists and throws an {@link IllegalArgumentException} if it doesn't.\n     *\n     * @param file The {@code File} to check.\n     * @param fileParamName The parameter name to use in the exception message in case of {@code null} input.\n     * @param options options indicating how symbolic links are handled.\n     * @return the given file.\n     * @throws NullPointerException if the given {@code File} is {@code null}.\n     * @throws IllegalArgumentException if the given {@code File} does not exist.\n     */\n    private static Path requireExists(final Path file, final String fileParamName, final LinkOption... options) {\n        Objects.requireNonNull(file, fileParamName);\n        if (!exists(file, options)) {\n            throw new IllegalArgumentException(\"File system element for parameter '\" + fileParamName + \"' does not exist: '\" + file + \"'\");\n        }\n        return file;\n    }\n\n    /**\n     * Requires that the given {@code Path} is a regular file.\n     *\n     * @param file The {@code Path} to check.\n     * @param name The parameter name to use in the exception message.\n     * @return the given file.\n     * @throws NullPointerException if the given {@code Path} is {@code null}.\n     * @throws IllegalArgumentException if the given {@code Path} does not exist or is not a regular file.\n     */\n    private static Path requireFile(final Path file, final String name) {\n        Objects.requireNonNull(file, name);\n        if (!Files.isRegularFile(file)) {\n            throw new IllegalArgumentException(\"Parameter '\" + name + \"' is not a regular file: \" + file);\n        }\n        return file;\n    }\n\n    /**\n     * Sets the last modified time of the given file path to now.\n     *\n     * @param path The file path to set.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path path) throws IOException {\n        Files.setLastModifiedTime(path, FileTime.from(Instant.now()));\n    }\n\n    /**\n     * Sets the given {@code targetFile}'s last modified time to the value from {@code sourceFile}.\n     *\n     * @param sourceFile The source path to query.\n     * @param targetFile The target path to set.\n     * @throws NullPointerException if sourceFile is {@code null}.\n     * @throws NullPointerException if targetFile is {@code null}.\n     * @throws IOException if setting the last-modified time failed.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path sourceFile, final Path targetFile) throws IOException {\n        Objects.requireNonNull(sourceFile, \"sourceFile\");\n        Files.setLastModifiedTime(targetFile, getLastModifiedTime(sourceFile));\n    }\n\n    /**\n     * Sets the given Path to the {@code readOnly} value.\n     * <p>\n     * This behavior is OS dependent.\n     * </p>\n     *\n     * @param path The path to set.\n     * @param readOnly true for read-only, false for not read-only.\n     * @param linkOptions options indicating how symbolic links are handled.\n     * @return The given path.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        final List<Exception> causeList = new ArrayList<>(2);\n        final DosFileAttributeView fileAttributeView = Files.getFileAttributeView(path, DosFileAttributeView.class, linkOptions);\n        if (fileAttributeView != null) {\n            try {\n                fileAttributeView.setReadOnly(readOnly);\n                return path;\n            } catch (final IOException e) {\n                // ignore for now, retry with PosixFileAttributeView\n                causeList.add(e);\n            }\n        }\n        final PosixFileAttributeView posixFileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class, linkOptions);\n        if (posixFileAttributeView != null) {\n            // Works on Windows but not on Ubuntu:\n            // Files.setAttribute(path, \"unix:readonly\", readOnly, options);\n            // java.lang.IllegalArgumentException: 'unix:readonly' not recognized\n            final PosixFileAttributes readAttributes = posixFileAttributeView.readAttributes();\n            final Set<PosixFilePermission> permissions = readAttributes.permissions();\n            permissions.remove(PosixFilePermission.OWNER_WRITE);\n            permissions.remove(PosixFilePermission.GROUP_WRITE);\n            permissions.remove(PosixFilePermission.OTHERS_WRITE);\n            try {\n                return Files.setPosixFilePermissions(path, permissions);\n            } catch (final IOException e) {\n                causeList.add(e);\n            }\n        }\n        if (!causeList.isEmpty()) {\n            throw new IOExceptionList(path.toString(), causeList);\n        }\n        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(linkOptions)));\n    }\n\n    /**\n     * Returns the size of the specified file or directory. If the provided {@link File} is a regular file, then the file's\n     * length is returned. If the argument is a directory, then the size of the directory is calculated recursively.\n     * <p>\n     * Note that overflow is not detected, and the return value may be negative if overflow occurs. See\n     * {@link #sizeOfAsBigInteger(Path)} for an alternative method that does not overflow.\n     * </p>\n     *\n     * @param path the regular file or directory to return the size of (must not be {@code null}).\n     * @return the length of the file, or recursive size of the directory, provided (in bytes).\n     * @throws NullPointerException if the file is {@code null}.\n     * @throws IllegalArgumentException if the file does not exist.\n     * @throws IOException if an I/O error occurs.\n     *\n     * @since 2.12.0\n     */\n    public static long sizeOf(final Path path) throws IOException {\n        requireExists(path, \"path\");\n        return Files.isDirectory(path) ? sizeOfDirectory(path) : Files.size(path);\n    }\n\n    /**\n     * Returns the size of the specified file or directory. If the provided {@link Path} is a regular file, then the file's\n     * length is returned. If the argument is a directory, then the size of the directory is calculated recursively. If a\n     * directory or subdirectory is security restricted, its size will not be included.\n     *\n     * @param path the regular file or directory to return the size of (must not be {@code null}).\n     * @return the length of the file, or recursive size of the directory, provided (in bytes).\n     * @throws NullPointerException if the file is {@code null}.\n     * @throws IllegalArgumentException if the file does not exist.\n     * @throws IOException if an I/O error occurs.\n     *\n     * @since 2.12.0\n     */\n    public static BigInteger sizeOfAsBigInteger(final Path path) throws IOException {\n        requireExists(path, \"path\");\n        return Files.isDirectory(path) ? sizeOfDirectoryAsBigInteger(path) : BigInteger.valueOf(Files.size(path));\n    }\n\n    /**\n     * Counts the size of a directory recursively (sum of the length of all files).\n     * <p>\n     * Note that overflow is not detected, and the return value may be negative if overflow occurs. See\n     * {@link #sizeOfDirectoryAsBigInteger(Path)} for an alternative method that does not overflow.\n     * </p>\n     *\n     * @param directory directory to inspect, must not be {@code null}.\n     * @return size of directory in bytes, 0 if directory is security restricted, a negative number when the real total is\n     *         greater than {@link Long#MAX_VALUE}.\n     * @throws NullPointerException if the directory is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static long sizeOfDirectory(final Path directory) throws IOException {\n        return countDirectory(directory).getByteCounter().getLong();\n    }\n\n    /**\n     * Counts the size of a directory recursively (sum of the length of all files).\n     *\n     * @param directory directory to inspect, must not be {@code null}.\n     * @return size of directory in bytes, 0 if directory is security restricted.\n     * @throws NullPointerException if the directory is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static BigInteger sizeOfDirectoryAsBigInteger(final Path directory) throws IOException {\n        return countDirectoryAsBigInteger(directory).getByteCounter().getBigInteger();\n    }\n\n    /**\n     * Converts an array of {@link FileVisitOption} to a {@link Set}.\n     *\n     * @param fileVisitOptions input array.\n     * @return a new Set.\n     */\n    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n        return fileVisitOptions == null ? EnumSet.noneOf(FileVisitOption.class) : Stream.of(fileVisitOptions).collect(Collectors.toSet());\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n        requireExists(directory, \"directory\");\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param start See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param options See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param visitor See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options,\n        final int maxDepth) throws IOException {\n        Files.walkFileTree(start, options, maxDepth, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param first See {@link Paths#get(String,String[])}.\n     * @param more See {@link Paths#get(String,String[])}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param uri See {@link Paths#get(URI)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }\n\n    /**\n     * Waits for the file system to propagate a file creation, with a timeout.\n     * <p>\n     * This method repeatedly tests {@link Files#exists(Path,LinkOption...)} until it returns true up to the maximum time\n     * specified.\n     * </p>\n     *\n     * @param file the file to check, must not be {@code null}.\n     * @param timeout the maximum time to wait.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if file exists.\n     * @throws NullPointerException if the file is {@code null}.\n     * @since 2.12.0\n     */\n    public static boolean waitFor(final Path file, final Duration timeout, final LinkOption... options) {\n        Objects.requireNonNull(file, \"file\");\n        final Instant finishInstant = Instant.now().plus(timeout);\n        boolean interrupted = false;\n        final long minSleepMillis = 100;\n        try {\n            while (!exists(file, options)) {\n                final Instant now = Instant.now();\n                if (now.isAfter(finishInstant)) {\n                    return false;\n                }\n                try {\n                    Thread.sleep(Math.min(minSleepMillis, finishInstant.minusMillis(now.toEpochMilli()).toEpochMilli()));\n                } catch (final InterruptedException ignore) {\n                    interrupted = true;\n                } catch (final Exception ex) {\n                    break;\n                }\n            }\n        } finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        return Files.exists(file, options);\n    }\n\n    /**\n     * Returns a stream of filtered paths.\n     *\n     * @param start the start path\n     * @param pathFilter the path filter\n     * @param maxDepth the maximum depth of directories to walk.\n     * @param readAttributes whether to call the filters with file attributes (false passes null).\n     * @param options the options to configure the walk.\n     * @return a filtered stream of paths.\n     * @throws IOException if an I/O error is thrown when accessing the starting file.\n     * @since 2.9.0\n     */\n    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,\n        final FileVisitOption... options) throws IOException {\n        return Files.walk(start, maxDepth, options)\n            .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n    }\n\n    /**\n     * Does allow to instantiate.\n     */\n    private PathUtils() {\n        // do not instantiate.\n    }\n\n}\n", "diffSourceCodeSet": ["private static boolean exists(final Path path, final LinkOption... options) {\n        return Files.exists(Objects.requireNonNull(path, \"path\"), options);\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.FileUtils#isDirectory\n methodBody: public static boolean isDirectory(final File file, final LinkOption... options) {\nreturn file != null && Files.isDirectory(file.toPath(),options);\n}", "methodSignature: org.apache.commons.io.FileUtils#contentEquals\n methodBody: public static boolean contentEquals(final File file1, final File file2) throws IOException {\nif(file1 == null && file2 == null){return true;\n}if(file1 == null || file2 == null){return false;\n}final boolean file1Exists=file1.exists();\nif(file1Exists != file2.exists()){return false;\n}if(!file1Exists){return true;\n}requireFile(file1,\"file1\");\nrequireFile(file2,\"file2\");\nif(file1.length() != file2.length()){return false;\n}if(file1.getCanonicalFile().equals(file2.getCanonicalFile())){return true;\n}try(InputStream input1=Files.newInputStream(file1.toPath()); InputStream input2=Files.newInputStream(file2.toPath()))return IOUtils.contentEquals(input1,input2);\n}", "methodSignature: org.apache.commons.io.file.PathUtils#isDirectory\n methodBody: public static boolean isDirectory(final Path path, final LinkOption... options) {\nreturn path != null && Files.isDirectory(path,options);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = exists(nPath1, linkOptions);\n        if (path1Exists != exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\nprivate static boolean exists(final Path path, final LinkOption... options) {\n        return Files.exists(Objects.requireNonNull(path, \"path\"), options);\n    }", "diffSourceCode": "-  595:     /**\n-  596:      * Compares the file contents of two Paths to determine if they are equal or not.\n-  597:      * <p>\n-  612:     /**\n-  613:      * Compares the file contents of two Paths to determine if they are equal or not.\n-  614:      * <p>\n-  615:      * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n-  616:      * </p>\n-  617:      *\n-  618:      * @param path1 the first stream.\n-  619:      * @param path2 the second stream.\n-  620:      * @param linkOptions options specifying how files are followed.\n-  621:      * @param openOptions options specifying how files are opened.\n-  622:      * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n-  623:      * @throws NullPointerException if either input is null.\n-  624:      * @throws IOException if an I/O error occurs.\n-  625:      * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n-  626:      */\n-  627:     public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n-  628:         throws IOException {\n-  629:         if (path1 == null && path2 == null) {\n-  630:             return true;\n-  631:         }\n-  632:         if (path1 == null || path2 == null) {\n-  633:             return false;\n-  634:         }\n-  635:         final Path nPath1 = path1.normalize();\n-  636:         final Path nPath2 = path2.normalize();\n-  637:         final boolean path1Exists = Files.exists(nPath1, linkOptions);\n-  638:         if (path1Exists != Files.exists(nPath2, linkOptions)) {\n-  639:             return false;\n-  640:         }\n-  641:         if (!path1Exists) {\n-  642:             // Two not existing files are equal?\n-  643:             // Same as FileUtils\n-  644:             return true;\n-  645:         }\n-  646:         if (Files.isDirectory(nPath1, linkOptions)) {\n-  647:             // don't compare directory contents.\n-  648:             throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n+  595:     private static boolean exists(final Path path, final LinkOption... options) {\n+  596:         return Files.exists(Objects.requireNonNull(path, \"path\"), options);\n+  597:     }\n+  612:     public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n+  613:         return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n+  614:     }\n+  615: \n+  616:     /**\n+  617:      * Compares the file contents of two Paths to determine if they are equal or not.\n+  618:      * <p>\n+  619:      * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n+  620:      * </p>\n+  621:      *\n+  622:      * @param path1 the first stream.\n+  623:      * @param path2 the second stream.\n+  624:      * @param linkOptions options specifying how files are followed.\n+  625:      * @param openOptions options specifying how files are opened.\n+  626:      * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n+  627:      * @throws NullPointerException if either input is null.\n+  628:      * @throws IOException if an I/O error occurs.\n+  629:      * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n+  630:      */\n+  631:     public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n+  632:         throws IOException {\n+  633:         if (path1 == null && path2 == null) {\n+  634:             return true;\n+  635:         }\n+  636:         if (path1 == null || path2 == null) {\n+  637:             return false;\n+  638:         }\n+  639:         final Path nPath1 = path1.normalize();\n+  640:         final Path nPath2 = path2.normalize();\n+  641:         final boolean path1Exists = exists(nPath1, linkOptions);\n+  642:         if (path1Exists != exists(nPath2, linkOptions)) {\n+  643:             return false;\n+  644:         }\n+  645:         if (!path1Exists) {\n+  646:             // Two not existing files are equal?\n+  647:             // Same as FileUtils\n+  648:             return true;\n   649:         }\n-  650:         if (Files.isDirectory(nPath2, linkOptions)) {\n+  650:         if (Files.isDirectory(nPath1, linkOptions)) {\n   651:             // don't compare directory contents.\n-  652:             throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n+  652:             throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n   653:         }\n-  654:         if (Files.size(nPath1) != Files.size(nPath2)) {\n-  655:             // lengths differ, cannot be equal\n-  656:             return false;\n+  654:         if (Files.isDirectory(nPath2, linkOptions)) {\n+  655:             // don't compare directory contents.\n+  656:             throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n   657:         }\n-  658:         if (path1.equals(path2)) {\n-  659:             // same file\n-  660:             return true;\n+  658:         if (Files.size(nPath1) != Files.size(nPath2)) {\n+  659:             // lengths differ, cannot be equal\n+  660:             return false;\n   661:         }\n-  662:         try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n-  663:             final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n-  664:             return IOUtils.contentEquals(inputStream1, inputStream2);\n+  662:         if (path1.equals(path2)) {\n+  663:             // same file\n+  664:             return true;\n   665:         }\n-  666:     }\n-  667: \n-  668:     /**\n-  669:      * <p>\n-  670:      * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original\n+  666:         try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n+  667:             final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n+  668:             return IOUtils.contentEquals(inputStream1, inputStream2);\n+  669:         }\n+  670:     }\n", "uniqueId": "1e73dd92a2224828dd45f47ae8e96a8c0cd2d3d8_612_666_595_597_616_670", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 14, "covered": 79}, "BRANCH": {"missed": 2, "covered": 18}, "LINE": {"missed": 2, "covered": 20}, "COMPLEXITY": {"missed": 2, "covered": 9}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `fileContentEquals` method, we can extract some of its logic into smaller, more focused methods. This will help to clarify the purpose of each part of the code and make it easier to test and maintain.\n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n##########################\nprivate static boolean areBothPathsNull(final Path path1, final Path path2) {\n    return path1 == null && path2 == null;\n}\n\nprivate static boolean isOnePathNull(final Path path1, final Path path2) {\n    return path1 == null || path2 == null;\n}\n\nprivate static boolean arePathsEqual(final Path nPath1, final Path nPath2, final LinkOption[] linkOptions) throws IOException {\n    return Files.exists(nPath1, linkOptions) == Files.exists(nPath2, linkOptions);\n}\n\nprivate static boolean areBothPathsDirectories(final Path nPath1, final Path nPath2, final LinkOption[] linkOptions) throws IOException {\n    return Files.isDirectory(nPath1, linkOptions) || Files.isDirectory(nPath2, linkOptions);\n}\n\npublic static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n    if (areBothPathsNull(path1, path2)) {\n        return true;\n    }\n    if (isOnePathNull(path1, path2)) {\n        return false;\n    }\n    final Path nPath1 = path1.normalize();\n    final Path nPath2 = path2.normalize();\n\n    if (!arePathsEqual(nPath1, nPath2, linkOptions)) {\n        return false;\n    }\n    if (!Files.exists(nPath1, linkOptions)) {\n        return true; // Both paths do not exist\n    }\n    if (areBothPathsDirectories(nPath1, nPath2, linkOptions)) {\n        throw new IOException(\"Can't compare directories, only files: \" + nPath1 + \" and \" + nPath2);\n    }\n    if (Files.size(nPath1) != Files.size(nPath2)) {\n        return false; // Lengths differ\n    }\n    if (path1.equals(path2)) {\n        return true; // Same file\n    }\n    try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n         final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n        return IOUtils.contentEquals(inputStream1, inputStream2);\n    }\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Methods**:\n   - `areBothPathsNull`: Checks if both paths are null.\n   - `isOnePathNull`: Checks if one of the paths is null.\n   - `arePathsEqual`: Checks if both paths exist.\n   - `areBothPathsDirectories`: Checks if either path is a directory.\n\n2. **Refactored Logic**: The main `fileContentEquals` method now reads more clearly, as it delegates specific checks to the extracted methods, making the code easier to follow and maintain.\n\nThis refactoring enhances the modularity of the code, allowing for easier testing of individual components.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.CopyOption;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.NotDirectoryException;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.chrono.ChronoZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOExceptionList;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.UncheckedIOExceptions;\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.IOFileFilter;\n\n/**\n * NIO Path utilities.\n *\n * @since 2.7\n */\npublic final class PathUtils {\n\n    /**\n     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative\n     * lists when comparing directories.\n     */\n    private static class RelativeSortedPaths {\n\n        final boolean equals;\n        // final List<Path> relativeDirList1; // might need later?\n        // final List<Path> relativeDirList2; // might need later?\n        final List<Path> relativeFileList1;\n        final List<Path> relativeFileList2;\n\n        /**\n         * Constructs and initializes a new instance by accumulating directory and file info.\n         *\n         * @param dir1 First directory to compare.\n         * @param dir2 Seconds directory to compare.\n         * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @param linkOptions Options indicating how symbolic links are handled.\n         * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @throws IOException if an I/O error is thrown by a visitor method.\n         */\n        private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,\n            final FileVisitOption[] fileVisitOptions) throws IOException {\n            final List<Path> tmpRelativeDirList1;\n            final List<Path> tmpRelativeDirList2;\n            List<Path> tmpRelativeFileList1 = null;\n            List<Path> tmpRelativeFileList2 = null;\n            if (dir1 == null && dir2 == null) {\n                equals = true;\n            } else if (dir1 == null ^ dir2 == null) {\n                equals = false;\n            } else {\n                final boolean parentDirNotExists1 = Files.notExists(dir1, linkOptions);\n                final boolean parentDirNotExists2 = Files.notExists(dir2, linkOptions);\n                if (parentDirNotExists1 || parentDirNotExists2) {\n                    equals = parentDirNotExists1 && parentDirNotExists2;\n                } else {\n                    final AccumulatorPathVisitor visitor1 = accumulate(dir1, maxDepth, fileVisitOptions);\n                    final AccumulatorPathVisitor visitor2 = accumulate(dir2, maxDepth, fileVisitOptions);\n                    if (visitor1.getDirList().size() != visitor2.getDirList().size() || visitor1.getFileList().size() != visitor2.getFileList().size()) {\n                        equals = false;\n                    } else {\n                        tmpRelativeDirList1 = visitor1.relativizeDirectories(dir1, true, null);\n                        tmpRelativeDirList2 = visitor2.relativizeDirectories(dir2, true, null);\n                        if (!tmpRelativeDirList1.equals(tmpRelativeDirList2)) {\n                            equals = false;\n                        } else {\n                            tmpRelativeFileList1 = visitor1.relativizeFiles(dir1, true, null);\n                            tmpRelativeFileList2 = visitor2.relativizeFiles(dir2, true, null);\n                            equals = tmpRelativeFileList1.equals(tmpRelativeFileList2);\n                        }\n                    }\n                }\n            }\n            // relativeDirList1 = tmpRelativeDirList1;\n            // relativeDirList2 = tmpRelativeDirList2;\n            relativeFileList1 = tmpRelativeFileList1;\n            relativeFileList2 = tmpRelativeFileList2;\n        }\n    }\n\n    /**\n     * Empty {@link CopyOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final CopyOption[] EMPTY_COPY_OPTIONS = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final DeleteOption[] EMPTY_DELETE_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link FileVisitOption} array.\n     */\n    public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     */\n    public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY = {};\n\n    /**\n     * {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n     *\n     * @since 2.9.0\n     */\n    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = {LinkOption.NOFOLLOW_LINKS};\n\n    /**\n     * Empty {@link OpenOption} array.\n     */\n    public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link Path} array.\n     *\n     * @since 2.9.0\n     */\n    public static final Path[] EMPTY_PATH_ARRAY = {};\n\n    /**\n     * Accumulates file tree information in a {@link AccumulatorPathVisitor}.\n     *\n     * @param directory The directory to accumulate information.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @return file tree information.\n     */\n    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return cleanDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Compares the specified {@code Path}'s last modified time to the given file time.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return See {@link FileTime#compareTo(FileTime)}\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     */\n    private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        return getLastModifiedTime(file, options).compareTo(fileTime);\n    }\n\n    /**\n     * Copies a directory to another directory.\n     *\n     * @param sourceDirectory The source directory.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path absoluteSource = sourceDirectory.toAbsolutePath();\n        return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)\n            .getPathCounters();\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetFile The target file.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetFile, copyOptions);\n            return targetFile;\n        }\n    }\n\n    /**\n     * Copies a file to a directory.\n     *\n     * @param sourceFile The source file.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(Path, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n            return targetDirectory;\n        }\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(CountingPathVisitor.withLongCounters(), directory).getPathCounters();\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.12.0\n     */\n    public static PathCounters countDirectoryAsBigInteger(final Path directory) throws IOException {\n        return visitFileTree(CountingPathVisitor.withBigIntegerCounters(), directory).getPathCounters();\n    }\n\n    /**\n     * Creates the parent directories for the given {@code path}.\n     *\n     * @param path The path to a file (or directory).\n     * @param attrs An optional list of file attributes to set atomically when creating the directories.\n     * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static Path createParentDirectories(final Path path, final FileAttribute<?>... attrs) throws IOException {\n        final Path parent = path.getParent();\n        return parent == null ? null : Files.createDirectories(parent, attrs);\n    }\n\n    /**\n     * Gets the current directory.\n     *\n     * @return the current directory.\n     *\n     * @since 2.9.0\n     */\n    public static Path current() {\n        return Paths.get(\"\");\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     */\n    public static PathCounters delete(final Path path) throws IOException {\n        return delete(path, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return deleteDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions), directory)\n            .getPathCounters();\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     */\n    public static PathCounters deleteFile(final Path file) throws IOException {\n        return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n        // Files.deleteIfExists() never follows links, so use LinkOption.NOFOLLOW_LINKS in other calls to Files.\n        return deleteFile(file, NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)\n        throws NoSuchFileException, IOException {\n        if (Files.isDirectory(file, linkOptions)) {\n            throw new NoSuchFileException(file.toString());\n        }\n        final PathCounters pathCounts = Counters.longPathCounters();\n        final boolean exists = Files.exists(file, linkOptions);\n        final long size = exists && !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n        if (overrideReadOnly(deleteOptions) && exists) {\n            setReadOnly(file, false, linkOptions);\n        }\n        if (Files.deleteIfExists(file)) {\n            pathCounts.getFileCounter().increment();\n            pathCounts.getByteCounter().add(size);\n        }\n        return pathCounts;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryAndFileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param linkOptions options to follow links.\n     * @param openOptions options to open files.\n     * @param fileVisitOption options to configure traversal.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,\n        final FileVisitOption[] fileVisitOption) throws IOException {\n        // First walk both file trees and gather normalized paths.\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        if (notExists(path1) && notExists(path2)) {\n            return true;\n        }\n        final RelativeSortedPaths relativeSortedPaths = new RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption);\n        // If the normalized path names and counts are not the same, no need to compare contents.\n        if (!relativeSortedPaths.equals) {\n            return false;\n        }\n        // Both visitors contain the same normalized paths, we can compare file contents.\n        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n        for (final Path path : fileList1) {\n            final int binarySearch = Collections.binarySearch(fileList2, path);\n            if (binarySearch <= -1) {\n                throw new IllegalStateException(\"Unexpected mismatch.\");\n            }\n            if (!fileContentEquals(path1.resolve(path), path2.resolve(path), linkOptions, openOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, EMPTY_LINK_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param linkOptions options to follow links.\n     * @param fileVisitOptions options to configure the traversal\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,\n        final FileVisitOption[] fileVisitOptions) throws IOException {\n        return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n        return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\n\n    /**\n     * <p>\n     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original\n     * file list that matches the provided filter.\n     * </p>\n     *\n     * <p>\n     * The {@link Set} returned by this method is not guaranteed to be thread safe.\n     * </p>\n     *\n     * <pre>\n     * Set&lt;File&gt; allFiles = ...\n     * Set&lt;File&gt; javaFiles = FileFilterUtils.filterSet(allFiles,\n     *     FileFilterUtils.suffixFileFilter(\".java\"));\n     * </pre>\n     *\n     * @param filter the filter to apply to the set of files.\n     * @param paths the array of files to apply the filter to.\n     *\n     * @return a subset of {@code files} that is accepted by the file filter.\n     * @throws IllegalArgumentException if the filter is {@code null} or {@code files} contains a {@code null} value.\n     *\n     * @since 2.9.0\n     */\n    public static Path[] filter(final PathFilter filter, final Path... paths) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (paths == null) {\n            return EMPTY_PATH_ARRAY;\n        }\n        return filterPaths(filter, Stream.of(paths), Collectors.toList()).toArray(EMPTY_PATH_ARRAY);\n    }\n\n    private static <R, A> R filterPaths(final PathFilter filter, final Stream<Path> stream, final Collector<? super Path, A, R> collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream == null) {\n            return Stream.<Path>empty().collect(collector);\n        }\n        return stream.filter(p -> {\n            try {\n                return p != null && filter.accept(p, readBasicFileAttributes(p)) == FileVisitResult.CONTINUE;\n            } catch (final IOException e) {\n                return false;\n            }\n        }).collect(collector);\n    }\n\n    /**\n     * Reads the access control list from a file attribute view.\n     *\n     * @param sourcePath the path to the file.\n     * @return a file attribute view of the specified type, or null if the attribute view type is not available.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOException {\n        final AclFileAttributeView fileAttributeView = Files.getFileAttributeView(sourcePath, AclFileAttributeView.class);\n        return fileAttributeView == null ? null : fileAttributeView.getAcl();\n    }\n\n    private static FileTime getLastModifiedTime(final Path path, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(Objects.requireNonNull(path, \"path\"), options);\n    }\n\n    /**\n     * Returns a {@link Path} representing the system temporary directory.\n     *\n     * @return the system temporary directory.\n     *\n     * @since 2.12.0\n     */\n    public static Path getTempDirectory() {\n        return Paths.get(FileUtils.getTempDirectoryPath());\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a directory or not. Implemented as a null-safe delegate to\n     * {@code Files.isDirectory(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a\n     *         directory, or it cannot be determined if the file is a directory or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isDirectory(final Path path, final LinkOption... options) {\n        return path != null && Files.isDirectory(path, options);\n    }\n\n    /**\n     * Tests whether the given file or directory is empty.\n     *\n     * @param path the file or directory to query.\n     * @return whether the file or directory is empty.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }\n\n    /**\n     * Tests whether the directory is empty.\n     *\n     * @param directory the directory to query.\n     * @return whether the directory is empty.\n     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <i>(optional\n     *         specific exception)</i>.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     */\n    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n            return !directoryStream.iterator().hasNext();\n        }\n    }\n\n    /**\n     * Tests whether the given file is empty.\n     *\n     * @param file the file to query.\n     * @return whether the file is empty.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, its\n     *         {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.\n     */\n    public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) <= 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param czdt the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final ChronoZonedDateTime<?> czdt, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(czdt, \"czdt\");\n        return isNewer(file, czdt.toInstant(), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) > 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.from(instant), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the reference {@code Path}.\n     *\n     * @param file      the {@code File} of which the modification date must be compared.\n     * @param reference the {@code File} of which the modification date is used.\n     * @return true if the {@code File} exists and has been modified more\n     * recently than the reference {@code File}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Path reference) throws IOException {\n        return isNewer(file, getLastModifiedTime(reference));\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared.\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified before the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) < 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared.\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isOlder(file, FileTime.from(instant), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified before the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isOlder(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the reference {@code Path}.\n     *\n     * @param file the {@code File} of which the modification date must be compared.\n     * @param reference the {@code File} of which the modification date is used.\n     * @return true if the {@code File} exists and has been modified before than the reference {@code File}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final Path reference) throws IOException {\n        return isOlder(file, getLastModifiedTime(reference));\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a regular file or not. Implemented as a null-safe delegate to\n     * {@code Files.isRegularFile(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is\n     *         not a directory, or it cannot be determined if the file is a regular file or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isRegularFile(final Path path, final LinkOption... options) {\n        return path != null && Files.isRegularFile(path, options);\n    }\n\n\n    /**\n     * Creates a new DirectoryStream for Paths rooted at the given directory.\n     *\n     * @param dir the path to the directory to stream.\n     * @param pathFilter the directory stream filter.\n     * @return a new instance.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n        return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n    }\n\n    /**\n     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes\n     * to the file.\n     *\n     * @param path the Path.\n     * @param append Whether or not to append.\n     *\n     * @return a new OutputStream.\n     * @throws IOException if an I/O error occurs.\n     * @see Files#newOutputStream(Path, OpenOption...)\n     * @since 2.12.0\n     */\n    public static OutputStream newOutputStream(final Path path, final boolean append) throws IOException {\n        // @formatter:off\n        return Files.newOutputStream(path, append ?\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.APPEND} :\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING});\n        // @formatter:on\n    }\n\n    private static boolean notExists(final Path file) {\n        return Files.notExists(Objects.requireNonNull(file, \"file\"));\n    }\n\n    /**\n     * Returns true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     *\n     * @param deleteOptions the array to test\n     * @return true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     */\n    private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n        if (deleteOptions == null) {\n            return false;\n        }\n        return Stream.of(deleteOptions).anyMatch(e -> e == StandardDeleteOption.OVERRIDE_READ_ONLY);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)}\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n        return Files.readAttributes(path, BasicFileAttributes.class);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)} while wrapping {@link IOException} as\n     * {@link UncheckedIOException}.\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws UncheckedIOException if an I/O error occurs\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n        try {\n            return readBasicFileAttributes(path);\n        } catch (final IOException e) {\n            throw UncheckedIOExceptions.create(path, e);\n        }\n    }\n\n    /**\n     * Reads the given path as a String.\n     *\n     * @param path The source path.\n     * @param charset How to convert bytes to a String, null uses the default Charset.\n     * @return a new String.\n     * @throws IOException if an I/O error occurs reading from the stream.\n     * @see Files#readAllBytes(Path)\n     * @since 2.12.0\n     */\n    public static String readString(final Path path, final Charset charset) throws IOException {\n        return new String(Files.readAllBytes(path), Charsets.toCharset(charset));\n    }\n\n    /**\n     * Relativizes all files in the given {@code collection} against a {@code parent}.\n     *\n     * @param collection The collection of paths to relativize.\n     * @param parent relativizes against this parent path.\n     * @param sort Whether to sort the result.\n     * @param comparator How to sort.\n     * @return A collection of relativized paths, optionally sorted.\n     */\n    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n        Stream<Path> stream = collection.stream().map(parent::relativize);\n        if (sort) {\n            stream = comparator == null ? stream.sorted() : stream.sorted(comparator);\n        }\n        return stream.collect(Collectors.toList());\n    }\n\n    /**\n     * Sets the last modified time of the given file path to now.\n     *\n     * @param path The file path to set.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path path) throws IOException {\n        Files.setLastModifiedTime(path, FileTime.from(Instant.now()));\n    }\n\n    /**\n     * Sets the given {@code targetFile}'s last modified time to the value from {@code sourceFile}.\n     *\n     * @param sourceFile The source path to query.\n     * @param targetFile The target path to set.\n     * @throws NullPointerException if sourceFile is {@code null}.\n     * @throws NullPointerException if targetFile is {@code null}.\n     * @throws IOException if setting the last-modified time failed.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path sourceFile, final Path targetFile) throws IOException {\n        Objects.requireNonNull(sourceFile, \"sourceFile\");\n        Files.setLastModifiedTime(targetFile, getLastModifiedTime(sourceFile));\n    }\n\n    /**\n     * Sets the given Path to the {@code readOnly} value.\n     * <p>\n     * This behavior is OS dependent.\n     * </p>\n     *\n     * @param path The path to set.\n     * @param readOnly true for read-only, false for not read-only.\n     * @param linkOptions options indicating how symbolic links are handled.\n     * @return The given path.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        final List<Exception> causeList = new ArrayList<>(2);\n        final DosFileAttributeView fileAttributeView = Files.getFileAttributeView(path, DosFileAttributeView.class, linkOptions);\n        if (fileAttributeView != null) {\n            try {\n                fileAttributeView.setReadOnly(readOnly);\n                return path;\n            } catch (final IOException e) {\n                // ignore for now, retry with PosixFileAttributeView\n                causeList.add(e);\n            }\n        }\n        final PosixFileAttributeView posixFileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class, linkOptions);\n        if (posixFileAttributeView != null) {\n            // Works on Windows but not on Ubuntu:\n            // Files.setAttribute(path, \"unix:readonly\", readOnly, options);\n            // java.lang.IllegalArgumentException: 'unix:readonly' not recognized\n            final PosixFileAttributes readAttributes = posixFileAttributeView.readAttributes();\n            final Set<PosixFilePermission> permissions = readAttributes.permissions();\n            permissions.remove(PosixFilePermission.OWNER_WRITE);\n            permissions.remove(PosixFilePermission.GROUP_WRITE);\n            permissions.remove(PosixFilePermission.OTHERS_WRITE);\n            try {\n                return Files.setPosixFilePermissions(path, permissions);\n            } catch (final IOException e) {\n                causeList.add(e);\n            }\n        }\n        if (!causeList.isEmpty()) {\n            throw new IOExceptionList(path.toString(), causeList);\n        }\n        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(linkOptions)));\n    }\n\n    /**\n     * Returns the size of the specified file or directory. If the provided {@link File} is a regular file, then the file's\n     * length is returned. If the argument is a directory, then the size of the directory is calculated recursively. If a\n     * directory or subdirectory is security restricted, its size will not be included.\n     * <p>\n     * Note that overflow is not detected, and the return value may be negative if overflow occurs. See\n     * {@link #sizeOfAsBigInteger(Path)} for an alternative method that does not overflow.\n     * </p>\n     *\n     * @param path the regular file or directory to return the size of (must not be {@code null}).\n     * @return the length of the file, or recursive size of the directory, provided (in bytes).\n     * @throws NullPointerException if the file is {@code null}.\n     * @throws IllegalArgumentException if the file does not exist.\n     * @throws IOException if an I/O error occurs.\n     *\n     * @since 2.12.0\n     */\n    public static long sizeOf(final Path path) throws IOException {\n        requireExists(path, \"path\");\n        return Files.isDirectory(path) ? sizeOfDirectory(path) : Files.size(path);\n    }\n\n    /**\n     * Returns the size of the specified file or directory. If the provided {@link Path} is a regular file, then the file's\n     * length is returned. If the argument is a directory, then the size of the directory is calculated recursively. If a\n     * directory or subdirectory is security restricted, its size will not be included.\n     *\n     * @param path the regular file or directory to return the size of (must not be {@code null}).\n     * @return the length of the file, or recursive size of the directory, provided (in bytes).\n     * @throws NullPointerException if the file is {@code null}.\n     * @throws IllegalArgumentException if the file does not exist.\n     * @throws IOException if an I/O error occurs.\n     *\n     * @since 2.12.0\n     */\n    public static BigInteger sizeOfAsBigInteger(final Path path) throws IOException {\n        requireExists(path, \"path\");\n        return Files.isDirectory(path) ? sizeOfDirectoryAsBigInteger(path) : BigInteger.valueOf(Files.size(path));\n    }\n\n    /**\n     * Counts the size of a directory recursively (sum of the length of all files).\n     * <p>\n     * Note that overflow is not detected, and the return value may be negative if overflow occurs. See\n     * {@link #sizeOfDirectoryAsBigInteger(Path)} for an alternative method that does not overflow.\n     * </p>\n     *\n     * @param directory directory to inspect, must not be {@code null}.\n     * @return size of directory in bytes, 0 if directory is security restricted, a negative number when the real total is\n     *         greater than {@link Long#MAX_VALUE}.\n     * @throws NullPointerException if the directory is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static long sizeOfDirectory(final Path directory) throws IOException {\n        return countDirectory(directory).getByteCounter().getLong();\n    }\n\n    /**\n     * Counts the size of a directory recursively (sum of the length of all files).\n     *\n     * @param directory directory to inspect, must not be {@code null}.\n     * @return size of directory in bytes, 0 if directory is security restricted.\n     * @throws NullPointerException if the directory is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static BigInteger sizeOfDirectoryAsBigInteger(final Path directory) throws IOException {\n        return countDirectoryAsBigInteger(directory).getByteCounter().getBigInteger();\n    }\n\n    /**\n     * Requires that the given {@code File} exists and throws an {@link IllegalArgumentException} if it doesn't.\n     *\n     * @param file The {@code File} to check.\n     * @param fileParamName The parameter name to use in the exception message in case of {@code null} input.\n     * @return the given file.\n     * @throws NullPointerException if the given {@code File} is {@code null}.\n     * @throws IllegalArgumentException if the given {@code File} does not exist.\n     */\n    private static Path requireExists(final Path file, final String fileParamName) {\n        Objects.requireNonNull(file, fileParamName);\n        if (!Files.exists(file)) {\n            throw new IllegalArgumentException(\"File system element for parameter '\" + fileParamName + \"' does not exist: '\" + file + \"'\");\n        }\n        return file;\n    }\n\n    /**\n     * Converts an array of {@link FileVisitOption} to a {@link Set}.\n     *\n     * @param fileVisitOptions input array.\n     * @return a new Set.\n     */\n    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n        return fileVisitOptions == null ? EnumSet.noneOf(FileVisitOption.class) : Stream.of(fileVisitOptions).collect(Collectors.toSet());\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n        requireExists(directory, \"directory\");\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param start See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param options See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param visitor See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options,\n        final int maxDepth) throws IOException {\n        Files.walkFileTree(start, options, maxDepth, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param first See {@link Paths#get(String,String[])}.\n     * @param more See {@link Paths#get(String,String[])}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param uri See {@link Paths#get(URI)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }\n\n    /**\n     * Waits for the file system to propagate a file creation, with a timeout.\n     * <p>\n     * This method repeatedly tests {@link Files#exists(Path,LinkOption...)} until it returns true up to the maximum time\n     * specified.\n     * </p>\n     *\n     * @param file the file to check, must not be {@code null}.\n     * @param timeout the maximum time to wait.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if file exists.\n     * @throws NullPointerException if the file is {@code null}.\n     * @since 2.12.0\n     */\n    public static boolean waitFor(final Path file, final Duration timeout, final LinkOption... options) {\n        Objects.requireNonNull(file, \"file\");\n        final Instant finishInstant = Instant.now().plus(timeout);\n        boolean interrupted = false;\n        final long minSleepMillis = 100;\n        try {\n            while (!Files.exists(file, options)) {\n                final Instant now = Instant.now();\n                if (now.isAfter(finishInstant)) {\n                    return false;\n                }\n                try {\n                    Thread.sleep(Math.min(minSleepMillis, finishInstant.minusMillis(now.toEpochMilli()).toEpochMilli()));\n                } catch (final InterruptedException ignore) {\n                    interrupted = true;\n                } catch (final Exception ex) {\n                    break;\n                }\n            }\n        } finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        return Files.exists(file, options);\n    }\n\n    /**\n     * Returns a stream of filtered paths.\n     *\n     * @param start the start path\n     * @param pathFilter the path filter\n     * @param maxDepth the maximum depth of directories to walk.\n     * @param readAttributes whether to call the filters with file attributes (false passes null).\n     * @param options the options to configure the walk.\n     * @return a filtered stream of paths.\n     * @throws IOException if an I/O error is thrown when accessing the starting file.\n     * @since 2.9.0\n     */\n    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,\n        final FileVisitOption... options) throws IOException {\n        return Files.walk(start, maxDepth, options)\n            .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n    }\n\n    /**\n     * Does allow to instantiate.\n     */\n    private PathUtils() {\n        // do not instantiate.\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate getLastModifiedTime(path Path, options LinkOption...) : FileTime extracted from private compareLastModifiedTimeTo(file Path, fileTime FileTime, options LinkOption...) : int in class org.apache.commons.io.file.PathUtils", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/file/PathUtils.java", "startLine": 223, "endLine": 235, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/file/PathUtils.java", "startLine": 223, "endLine": 235, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/file/PathUtils.java", "startLine": 715, "endLine": 717, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Compares the specified {@code Path}'s last modified time to the given file time.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return See {@link FileTime#compareTo(FileTime)}\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     */\n    private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(file, options).compareTo(fileTime);\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/file/PathUtils.java", "isPureRefactoring": true, "commitId": "d75027d357838e4a56ff43a233169942b12ef7a1", "packageNameBefore": "org.apache.commons.io.file", "classNameBefore": "org.apache.commons.io.file.PathUtils", "methodNameBefore": "org.apache.commons.io.file.PathUtils#compareLastModifiedTimeTo", "classSignatureBefore": "public final class PathUtils ", "methodNameBeforeSet": ["org.apache.commons.io.file.PathUtils#compareLastModifiedTimeTo"], "classNameBeforeSet": ["org.apache.commons.io.file.PathUtils"], "classSignatureBeforeSet": ["public final class PathUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics\nTolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.CopyOption;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.NotDirectoryException;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.chrono.ChronoZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOExceptionList;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.UncheckedIOExceptions;\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.IOFileFilter;\n\n/**\n * NIO Path utilities.\n *\n * @since 2.7\n */\npublic final class PathUtils {\n\n    /**\n     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative\n     * lists when comparing directories.\n     */\n    private static class RelativeSortedPaths {\n\n        final boolean equals;\n        // final List<Path> relativeDirList1; // might need later?\n        // final List<Path> relativeDirList2; // might need later?\n        final List<Path> relativeFileList1;\n        final List<Path> relativeFileList2;\n\n        /**\n         * Constructs and initializes a new instance by accumulating directory and file info.\n         *\n         * @param dir1 First directory to compare.\n         * @param dir2 Seconds directory to compare.\n         * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @param linkOptions Options indicating how symbolic links are handled.\n         * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @throws IOException if an I/O error is thrown by a visitor method.\n         */\n        private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,\n            final FileVisitOption[] fileVisitOptions) throws IOException {\n            final List<Path> tmpRelativeDirList1;\n            final List<Path> tmpRelativeDirList2;\n            List<Path> tmpRelativeFileList1 = null;\n            List<Path> tmpRelativeFileList2 = null;\n            if (dir1 == null && dir2 == null) {\n                equals = true;\n            } else if (dir1 == null ^ dir2 == null) {\n                equals = false;\n            } else {\n                final boolean parentDirNotExists1 = Files.notExists(dir1, linkOptions);\n                final boolean parentDirNotExists2 = Files.notExists(dir2, linkOptions);\n                if (parentDirNotExists1 || parentDirNotExists2) {\n                    equals = parentDirNotExists1 && parentDirNotExists2;\n                } else {\n                    final AccumulatorPathVisitor visitor1 = accumulate(dir1, maxDepth, fileVisitOptions);\n                    final AccumulatorPathVisitor visitor2 = accumulate(dir2, maxDepth, fileVisitOptions);\n                    if (visitor1.getDirList().size() != visitor2.getDirList().size() || visitor1.getFileList().size() != visitor2.getFileList().size()) {\n                        equals = false;\n                    } else {\n                        tmpRelativeDirList1 = visitor1.relativizeDirectories(dir1, true, null);\n                        tmpRelativeDirList2 = visitor2.relativizeDirectories(dir2, true, null);\n                        if (!tmpRelativeDirList1.equals(tmpRelativeDirList2)) {\n                            equals = false;\n                        } else {\n                            tmpRelativeFileList1 = visitor1.relativizeFiles(dir1, true, null);\n                            tmpRelativeFileList2 = visitor2.relativizeFiles(dir2, true, null);\n                            equals = tmpRelativeFileList1.equals(tmpRelativeFileList2);\n                        }\n                    }\n                }\n            }\n            // relativeDirList1 = tmpRelativeDirList1;\n            // relativeDirList2 = tmpRelativeDirList2;\n            relativeFileList1 = tmpRelativeFileList1;\n            relativeFileList2 = tmpRelativeFileList2;\n        }\n    }\n\n    /**\n     * Empty {@link CopyOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final CopyOption[] EMPTY_COPY_OPTIONS = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final DeleteOption[] EMPTY_DELETE_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link FileVisitOption} array.\n     */\n    public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     */\n    public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY = {};\n\n    /**\n     * {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n     *\n     * @since 2.9.0\n     */\n    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = {LinkOption.NOFOLLOW_LINKS};\n\n    /**\n     * Empty {@link OpenOption} array.\n     */\n    public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link Path} array.\n     *\n     * @since 2.9.0\n     */\n    public static final Path[] EMPTY_PATH_ARRAY = {};\n\n    /**\n     * Accumulates file tree information in a {@link AccumulatorPathVisitor}.\n     *\n     * @param directory The directory to accumulate information.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @return file tree information.\n     */\n    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return cleanDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Compares the specified {@code Path}'s last modified time to the given file time.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return See {@link FileTime#compareTo(FileTime)}\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     */\n    private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(file, options).compareTo(fileTime);\n    }\n\n    /**\n     * Copies a directory to another directory.\n     *\n     * @param sourceDirectory The source directory.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path absoluteSource = sourceDirectory.toAbsolutePath();\n        return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)\n            .getPathCounters();\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetFile The target file.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetFile, copyOptions);\n            return targetFile;\n        }\n    }\n\n    /**\n     * Copies a file to a directory.\n     *\n     * @param sourceFile The source file.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(Path, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n            return targetDirectory;\n        }\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), directory).getPathCounters();\n    }\n\n    /**\n     * Creates the parent directories for the given {@code path}.\n     *\n     * @param path The path to a file (or directory).\n     * @param attrs An optional list of file attributes to set atomically when creating the directories.\n     * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static Path createParentDirectories(final Path path, final FileAttribute<?>... attrs) throws IOException {\n        final Path parent = path.getParent();\n        return parent == null ? null : Files.createDirectories(parent, attrs);\n    }\n\n    /**\n     * Gets the current directory.\n     *\n     * @return the current directory.\n     *\n     * @since 2.9.0\n     */\n    public static Path current() {\n        return Paths.get(\"\");\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     */\n    public static PathCounters delete(final Path path) throws IOException {\n        return delete(path, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return deleteDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions), directory)\n            .getPathCounters();\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     */\n    public static PathCounters deleteFile(final Path file) throws IOException {\n        return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n        // Files.deleteIfExists() never follows links, so use LinkOption.NOFOLLOW_LINKS in other calls to Files.\n        return deleteFile(file, NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)\n        throws NoSuchFileException, IOException {\n        if (Files.isDirectory(file, linkOptions)) {\n            throw new NoSuchFileException(file.toString());\n        }\n        final PathCounters pathCounts = Counters.longPathCounters();\n        final boolean exists = Files.exists(file, linkOptions);\n        final long size = exists && !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n        if (overrideReadOnly(deleteOptions) && exists) {\n            setReadOnly(file, false, linkOptions);\n        }\n        if (Files.deleteIfExists(file)) {\n            pathCounts.getFileCounter().increment();\n            pathCounts.getByteCounter().add(size);\n        }\n        return pathCounts;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryAndFileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param linkOptions options to follow links.\n     * @param openOptions options to open files.\n     * @param fileVisitOption options to configure traversal.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,\n        final FileVisitOption[] fileVisitOption) throws IOException {\n        // First walk both file trees and gather normalized paths.\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        if (notExists(path1) && notExists(path2)) {\n            return true;\n        }\n        final RelativeSortedPaths relativeSortedPaths = new RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption);\n        // If the normalized path names and counts are not the same, no need to compare contents.\n        if (!relativeSortedPaths.equals) {\n            return false;\n        }\n        // Both visitors contain the same normalized paths, we can compare file contents.\n        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n        for (final Path path : fileList1) {\n            final int binarySearch = Collections.binarySearch(fileList2, path);\n            if (binarySearch <= -1) {\n                throw new IllegalStateException(\"Unexpected mismatch.\");\n            }\n            if (!fileContentEquals(path1.resolve(path), path2.resolve(path), linkOptions, openOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, EMPTY_LINK_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param linkOptions options to follow links.\n     * @param fileVisitOptions options to configure the traversal\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,\n        final FileVisitOption[] fileVisitOptions) throws IOException {\n        return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n        return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\n\n    /**\n     * <p>\n     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original\n     * file list that matches the provided filter.\n     * </p>\n     *\n     * <p>\n     * The {@link Set} returned by this method is not guaranteed to be thread safe.\n     * </p>\n     *\n     * <pre>\n     * Set&lt;File&gt; allFiles = ...\n     * Set&lt;File&gt; javaFiles = FileFilterUtils.filterSet(allFiles,\n     *     FileFilterUtils.suffixFileFilter(\".java\"));\n     * </pre>\n     *\n     * @param filter the filter to apply to the set of files.\n     * @param paths the array of files to apply the filter to.\n     *\n     * @return a subset of {@code files} that is accepted by the file filter.\n     * @throws IllegalArgumentException if the filter is {@code null} or {@code files} contains a {@code null} value.\n     *\n     * @since 2.9.0\n     */\n    public static Path[] filter(final PathFilter filter, final Path... paths) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (paths == null) {\n            return EMPTY_PATH_ARRAY;\n        }\n        return filterPaths(filter, Stream.of(paths), Collectors.toList()).toArray(EMPTY_PATH_ARRAY);\n    }\n\n    private static <R, A> R filterPaths(final PathFilter filter, final Stream<Path> stream, final Collector<? super Path, A, R> collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream == null) {\n            return Stream.<Path>empty().collect(collector);\n        }\n        return stream.filter(p -> {\n            try {\n                return p != null && filter.accept(p, readBasicFileAttributes(p)) == FileVisitResult.CONTINUE;\n            } catch (final IOException e) {\n                return false;\n            }\n        }).collect(collector);\n    }\n\n    /**\n     * Reads the access control list from a file attribute view.\n     *\n     * @param sourcePath the path to the file.\n     * @return a file attribute view of the specified type, or null if the attribute view type is not available.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOException {\n        final AclFileAttributeView fileAttributeView = Files.getFileAttributeView(sourcePath, AclFileAttributeView.class);\n        return fileAttributeView == null ? null : fileAttributeView.getAcl();\n    }\n\n    /**\n     * Returns a {@link Path} representing the system temporary directory.\n     *\n     * @return the system temporary directory.\n     *\n     * @since 2.12.0\n     */\n    public static Path getTempDirectory() {\n        return Paths.get(FileUtils.getTempDirectoryPath());\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a directory or not. Implemented as a null-safe delegate to\n     * {@code Files.isDirectory(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a\n     *         directory, or it cannot be determined if the file is a directory or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isDirectory(final Path path, final LinkOption... options) {\n        return path != null && Files.isDirectory(path, options);\n    }\n\n    /**\n     * Tests whether the given file or directory is empty.\n     *\n     * @param path the file or directory to query.\n     * @return whether the file or directory is empty.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }\n\n    /**\n     * Tests whether the directory is empty.\n     *\n     * @param directory the directory to query.\n     * @return whether the directory is empty.\n     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <i>(optional\n     *         specific exception)</i>.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     */\n    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n            return !directoryStream.iterator().hasNext();\n        }\n    }\n\n    /**\n     * Tests whether the given file is empty.\n     *\n     * @param file the file to query.\n     * @return whether the file is empty.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, its\n     *         {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.\n     */\n    public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) <= 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param czdt the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final ChronoZonedDateTime<?> czdt, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(czdt, \"czdt\");\n        return isNewer(file, czdt.toInstant(), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) > 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.from(instant), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the reference {@code Path}.\n     *\n     * @param file      the {@code File} of which the modification date must be compared.\n     * @param reference the {@code File} of which the modification date is used.\n     * @return true if the {@code File} exists and has been modified more\n     * recently than the reference {@code File}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Path reference) throws IOException {\n        return isNewer(file, Files.getLastModifiedTime(reference));\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a regular file or not. Implemented as a null-safe delegate to\n     * {@code Files.isRegularFile(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is\n     *         not a directory, or it cannot be determined if the file is a regular file or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isRegularFile(final Path path, final LinkOption... options) {\n        return path != null && Files.isRegularFile(path, options);\n    }\n\n\n    /**\n     * Creates a new DirectoryStream for Paths rooted at the given directory.\n     *\n     * @param dir the path to the directory to stream.\n     * @param pathFilter the directory stream filter.\n     * @return a new instance.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n        return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n    }\n\n    /**\n     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes\n     * to the file.\n     *\n     * @param path the Path.\n     * @param append Whether or not to append.\n     *\n     * @return a new OutputStream.\n     * @throws IOException if an I/O error occurs.\n     * @see Files#newOutputStream(Path, OpenOption...)\n     * @since 2.12.0\n     */\n    public static OutputStream newOutputStream(final Path path, final boolean append) throws IOException {\n        // @formatter:off\n        return Files.newOutputStream(path, append ?\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.APPEND} :\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING});\n        // @formatter:on\n    }\n\n    private static boolean notExists(final Path file) {\n        return Files.notExists(Objects.requireNonNull(file, \"file\"));\n    }\n\n    /**\n     * Returns true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     *\n     * @param deleteOptions the array to test\n     * @return true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     */\n    private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n        if (deleteOptions == null) {\n            return false;\n        }\n        return Stream.of(deleteOptions).anyMatch(e -> e == StandardDeleteOption.OVERRIDE_READ_ONLY);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)}\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n        return Files.readAttributes(path, BasicFileAttributes.class);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)} while wrapping {@link IOException} as\n     * {@link UncheckedIOException}.\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws UncheckedIOException if an I/O error occurs\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n        try {\n            return readBasicFileAttributes(path);\n        } catch (final IOException e) {\n            throw UncheckedIOExceptions.create(path, e);\n        }\n    }\n\n    /**\n     * Reads the given path as a String.\n     *\n     * @param path The source path.\n     * @param charset How to convert bytes to a String, null uses the default Charset.\n     * @return a new String.\n     * @throws IOException if an I/O error occurs reading from the stream.\n     * @see Files#readAllBytes(Path)\n     * @since 2.12.0\n     */\n    public static String readString(final Path path, final Charset charset) throws IOException {\n        return new String(Files.readAllBytes(path), Charsets.toCharset(charset));\n    }\n\n    /**\n     * Relativizes all files in the given {@code collection} against a {@code parent}.\n     *\n     * @param collection The collection of paths to relativize.\n     * @param parent relativizes against this parent path.\n     * @param sort Whether to sort the result.\n     * @param comparator How to sort.\n     * @return A collection of relativized paths, optionally sorted.\n     */\n    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n        Stream<Path> stream = collection.stream().map(parent::relativize);\n        if (sort) {\n            stream = comparator == null ? stream.sorted() : stream.sorted(comparator);\n        }\n        return stream.collect(Collectors.toList());\n    }\n\n    /**\n     * Sets the last modified time of the given file path to now.\n     *\n     * @param path The file path to set.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path path) throws IOException {\n        Files.setLastModifiedTime(path, FileTime.from(Instant.now()));\n    }\n\n    /**\n     * Sets the given {@code targetFile}'s last modified time to the value from {@code sourceFile}.\n     *\n     * @param sourceFile The source path to query.\n     * @param targetFile The target path to set.\n     * @throws NullPointerException if sourceFile is {@code null}.\n     * @throws NullPointerException if targetFile is {@code null}.\n     * @throws IOException if setting the last-modified time failed.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path sourceFile, final Path targetFile) throws IOException {\n        Objects.requireNonNull(sourceFile, \"sourceFile\");\n        Files.setLastModifiedTime(targetFile, Files.getLastModifiedTime(sourceFile));\n    }\n\n    /**\n     * Sets the given Path to the {@code readOnly} value.\n     * <p>\n     * This behavior is OS dependent.\n     * </p>\n     *\n     * @param path The path to set.\n     * @param readOnly true for read-only, false for not read-only.\n     * @param linkOptions options indicating how symbolic links are handled.\n     * @return The given path.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        final List<Exception> causeList = new ArrayList<>(2);\n        final DosFileAttributeView fileAttributeView = Files.getFileAttributeView(path, DosFileAttributeView.class, linkOptions);\n        if (fileAttributeView != null) {\n            try {\n                fileAttributeView.setReadOnly(readOnly);\n                return path;\n            } catch (final IOException e) {\n                // ignore for now, retry with PosixFileAttributeView\n                causeList.add(e);\n            }\n        }\n        final PosixFileAttributeView posixFileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class, linkOptions);\n        if (posixFileAttributeView != null) {\n            // Works on Windows but not on Ubuntu:\n            // Files.setAttribute(path, \"unix:readonly\", readOnly, options);\n            // java.lang.IllegalArgumentException: 'unix:readonly' not recognized\n            final PosixFileAttributes readAttributes = posixFileAttributeView.readAttributes();\n            final Set<PosixFilePermission> permissions = readAttributes.permissions();\n            permissions.remove(PosixFilePermission.OWNER_WRITE);\n            permissions.remove(PosixFilePermission.GROUP_WRITE);\n            permissions.remove(PosixFilePermission.OTHERS_WRITE);\n            try {\n                return Files.setPosixFilePermissions(path, permissions);\n            } catch (final IOException e) {\n                causeList.add(e);\n            }\n        }\n        if (!causeList.isEmpty()) {\n            throw new IOExceptionList(path.toString(), causeList);\n        }\n        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(linkOptions)));\n    }\n\n    /**\n     * Converts an array of {@link FileVisitOption} to a {@link Set}.\n     *\n     * @param fileVisitOptions input array.\n     * @return a new Set.\n     */\n    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n        return fileVisitOptions == null ? EnumSet.noneOf(FileVisitOption.class) : Stream.of(fileVisitOptions).collect(Collectors.toSet());\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param start See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param options See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param visitor See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options,\n        final int maxDepth) throws IOException {\n        Files.walkFileTree(start, options, maxDepth, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param first See {@link Paths#get(String,String[])}.\n     * @param more See {@link Paths#get(String,String[])}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param uri See {@link Paths#get(URI)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }\n\n    /**\n     * Waits for the file system to propagate a file creation, with a timeout.\n     * <p>\n     * This method repeatedly tests {@link Files#exists(Path,LinkOption...)} until it returns true up to the maximum time\n     * specified.\n     * </p>\n     *\n     * @param file the file to check, must not be {@code null}.\n     * @param timeout the maximum time to wait.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if file exists.\n     * @throws NullPointerException if the file is {@code null}.\n     * @since 2.12.0\n     */\n    public static boolean waitFor(final Path file, final Duration timeout, final LinkOption... options) {\n        Objects.requireNonNull(file, \"file\");\n        final Instant finishInstant = Instant.now().plus(timeout);\n        boolean interrupted = false;\n        final long minSleepMillis = 100;\n        try {\n            while (!Files.exists(file, options)) {\n                final Instant now = Instant.now();\n                if (now.isAfter(finishInstant)) {\n                    return false;\n                }\n                try {\n                    Thread.sleep(Math.min(minSleepMillis, finishInstant.minusMillis(now.toEpochMilli()).toEpochMilli()));\n                } catch (final InterruptedException ignore) {\n                    interrupted = true;\n                } catch (final Exception ex) {\n                    break;\n                }\n            }\n        } finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        return Files.exists(file, options);\n    }\n\n    /**\n     * Returns a stream of filtered paths.\n     *\n     * @param start the start path\n     * @param pathFilter the path filter\n     * @param maxDepth the maximum depth of directories to walk.\n     * @param readAttributes whether to call the filters with file attributes (false passes null).\n     * @param options the options to configure the walk.\n     * @return a filtered stream of paths.\n     * @throws IOException if an I/O error is thrown when accessing the starting file.\n     * @since 2.9.0\n     */\n    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,\n        final FileVisitOption... options) throws IOException {\n        return Files.walk(start, maxDepth, options)\n            .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n    }\n\n    /**\n     * Does allow to instantiate.\n     */\n    private PathUtils() {\n        // do not instantiate.\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/file/PathUtils.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.CopyOption;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.NotDirectoryException;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.chrono.ChronoZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOExceptionList;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.UncheckedIOExceptions;\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.IOFileFilter;\n\n/**\n * NIO Path utilities.\n *\n * @since 2.7\n */\npublic final class PathUtils {\n\n    /**\n     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative\n     * lists when comparing directories.\n     */\n    private static class RelativeSortedPaths {\n\n        final boolean equals;\n        // final List<Path> relativeDirList1; // might need later?\n        // final List<Path> relativeDirList2; // might need later?\n        final List<Path> relativeFileList1;\n        final List<Path> relativeFileList2;\n\n        /**\n         * Constructs and initializes a new instance by accumulating directory and file info.\n         *\n         * @param dir1 First directory to compare.\n         * @param dir2 Seconds directory to compare.\n         * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @param linkOptions Options indicating how symbolic links are handled.\n         * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @throws IOException if an I/O error is thrown by a visitor method.\n         */\n        private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,\n            final FileVisitOption[] fileVisitOptions) throws IOException {\n            final List<Path> tmpRelativeDirList1;\n            final List<Path> tmpRelativeDirList2;\n            List<Path> tmpRelativeFileList1 = null;\n            List<Path> tmpRelativeFileList2 = null;\n            if (dir1 == null && dir2 == null) {\n                equals = true;\n            } else if (dir1 == null ^ dir2 == null) {\n                equals = false;\n            } else {\n                final boolean parentDirNotExists1 = Files.notExists(dir1, linkOptions);\n                final boolean parentDirNotExists2 = Files.notExists(dir2, linkOptions);\n                if (parentDirNotExists1 || parentDirNotExists2) {\n                    equals = parentDirNotExists1 && parentDirNotExists2;\n                } else {\n                    final AccumulatorPathVisitor visitor1 = accumulate(dir1, maxDepth, fileVisitOptions);\n                    final AccumulatorPathVisitor visitor2 = accumulate(dir2, maxDepth, fileVisitOptions);\n                    if (visitor1.getDirList().size() != visitor2.getDirList().size() || visitor1.getFileList().size() != visitor2.getFileList().size()) {\n                        equals = false;\n                    } else {\n                        tmpRelativeDirList1 = visitor1.relativizeDirectories(dir1, true, null);\n                        tmpRelativeDirList2 = visitor2.relativizeDirectories(dir2, true, null);\n                        if (!tmpRelativeDirList1.equals(tmpRelativeDirList2)) {\n                            equals = false;\n                        } else {\n                            tmpRelativeFileList1 = visitor1.relativizeFiles(dir1, true, null);\n                            tmpRelativeFileList2 = visitor2.relativizeFiles(dir2, true, null);\n                            equals = tmpRelativeFileList1.equals(tmpRelativeFileList2);\n                        }\n                    }\n                }\n            }\n            // relativeDirList1 = tmpRelativeDirList1;\n            // relativeDirList2 = tmpRelativeDirList2;\n            relativeFileList1 = tmpRelativeFileList1;\n            relativeFileList2 = tmpRelativeFileList2;\n        }\n    }\n\n    /**\n     * Empty {@link CopyOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final CopyOption[] EMPTY_COPY_OPTIONS = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final DeleteOption[] EMPTY_DELETE_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link FileVisitOption} array.\n     */\n    public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     */\n    public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY = {};\n\n    /**\n     * {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n     *\n     * @since 2.9.0\n     */\n    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = {LinkOption.NOFOLLOW_LINKS};\n\n    /**\n     * Empty {@link OpenOption} array.\n     */\n    public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link Path} array.\n     *\n     * @since 2.9.0\n     */\n    public static final Path[] EMPTY_PATH_ARRAY = {};\n\n    /**\n     * Accumulates file tree information in a {@link AccumulatorPathVisitor}.\n     *\n     * @param directory The directory to accumulate information.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @return file tree information.\n     */\n    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return cleanDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Compares the specified {@code Path}'s last modified time to the given file time.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return See {@link FileTime#compareTo(FileTime)}\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     */\n    private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        return getLastModifiedTime(file, options).compareTo(fileTime);\n    }\n\n    /**\n     * Copies a directory to another directory.\n     *\n     * @param sourceDirectory The source directory.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path absoluteSource = sourceDirectory.toAbsolutePath();\n        return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)\n            .getPathCounters();\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetFile The target file.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetFile, copyOptions);\n            return targetFile;\n        }\n    }\n\n    /**\n     * Copies a file to a directory.\n     *\n     * @param sourceFile The source file.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(Path, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n            return targetDirectory;\n        }\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), directory).getPathCounters();\n    }\n\n    /**\n     * Creates the parent directories for the given {@code path}.\n     *\n     * @param path The path to a file (or directory).\n     * @param attrs An optional list of file attributes to set atomically when creating the directories.\n     * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static Path createParentDirectories(final Path path, final FileAttribute<?>... attrs) throws IOException {\n        final Path parent = path.getParent();\n        return parent == null ? null : Files.createDirectories(parent, attrs);\n    }\n\n    /**\n     * Gets the current directory.\n     *\n     * @return the current directory.\n     *\n     * @since 2.9.0\n     */\n    public static Path current() {\n        return Paths.get(\"\");\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     */\n    public static PathCounters delete(final Path path) throws IOException {\n        return delete(path, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return deleteDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions), directory)\n            .getPathCounters();\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     */\n    public static PathCounters deleteFile(final Path file) throws IOException {\n        return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n        // Files.deleteIfExists() never follows links, so use LinkOption.NOFOLLOW_LINKS in other calls to Files.\n        return deleteFile(file, NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)\n        throws NoSuchFileException, IOException {\n        if (Files.isDirectory(file, linkOptions)) {\n            throw new NoSuchFileException(file.toString());\n        }\n        final PathCounters pathCounts = Counters.longPathCounters();\n        final boolean exists = Files.exists(file, linkOptions);\n        final long size = exists && !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n        if (overrideReadOnly(deleteOptions) && exists) {\n            setReadOnly(file, false, linkOptions);\n        }\n        if (Files.deleteIfExists(file)) {\n            pathCounts.getFileCounter().increment();\n            pathCounts.getByteCounter().add(size);\n        }\n        return pathCounts;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryAndFileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param linkOptions options to follow links.\n     * @param openOptions options to open files.\n     * @param fileVisitOption options to configure traversal.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,\n        final FileVisitOption[] fileVisitOption) throws IOException {\n        // First walk both file trees and gather normalized paths.\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        if (notExists(path1) && notExists(path2)) {\n            return true;\n        }\n        final RelativeSortedPaths relativeSortedPaths = new RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption);\n        // If the normalized path names and counts are not the same, no need to compare contents.\n        if (!relativeSortedPaths.equals) {\n            return false;\n        }\n        // Both visitors contain the same normalized paths, we can compare file contents.\n        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n        for (final Path path : fileList1) {\n            final int binarySearch = Collections.binarySearch(fileList2, path);\n            if (binarySearch <= -1) {\n                throw new IllegalStateException(\"Unexpected mismatch.\");\n            }\n            if (!fileContentEquals(path1.resolve(path), path2.resolve(path), linkOptions, openOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, EMPTY_LINK_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param linkOptions options to follow links.\n     * @param fileVisitOptions options to configure the traversal\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,\n        final FileVisitOption[] fileVisitOptions) throws IOException {\n        return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n        return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\n\n    /**\n     * <p>\n     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original\n     * file list that matches the provided filter.\n     * </p>\n     *\n     * <p>\n     * The {@link Set} returned by this method is not guaranteed to be thread safe.\n     * </p>\n     *\n     * <pre>\n     * Set&lt;File&gt; allFiles = ...\n     * Set&lt;File&gt; javaFiles = FileFilterUtils.filterSet(allFiles,\n     *     FileFilterUtils.suffixFileFilter(\".java\"));\n     * </pre>\n     *\n     * @param filter the filter to apply to the set of files.\n     * @param paths the array of files to apply the filter to.\n     *\n     * @return a subset of {@code files} that is accepted by the file filter.\n     * @throws IllegalArgumentException if the filter is {@code null} or {@code files} contains a {@code null} value.\n     *\n     * @since 2.9.0\n     */\n    public static Path[] filter(final PathFilter filter, final Path... paths) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (paths == null) {\n            return EMPTY_PATH_ARRAY;\n        }\n        return filterPaths(filter, Stream.of(paths), Collectors.toList()).toArray(EMPTY_PATH_ARRAY);\n    }\n\n    private static <R, A> R filterPaths(final PathFilter filter, final Stream<Path> stream, final Collector<? super Path, A, R> collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream == null) {\n            return Stream.<Path>empty().collect(collector);\n        }\n        return stream.filter(p -> {\n            try {\n                return p != null && filter.accept(p, readBasicFileAttributes(p)) == FileVisitResult.CONTINUE;\n            } catch (final IOException e) {\n                return false;\n            }\n        }).collect(collector);\n    }\n\n    /**\n     * Reads the access control list from a file attribute view.\n     *\n     * @param sourcePath the path to the file.\n     * @return a file attribute view of the specified type, or null if the attribute view type is not available.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOException {\n        final AclFileAttributeView fileAttributeView = Files.getFileAttributeView(sourcePath, AclFileAttributeView.class);\n        return fileAttributeView == null ? null : fileAttributeView.getAcl();\n    }\n\n    private static FileTime getLastModifiedTime(final Path path, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(Objects.requireNonNull(path, \"path\"), options);\n    }\n\n    /**\n     * Returns a {@link Path} representing the system temporary directory.\n     *\n     * @return the system temporary directory.\n     *\n     * @since 2.12.0\n     */\n    public static Path getTempDirectory() {\n        return Paths.get(FileUtils.getTempDirectoryPath());\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a directory or not. Implemented as a null-safe delegate to\n     * {@code Files.isDirectory(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a\n     *         directory, or it cannot be determined if the file is a directory or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isDirectory(final Path path, final LinkOption... options) {\n        return path != null && Files.isDirectory(path, options);\n    }\n\n    /**\n     * Tests whether the given file or directory is empty.\n     *\n     * @param path the file or directory to query.\n     * @return whether the file or directory is empty.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }\n\n    /**\n     * Tests whether the directory is empty.\n     *\n     * @param directory the directory to query.\n     * @return whether the directory is empty.\n     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <i>(optional\n     *         specific exception)</i>.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     */\n    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n            return !directoryStream.iterator().hasNext();\n        }\n    }\n\n    /**\n     * Tests whether the given file is empty.\n     *\n     * @param file the file to query.\n     * @return whether the file is empty.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, its\n     *         {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.\n     */\n    public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) <= 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param czdt the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final ChronoZonedDateTime<?> czdt, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(czdt, \"czdt\");\n        return isNewer(file, czdt.toInstant(), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) > 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.from(instant), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the reference {@code Path}.\n     *\n     * @param file      the {@code File} of which the modification date must be compared.\n     * @param reference the {@code File} of which the modification date is used.\n     * @return true if the {@code File} exists and has been modified more\n     * recently than the reference {@code File}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Path reference) throws IOException {\n        return isNewer(file, getLastModifiedTime(reference));\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared.\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified before the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) < 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared.\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isOlder(file, FileTime.from(instant), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified before the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isOlder(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is older than the reference {@code Path}.\n     *\n     * @param file the {@code File} of which the modification date must be compared.\n     * @param reference the {@code File} of which the modification date is used.\n     * @return true if the {@code File} exists and has been modified before than the reference {@code File}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static boolean isOlder(final Path file, final Path reference) throws IOException {\n        return isOlder(file, getLastModifiedTime(reference));\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a regular file or not. Implemented as a null-safe delegate to\n     * {@code Files.isRegularFile(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is\n     *         not a directory, or it cannot be determined if the file is a regular file or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isRegularFile(final Path path, final LinkOption... options) {\n        return path != null && Files.isRegularFile(path, options);\n    }\n\n\n    /**\n     * Creates a new DirectoryStream for Paths rooted at the given directory.\n     *\n     * @param dir the path to the directory to stream.\n     * @param pathFilter the directory stream filter.\n     * @return a new instance.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n        return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n    }\n\n    /**\n     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes\n     * to the file.\n     *\n     * @param path the Path.\n     * @param append Whether or not to append.\n     *\n     * @return a new OutputStream.\n     * @throws IOException if an I/O error occurs.\n     * @see Files#newOutputStream(Path, OpenOption...)\n     * @since 2.12.0\n     */\n    public static OutputStream newOutputStream(final Path path, final boolean append) throws IOException {\n        // @formatter:off\n        return Files.newOutputStream(path, append ?\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.APPEND} :\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING});\n        // @formatter:on\n    }\n\n    private static boolean notExists(final Path file) {\n        return Files.notExists(Objects.requireNonNull(file, \"file\"));\n    }\n\n    /**\n     * Returns true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     *\n     * @param deleteOptions the array to test\n     * @return true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     */\n    private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n        if (deleteOptions == null) {\n            return false;\n        }\n        return Stream.of(deleteOptions).anyMatch(e -> e == StandardDeleteOption.OVERRIDE_READ_ONLY);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)}\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n        return Files.readAttributes(path, BasicFileAttributes.class);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)} while wrapping {@link IOException} as\n     * {@link UncheckedIOException}.\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws UncheckedIOException if an I/O error occurs\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n        try {\n            return readBasicFileAttributes(path);\n        } catch (final IOException e) {\n            throw UncheckedIOExceptions.create(path, e);\n        }\n    }\n\n    /**\n     * Reads the given path as a String.\n     *\n     * @param path The source path.\n     * @param charset How to convert bytes to a String, null uses the default Charset.\n     * @return a new String.\n     * @throws IOException if an I/O error occurs reading from the stream.\n     * @see Files#readAllBytes(Path)\n     * @since 2.12.0\n     */\n    public static String readString(final Path path, final Charset charset) throws IOException {\n        return new String(Files.readAllBytes(path), Charsets.toCharset(charset));\n    }\n\n    /**\n     * Relativizes all files in the given {@code collection} against a {@code parent}.\n     *\n     * @param collection The collection of paths to relativize.\n     * @param parent relativizes against this parent path.\n     * @param sort Whether to sort the result.\n     * @param comparator How to sort.\n     * @return A collection of relativized paths, optionally sorted.\n     */\n    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n        Stream<Path> stream = collection.stream().map(parent::relativize);\n        if (sort) {\n            stream = comparator == null ? stream.sorted() : stream.sorted(comparator);\n        }\n        return stream.collect(Collectors.toList());\n    }\n\n    /**\n     * Sets the last modified time of the given file path to now.\n     *\n     * @param path The file path to set.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path path) throws IOException {\n        Files.setLastModifiedTime(path, FileTime.from(Instant.now()));\n    }\n\n    /**\n     * Sets the given {@code targetFile}'s last modified time to the value from {@code sourceFile}.\n     *\n     * @param sourceFile The source path to query.\n     * @param targetFile The target path to set.\n     * @throws NullPointerException if sourceFile is {@code null}.\n     * @throws NullPointerException if targetFile is {@code null}.\n     * @throws IOException if setting the last-modified time failed.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path sourceFile, final Path targetFile) throws IOException {\n        Objects.requireNonNull(sourceFile, \"sourceFile\");\n        Files.setLastModifiedTime(targetFile, getLastModifiedTime(sourceFile));\n    }\n\n    /**\n     * Sets the given Path to the {@code readOnly} value.\n     * <p>\n     * This behavior is OS dependent.\n     * </p>\n     *\n     * @param path The path to set.\n     * @param readOnly true for read-only, false for not read-only.\n     * @param linkOptions options indicating how symbolic links are handled.\n     * @return The given path.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        final List<Exception> causeList = new ArrayList<>(2);\n        final DosFileAttributeView fileAttributeView = Files.getFileAttributeView(path, DosFileAttributeView.class, linkOptions);\n        if (fileAttributeView != null) {\n            try {\n                fileAttributeView.setReadOnly(readOnly);\n                return path;\n            } catch (final IOException e) {\n                // ignore for now, retry with PosixFileAttributeView\n                causeList.add(e);\n            }\n        }\n        final PosixFileAttributeView posixFileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class, linkOptions);\n        if (posixFileAttributeView != null) {\n            // Works on Windows but not on Ubuntu:\n            // Files.setAttribute(path, \"unix:readonly\", readOnly, options);\n            // java.lang.IllegalArgumentException: 'unix:readonly' not recognized\n            final PosixFileAttributes readAttributes = posixFileAttributeView.readAttributes();\n            final Set<PosixFilePermission> permissions = readAttributes.permissions();\n            permissions.remove(PosixFilePermission.OWNER_WRITE);\n            permissions.remove(PosixFilePermission.GROUP_WRITE);\n            permissions.remove(PosixFilePermission.OTHERS_WRITE);\n            try {\n                return Files.setPosixFilePermissions(path, permissions);\n            } catch (final IOException e) {\n                causeList.add(e);\n            }\n        }\n        if (!causeList.isEmpty()) {\n            throw new IOExceptionList(path.toString(), causeList);\n        }\n        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(linkOptions)));\n    }\n\n    /**\n     * Converts an array of {@link FileVisitOption} to a {@link Set}.\n     *\n     * @param fileVisitOptions input array.\n     * @return a new Set.\n     */\n    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n        return fileVisitOptions == null ? EnumSet.noneOf(FileVisitOption.class) : Stream.of(fileVisitOptions).collect(Collectors.toSet());\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param start See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param options See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param visitor See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options,\n        final int maxDepth) throws IOException {\n        Files.walkFileTree(start, options, maxDepth, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param first See {@link Paths#get(String,String[])}.\n     * @param more See {@link Paths#get(String,String[])}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param uri See {@link Paths#get(URI)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }\n\n    /**\n     * Waits for the file system to propagate a file creation, with a timeout.\n     * <p>\n     * This method repeatedly tests {@link Files#exists(Path,LinkOption...)} until it returns true up to the maximum time\n     * specified.\n     * </p>\n     *\n     * @param file the file to check, must not be {@code null}.\n     * @param timeout the maximum time to wait.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if file exists.\n     * @throws NullPointerException if the file is {@code null}.\n     * @since 2.12.0\n     */\n    public static boolean waitFor(final Path file, final Duration timeout, final LinkOption... options) {\n        Objects.requireNonNull(file, \"file\");\n        final Instant finishInstant = Instant.now().plus(timeout);\n        boolean interrupted = false;\n        final long minSleepMillis = 100;\n        try {\n            while (!Files.exists(file, options)) {\n                final Instant now = Instant.now();\n                if (now.isAfter(finishInstant)) {\n                    return false;\n                }\n                try {\n                    Thread.sleep(Math.min(minSleepMillis, finishInstant.minusMillis(now.toEpochMilli()).toEpochMilli()));\n                } catch (final InterruptedException ignore) {\n                    interrupted = true;\n                } catch (final Exception ex) {\n                    break;\n                }\n            }\n        } finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        return Files.exists(file, options);\n    }\n\n    /**\n     * Returns a stream of filtered paths.\n     *\n     * @param start the start path\n     * @param pathFilter the path filter\n     * @param maxDepth the maximum depth of directories to walk.\n     * @param readAttributes whether to call the filters with file attributes (false passes null).\n     * @param options the options to configure the walk.\n     * @return a filtered stream of paths.\n     * @throws IOException if an I/O error is thrown when accessing the starting file.\n     * @since 2.9.0\n     */\n    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,\n        final FileVisitOption... options) throws IOException {\n        return Files.walk(start, maxDepth, options)\n            .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n    }\n\n    /**\n     * Does allow to instantiate.\n     */\n    private PathUtils() {\n        // do not instantiate.\n    }\n\n}\n", "diffSourceCodeSet": ["private static FileTime getLastModifiedTime(final Path path, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(Objects.requireNonNull(path, \"path\"), options);\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Compares the specified {@code Path}'s last modified time to the given file time.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return See {@link FileTime#compareTo(FileTime)}\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     */\n    private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        return getLastModifiedTime(file, options).compareTo(fileTime);\n    }\nprivate static FileTime getLastModifiedTime(final Path path, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(Objects.requireNonNull(path, \"path\"), options);\n    }", "diffSourceCode": "   223:     /**\n   224:      * Compares the specified {@code Path}'s last modified time to the given file time.\n   225:      *\n   226:      * @param file the {@code Path} of which the modification date must be compared\n   227:      * @param fileTime the time reference.\n   228:      * @param options options indicating how symbolic links are handled been modified after the given time reference.\n   229:      * @return See {@link FileTime#compareTo(FileTime)}\n   230:      * @throws IOException if an I/O error occurs.\n   231:      * @throws NullPointerException if the file is {@code null}\n   232:      */\n   233:     private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n-  234:         return Files.getLastModifiedTime(file, options).compareTo(fileTime);\n+  234:         return getLastModifiedTime(file, options).compareTo(fileTime);\n   235:     }\n-  715:     /**\n-  716:      * Returns a {@link Path} representing the system temporary directory.\n-  717:      *\n+  715:     private static FileTime getLastModifiedTime(final Path path, final LinkOption... options) throws IOException {\n+  716:         return Files.getLastModifiedTime(Objects.requireNonNull(path, \"path\"), options);\n+  717:     }\n", "uniqueId": "d75027d357838e4a56ff43a233169942b12ef7a1_223_235_715_717_223_235", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 6}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `compareLastModifiedTimeTo` method, we can extract the logic of retrieving the last modified time into a separate method. This will make the code more modular and easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\n/**\n * Compares the specified {@code Path}'s last modified time to the given file time.\n *\n * @param file the {@code Path} of which the modification date must be compared\n * @param fileTime the time reference.\n * @param options options indicating how symbolic links are handled been modified after the given time reference.\n * @return See {@link FileTime#compareTo(FileTime)}\n * @throws IOException if an I/O error occurs.\n * @throws NullPointerException if the file is {@code null}\n */\nprivate static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n    FileTime lastModifiedTime = getLastModifiedTime(file, options);\n    return lastModifiedTime.compareTo(fileTime);\n}\n\n/**\n * Retrieves the last modified time of the specified {@code Path}.\n *\n * @param file the {@code Path} to retrieve the last modified time from\n * @param options options indicating how symbolic links are handled\n * @return the last modified time of the file\n * @throws IOException if an I/O error occurs\n * @throws NullPointerException if the file is {@code null}\n */\nprivate static FileTime getLastModifiedTime(final Path file, final LinkOption... options) throws IOException {\n    return Files.getLastModifiedTime(file, options);\n}\n```\n\nThis refactoring extracts the logic of getting the last modified time into a new method called `getLastModifiedTime`. This makes the `compareLastModifiedTimeTo` method cleaner and focuses on its primary responsibility, which is comparing the last modified times. \n\nThe refactored method code is as follows:\n\n##########################\n```java\nprivate static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n    FileTime lastModifiedTime = getLastModifiedTime(file, options);\n    return lastModifiedTime.compareTo(fileTime);\n}\n\nprivate static FileTime getLastModifiedTime(final Path file, final LinkOption... options) throws IOException {\n    return Files.getLastModifiedTime(file, options);\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Compares the specified {@code Path}'s last modified time to the given file time.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return See {@link FileTime#compareTo(FileTime)}\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     */\n    private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(file, options).compareTo(fileTime);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.CopyOption;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.NotDirectoryException;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.chrono.ChronoZonedDateTime;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOExceptionList;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.UncheckedIOExceptions;\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.IOFileFilter;\n\n/**\n * NIO Path utilities.\n *\n * @since 2.7\n */\npublic final class PathUtils {\n\n    /**\n     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative\n     * lists when comparing directories.\n     */\n    private static class RelativeSortedPaths {\n\n        final boolean equals;\n        // final List<Path> relativeDirList1; // might need later?\n        // final List<Path> relativeDirList2; // might need later?\n        final List<Path> relativeFileList1;\n        final List<Path> relativeFileList2;\n\n        /**\n         * Constructs and initializes a new instance by accumulating directory and file info.\n         *\n         * @param dir1 First directory to compare.\n         * @param dir2 Seconds directory to compare.\n         * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @param linkOptions Options indicating how symbolic links are handled.\n         * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @throws IOException if an I/O error is thrown by a visitor method.\n         */\n        private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,\n            final FileVisitOption[] fileVisitOptions) throws IOException {\n            final List<Path> tmpRelativeDirList1;\n            final List<Path> tmpRelativeDirList2;\n            List<Path> tmpRelativeFileList1 = null;\n            List<Path> tmpRelativeFileList2 = null;\n            if (dir1 == null && dir2 == null) {\n                equals = true;\n            } else if (dir1 == null ^ dir2 == null) {\n                equals = false;\n            } else {\n                final boolean parentDirNotExists1 = Files.notExists(dir1, linkOptions);\n                final boolean parentDirNotExists2 = Files.notExists(dir2, linkOptions);\n                if (parentDirNotExists1 || parentDirNotExists2) {\n                    equals = parentDirNotExists1 && parentDirNotExists2;\n                } else {\n                    final AccumulatorPathVisitor visitor1 = accumulate(dir1, maxDepth, fileVisitOptions);\n                    final AccumulatorPathVisitor visitor2 = accumulate(dir2, maxDepth, fileVisitOptions);\n                    if (visitor1.getDirList().size() != visitor2.getDirList().size() || visitor1.getFileList().size() != visitor2.getFileList().size()) {\n                        equals = false;\n                    } else {\n                        tmpRelativeDirList1 = visitor1.relativizeDirectories(dir1, true, null);\n                        tmpRelativeDirList2 = visitor2.relativizeDirectories(dir2, true, null);\n                        if (!tmpRelativeDirList1.equals(tmpRelativeDirList2)) {\n                            equals = false;\n                        } else {\n                            tmpRelativeFileList1 = visitor1.relativizeFiles(dir1, true, null);\n                            tmpRelativeFileList2 = visitor2.relativizeFiles(dir2, true, null);\n                            equals = tmpRelativeFileList1.equals(tmpRelativeFileList2);\n                        }\n                    }\n                }\n            }\n            // relativeDirList1 = tmpRelativeDirList1;\n            // relativeDirList2 = tmpRelativeDirList2;\n            relativeFileList1 = tmpRelativeFileList1;\n            relativeFileList2 = tmpRelativeFileList2;\n        }\n    }\n\n    /**\n     * Empty {@link CopyOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final CopyOption[] EMPTY_COPY_OPTIONS = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final DeleteOption[] EMPTY_DELETE_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link FileVisitOption} array.\n     */\n    public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     */\n    public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY = {};\n\n    /**\n     * {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n     *\n     * @since 2.9.0\n     */\n    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = {LinkOption.NOFOLLOW_LINKS};\n\n    /**\n     * Empty {@link OpenOption} array.\n     */\n    public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link Path} array.\n     *\n     * @since 2.9.0\n     */\n    public static final Path[] EMPTY_PATH_ARRAY = {};\n\n    /**\n     * Accumulates file tree information in a {@link AccumulatorPathVisitor}.\n     *\n     * @param directory The directory to accumulate information.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @return file tree information.\n     */\n    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return cleanDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Compares the specified {@code Path}'s last modified time to the given file time.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return See {@link FileTime#compareTo(FileTime)}\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     */\n    private static int compareLastModifiedTimeTo(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        return Files.getLastModifiedTime(file, options).compareTo(fileTime);\n    }\n\n    /**\n     * Copies a directory to another directory.\n     *\n     * @param sourceDirectory The source directory.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path absoluteSource = sourceDirectory.toAbsolutePath();\n        return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)\n            .getPathCounters();\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetFile The target file.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetFile, copyOptions);\n            return targetFile;\n        }\n    }\n\n    /**\n     * Copies a file to a directory.\n     *\n     * @param sourceFile The source file.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(Path, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n            return targetDirectory;\n        }\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), directory).getPathCounters();\n    }\n\n    /**\n     * Creates the parent directories for the given {@code path}.\n     *\n     * @param path The path to a file (or directory).\n     * @param attrs An optional list of file attributes to set atomically when creating the directories.\n     * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static Path createParentDirectories(final Path path, final FileAttribute<?>... attrs) throws IOException {\n        final Path parent = path.getParent();\n        return parent == null ? null : Files.createDirectories(parent, attrs);\n    }\n\n    /**\n     * Gets the current directory.\n     *\n     * @return the current directory.\n     *\n     * @since 2.9.0\n     */\n    public static Path current() {\n        return Paths.get(\"\");\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     */\n    public static PathCounters delete(final Path path) throws IOException {\n        return delete(path, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return deleteDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions), directory)\n            .getPathCounters();\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     */\n    public static PathCounters deleteFile(final Path file) throws IOException {\n        return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n        // Files.deleteIfExists() never follows links, so use LinkOption.NOFOLLOW_LINKS in other calls to Files.\n        return deleteFile(file, NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)\n        throws NoSuchFileException, IOException {\n        if (Files.isDirectory(file, linkOptions)) {\n            throw new NoSuchFileException(file.toString());\n        }\n        final PathCounters pathCounts = Counters.longPathCounters();\n        final boolean exists = Files.exists(file, linkOptions);\n        final long size = exists && !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n        if (overrideReadOnly(deleteOptions) && exists) {\n            setReadOnly(file, false, linkOptions);\n        }\n        if (Files.deleteIfExists(file)) {\n            pathCounts.getFileCounter().increment();\n            pathCounts.getByteCounter().add(size);\n        }\n        return pathCounts;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryAndFileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param linkOptions options to follow links.\n     * @param openOptions options to open files.\n     * @param fileVisitOption options to configure traversal.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,\n        final FileVisitOption[] fileVisitOption) throws IOException {\n        // First walk both file trees and gather normalized paths.\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        if (notExists(path1) && notExists(path2)) {\n            return true;\n        }\n        final RelativeSortedPaths relativeSortedPaths = new RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption);\n        // If the normalized path names and counts are not the same, no need to compare contents.\n        if (!relativeSortedPaths.equals) {\n            return false;\n        }\n        // Both visitors contain the same normalized paths, we can compare file contents.\n        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n        for (final Path path : fileList1) {\n            final int binarySearch = Collections.binarySearch(fileList2, path);\n            if (binarySearch <= -1) {\n                throw new IllegalStateException(\"Unexpected mismatch.\");\n            }\n            if (!fileContentEquals(path1.resolve(path), path2.resolve(path), linkOptions, openOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, EMPTY_LINK_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param linkOptions options to follow links.\n     * @param fileVisitOptions options to configure the traversal\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,\n        final FileVisitOption[] fileVisitOptions) throws IOException {\n        return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n        return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\n\n    /**\n     * <p>\n     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original\n     * file list that matches the provided filter.\n     * </p>\n     *\n     * <p>\n     * The {@link Set} returned by this method is not guaranteed to be thread safe.\n     * </p>\n     *\n     * <pre>\n     * Set&lt;File&gt; allFiles = ...\n     * Set&lt;File&gt; javaFiles = FileFilterUtils.filterSet(allFiles,\n     *     FileFilterUtils.suffixFileFilter(\".java\"));\n     * </pre>\n     *\n     * @param filter the filter to apply to the set of files.\n     * @param paths the array of files to apply the filter to.\n     *\n     * @return a subset of {@code files} that is accepted by the file filter.\n     * @throws IllegalArgumentException if the filter is {@code null} or {@code files} contains a {@code null} value.\n     *\n     * @since 2.9.0\n     */\n    public static Path[] filter(final PathFilter filter, final Path... paths) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (paths == null) {\n            return EMPTY_PATH_ARRAY;\n        }\n        return filterPaths(filter, Stream.of(paths), Collectors.toList()).toArray(EMPTY_PATH_ARRAY);\n    }\n\n    private static <R, A> R filterPaths(final PathFilter filter, final Stream<Path> stream, final Collector<? super Path, A, R> collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream == null) {\n            return Stream.<Path>empty().collect(collector);\n        }\n        return stream.filter(p -> {\n            try {\n                return p != null && filter.accept(p, readBasicFileAttributes(p)) == FileVisitResult.CONTINUE;\n            } catch (final IOException e) {\n                return false;\n            }\n        }).collect(collector);\n    }\n\n    /**\n     * Reads the access control list from a file attribute view.\n     *\n     * @param sourcePath the path to the file.\n     * @return a file attribute view of the specified type, or null if the attribute view type is not available.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOException {\n        final AclFileAttributeView fileAttributeView = Files.getFileAttributeView(sourcePath, AclFileAttributeView.class);\n        return fileAttributeView == null ? null : fileAttributeView.getAcl();\n    }\n\n    /**\n     * Returns a {@link Path} representing the system temporary directory.\n     *\n     * @return the system temporary directory.\n     *\n     * @since 2.12.0\n     */\n    public static Path getTempDirectory() {\n        return Paths.get(FileUtils.getTempDirectoryPath());\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a directory or not. Implemented as a null-safe delegate to\n     * {@code Files.isDirectory(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a\n     *         directory, or it cannot be determined if the file is a directory or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isDirectory(final Path path, final LinkOption... options) {\n        return path != null && Files.isDirectory(path, options);\n    }\n\n    /**\n     * Tests whether the given file or directory is empty.\n     *\n     * @param path the file or directory to query.\n     * @return whether the file or directory is empty.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }\n\n    /**\n     * Tests whether the directory is empty.\n     *\n     * @param directory the directory to query.\n     * @return whether the directory is empty.\n     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <i>(optional\n     *         specific exception)</i>.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     */\n    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n            return !directoryStream.iterator().hasNext();\n        }\n    }\n\n    /**\n     * Tests whether the given file is empty.\n     *\n     * @param file the file to query.\n     * @return whether the file is empty.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, its\n     *         {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.\n     */\n    public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) <= 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param czdt the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final ChronoZonedDateTime<?> czdt, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(czdt, \"czdt\");\n        return isNewer(file, czdt.toInstant(), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        if (notExists(file)) {\n            return false;\n        }\n        return compareLastModifiedTimeTo(file, fileTime, options) > 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.from(instant), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the reference {@code Path}.\n     *\n     * @param file      the {@code File} of which the modification date must be compared.\n     * @param reference the {@code File} of which the modification date is used.\n     * @return true if the {@code File} exists and has been modified more\n     * recently than the reference {@code File}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Path reference) throws IOException {\n        return isNewer(file, Files.getLastModifiedTime(reference));\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a regular file or not. Implemented as a null-safe delegate to\n     * {@code Files.isRegularFile(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is\n     *         not a directory, or it cannot be determined if the file is a regular file or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isRegularFile(final Path path, final LinkOption... options) {\n        return path != null && Files.isRegularFile(path, options);\n    }\n\n\n    /**\n     * Creates a new DirectoryStream for Paths rooted at the given directory.\n     *\n     * @param dir the path to the directory to stream.\n     * @param pathFilter the directory stream filter.\n     * @return a new instance.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n        return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n    }\n\n    /**\n     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes\n     * to the file.\n     *\n     * @param path the Path.\n     * @param append Whether or not to append.\n     *\n     * @return a new OutputStream.\n     * @throws IOException if an I/O error occurs.\n     * @see Files#newOutputStream(Path, OpenOption...)\n     * @since 2.12.0\n     */\n    public static OutputStream newOutputStream(final Path path, final boolean append) throws IOException {\n        // @formatter:off\n        return Files.newOutputStream(path, append ?\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.APPEND} :\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING});\n        // @formatter:on\n    }\n\n    private static boolean notExists(final Path file) {\n        return Files.notExists(Objects.requireNonNull(file, \"file\"));\n    }\n\n    /**\n     * Returns true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     *\n     * @param deleteOptions the array to test\n     * @return true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     */\n    private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n        if (deleteOptions == null) {\n            return false;\n        }\n        return Stream.of(deleteOptions).anyMatch(e -> e == StandardDeleteOption.OVERRIDE_READ_ONLY);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)}\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n        return Files.readAttributes(path, BasicFileAttributes.class);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)} while wrapping {@link IOException} as\n     * {@link UncheckedIOException}.\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws UncheckedIOException if an I/O error occurs\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n        try {\n            return readBasicFileAttributes(path);\n        } catch (final IOException e) {\n            throw UncheckedIOExceptions.create(path, e);\n        }\n    }\n\n    /**\n     * Reads the given path as a String.\n     *\n     * @param path The source path.\n     * @param charset How to convert bytes to a String, null uses the default Charset.\n     * @return a new String.\n     * @throws IOException if an I/O error occurs reading from the stream.\n     * @see Files#readAllBytes(Path)\n     * @since 2.12.0\n     */\n    public static String readString(final Path path, final Charset charset) throws IOException {\n        return new String(Files.readAllBytes(path), Charsets.toCharset(charset));\n    }\n\n    /**\n     * Relativizes all files in the given {@code collection} against a {@code parent}.\n     *\n     * @param collection The collection of paths to relativize.\n     * @param parent relativizes against this parent path.\n     * @param sort Whether to sort the result.\n     * @param comparator How to sort.\n     * @return A collection of relativized paths, optionally sorted.\n     */\n    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n        Stream<Path> stream = collection.stream().map(parent::relativize);\n        if (sort) {\n            stream = comparator == null ? stream.sorted() : stream.sorted(comparator);\n        }\n        return stream.collect(Collectors.toList());\n    }\n\n    /**\n     * Sets the last modified time of the given file path to now.\n     *\n     * @param path The file path to set.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path path) throws IOException {\n        Files.setLastModifiedTime(path, FileTime.from(Instant.now()));\n    }\n\n    /**\n     * Sets the given {@code targetFile}'s last modified time to the value from {@code sourceFile}.\n     *\n     * @param sourceFile The source path to query.\n     * @param targetFile The target path to set.\n     * @throws NullPointerException if sourceFile is {@code null}.\n     * @throws NullPointerException if targetFile is {@code null}.\n     * @throws IOException if setting the last-modified time failed.\n     * @since 2.12.0\n     */\n    public static void setLastModifiedTime(final Path sourceFile, final Path targetFile) throws IOException {\n        Objects.requireNonNull(sourceFile, \"sourceFile\");\n        Files.setLastModifiedTime(targetFile, Files.getLastModifiedTime(sourceFile));\n    }\n\n    /**\n     * Sets the given Path to the {@code readOnly} value.\n     * <p>\n     * This behavior is OS dependent.\n     * </p>\n     *\n     * @param path The path to set.\n     * @param readOnly true for read-only, false for not read-only.\n     * @param linkOptions options indicating how symbolic links are handled.\n     * @return The given path.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        final List<Exception> causeList = new ArrayList<>(2);\n        final DosFileAttributeView fileAttributeView = Files.getFileAttributeView(path, DosFileAttributeView.class, linkOptions);\n        if (fileAttributeView != null) {\n            try {\n                fileAttributeView.setReadOnly(readOnly);\n                return path;\n            } catch (final IOException e) {\n                // ignore for now, retry with PosixFileAttributeView\n                causeList.add(e);\n            }\n        }\n        final PosixFileAttributeView posixFileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class, linkOptions);\n        if (posixFileAttributeView != null) {\n            // Works on Windows but not on Ubuntu:\n            // Files.setAttribute(path, \"unix:readonly\", readOnly, options);\n            // java.lang.IllegalArgumentException: 'unix:readonly' not recognized\n            final PosixFileAttributes readAttributes = posixFileAttributeView.readAttributes();\n            final Set<PosixFilePermission> permissions = readAttributes.permissions();\n            permissions.remove(PosixFilePermission.OWNER_WRITE);\n            permissions.remove(PosixFilePermission.GROUP_WRITE);\n            permissions.remove(PosixFilePermission.OTHERS_WRITE);\n            try {\n                return Files.setPosixFilePermissions(path, permissions);\n            } catch (final IOException e) {\n                causeList.add(e);\n            }\n        }\n        if (!causeList.isEmpty()) {\n            throw new IOExceptionList(path.toString(), causeList);\n        }\n        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(linkOptions)));\n    }\n\n    /**\n     * Converts an array of {@link FileVisitOption} to a {@link Set}.\n     *\n     * @param fileVisitOptions input array.\n     * @return a new Set.\n     */\n    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n        return fileVisitOptions == null ? EnumSet.noneOf(FileVisitOption.class) : Stream.of(fileVisitOptions).collect(Collectors.toSet());\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param start See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param options See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param visitor See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options,\n        final int maxDepth) throws IOException {\n        Files.walkFileTree(start, options, maxDepth, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param first See {@link Paths#get(String,String[])}.\n     * @param more See {@link Paths#get(String,String[])}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param uri See {@link Paths#get(URI)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }\n\n    /**\n     * Waits for the file system to propagate a file creation, with a timeout.\n     * <p>\n     * This method repeatedly tests {@link Files#exists(Path,LinkOption...)} until it returns true up to the maximum time\n     * specified.\n     * </p>\n     *\n     * @param file the file to check, must not be {@code null}.\n     * @param timeout the maximum time to wait.\n     * @param options options indicating how symbolic links are handled.\n     * @return true if file exists.\n     * @throws NullPointerException if the file is {@code null}.\n     * @since 2.12.0\n     */\n    public static boolean waitFor(final Path file, final Duration timeout, final LinkOption... options) {\n        Objects.requireNonNull(file, \"file\");\n        final Instant finishInstant = Instant.now().plus(timeout);\n        boolean interrupted = false;\n        final long minSleepMillis = 100;\n        try {\n            while (!Files.exists(file, options)) {\n                final Instant now = Instant.now();\n                if (now.isAfter(finishInstant)) {\n                    return false;\n                }\n                try {\n                    Thread.sleep(Math.min(minSleepMillis, finishInstant.minusMillis(now.toEpochMilli()).toEpochMilli()));\n                } catch (final InterruptedException ignore) {\n                    interrupted = true;\n                } catch (final Exception ex) {\n                    break;\n                }\n            }\n        } finally {\n            if (interrupted) {\n                Thread.currentThread().interrupt();\n            }\n        }\n        return Files.exists(file, options);\n    }\n\n    /**\n     * Returns a stream of filtered paths.\n     *\n     * @param start the start path\n     * @param pathFilter the path filter\n     * @param maxDepth the maximum depth of directories to walk.\n     * @param readAttributes whether to call the filters with file attributes (false passes null).\n     * @param options the options to configure the walk.\n     * @return a filtered stream of paths.\n     * @throws IOException if an I/O error is thrown when accessing the starting file.\n     * @since 2.9.0\n     */\n    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,\n        final FileVisitOption... options) throws IOException {\n        return Files.walk(start, maxDepth, options)\n            .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n    }\n\n    /**\n     * Does allow to instantiate.\n     */\n    private PathUtils() {\n        // do not instantiate.\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic isNewer(file Path, fileTime FileTime, options LinkOption...) : boolean extracted from public isNewer(file Path, timeMillis long, options LinkOption...) : boolean in class org.apache.commons.io.file.PathUtils", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/file/PathUtils.java", "startLine": 765, "endLine": 783, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/file/PathUtils.java", "startLine": 807, "endLine": 821, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/file/PathUtils.java", "startLine": 767, "endLine": 785, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        if (Files.notExists(file)) {\n            return false;\n        }\n        return Files.getLastModifiedTime(file, options).toMillis() > timeMillis;\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/file/PathUtils.java", "isPureRefactoring": true, "commitId": "8e265178364e412cd00721b4c164c25381001d7c", "packageNameBefore": "org.apache.commons.io.file", "classNameBefore": "org.apache.commons.io.file.PathUtils", "methodNameBefore": "org.apache.commons.io.file.PathUtils#isNewer", "classSignatureBefore": "public final class PathUtils ", "methodNameBeforeSet": ["org.apache.commons.io.file.PathUtils#isNewer"], "classNameBeforeSet": ["org.apache.commons.io.file.PathUtils"], "classSignatureBeforeSet": ["public final class PathUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.CopyOption;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.NotDirectoryException;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOExceptionList;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.UncheckedIOExceptions;\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.IOFileFilter;\n\n/**\n * NIO Path utilities.\n *\n * @since 2.7\n */\npublic final class PathUtils {\n\n    /**\n     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative\n     * lists when comparing directories.\n     */\n    private static class RelativeSortedPaths {\n\n        final boolean equals;\n        // final List<Path> relativeDirList1; // might need later?\n        // final List<Path> relativeDirList2; // might need later?\n        final List<Path> relativeFileList1;\n        final List<Path> relativeFileList2;\n\n        /**\n         * Constructs and initializes a new instance by accumulating directory and file info.\n         *\n         * @param dir1 First directory to compare.\n         * @param dir2 Seconds directory to compare.\n         * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @param linkOptions Options indicating how symbolic links are handled.\n         * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @throws IOException if an I/O error is thrown by a visitor method.\n         */\n        private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,\n            final FileVisitOption[] fileVisitOptions) throws IOException {\n            final List<Path> tmpRelativeDirList1;\n            final List<Path> tmpRelativeDirList2;\n            List<Path> tmpRelativeFileList1 = null;\n            List<Path> tmpRelativeFileList2 = null;\n            if (dir1 == null && dir2 == null) {\n                equals = true;\n            } else if (dir1 == null ^ dir2 == null) {\n                equals = false;\n            } else {\n                final boolean parentDirNotExists1 = Files.notExists(dir1, linkOptions);\n                final boolean parentDirNotExists2 = Files.notExists(dir2, linkOptions);\n                if (parentDirNotExists1 || parentDirNotExists2) {\n                    equals = parentDirNotExists1 && parentDirNotExists2;\n                } else {\n                    final AccumulatorPathVisitor visitor1 = accumulate(dir1, maxDepth, fileVisitOptions);\n                    final AccumulatorPathVisitor visitor2 = accumulate(dir2, maxDepth, fileVisitOptions);\n                    if (visitor1.getDirList().size() != visitor2.getDirList().size() || visitor1.getFileList().size() != visitor2.getFileList().size()) {\n                        equals = false;\n                    } else {\n                        tmpRelativeDirList1 = visitor1.relativizeDirectories(dir1, true, null);\n                        tmpRelativeDirList2 = visitor2.relativizeDirectories(dir2, true, null);\n                        if (!tmpRelativeDirList1.equals(tmpRelativeDirList2)) {\n                            equals = false;\n                        } else {\n                            tmpRelativeFileList1 = visitor1.relativizeFiles(dir1, true, null);\n                            tmpRelativeFileList2 = visitor2.relativizeFiles(dir2, true, null);\n                            equals = tmpRelativeFileList1.equals(tmpRelativeFileList2);\n                        }\n                    }\n                }\n            }\n            // relativeDirList1 = tmpRelativeDirList1;\n            // relativeDirList2 = tmpRelativeDirList2;\n            relativeFileList1 = tmpRelativeFileList1;\n            relativeFileList2 = tmpRelativeFileList2;\n        }\n    }\n\n    /**\n     * Empty {@link CopyOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final CopyOption[] EMPTY_COPY_OPTIONS = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final DeleteOption[] EMPTY_DELETE_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link FileVisitOption} array.\n     */\n    public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     */\n    public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY = {};\n\n    /**\n     * {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n     *\n     * @since 2.9.0\n     */\n    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = {LinkOption.NOFOLLOW_LINKS};\n\n    /**\n     * Empty {@link OpenOption} array.\n     */\n    public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link Path} array.\n     *\n     * @since 2.9.0\n     */\n    public static final Path[] EMPTY_PATH_ARRAY = {};\n\n    /**\n     * Accumulates file tree information in a {@link AccumulatorPathVisitor}.\n     *\n     * @param directory The directory to accumulate information.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @return file tree information.\n     */\n    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return cleanDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Copies a directory to another directory.\n     *\n     * @param sourceDirectory The source directory.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path absoluteSource = sourceDirectory.toAbsolutePath();\n        return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)\n            .getPathCounters();\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetFile The target file.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetFile, copyOptions);\n            return targetFile;\n        }\n    }\n\n    /**\n     * Copies a file to a directory.\n     *\n     * @param sourceFile The source file.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(Path, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n            return targetDirectory;\n        }\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), directory).getPathCounters();\n    }\n\n    /**\n     * Creates the parent directories for the given {@code path}.\n     *\n     * @param path The path to a file (or directory).\n     * @param attrs An optional list of file attributes to set atomically when creating the directories.\n     * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static Path createParentDirectories(final Path path, final FileAttribute<?>... attrs) throws IOException {\n        final Path parent = path.getParent();\n        return parent == null ? null : Files.createDirectories(parent, attrs);\n    }\n\n    /**\n     * Gets the current directory.\n     *\n     * @return the current directory.\n     *\n     * @since 2.9.0\n     */\n    public static Path current() {\n        return Paths.get(\"\");\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     */\n    public static PathCounters delete(final Path path) throws IOException {\n        return delete(path, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return deleteDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions), directory)\n            .getPathCounters();\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     */\n    public static PathCounters deleteFile(final Path file) throws IOException {\n        return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n        // Files.deleteIfExists() never follows links, so use LinkOption.NOFOLLOW_LINKS in other calls to Files.\n        return deleteFile(file, NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)\n        throws NoSuchFileException, IOException {\n        if (Files.isDirectory(file, linkOptions)) {\n            throw new NoSuchFileException(file.toString());\n        }\n        final PathCounters pathCounts = Counters.longPathCounters();\n        final boolean exists = Files.exists(file, linkOptions);\n        final long size = exists && !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n        if (overrideReadOnly(deleteOptions) && exists) {\n            setReadOnly(file, false, linkOptions);\n        }\n        if (Files.deleteIfExists(file)) {\n            pathCounts.getFileCounter().increment();\n            pathCounts.getByteCounter().add(size);\n        }\n        return pathCounts;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryAndFileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param linkOptions options to follow links.\n     * @param openOptions options to open files.\n     * @param fileVisitOption options to configure traversal.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,\n        final FileVisitOption[] fileVisitOption) throws IOException {\n        // First walk both file trees and gather normalized paths.\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        if (Files.notExists(path1) && Files.notExists(path2)) {\n            return true;\n        }\n        final RelativeSortedPaths relativeSortedPaths = new RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption);\n        // If the normalized path names and counts are not the same, no need to compare contents.\n        if (!relativeSortedPaths.equals) {\n            return false;\n        }\n        // Both visitors contain the same normalized paths, we can compare file contents.\n        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n        for (final Path path : fileList1) {\n            final int binarySearch = Collections.binarySearch(fileList2, path);\n            if (binarySearch <= -1) {\n                throw new IllegalStateException(\"Unexpected mismatch.\");\n            }\n            if (!fileContentEquals(path1.resolve(path), path2.resolve(path), linkOptions, openOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, EMPTY_LINK_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param linkOptions options to follow links.\n     * @param fileVisitOptions options to configure the traversal\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,\n        final FileVisitOption[] fileVisitOptions) throws IOException {\n        return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n        return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\n\n    /**\n     * <p>\n     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original\n     * file list that matches the provided filter.\n     * </p>\n     *\n     * <p>\n     * The {@link Set} returned by this method is not guaranteed to be thread safe.\n     * </p>\n     *\n     * <pre>\n     * Set&lt;File&gt; allFiles = ...\n     * Set&lt;File&gt; javaFiles = FileFilterUtils.filterSet(allFiles,\n     *     FileFilterUtils.suffixFileFilter(\".java\"));\n     * </pre>\n     *\n     * @param filter the filter to apply to the set of files.\n     * @param paths the array of files to apply the filter to.\n     *\n     * @return a subset of {@code files} that is accepted by the file filter.\n     * @throws IllegalArgumentException if the filter is {@code null} or {@code files} contains a {@code null} value.\n     *\n     * @since 2.9.0\n     */\n    public static Path[] filter(final PathFilter filter, final Path... paths) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (paths == null) {\n            return EMPTY_PATH_ARRAY;\n        }\n        return filterPaths(filter, Stream.of(paths), Collectors.toList()).toArray(EMPTY_PATH_ARRAY);\n    }\n\n    private static <R, A> R filterPaths(final PathFilter filter, final Stream<Path> stream, final Collector<? super Path, A, R> collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream == null) {\n            return Stream.<Path>empty().collect(collector);\n        }\n        return stream.filter(p -> {\n            try {\n                return p != null && filter.accept(p, readBasicFileAttributes(p)) == FileVisitResult.CONTINUE;\n            } catch (final IOException e) {\n                return false;\n            }\n        }).collect(collector);\n    }\n\n    /**\n     * Reads the access control list from a file attribute view.\n     *\n     * @param sourcePath the path to the file.\n     * @return a file attribute view of the specified type, or null if the attribute view type is not available.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOException {\n        final AclFileAttributeView fileAttributeView = Files.getFileAttributeView(sourcePath, AclFileAttributeView.class);\n        return fileAttributeView == null ? null : fileAttributeView.getAcl();\n    }\n\n    /**\n     * Returns a {@link Path} representing the system temporary directory.\n     *\n     * @return the system temporary directory.\n     *\n     * @since 2.12.0\n     */\n    public static Path getTempDirectory() {\n        return Paths.get(FileUtils.getTempDirectoryPath());\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a directory or not. Implemented as a null-safe delegate to\n     * {@code Files.isDirectory(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a\n     *         directory, or it cannot be determined if the file is a directory or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isDirectory(final Path path, final LinkOption... options) {\n        return path != null && Files.isDirectory(path, options);\n    }\n\n    /**\n     * Tests whether the given file or directory is empty.\n     *\n     * @param path the file or directory to query.\n     * @return whether the file or directory is empty.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }\n\n    /**\n     * Tests whether the directory is empty.\n     *\n     * @param directory the directory to query.\n     * @return whether the directory is empty.\n     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <i>(optional\n     *         specific exception)</i>.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     */\n    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n            return !directoryStream.iterator().hasNext();\n        }\n    }\n\n    /**\n     * Tests whether the given file is empty.\n     *\n     * @param file the file to query.\n     * @return whether the file is empty.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, its\n     *         {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.\n     */\n    public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) <= 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        if (Files.notExists(file)) {\n            return false;\n        }\n        return Files.getLastModifiedTime(file, options).toMillis() > timeMillis;\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a regular file or not. Implemented as a null-safe delegate to\n     * {@code Files.isRegularFile(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is\n     *         not a directory, or it cannot be determined if the file is a regular file or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isRegularFile(final Path path, final LinkOption... options) {\n        return path != null && Files.isRegularFile(path, options);\n    }\n\n    /**\n     * Creates a new DirectoryStream for Paths rooted at the given directory.\n     *\n     * @param dir the path to the directory to stream.\n     * @param pathFilter the directory stream filter.\n     * @return a new instance.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n        return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n    }\n\n    /**\n     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes\n     * to the file.\n     *\n     * @param path the Path.\n     * @param append Whether or not to append.\n     *\n     * @return a new OutputStream.\n     * @throws IOException if an I/O error occurs.\n     * @see Files#newOutputStream(Path, OpenOption...)\n     * @since 2.12.0\n     */\n    public static OutputStream newOutputStream(final Path path, final boolean append) throws IOException {\n        // @formatter:off\n        return Files.newOutputStream(path, append ?\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.APPEND} :\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING});\n        // @formatter:on\n    }\n\n    /**\n     * Returns true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     *\n     * @param deleteOptions the array to test\n     * @return true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     */\n    private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n        if (deleteOptions == null) {\n            return false;\n        }\n        return Stream.of(deleteOptions).anyMatch(e -> e == StandardDeleteOption.OVERRIDE_READ_ONLY);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)}\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n        return Files.readAttributes(path, BasicFileAttributes.class);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)} while wrapping {@link IOException} as\n     * {@link UncheckedIOException}.\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws UncheckedIOException if an I/O error occurs\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n        try {\n            return readBasicFileAttributes(path);\n        } catch (final IOException e) {\n            throw UncheckedIOExceptions.create(path, e);\n        }\n    }\n\n    /**\n     * Reads the given path as a String.\n     *\n     * @param path The source path.\n     * @param charset How to convert bytes to a String, null uses the default Charset.\n     * @return a new String.\n     * @throws IOException if an I/O error occurs reading from the stream.\n     * @see Files#readAllBytes(Path)\n     * @since 2.12.0\n     */\n    public static String readString(final Path path, final Charset charset) throws IOException {\n        return new String(Files.readAllBytes(path), Charsets.toCharset(charset));\n    }\n\n    /**\n     * Relativizes all files in the given {@code collection} against a {@code parent}.\n     *\n     * @param collection The collection of paths to relativize.\n     * @param parent relativizes against this parent path.\n     * @param sort Whether to sort the result.\n     * @param comparator How to sort.\n     * @return A collection of relativized paths, optionally sorted.\n     */\n    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n        Stream<Path> stream = collection.stream().map(parent::relativize);\n        if (sort) {\n            stream = comparator == null ? stream.sorted() : stream.sorted(comparator);\n        }\n        return stream.collect(Collectors.toList());\n    }\n\n    /**\n     * Sets the given Path to the {@code readOnly} value.\n     * <p>\n     * This behavior is OS dependent.\n     * </p>\n     *\n     * @param path The path to set.\n     * @param readOnly true for read-only, false for not read-only.\n     * @param linkOptions options indicating how symbolic links are handled.\n     * @return The given path.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        final List<Exception> causeList = new ArrayList<>(2);\n        final DosFileAttributeView fileAttributeView = Files.getFileAttributeView(path, DosFileAttributeView.class, linkOptions);\n        if (fileAttributeView != null) {\n            try {\n                fileAttributeView.setReadOnly(readOnly);\n                return path;\n            } catch (final IOException e) {\n                // ignore for now, retry with PosixFileAttributeView\n                causeList.add(e);\n            }\n        }\n        final PosixFileAttributeView posixFileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class, linkOptions);\n        if (posixFileAttributeView != null) {\n            // Works on Windows but not on Ubuntu:\n            // Files.setAttribute(path, \"unix:readonly\", readOnly, options);\n            // java.lang.IllegalArgumentException: 'unix:readonly' not recognized\n            final PosixFileAttributes readAttributes = posixFileAttributeView.readAttributes();\n            final Set<PosixFilePermission> permissions = readAttributes.permissions();\n            permissions.remove(PosixFilePermission.OWNER_WRITE);\n            permissions.remove(PosixFilePermission.GROUP_WRITE);\n            permissions.remove(PosixFilePermission.OTHERS_WRITE);\n            try {\n                return Files.setPosixFilePermissions(path, permissions);\n            } catch (final IOException e) {\n                causeList.add(e);\n            }\n        }\n        if (!causeList.isEmpty()) {\n            throw new IOExceptionList(path.toString(), causeList);\n        }\n        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(linkOptions)));\n    }\n\n    /**\n     * Converts an array of {@link FileVisitOption} to a {@link Set}.\n     *\n     * @param fileVisitOptions input array.\n     * @return a new Set.\n     */\n    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n        return fileVisitOptions == null ? EnumSet.noneOf(FileVisitOption.class) : Stream.of(fileVisitOptions).collect(Collectors.toSet());\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param start See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param options See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param visitor See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options,\n        final int maxDepth) throws IOException {\n        Files.walkFileTree(start, options, maxDepth, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param first See {@link Paths#get(String,String[])}.\n     * @param more See {@link Paths#get(String,String[])}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param uri See {@link Paths#get(URI)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }\n\n    /**\n     * Returns a stream of filtered paths.\n     *\n     * @param start the start path\n     * @param pathFilter the path filter\n     * @param maxDepth the maximum depth of directories to walk.\n     * @param readAttributes whether to call the filters with file attributes (false passes null).\n     * @param options the options to configure the walk.\n     * @return a filtered stream of paths.\n     * @throws IOException if an I/O error is thrown when accessing the starting file.\n     * @since 2.9.0\n     */\n    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,\n        final FileVisitOption... options) throws IOException {\n        return Files.walk(start, maxDepth, options)\n            .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n    }\n\n    /**\n     * Does allow to instantiate.\n     */\n    private PathUtils() {\n        // do not instantiate.\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/file/PathUtils.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.CopyOption;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.NotDirectoryException;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOExceptionList;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.UncheckedIOExceptions;\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.IOFileFilter;\n\n/**\n * NIO Path utilities.\n *\n * @since 2.7\n */\npublic final class PathUtils {\n\n    /**\n     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative\n     * lists when comparing directories.\n     */\n    private static class RelativeSortedPaths {\n\n        final boolean equals;\n        // final List<Path> relativeDirList1; // might need later?\n        // final List<Path> relativeDirList2; // might need later?\n        final List<Path> relativeFileList1;\n        final List<Path> relativeFileList2;\n\n        /**\n         * Constructs and initializes a new instance by accumulating directory and file info.\n         *\n         * @param dir1 First directory to compare.\n         * @param dir2 Seconds directory to compare.\n         * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @param linkOptions Options indicating how symbolic links are handled.\n         * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @throws IOException if an I/O error is thrown by a visitor method.\n         */\n        private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,\n            final FileVisitOption[] fileVisitOptions) throws IOException {\n            final List<Path> tmpRelativeDirList1;\n            final List<Path> tmpRelativeDirList2;\n            List<Path> tmpRelativeFileList1 = null;\n            List<Path> tmpRelativeFileList2 = null;\n            if (dir1 == null && dir2 == null) {\n                equals = true;\n            } else if (dir1 == null ^ dir2 == null) {\n                equals = false;\n            } else {\n                final boolean parentDirNotExists1 = Files.notExists(dir1, linkOptions);\n                final boolean parentDirNotExists2 = Files.notExists(dir2, linkOptions);\n                if (parentDirNotExists1 || parentDirNotExists2) {\n                    equals = parentDirNotExists1 && parentDirNotExists2;\n                } else {\n                    final AccumulatorPathVisitor visitor1 = accumulate(dir1, maxDepth, fileVisitOptions);\n                    final AccumulatorPathVisitor visitor2 = accumulate(dir2, maxDepth, fileVisitOptions);\n                    if (visitor1.getDirList().size() != visitor2.getDirList().size() || visitor1.getFileList().size() != visitor2.getFileList().size()) {\n                        equals = false;\n                    } else {\n                        tmpRelativeDirList1 = visitor1.relativizeDirectories(dir1, true, null);\n                        tmpRelativeDirList2 = visitor2.relativizeDirectories(dir2, true, null);\n                        if (!tmpRelativeDirList1.equals(tmpRelativeDirList2)) {\n                            equals = false;\n                        } else {\n                            tmpRelativeFileList1 = visitor1.relativizeFiles(dir1, true, null);\n                            tmpRelativeFileList2 = visitor2.relativizeFiles(dir2, true, null);\n                            equals = tmpRelativeFileList1.equals(tmpRelativeFileList2);\n                        }\n                    }\n                }\n            }\n            // relativeDirList1 = tmpRelativeDirList1;\n            // relativeDirList2 = tmpRelativeDirList2;\n            relativeFileList1 = tmpRelativeFileList1;\n            relativeFileList2 = tmpRelativeFileList2;\n        }\n    }\n\n    /**\n     * Empty {@link CopyOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final CopyOption[] EMPTY_COPY_OPTIONS = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final DeleteOption[] EMPTY_DELETE_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link FileVisitOption} array.\n     */\n    public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     */\n    public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY = {};\n\n    /**\n     * {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n     *\n     * @since 2.9.0\n     */\n    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = {LinkOption.NOFOLLOW_LINKS};\n\n    /**\n     * Empty {@link OpenOption} array.\n     */\n    public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link Path} array.\n     *\n     * @since 2.9.0\n     */\n    public static final Path[] EMPTY_PATH_ARRAY = {};\n\n    /**\n     * Accumulates file tree information in a {@link AccumulatorPathVisitor}.\n     *\n     * @param directory The directory to accumulate information.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @return file tree information.\n     */\n    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return cleanDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Copies a directory to another directory.\n     *\n     * @param sourceDirectory The source directory.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path absoluteSource = sourceDirectory.toAbsolutePath();\n        return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)\n            .getPathCounters();\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetFile The target file.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetFile, copyOptions);\n            return targetFile;\n        }\n    }\n\n    /**\n     * Copies a file to a directory.\n     *\n     * @param sourceFile The source file.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(Path, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n            return targetDirectory;\n        }\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), directory).getPathCounters();\n    }\n\n    /**\n     * Creates the parent directories for the given {@code path}.\n     *\n     * @param path The path to a file (or directory).\n     * @param attrs An optional list of file attributes to set atomically when creating the directories.\n     * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static Path createParentDirectories(final Path path, final FileAttribute<?>... attrs) throws IOException {\n        final Path parent = path.getParent();\n        return parent == null ? null : Files.createDirectories(parent, attrs);\n    }\n\n    /**\n     * Gets the current directory.\n     *\n     * @return the current directory.\n     *\n     * @since 2.9.0\n     */\n    public static Path current() {\n        return Paths.get(\"\");\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     */\n    public static PathCounters delete(final Path path) throws IOException {\n        return delete(path, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return deleteDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions), directory)\n            .getPathCounters();\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     */\n    public static PathCounters deleteFile(final Path file) throws IOException {\n        return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n        // Files.deleteIfExists() never follows links, so use LinkOption.NOFOLLOW_LINKS in other calls to Files.\n        return deleteFile(file, NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)\n        throws NoSuchFileException, IOException {\n        if (Files.isDirectory(file, linkOptions)) {\n            throw new NoSuchFileException(file.toString());\n        }\n        final PathCounters pathCounts = Counters.longPathCounters();\n        final boolean exists = Files.exists(file, linkOptions);\n        final long size = exists && !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n        if (overrideReadOnly(deleteOptions) && exists) {\n            setReadOnly(file, false, linkOptions);\n        }\n        if (Files.deleteIfExists(file)) {\n            pathCounts.getFileCounter().increment();\n            pathCounts.getByteCounter().add(size);\n        }\n        return pathCounts;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryAndFileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param linkOptions options to follow links.\n     * @param openOptions options to open files.\n     * @param fileVisitOption options to configure traversal.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,\n        final FileVisitOption[] fileVisitOption) throws IOException {\n        // First walk both file trees and gather normalized paths.\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        if (Files.notExists(path1) && Files.notExists(path2)) {\n            return true;\n        }\n        final RelativeSortedPaths relativeSortedPaths = new RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption);\n        // If the normalized path names and counts are not the same, no need to compare contents.\n        if (!relativeSortedPaths.equals) {\n            return false;\n        }\n        // Both visitors contain the same normalized paths, we can compare file contents.\n        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n        for (final Path path : fileList1) {\n            final int binarySearch = Collections.binarySearch(fileList2, path);\n            if (binarySearch <= -1) {\n                throw new IllegalStateException(\"Unexpected mismatch.\");\n            }\n            if (!fileContentEquals(path1.resolve(path), path2.resolve(path), linkOptions, openOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, EMPTY_LINK_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param linkOptions options to follow links.\n     * @param fileVisitOptions options to configure the traversal\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,\n        final FileVisitOption[] fileVisitOptions) throws IOException {\n        return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n        return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\n\n    /**\n     * <p>\n     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original\n     * file list that matches the provided filter.\n     * </p>\n     *\n     * <p>\n     * The {@link Set} returned by this method is not guaranteed to be thread safe.\n     * </p>\n     *\n     * <pre>\n     * Set&lt;File&gt; allFiles = ...\n     * Set&lt;File&gt; javaFiles = FileFilterUtils.filterSet(allFiles,\n     *     FileFilterUtils.suffixFileFilter(\".java\"));\n     * </pre>\n     *\n     * @param filter the filter to apply to the set of files.\n     * @param paths the array of files to apply the filter to.\n     *\n     * @return a subset of {@code files} that is accepted by the file filter.\n     * @throws IllegalArgumentException if the filter is {@code null} or {@code files} contains a {@code null} value.\n     *\n     * @since 2.9.0\n     */\n    public static Path[] filter(final PathFilter filter, final Path... paths) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (paths == null) {\n            return EMPTY_PATH_ARRAY;\n        }\n        return filterPaths(filter, Stream.of(paths), Collectors.toList()).toArray(EMPTY_PATH_ARRAY);\n    }\n\n    private static <R, A> R filterPaths(final PathFilter filter, final Stream<Path> stream, final Collector<? super Path, A, R> collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream == null) {\n            return Stream.<Path>empty().collect(collector);\n        }\n        return stream.filter(p -> {\n            try {\n                return p != null && filter.accept(p, readBasicFileAttributes(p)) == FileVisitResult.CONTINUE;\n            } catch (final IOException e) {\n                return false;\n            }\n        }).collect(collector);\n    }\n\n    /**\n     * Reads the access control list from a file attribute view.\n     *\n     * @param sourcePath the path to the file.\n     * @return a file attribute view of the specified type, or null if the attribute view type is not available.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOException {\n        final AclFileAttributeView fileAttributeView = Files.getFileAttributeView(sourcePath, AclFileAttributeView.class);\n        return fileAttributeView == null ? null : fileAttributeView.getAcl();\n    }\n\n    /**\n     * Returns a {@link Path} representing the system temporary directory.\n     *\n     * @return the system temporary directory.\n     *\n     * @since 2.12.0\n     */\n    public static Path getTempDirectory() {\n        return Paths.get(FileUtils.getTempDirectoryPath());\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a directory or not. Implemented as a null-safe delegate to\n     * {@code Files.isDirectory(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a\n     *         directory, or it cannot be determined if the file is a directory or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isDirectory(final Path path, final LinkOption... options) {\n        return path != null && Files.isDirectory(path, options);\n    }\n\n    /**\n     * Tests whether the given file or directory is empty.\n     *\n     * @param path the file or directory to query.\n     * @return whether the file or directory is empty.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }\n\n    /**\n     * Tests whether the directory is empty.\n     *\n     * @param directory the directory to query.\n     * @return whether the directory is empty.\n     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <i>(optional\n     *         specific exception)</i>.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     */\n    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n            return !directoryStream.iterator().hasNext();\n        }\n    }\n\n    /**\n     * Tests whether the given file is empty.\n     *\n     * @param file the file to query.\n     * @return whether the file is empty.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, its\n     *         {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.\n     */\n    public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) <= 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        if (Files.notExists(file)) {\n            return false;\n        }\n        return Files.getLastModifiedTime(file, options).compareTo(fileTime) > 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param instant the time reference.\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final Instant instant, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        if (Files.notExists(file)) {\n            return false;\n        }\n        return Files.getLastModifiedTime(file, options).toInstant().isAfter(instant);\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.fromMillis(timeMillis), options);\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a regular file or not. Implemented as a null-safe delegate to\n     * {@code Files.isRegularFile(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is\n     *         not a directory, or it cannot be determined if the file is a regular file or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isRegularFile(final Path path, final LinkOption... options) {\n        return path != null && Files.isRegularFile(path, options);\n    }\n\n    /**\n     * Creates a new DirectoryStream for Paths rooted at the given directory.\n     *\n     * @param dir the path to the directory to stream.\n     * @param pathFilter the directory stream filter.\n     * @return a new instance.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n        return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n    }\n\n    /**\n     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes\n     * to the file.\n     *\n     * @param path the Path.\n     * @param append Whether or not to append.\n     *\n     * @return a new OutputStream.\n     * @throws IOException if an I/O error occurs.\n     * @see Files#newOutputStream(Path, OpenOption...)\n     * @since 2.12.0\n     */\n    public static OutputStream newOutputStream(final Path path, final boolean append) throws IOException {\n        // @formatter:off\n        return Files.newOutputStream(path, append ?\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.APPEND} :\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING});\n        // @formatter:on\n    }\n\n    /**\n     * Returns true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     *\n     * @param deleteOptions the array to test\n     * @return true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     */\n    private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n        if (deleteOptions == null) {\n            return false;\n        }\n        return Stream.of(deleteOptions).anyMatch(e -> e == StandardDeleteOption.OVERRIDE_READ_ONLY);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)}\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n        return Files.readAttributes(path, BasicFileAttributes.class);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)} while wrapping {@link IOException} as\n     * {@link UncheckedIOException}.\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws UncheckedIOException if an I/O error occurs\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n        try {\n            return readBasicFileAttributes(path);\n        } catch (final IOException e) {\n            throw UncheckedIOExceptions.create(path, e);\n        }\n    }\n\n    /**\n     * Reads the given path as a String.\n     *\n     * @param path The source path.\n     * @param charset How to convert bytes to a String, null uses the default Charset.\n     * @return a new String.\n     * @throws IOException if an I/O error occurs reading from the stream.\n     * @see Files#readAllBytes(Path)\n     * @since 2.12.0\n     */\n    public static String readString(final Path path, final Charset charset) throws IOException {\n        return new String(Files.readAllBytes(path), Charsets.toCharset(charset));\n    }\n\n    /**\n     * Relativizes all files in the given {@code collection} against a {@code parent}.\n     *\n     * @param collection The collection of paths to relativize.\n     * @param parent relativizes against this parent path.\n     * @param sort Whether to sort the result.\n     * @param comparator How to sort.\n     * @return A collection of relativized paths, optionally sorted.\n     */\n    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n        Stream<Path> stream = collection.stream().map(parent::relativize);\n        if (sort) {\n            stream = comparator == null ? stream.sorted() : stream.sorted(comparator);\n        }\n        return stream.collect(Collectors.toList());\n    }\n\n    /**\n     * Sets the given Path to the {@code readOnly} value.\n     * <p>\n     * This behavior is OS dependent.\n     * </p>\n     *\n     * @param path The path to set.\n     * @param readOnly true for read-only, false for not read-only.\n     * @param linkOptions options indicating how symbolic links are handled.\n     * @return The given path.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        final List<Exception> causeList = new ArrayList<>(2);\n        final DosFileAttributeView fileAttributeView = Files.getFileAttributeView(path, DosFileAttributeView.class, linkOptions);\n        if (fileAttributeView != null) {\n            try {\n                fileAttributeView.setReadOnly(readOnly);\n                return path;\n            } catch (final IOException e) {\n                // ignore for now, retry with PosixFileAttributeView\n                causeList.add(e);\n            }\n        }\n        final PosixFileAttributeView posixFileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class, linkOptions);\n        if (posixFileAttributeView != null) {\n            // Works on Windows but not on Ubuntu:\n            // Files.setAttribute(path, \"unix:readonly\", readOnly, options);\n            // java.lang.IllegalArgumentException: 'unix:readonly' not recognized\n            final PosixFileAttributes readAttributes = posixFileAttributeView.readAttributes();\n            final Set<PosixFilePermission> permissions = readAttributes.permissions();\n            permissions.remove(PosixFilePermission.OWNER_WRITE);\n            permissions.remove(PosixFilePermission.GROUP_WRITE);\n            permissions.remove(PosixFilePermission.OTHERS_WRITE);\n            try {\n                return Files.setPosixFilePermissions(path, permissions);\n            } catch (final IOException e) {\n                causeList.add(e);\n            }\n        }\n        if (!causeList.isEmpty()) {\n            throw new IOExceptionList(path.toString(), causeList);\n        }\n        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(linkOptions)));\n    }\n\n    /**\n     * Converts an array of {@link FileVisitOption} to a {@link Set}.\n     *\n     * @param fileVisitOptions input array.\n     * @return a new Set.\n     */\n    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n        return fileVisitOptions == null ? EnumSet.noneOf(FileVisitOption.class) : Stream.of(fileVisitOptions).collect(Collectors.toSet());\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param start See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param options See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param visitor See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options,\n        final int maxDepth) throws IOException {\n        Files.walkFileTree(start, options, maxDepth, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param first See {@link Paths#get(String,String[])}.\n     * @param more See {@link Paths#get(String,String[])}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param uri See {@link Paths#get(URI)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }\n\n    /**\n     * Returns a stream of filtered paths.\n     *\n     * @param start the start path\n     * @param pathFilter the path filter\n     * @param maxDepth the maximum depth of directories to walk.\n     * @param readAttributes whether to call the filters with file attributes (false passes null).\n     * @param options the options to configure the walk.\n     * @return a filtered stream of paths.\n     * @throws IOException if an I/O error is thrown when accessing the starting file.\n     * @since 2.9.0\n     */\n    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,\n        final FileVisitOption... options) throws IOException {\n        return Files.walk(start, maxDepth, options)\n            .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n    }\n\n    /**\n     * Does allow to instantiate.\n     */\n    private PathUtils() {\n        // do not instantiate.\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        if (Files.notExists(file)) {\n            return false;\n        }\n        return Files.getLastModifiedTime(file, options).compareTo(fileTime) > 0;\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        return isNewer(file, FileTime.fromMillis(timeMillis), options);\n    }\n/**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param fileTime the time reference.\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.12.0\n     */\n    public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        if (Files.notExists(file)) {\n            return false;\n        }\n        return Files.getLastModifiedTime(file, options).compareTo(fileTime) > 0;\n    }", "diffSourceCode": "-  765:     /**\n-  766:      * Tests if the specified {@code Path} is newer than the specified time reference.\n-  767:      *\n-  768:      * @param file the {@code Path} of which the modification date must be compared\n-  769:      * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n-  770:      * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n-  771:      *        been modified after the given time reference.\n-  772:      * @return true if the {@code Path} exists and has been modified after the given time reference.\n-  773:      * @throws IOException if an I/O error occurs.\n-  774:      * @throws NullPointerException if the file is {@code null}\n-  775:      * @since 2.9.0\n-  776:      */\n-  777:     public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n-  778:         Objects.requireNonNull(file, \"file\");\n-  779:         if (Files.notExists(file)) {\n-  780:             return false;\n-  781:         }\n-  782:         return Files.getLastModifiedTime(file, options).toMillis() > timeMillis;\n-  783:     }\n-  784: \n-  785:     /**\n-  807:      * @throws IOException if an I/O error occurs.\n-  808:      */\n-  809:     public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n-  810:         return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n-  811:     }\n-  812: \n-  813:     /**\n-  814:      * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes\n-  815:      * to the file.\n-  816:      *\n-  817:      * @param path the Path.\n-  818:      * @param append Whether or not to append.\n-  819:      *\n-  820:      * @return a new OutputStream.\n-  821:      * @throws IOException if an I/O error occurs.\n+  765:     }\n+  766: \n+  767:     /**\n+  768:      * Tests if the specified {@code Path} is newer than the specified time reference.\n+  769:      *\n+  770:      * @param file the {@code Path} of which the modification date must be compared\n+  771:      * @param fileTime the time reference.\n+  772:      * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n+  773:      *        been modified after the given time reference.\n+  774:      * @return true if the {@code Path} exists and has been modified after the given time reference.\n+  775:      * @throws IOException if an I/O error occurs.\n+  776:      * @throws NullPointerException if the file is {@code null}\n+  777:      * @since 2.12.0\n+  778:      */\n+  779:     public static boolean isNewer(final Path file, final FileTime fileTime, final LinkOption... options) throws IOException {\n+  780:         Objects.requireNonNull(file, \"file\");\n+  781:         if (Files.notExists(file)) {\n+  782:             return false;\n+  783:         }\n+  784:         return Files.getLastModifiedTime(file, options).compareTo(fileTime) > 0;\n+  785:     }\n+  807:     /**\n+  808:      * Tests if the specified {@code Path} is newer than the specified time reference.\n+  809:      *\n+  810:      * @param file the {@code Path} of which the modification date must be compared\n+  811:      * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n+  812:      * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n+  813:      *        been modified after the given time reference.\n+  814:      * @return true if the {@code Path} exists and has been modified after the given time reference.\n+  815:      * @throws IOException if an I/O error occurs.\n+  816:      * @throws NullPointerException if the file is {@code null}\n+  817:      * @since 2.9.0\n+  818:      */\n+  819:     public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n+  820:         return isNewer(file, FileTime.fromMillis(timeMillis), options);\n+  821:     }\n", "uniqueId": "8e265178364e412cd00721b4c164c25381001d7c_765_783_767_785_807_821", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 2, "covered": 20}, "BRANCH": {"missed": 1, "covered": 3}, "LINE": {"missed": 1, "covered": 3}, "COMPLEXITY": {"missed": 1, "covered": 2}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `isNewer` method, we can extract the logic that checks if the file exists and retrieves its last modified time into a separate method. This will make the `isNewer` method cleaner and easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\nprivate static boolean fileExists(final Path file, final LinkOption... options) throws IOException {\n    return Files.exists(file, options);\n}\n\nprivate static long getLastModifiedTime(final Path file, final LinkOption... options) throws IOException {\n    return Files.getLastModifiedTime(file, options).toMillis();\n}\n\npublic static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n    Objects.requireNonNull(file, \"file\");\n    if (!fileExists(file, options)) {\n        return false;\n    }\n    return getLastModifiedTime(file, options) > timeMillis;\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Methods**:\n   - `fileExists`: This method checks if the file exists using the provided options.\n   - `getLastModifiedTime`: This method retrieves the last modified time of the file in milliseconds.\n\n2. **Updated `isNewer` Method**: \n   - The `isNewer` method now calls the extracted methods, making it more concise and focused on its primary purpose.\n\nThis refactoring enhances the modularity of the code, making it easier to test and maintain.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        if (Files.notExists(file)) {\n            return false;\n        }\n        return Files.getLastModifiedTime(file, options).toMillis() > timeMillis;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UncheckedIOException;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.nio.file.CopyOption;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.NoSuchFileException;\nimport java.nio.file.NotDirectoryException;\nimport java.nio.file.OpenOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.nio.file.attribute.AclEntry;\nimport java.nio.file.attribute.AclFileAttributeView;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileAttribute;\nimport java.nio.file.attribute.PosixFileAttributeView;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.nio.file.attribute.PosixFilePermission;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOExceptionList;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.UncheckedIOExceptions;\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.IOFileFilter;\n\n/**\n * NIO Path utilities.\n *\n * @since 2.7\n */\npublic final class PathUtils {\n\n    /**\n     * Private worker/holder that computes and tracks relative path names and their equality. We reuse the sorted relative\n     * lists when comparing directories.\n     */\n    private static class RelativeSortedPaths {\n\n        final boolean equals;\n        // final List<Path> relativeDirList1; // might need later?\n        // final List<Path> relativeDirList2; // might need later?\n        final List<Path> relativeFileList1;\n        final List<Path> relativeFileList2;\n\n        /**\n         * Constructs and initializes a new instance by accumulating directory and file info.\n         *\n         * @param dir1 First directory to compare.\n         * @param dir2 Seconds directory to compare.\n         * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @param linkOptions Options indicating how symbolic links are handled.\n         * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n         * @throws IOException if an I/O error is thrown by a visitor method.\n         */\n        private RelativeSortedPaths(final Path dir1, final Path dir2, final int maxDepth, final LinkOption[] linkOptions,\n            final FileVisitOption[] fileVisitOptions) throws IOException {\n            final List<Path> tmpRelativeDirList1;\n            final List<Path> tmpRelativeDirList2;\n            List<Path> tmpRelativeFileList1 = null;\n            List<Path> tmpRelativeFileList2 = null;\n            if (dir1 == null && dir2 == null) {\n                equals = true;\n            } else if (dir1 == null ^ dir2 == null) {\n                equals = false;\n            } else {\n                final boolean parentDirNotExists1 = Files.notExists(dir1, linkOptions);\n                final boolean parentDirNotExists2 = Files.notExists(dir2, linkOptions);\n                if (parentDirNotExists1 || parentDirNotExists2) {\n                    equals = parentDirNotExists1 && parentDirNotExists2;\n                } else {\n                    final AccumulatorPathVisitor visitor1 = accumulate(dir1, maxDepth, fileVisitOptions);\n                    final AccumulatorPathVisitor visitor2 = accumulate(dir2, maxDepth, fileVisitOptions);\n                    if (visitor1.getDirList().size() != visitor2.getDirList().size() || visitor1.getFileList().size() != visitor2.getFileList().size()) {\n                        equals = false;\n                    } else {\n                        tmpRelativeDirList1 = visitor1.relativizeDirectories(dir1, true, null);\n                        tmpRelativeDirList2 = visitor2.relativizeDirectories(dir2, true, null);\n                        if (!tmpRelativeDirList1.equals(tmpRelativeDirList2)) {\n                            equals = false;\n                        } else {\n                            tmpRelativeFileList1 = visitor1.relativizeFiles(dir1, true, null);\n                            tmpRelativeFileList2 = visitor2.relativizeFiles(dir2, true, null);\n                            equals = tmpRelativeFileList1.equals(tmpRelativeFileList2);\n                        }\n                    }\n                }\n            }\n            // relativeDirList1 = tmpRelativeDirList1;\n            // relativeDirList2 = tmpRelativeDirList2;\n            relativeFileList1 = tmpRelativeFileList1;\n            relativeFileList2 = tmpRelativeFileList2;\n        }\n    }\n\n    /**\n     * Empty {@link CopyOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final CopyOption[] EMPTY_COPY_OPTIONS = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     *\n     * @since 2.8.0\n     */\n    public static final DeleteOption[] EMPTY_DELETE_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link FileVisitOption} array.\n     */\n    public static final FileVisitOption[] EMPTY_FILE_VISIT_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link LinkOption} array.\n     */\n    public static final LinkOption[] EMPTY_LINK_OPTION_ARRAY = {};\n\n    /**\n     * {@link LinkOption} array for {@link LinkOption#NOFOLLOW_LINKS}.\n     *\n     * @since 2.9.0\n     */\n    public static final LinkOption[] NOFOLLOW_LINK_OPTION_ARRAY = {LinkOption.NOFOLLOW_LINKS};\n\n    /**\n     * Empty {@link OpenOption} array.\n     */\n    public static final OpenOption[] EMPTY_OPEN_OPTION_ARRAY = {};\n\n    /**\n     * Empty {@link Path} array.\n     *\n     * @since 2.9.0\n     */\n    public static final Path[] EMPTY_PATH_ARRAY = {};\n\n    /**\n     * Accumulates file tree information in a {@link AccumulatorPathVisitor}.\n     *\n     * @param directory The directory to accumulate information.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param fileVisitOptions See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @return file tree information.\n     */\n    private static AccumulatorPathVisitor accumulate(final Path directory, final int maxDepth, final FileVisitOption[] fileVisitOptions) throws IOException {\n        return visitFileTree(AccumulatorPathVisitor.withLongCounters(), directory, toFileVisitOptionSet(fileVisitOptions), maxDepth);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters cleanDirectory(final Path directory) throws IOException {\n        return cleanDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Cleans a directory including sub-directories without deleting directories.\n     *\n     * @param directory directory to clean.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters cleanDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new CleaningPathVisitor(Counters.longPathCounters(), deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Copies a directory to another directory.\n     *\n     * @param sourceDirectory The source directory.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The visitation path counters.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters copyDirectory(final Path sourceDirectory, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        final Path absoluteSource = sourceDirectory.toAbsolutePath();\n        return visitFileTree(new CopyDirectoryVisitor(Counters.longPathCounters(), absoluteSource, targetDirectory, copyOptions), absoluteSource)\n            .getPathCounters();\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetFile The target file.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFile(final URL sourceFile, final Path targetFile, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetFile, copyOptions);\n            return targetFile;\n        }\n    }\n\n    /**\n     * Copies a file to a directory.\n     *\n     * @param sourceFile The source file.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(Path, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final Path sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        return Files.copy(sourceFile, targetDirectory.resolve(sourceFile.getFileName()), copyOptions);\n    }\n\n    /**\n     * Copies a URL to a directory.\n     *\n     * @param sourceFile The source URL.\n     * @param targetDirectory The target directory.\n     * @param copyOptions Specifies how the copying should be done.\n     * @return The target file\n     * @throws IOException if an I/O error occurs.\n     * @see Files#copy(InputStream, Path, CopyOption...)\n     */\n    public static Path copyFileToDirectory(final URL sourceFile, final Path targetDirectory, final CopyOption... copyOptions) throws IOException {\n        try (final InputStream inputStream = sourceFile.openStream()) {\n            Files.copy(inputStream, targetDirectory.resolve(sourceFile.getFile()), copyOptions);\n            return targetDirectory;\n        }\n    }\n\n    /**\n     * Counts aspects of a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to count the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters countDirectory(final Path directory) throws IOException {\n        return visitFileTree(new CountingPathVisitor(Counters.longPathCounters()), directory).getPathCounters();\n    }\n\n    /**\n     * Creates the parent directories for the given {@code path}.\n     *\n     * @param path The path to a file (or directory).\n     * @param attrs An optional list of file attributes to set atomically when creating the directories.\n     * @return The Path for the {@code path}'s parent directory or null if the given path has no parent.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static Path createParentDirectories(final Path path, final FileAttribute<?>... attrs) throws IOException {\n        final Path parent = path.getParent();\n        return parent == null ? null : Files.createDirectories(parent, attrs);\n    }\n\n    /**\n     * Gets the current directory.\n     *\n     * @return the current directory.\n     *\n     * @since 2.9.0\n     */\n    public static Path current() {\n        return Paths.get(\"\");\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     */\n    public static PathCounters delete(final Path path) throws IOException {\n        return delete(path, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static PathCounters delete(final Path path, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS) ? deleteDirectory(path, deleteOptions) : deleteFile(path, deleteOptions);\n    }\n\n    /**\n     * Deletes a file or directory. If the path is a directory, delete it and all sub-directories.\n     * <p>\n     * The difference between File.delete() and this method are:\n     * </p>\n     * <ul>\n     * <li>A directory to delete does not have to be empty.</li>\n     * <li>You get exceptions when a file or directory cannot be deleted; {@link java.io.File#delete()} returns a boolean.\n     * </ul>\n     *\n     * @param path file or directory to delete, must not be {@code null}\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws NullPointerException if the directory is {@code null}\n     * @throws IOException if an I/O error is thrown by a visitor method or if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static PathCounters delete(final Path path, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        // File deletion through Files deletes links, not targets, so use LinkOption.NOFOLLOW_LINKS.\n        return Files.isDirectory(path, linkOptions) ? deleteDirectory(path, linkOptions, deleteOptions) : deleteFile(path, linkOptions, deleteOptions);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     */\n    public static PathCounters deleteDirectory(final Path directory) throws IOException {\n        return deleteDirectory(directory, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), PathUtils.NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions), directory)\n            .getPathCounters();\n    }\n\n    /**\n     * Deletes a directory including sub-directories.\n     *\n     * @param directory directory to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return The visitor used to delete the given directory.\n     * @throws IOException if an I/O error is thrown by a visitor method.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteDirectory(final Path directory, final LinkOption[] linkOptions, final DeleteOption... deleteOptions) throws IOException {\n        return visitFileTree(new DeletingPathVisitor(Counters.longPathCounters(), linkOptions, deleteOptions), directory).getPathCounters();\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     */\n    public static PathCounters deleteFile(final Path file) throws IOException {\n        return deleteFile(file, EMPTY_DELETE_OPTION_ARRAY);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.8.0\n     */\n    public static PathCounters deleteFile(final Path file, final DeleteOption... deleteOptions) throws IOException {\n        // Files.deleteIfExists() never follows links, so use LinkOption.NOFOLLOW_LINKS in other calls to Files.\n        return deleteFile(file, NOFOLLOW_LINK_OPTION_ARRAY, deleteOptions);\n    }\n\n    /**\n     * Deletes the given file.\n     *\n     * @param file The file to delete.\n     * @param linkOptions How to handle symbolic links.\n     * @param deleteOptions How to handle deletion.\n     * @return A visitor with path counts set to 1 file, 0 directories, and the size of the deleted file.\n     * @throws IOException if an I/O error occurs.\n     * @throws NoSuchFileException if the file is a directory.\n     * @since 2.9.0\n     */\n    public static PathCounters deleteFile(final Path file, final LinkOption[] linkOptions, final DeleteOption... deleteOptions)\n        throws NoSuchFileException, IOException {\n        if (Files.isDirectory(file, linkOptions)) {\n            throw new NoSuchFileException(file.toString());\n        }\n        final PathCounters pathCounts = Counters.longPathCounters();\n        final boolean exists = Files.exists(file, linkOptions);\n        final long size = exists && !Files.isSymbolicLink(file) ? Files.size(file) : 0;\n        if (overrideReadOnly(deleteOptions) && exists) {\n            setReadOnly(file, false, linkOptions);\n        }\n        if (Files.deleteIfExists(file)) {\n            pathCounts.getFileCounter().increment();\n            pathCounts.getByteCounter().add(size);\n        }\n        return pathCounts;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryAndFileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not while considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param linkOptions options to follow links.\n     * @param openOptions options to open files.\n     * @param fileVisitOption options to configure traversal.\n     * @return Whether the two directories contain the same files while considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryAndFileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions,\n        final FileVisitOption[] fileVisitOption) throws IOException {\n        // First walk both file trees and gather normalized paths.\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        if (Files.notExists(path1) && Files.notExists(path2)) {\n            return true;\n        }\n        final RelativeSortedPaths relativeSortedPaths = new RelativeSortedPaths(path1, path2, Integer.MAX_VALUE, linkOptions, fileVisitOption);\n        // If the normalized path names and counts are not the same, no need to compare contents.\n        if (!relativeSortedPaths.equals) {\n            return false;\n        }\n        // Both visitors contain the same normalized paths, we can compare file contents.\n        final List<Path> fileList1 = relativeSortedPaths.relativeFileList1;\n        final List<Path> fileList2 = relativeSortedPaths.relativeFileList2;\n        for (final Path path : fileList1) {\n            final int binarySearch = Collections.binarySearch(fileList2, path);\n            if (binarySearch <= -1) {\n                throw new IllegalStateException(\"Unexpected mismatch.\");\n            }\n            if (!fileContentEquals(path1.resolve(path), path2.resolve(path), linkOptions, openOptions)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2) throws IOException {\n        return directoryContentEquals(path1, path2, Integer.MAX_VALUE, EMPTY_LINK_OPTION_ARRAY, EMPTY_FILE_VISIT_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file sets of two Paths to determine if they are equal or not without considering file contents. The\n     * comparison includes all files in all sub-directories.\n     *\n     * @param path1 The first directory.\n     * @param path2 The second directory.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param linkOptions options to follow links.\n     * @param fileVisitOptions options to configure the traversal\n     * @return Whether the two directories contain the same files without considering file contents.\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static boolean directoryContentEquals(final Path path1, final Path path2, final int maxDepth, final LinkOption[] linkOptions,\n        final FileVisitOption[] fileVisitOptions) throws IOException {\n        return new RelativeSortedPaths(path1, path2, maxDepth, linkOptions, fileVisitOptions).equals;\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2) throws IOException {\n        return fileContentEquals(path1, path2, EMPTY_LINK_OPTION_ARRAY, EMPTY_OPEN_OPTION_ARRAY);\n    }\n\n    /**\n     * Compares the file contents of two Paths to determine if they are equal or not.\n     * <p>\n     * File content is accessed through {@link Files#newInputStream(Path,OpenOption...)}.\n     * </p>\n     *\n     * @param path1 the first stream.\n     * @param path2 the second stream.\n     * @param linkOptions options specifying how files are followed.\n     * @param openOptions options specifying how files are opened.\n     * @return true if the content of the streams are equal or they both don't exist, false otherwise.\n     * @throws NullPointerException if either input is null.\n     * @throws IOException if an I/O error occurs.\n     * @see org.apache.commons.io.FileUtils#contentEquals(java.io.File, java.io.File)\n     */\n    public static boolean fileContentEquals(final Path path1, final Path path2, final LinkOption[] linkOptions, final OpenOption[] openOptions)\n        throws IOException {\n        if (path1 == null && path2 == null) {\n            return true;\n        }\n        if (path1 == null || path2 == null) {\n            return false;\n        }\n        final Path nPath1 = path1.normalize();\n        final Path nPath2 = path2.normalize();\n        final boolean path1Exists = Files.exists(nPath1, linkOptions);\n        if (path1Exists != Files.exists(nPath2, linkOptions)) {\n            return false;\n        }\n        if (!path1Exists) {\n            // Two not existing files are equal?\n            // Same as FileUtils\n            return true;\n        }\n        if (Files.isDirectory(nPath1, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath1);\n        }\n        if (Files.isDirectory(nPath2, linkOptions)) {\n            // don't compare directory contents.\n            throw new IOException(\"Can't compare directories, only files: \" + nPath2);\n        }\n        if (Files.size(nPath1) != Files.size(nPath2)) {\n            // lengths differ, cannot be equal\n            return false;\n        }\n        if (path1.equals(path2)) {\n            // same file\n            return true;\n        }\n        try (final InputStream inputStream1 = Files.newInputStream(nPath1, openOptions);\n            final InputStream inputStream2 = Files.newInputStream(nPath2, openOptions)) {\n            return IOUtils.contentEquals(inputStream1, inputStream2);\n        }\n    }\n\n    /**\n     * <p>\n     * Applies an {@link IOFileFilter} to the provided {@link File} objects. The resulting array is a subset of the original\n     * file list that matches the provided filter.\n     * </p>\n     *\n     * <p>\n     * The {@link Set} returned by this method is not guaranteed to be thread safe.\n     * </p>\n     *\n     * <pre>\n     * Set&lt;File&gt; allFiles = ...\n     * Set&lt;File&gt; javaFiles = FileFilterUtils.filterSet(allFiles,\n     *     FileFilterUtils.suffixFileFilter(\".java\"));\n     * </pre>\n     *\n     * @param filter the filter to apply to the set of files.\n     * @param paths the array of files to apply the filter to.\n     *\n     * @return a subset of {@code files} that is accepted by the file filter.\n     * @throws IllegalArgumentException if the filter is {@code null} or {@code files} contains a {@code null} value.\n     *\n     * @since 2.9.0\n     */\n    public static Path[] filter(final PathFilter filter, final Path... paths) {\n        Objects.requireNonNull(filter, \"filter\");\n        if (paths == null) {\n            return EMPTY_PATH_ARRAY;\n        }\n        return filterPaths(filter, Stream.of(paths), Collectors.toList()).toArray(EMPTY_PATH_ARRAY);\n    }\n\n    private static <R, A> R filterPaths(final PathFilter filter, final Stream<Path> stream, final Collector<? super Path, A, R> collector) {\n        Objects.requireNonNull(filter, \"filter\");\n        Objects.requireNonNull(collector, \"collector\");\n        if (stream == null) {\n            return Stream.<Path>empty().collect(collector);\n        }\n        return stream.filter(p -> {\n            try {\n                return p != null && filter.accept(p, readBasicFileAttributes(p)) == FileVisitResult.CONTINUE;\n            } catch (final IOException e) {\n                return false;\n            }\n        }).collect(collector);\n    }\n\n    /**\n     * Reads the access control list from a file attribute view.\n     *\n     * @param sourcePath the path to the file.\n     * @return a file attribute view of the specified type, or null if the attribute view type is not available.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static List<AclEntry> getAclEntryList(final Path sourcePath) throws IOException {\n        final AclFileAttributeView fileAttributeView = Files.getFileAttributeView(sourcePath, AclFileAttributeView.class);\n        return fileAttributeView == null ? null : fileAttributeView.getAcl();\n    }\n\n    /**\n     * Returns a {@link Path} representing the system temporary directory.\n     *\n     * @return the system temporary directory.\n     *\n     * @since 2.12.0\n     */\n    public static Path getTempDirectory() {\n        return Paths.get(FileUtils.getTempDirectoryPath());\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a directory or not. Implemented as a null-safe delegate to\n     * {@code Files.isDirectory(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a directory; {@code false} if the path is null, the file does not exist, is not a\n     *         directory, or it cannot be determined if the file is a directory or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isDirectory(final Path path, final LinkOption... options) {\n        return path != null && Files.isDirectory(path, options);\n    }\n\n    /**\n     * Tests whether the given file or directory is empty.\n     *\n     * @param path the file or directory to query.\n     * @return whether the file or directory is empty.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static boolean isEmpty(final Path path) throws IOException {\n        return Files.isDirectory(path) ? isEmptyDirectory(path) : isEmptyFile(path);\n    }\n\n    /**\n     * Tests whether the directory is empty.\n     *\n     * @param directory the directory to query.\n     * @return whether the directory is empty.\n     * @throws NotDirectoryException if the file could not otherwise be opened because it is not a directory <i>(optional\n     *         specific exception)</i>.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     */\n    public static boolean isEmptyDirectory(final Path directory) throws IOException {\n        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directory)) {\n            return !directoryStream.iterator().hasNext();\n        }\n    }\n\n    /**\n     * Tests whether the given file is empty.\n     *\n     * @param file the file to query.\n     * @return whether the file is empty.\n     * @throws IOException if an I/O error occurs.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, its\n     *         {@link SecurityManager#checkRead(String) checkRead} method denies read access to the file.\n     */\n    public static boolean isEmptyFile(final Path file) throws IOException {\n        return Files.size(file) <= 0;\n    }\n\n    /**\n     * Tests if the specified {@code Path} is newer than the specified time reference.\n     *\n     * @param file the {@code Path} of which the modification date must be compared\n     * @param timeMillis the time reference measured in milliseconds since the epoch (00:00:00 GMT, January 1, 1970)\n     * @param options options indicating how symbolic links are handled * @return true if the {@code Path} exists and has\n     *        been modified after the given time reference.\n     * @return true if the {@code Path} exists and has been modified after the given time reference.\n     * @throws IOException if an I/O error occurs.\n     * @throws NullPointerException if the file is {@code null}\n     * @since 2.9.0\n     */\n    public static boolean isNewer(final Path file, final long timeMillis, final LinkOption... options) throws IOException {\n        Objects.requireNonNull(file, \"file\");\n        if (Files.notExists(file)) {\n            return false;\n        }\n        return Files.getLastModifiedTime(file, options).toMillis() > timeMillis;\n    }\n\n    /**\n     * Tests whether the specified {@code Path} is a regular file or not. Implemented as a null-safe delegate to\n     * {@code Files.isRegularFile(Path path, LinkOption... options)}.\n     *\n     * @param path the path to the file.\n     * @param options options indicating how symbolic links are handled\n     * @return {@code true} if the file is a regular file; {@code false} if the path is null, the file does not exist, is\n     *         not a directory, or it cannot be determined if the file is a regular file or not.\n     * @throws SecurityException In the case of the default provider, and a security manager is installed, the\n     *         {@link SecurityManager#checkRead(String) checkRead} method is invoked to check read access to the directory.\n     * @since 2.9.0\n     */\n    public static boolean isRegularFile(final Path path, final LinkOption... options) {\n        return path != null && Files.isRegularFile(path, options);\n    }\n\n    /**\n     * Creates a new DirectoryStream for Paths rooted at the given directory.\n     *\n     * @param dir the path to the directory to stream.\n     * @param pathFilter the directory stream filter.\n     * @return a new instance.\n     * @throws IOException if an I/O error occurs.\n     */\n    public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\n        return Files.newDirectoryStream(dir, new DirectoryStreamFilter(pathFilter));\n    }\n\n    /**\n     * Creates a new OutputStream by opening or creating a file, returning an output stream that may be used to write bytes\n     * to the file.\n     *\n     * @param path the Path.\n     * @param append Whether or not to append.\n     *\n     * @return a new OutputStream.\n     * @throws IOException if an I/O error occurs.\n     * @see Files#newOutputStream(Path, OpenOption...)\n     * @since 2.12.0\n     */\n    public static OutputStream newOutputStream(final Path path, final boolean append) throws IOException {\n        // @formatter:off\n        return Files.newOutputStream(path, append ?\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.APPEND} :\n            new OpenOption[] {StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING});\n        // @formatter:on\n    }\n\n    /**\n     * Returns true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     *\n     * @param deleteOptions the array to test\n     * @return true if the given options contain {@link StandardDeleteOption#OVERRIDE_READ_ONLY}.\n     */\n    private static boolean overrideReadOnly(final DeleteOption... deleteOptions) {\n        if (deleteOptions == null) {\n            return false;\n        }\n        return Stream.of(deleteOptions).anyMatch(e -> e == StandardDeleteOption.OVERRIDE_READ_ONLY);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)}\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributes(final Path path) throws IOException {\n        return Files.readAttributes(path, BasicFileAttributes.class);\n    }\n\n    /**\n     * Shorthand for {@code Files.readAttributes(path, BasicFileAttributes.class)} while wrapping {@link IOException} as\n     * {@link UncheckedIOException}.\n     *\n     * @param path the path to read.\n     * @return the path attributes.\n     * @throws UncheckedIOException if an I/O error occurs\n     * @since 2.9.0\n     */\n    public static BasicFileAttributes readBasicFileAttributesUnchecked(final Path path) {\n        try {\n            return readBasicFileAttributes(path);\n        } catch (final IOException e) {\n            throw UncheckedIOExceptions.create(path, e);\n        }\n    }\n\n    /**\n     * Reads the given path as a String.\n     *\n     * @param path The source path.\n     * @param charset How to convert bytes to a String, null uses the default Charset.\n     * @return a new String.\n     * @throws IOException if an I/O error occurs reading from the stream.\n     * @see Files#readAllBytes(Path)\n     * @since 2.12.0\n     */\n    public static String readString(final Path path, final Charset charset) throws IOException {\n        return new String(Files.readAllBytes(path), Charsets.toCharset(charset));\n    }\n\n    /**\n     * Relativizes all files in the given {@code collection} against a {@code parent}.\n     *\n     * @param collection The collection of paths to relativize.\n     * @param parent relativizes against this parent path.\n     * @param sort Whether to sort the result.\n     * @param comparator How to sort.\n     * @return A collection of relativized paths, optionally sorted.\n     */\n    static List<Path> relativize(final Collection<Path> collection, final Path parent, final boolean sort, final Comparator<? super Path> comparator) {\n        Stream<Path> stream = collection.stream().map(parent::relativize);\n        if (sort) {\n            stream = comparator == null ? stream.sorted() : stream.sorted(comparator);\n        }\n        return stream.collect(Collectors.toList());\n    }\n\n    /**\n     * Sets the given Path to the {@code readOnly} value.\n     * <p>\n     * This behavior is OS dependent.\n     * </p>\n     *\n     * @param path The path to set.\n     * @param readOnly true for read-only, false for not read-only.\n     * @param linkOptions options indicating how symbolic links are handled.\n     * @return The given path.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static Path setReadOnly(final Path path, final boolean readOnly, final LinkOption... linkOptions) throws IOException {\n        final List<Exception> causeList = new ArrayList<>(2);\n        final DosFileAttributeView fileAttributeView = Files.getFileAttributeView(path, DosFileAttributeView.class, linkOptions);\n        if (fileAttributeView != null) {\n            try {\n                fileAttributeView.setReadOnly(readOnly);\n                return path;\n            } catch (final IOException e) {\n                // ignore for now, retry with PosixFileAttributeView\n                causeList.add(e);\n            }\n        }\n        final PosixFileAttributeView posixFileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class, linkOptions);\n        if (posixFileAttributeView != null) {\n            // Works on Windows but not on Ubuntu:\n            // Files.setAttribute(path, \"unix:readonly\", readOnly, options);\n            // java.lang.IllegalArgumentException: 'unix:readonly' not recognized\n            final PosixFileAttributes readAttributes = posixFileAttributeView.readAttributes();\n            final Set<PosixFilePermission> permissions = readAttributes.permissions();\n            permissions.remove(PosixFilePermission.OWNER_WRITE);\n            permissions.remove(PosixFilePermission.GROUP_WRITE);\n            permissions.remove(PosixFilePermission.OTHERS_WRITE);\n            try {\n                return Files.setPosixFilePermissions(path, permissions);\n            } catch (final IOException e) {\n                causeList.add(e);\n            }\n        }\n        if (!causeList.isEmpty()) {\n            throw new IOExceptionList(path.toString(), causeList);\n        }\n        throw new IOException(String.format(\"No DosFileAttributeView or PosixFileAttributeView for '%s' (linkOptions=%s)\", path, Arrays.toString(linkOptions)));\n    }\n\n    /**\n     * Converts an array of {@link FileVisitOption} to a {@link Set}.\n     *\n     * @param fileVisitOptions input array.\n     * @return a new Set.\n     */\n    static Set<FileVisitOption> toFileVisitOptionSet(final FileVisitOption... fileVisitOptions) {\n        return fileVisitOptions == null ? EnumSet.noneOf(FileVisitOption.class) : Stream.of(fileVisitOptions).collect(Collectors.toSet());\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param directory See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path directory) throws IOException {\n        Files.walkFileTree(directory, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param start See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param options See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param maxDepth See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param visitor See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @param <T> See {@link Files#walkFileTree(Path,Set,int,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final Path start, final Set<FileVisitOption> options,\n        final int maxDepth) throws IOException {\n        Files.walkFileTree(start, options, maxDepth, visitor);\n        return visitor;\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param first See {@link Paths#get(String,String[])}.\n     * @param more See {@link Paths#get(String,String[])}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final String first, final String... more) throws IOException {\n        return visitFileTree(visitor, Paths.get(first, more));\n    }\n\n    /**\n     * Performs {@link Files#walkFileTree(Path,FileVisitor)} and returns the given visitor.\n     *\n     * Note that {@link Files#walkFileTree(Path,FileVisitor)} returns the given path.\n     *\n     * @param visitor See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @param uri See {@link Paths#get(URI)}.\n     * @param <T> See {@link Files#walkFileTree(Path,FileVisitor)}.\n     * @return the given visitor.\n     *\n     * @throws IOException if an I/O error is thrown by a visitor method\n     */\n    public static <T extends FileVisitor<? super Path>> T visitFileTree(final T visitor, final URI uri) throws IOException {\n        return visitFileTree(visitor, Paths.get(uri));\n    }\n\n    /**\n     * Returns a stream of filtered paths.\n     *\n     * @param start the start path\n     * @param pathFilter the path filter\n     * @param maxDepth the maximum depth of directories to walk.\n     * @param readAttributes whether to call the filters with file attributes (false passes null).\n     * @param options the options to configure the walk.\n     * @return a filtered stream of paths.\n     * @throws IOException if an I/O error is thrown when accessing the starting file.\n     * @since 2.9.0\n     */\n    public static Stream<Path> walk(final Path start, final PathFilter pathFilter, final int maxDepth, final boolean readAttributes,\n        final FileVisitOption... options) throws IOException {\n        return Files.walk(start, maxDepth, options)\n            .filter(path -> pathFilter.accept(path, readAttributes ? readBasicFileAttributesUnchecked(path) : null) == FileVisitResult.CONTINUE);\n    }\n\n    /**\n     * Does allow to instantiate.\n     */\n    private PathUtils() {\n        // do not instantiate.\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate toSeparator(unixSeparator boolean) : char extracted from public normalizeNoEndSeparator(fileName String, unixSeparator boolean) : String in class org.apache.commons.io.FilenameUtils", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/FilenameUtils.java", "startLine": 295, "endLine": 341, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/FilenameUtils.java", "startLine": 1322, "endLine": 1367, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/FilenameUtils.java", "startLine": 1492, "endLine": 1500, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, false);\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/FilenameUtils.java", "isPureRefactoring": true, "commitId": "6dd4c0850cdc0c92a8171efbd98649bb3993a8c8", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.FilenameUtils", "methodNameBefore": "org.apache.commons.io.FilenameUtils#normalizeNoEndSeparator", "invokedMethod": "methodSignature: org.apache.commons.io.FilenameUtils#doNormalize\n methodBody: private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\nif(fileName == null){return null;\n}requireNonNullChars(fileName);\nint size=fileName.length();\nif(size == 0){return fileName;\n}final int prefix=getPrefixLength(fileName);\nif(prefix < 0){return null;\n}final char[] array=new char[size + 2];\nfileName.getChars(0,fileName.length(),array,0);\nfinal char otherSeparator=separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\nfor(int i=0; i < array.length; i++){if(array[i] == otherSeparator){array[i]=separator;\n}}boolean lastIsDirectory=true;\nif(array[size - 1] != separator){array[size++]=separator;\nlastIsDirectory=false;\n}for(int i=(prefix != 0) ? prefix : 1; i < size; i++){if(array[i] == separator && array[i - 1] == separator){System.arraycopy(array,i,array,i - 1,size - i);\nsize--;\ni--;\n}}for(int i=prefix + 1; i < size; i++){if(array[i] == separator && array[i - 1] == '.' && (i == prefix + 1 || array[i - 2] == separator)){if(i == size - 1){lastIsDirectory=true;\n}System.arraycopy(array,i + 1,array,i - 1,size - i);\nsize-=2;\ni--;\n}}outerfor(int i=prefix + 2; i < size; i++){if(array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' && (i == prefix + 2 || array[i - 3] == separator)){if(i == prefix + 2){return null;\n}if(i == size - 1){lastIsDirectory=true;\n}int j;\nfor(j=i - 4; j >= prefix; j--){if(array[j] == separator){System.arraycopy(array,i + 1,array,j + 1,size - i);\nsize-=i - j;\ni=j + 1;\ncontinue outer;\n}}System.arraycopy(array,i + 1,array,prefix,size - i);\nsize-=i + 1 - prefix;\ni=prefix + 1;\n}}if(size <= 0){return EMPTY_STRING;\n}if(size <= prefix){return new String(array,0,size);\n}if(lastIsDirectory && keepSeparator){return new String(array,0,size);\n}return new String(array,0,size - 1);\n}", "classSignatureBefore": "public class FilenameUtils ", "methodNameBeforeSet": ["org.apache.commons.io.FilenameUtils#normalizeNoEndSeparator"], "classNameBeforeSet": ["org.apache.commons.io.FilenameUtils"], "classSignatureBeforeSet": ["public class FilenameUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Overlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Attribute-", "description": "Rename Attribute on the top of the extracted method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.File;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * General file name and file path manipulation utilities.\n * <p>\n * When dealing with file names you can hit problems when moving from a Windows\n * based development machine to a Unix based production machine.\n * This class aims to help avoid those problems.\n * <p>\n * <b>NOTE</b>: You may be able to avoid using this class entirely simply by\n * using JDK {@link java.io.File File} objects and the two argument constructor\n * {@link java.io.File#File(java.io.File, java.lang.String) File(File,String)}.\n * <p>\n * Most methods on this class are designed to work the same on both Unix and Windows.\n * Those that don't include 'System', 'Unix' or 'Windows' in their name.\n * <p>\n * Most methods recognize both separators (forward and back), and both\n * sets of prefixes. See the Javadoc of each method for details.\n * <p>\n * This class defines six components within a file name\n * (example C:\\dev\\project\\file.txt):\n * <ul>\n * <li>the prefix - C:\\</li>\n * <li>the path - dev\\project\\</li>\n * <li>the full path - C:\\dev\\project\\</li>\n * <li>the name - file.txt</li>\n * <li>the base name - file</li>\n * <li>the extension - txt</li>\n * </ul>\n * Note that this class works best if directory file names end with a separator.\n * If you omit the last separator, it is impossible to determine if the file name\n * corresponds to a file or a directory. As a result, we have chosen to say\n * it corresponds to a file.\n * <p>\n * This class only supports Unix and Windows style names.\n * Prefixes are matched as follows:\n * <pre>\n * Windows:\n * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n *\n * Unix:\n * a/b/c.txt           --&gt; \"\"          --&gt; relative\n * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n * </pre>\n * Both prefix styles are matched always, irrespective of the machine that you are\n * currently running on.\n * <p>\n * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.\n *\n * @since 1.1\n */\npublic class FilenameUtils {\n\n    private static final String[] EMPTY_STRING_ARRAY = {};\n\n    private static final String EMPTY_STRING = \"\";\n\n    private static final int NOT_FOUND = -1;\n\n    /**\n     * The extension separator character.\n     * @since 1.4\n     */\n    public static final char EXTENSION_SEPARATOR = '.';\n\n    /**\n     * The extension separator String.\n     * @since 1.4\n     */\n    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n\n    /**\n     * The Unix separator character.\n     */\n    private static final char UNIX_SEPARATOR = '/';\n\n    /**\n     * The Windows separator character.\n     */\n    private static final char WINDOWS_SEPARATOR = '\\\\';\n\n    /**\n     * The system separator character.\n     */\n    private static final char SYSTEM_SEPARATOR = File.separatorChar;\n\n    /**\n     * The separator character that is the opposite of the system separator.\n     */\n    private static final char OTHER_SEPARATOR;\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_SEPARATOR;\n        }\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public FilenameUtils() {\n    }\n\n    /**\n     * Determines if Windows file system is in use.\n     *\n     * @return true if the system is Windows\n     */\n    static boolean isSystemWindows() {\n        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;\n    }\n\n    /**\n     * Checks if the character is a separator.\n     *\n     * @param ch  the character to check\n     * @return true if it is a separator character\n     */\n    private static boolean isSeparator(final char ch) {\n        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, true);\n    }\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalize(final String fileName, final boolean unixSeparator) {\n        final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, true);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, false);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, false);\n    }\n\n    /**\n     * Internal method to perform the normalization.\n     *\n     * @param fileName  the fileName\n     * @param separator The separator character to use\n     * @param keepSeparator  true to keep the final separator\n     * @return the normalized fileName. Null bytes inside string will be removed.\n     */\n    private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n\n        requireNonNullChars(fileName);\n\n        int size = fileName.length();\n        if (size == 0) {\n            return fileName;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n\n        final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        fileName.getChars(0, fileName.length(), array, 0);\n\n        // fix separators throughout\n        final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n\n        // adjoining slashes\n        // If we get here, prefix can only be 0 or greater, size 1 or greater\n        // If prefix is 0, set loop start to 1 to prevent index errors\n        for (int i = (prefix != 0) ? prefix : 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        // dot slash\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' &&\n                    (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -=2;\n                i--;\n            }\n        }\n\n        // double dot slash\n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&\n                    (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4 ; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n\n        if (size <= 0) {  // should never be less than 0\n            return EMPTY_STRING;\n        }\n        if (size <= prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }\n\n    /**\n     * Concatenates a fileName to a base path using normal command line style rules.\n     * <p>\n     * The effect is equivalent to resultant directory after changing\n     * directory to the first argument, followed by changing directory to\n     * the second argument.\n     * </p>\n     * <p>\n     * The first argument is the base path, the second is the path to concatenate.\n     * The returned path is always normalized via {@link #normalize(String)},\n     * thus {@code ..} is handled.\n     * </p>\n     * <p>\n     * If {@code pathToAdd} is absolute (has an absolute prefix), then\n     * it will be normalized and returned.\n     * Otherwise, the paths will be joined, normalized and returned.\n     * </p>\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * </p>\n     * <pre>\n     * /foo/      + bar        --&gt;  /foo/bar\n     * /foo       + bar        --&gt;  /foo/bar\n     * /foo       + /bar       --&gt;  /bar\n     * /foo       + C:/bar     --&gt;  C:/bar\n     * /foo       + C:bar      --&gt;  C:bar [1]\n     * /foo/a/    + ../bar     --&gt;  /foo/bar\n     * /foo/      + ../../bar  --&gt;  null\n     * /foo/      + /bar       --&gt;  /bar\n     * /foo/..    + /bar       --&gt;  /bar\n     * /foo       + bar/c.txt  --&gt;  /foo/bar/c.txt\n     * /foo/c.txt + bar        --&gt;  /foo/c.txt/bar [2]\n     * </pre>\n     * <p>\n     * [1] Note that the Windows relative drive prefix is unreliable when\n     * used with this method.\n     * </p>\n     * <p>\n     * [2] Note that the first parameter must be a path. If it ends with a name, then\n     * the name will be built into the concatenated path. If this might be a problem,\n     * use {@link #getFullPath(String)} on the base path argument.\n     * </p>\n     *\n     * @param basePath  the base path to attach to, always treated as a path\n     * @param fullFileNameToAdd  the fileName (or path) to attach to the base\n     * @return the concatenated path, or null if invalid.  Null bytes inside string will be removed\n     */\n    public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix = getPrefixLength(fullFileNameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        final int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + '/' + fullFileNameToAdd);\n    }\n\n    /**\n     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).\n     * <p>\n     * The files names are expected to be normalized.\n     * </p>\n     *\n     * Edge cases:\n     * <ul>\n     * <li>A {@code directory} must not be null: if null, throw IllegalArgumentException</li>\n     * <li>A directory does not contain itself: return false</li>\n     * <li>A null child file is not contained in any parent: return false</li>\n     * </ul>\n     *\n     * @param canonicalParent\n     *            the file to consider as the parent.\n     * @param canonicalChild\n     *            the file to consider as the child.\n     * @return true is the candidate leaf is under by the specified composite. False otherwise.\n     * @since 2.2\n     * @see FileUtils#directoryContains(File, File)\n     */\n    public static boolean directoryContains(final String canonicalParent, final String canonicalChild) {\n        if (isEmpty(canonicalParent) || isEmpty(canonicalChild)) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        final char separator = canonicalParent.charAt(0) == UNIX_SEPARATOR ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        final String parentWithEndSeparator = canonicalParent.charAt(canonicalParent.length() - 1) == separator ? canonicalParent : canonicalParent + separator;\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, parentWithEndSeparator);\n    }\n\n    private static boolean isEmpty(final String string) {\n        return string == null || string.isEmpty();\n    }\n\n    /**\n     * Converts all separators to the Unix separator of forward slash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the Windows separator of backslash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToWindows(final String path) {\n        if (path == null || path.indexOf(UNIX_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the system separator.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToSystem(final String path) {\n        if (path == null) {\n            return null;\n        }\n        return isSystemWindows() ? separatorsToWindows(path) : separatorsToUnix(path);\n    }\n\n    /**\n     * Returns the length of the fileName prefix, such as {@code C:/} or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * <p>\n     * The prefix length includes the first slash in the full fileName\n     * if applicable. Thus, it is possible that the length returned is greater\n     * than the length of the input string.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; 0           --&gt; relative\n     * \\a\\b\\c.txt          --&gt; 1           --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; 2           --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; 3           --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; 9           --&gt; UNC\n     * \\\\\\a\\b\\c.txt        --&gt; -1          --&gt; error\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; 0           --&gt; relative\n     * /a/b/c.txt          --&gt; 1           --&gt; absolute\n     * ~/a/b/c.txt         --&gt; 2           --&gt; current user\n     * ~                   --&gt; 2           --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; 6           --&gt; named user\n     * ~user               --&gt; 6           --&gt; named user (slash added)\n     * //server/a/b/c.txt  --&gt; 9\n     * ///a/b/c.txt        --&gt; -1          --&gt; error\n     * C:                  --&gt; 0           --&gt; valid filename as only null byte and / are reserved characters\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * Note that a leading // (or \\\\) is used to indicate a UNC name on Windows.\n     * These must be followed by a server name, so double-slashes are not collapsed\n     * to a single slash at the start of the fileName.\n     *\n     * @param fileName  the fileName to find the prefix in, null returns -1\n     * @return the length of the prefix, -1 if invalid or null\n     */\n    public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 && !FileSystem.getCurrent().supportsDriveLetter()) {\n                    return 0;\n                }\n                if (len == 2 || !isSeparator(fileName.charAt(2))) {\n                    return 2;\n                }\n                return 3;\n            }\n            if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        }\n        if (!isSeparator(ch0) || !isSeparator(ch1)) {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n        int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n        if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n            return NOT_FOUND;\n        }\n        posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n        posWin = posWin == NOT_FOUND ? posUnix : posWin;\n        final int pos = Math.min(posUnix, posWin) + 1;\n        final String hostnamePart = fileName.substring(2, pos - 1);\n        return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n    }\n\n    /**\n     * Returns the index of the last directory separator character.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The position of the last forward or backslash is returned.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfLastSeparator(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos = fileName.lastIndexOf(UNIX_SEPARATOR);\n        final int lastWindowsPos = fileName.lastIndexOf(WINDOWS_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    /**\n     * Returns the index of the last extension separator character, which is a dot.\n     * <p>\n     * This method also checks that there is no directory separator after the last dot. To do this it uses\n     * {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.\n     * </p>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName\n     *            the fileName to find the last extension separator in, null returns -1\n     * @return the index of the last extension separator character, or -1 if there is no such character\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            // Special handling for NTFS ADS: Don't accept colon in the fileName.\n            final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));\n            if (offset != -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n            }\n        }\n        final int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator = indexOfLastSeparator(fileName);\n        return lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n    }\n\n    /**\n     * Gets the prefix from a full fileName, such as {@code C:/}\n     * or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The prefix includes the first slash in the full fileName where applicable.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n     * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; \"\"          --&gt; relative\n     * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n     * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n     * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n     * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the prefix of the file, null if invalid. Null bytes inside string will be removed\n     */\n    public static String getPrefix(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        final int len = getPrefixLength(fileName);\n        if (len < 0) {\n            return null;\n        }\n        if (len > fileName.length()) {\n            requireNonNullChars(fileName + UNIX_SEPARATOR);\n            return fileName + UNIX_SEPARATOR;\n        }\n        final String path = fileName.substring(0, len);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\\\n     * ~/a/b/c.txt  --&gt; a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPath(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix, and\n     * also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\n     * ~/a/b/c.txt  --&gt; a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param separatorAdd  0 to omit the end separator, 1 to return it\n     * @return the path. Null bytes inside string will be removed\n     */\n    private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        final int endIndex = index+separatorAdd;\n        if (prefix >= fileName.length() || index < 0 || prefix >= endIndex) {\n            return EMPTY_STRING;\n        }\n        final String path = fileName.substring(prefix, endIndex);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\\\n     * ~/a/b/c.txt  --&gt; ~/a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~/\n     * ~/           --&gt; ~/\n     * ~user        --&gt; ~user/\n     * ~user/       --&gt; ~user/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path,\n     * and also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\n     * ~/a/b/c.txt  --&gt; ~/a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~\n     * ~/           --&gt; ~\n     * ~user        --&gt; ~user\n     * ~user/       --&gt; ~user\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param includeSeparator  true to include the end separator\n     * @return the path\n     */\n    private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  // add end slash if necessary\n            }\n            return fileName;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        if (index < 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }\n\n    /**\n     * Gets the name minus the path from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c.txt\n     * a.txt     --&gt; a.txt\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists.\n     * Null bytes inside string will be removed\n     */\n    public static String getName(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n        final int index = indexOfLastSeparator(fileName);\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Checks the input for null bytes, a sign of unsanitized data being passed to to file level functions.\n     *\n     * This may be used for poison byte attacks.\n     *\n     * @param path the path to check\n     */\n    private static void requireNonNullChars(final String path) {\n        if (path.indexOf(0) >= 0) {\n            throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \"\n                + \"known legitimate use cases for such data, but several injection attacks may use it\");\n        }\n    }\n\n    /**\n     * Gets the base name, minus the full path and extension, from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash and before the last dot is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c\n     * a.txt     --&gt; a\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists. Null bytes inside string\n     * will be removed\n     */\n    public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }\n\n    /**\n     * Gets the extension of a fileName.\n     * <p>\n     * This method returns the textual part of the fileName after the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt      --&gt; \"txt\"\n     * a/b/c.jpg    --&gt; \"jpg\"\n     * a/b.txt/c    --&gt; \"\"\n     * a/b/c        --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName the fileName to retrieve the extension of.\n     * @return the extension of the file or an empty string if none exists or {@code null}\n     * if the fileName is {@code null}.\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return null;\n        }\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Special handling for NTFS ADS: Don't accept colon in the fileName.\n     *\n     * @param fileName a file name\n     * @return ADS offsets.\n     */\n    private static int getAdsCriticalOffset(final String fileName) {\n        // Step 1: Remove leading path segments.\n        final int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);\n        final int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 == -1) {\n            if (offset2 == -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 == -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }\n\n    /**\n     * Removes the extension from a fileName.\n     * <p>\n     * This method returns the textual part of the fileName before the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt    --&gt; foo\n     * a\\b\\c.jpg  --&gt; a\\b\\c\n     * a\\b\\c      --&gt; a\\b\\c\n     * a.b\\c      --&gt; a.b\\c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the fileName minus the extension\n     */\n    public static String removeExtension(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }\n\n    /**\n     * Checks whether two fileNames are equal exactly.\n     * <p>\n     * No processing is performed on the fileNames other than comparison,\n     * thus this is merely a null-safe case-sensitive equals.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal using the case rules of the system.\n     * <p>\n     * No processing is performed on the fileNames other than comparison.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed in a case-sensitive manner.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized\n     * and using the case rules of the system.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed case-sensitive on Unix and\n     * case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal, optionally normalizing and providing\n     * control over the case-sensitivity.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @param normalized  whether to normalize the fileNames\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileNames are equal, null equals null\n     * @since 1.3\n     */\n    public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\n\n        if (fileName1 == null || fileName2 == null) {\n            return fileName1 == null && fileName2 == null;\n        }\n        if (normalized) {\n            fileName1 = normalize(fileName1);\n            if (fileName1 == null) {\n                return false;\n            }\n            fileName2 = normalize(fileName2);\n            if (fileName2 == null) {\n                return false;\n            }\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        return caseSensitivity.checkEquals(fileName1, fileName2);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (isEmpty(extension)) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String... extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final Collection<String> extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher,\n     * always testing case-sensitive.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive always.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * using the case rules of the system.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SYSTEM\n     */\n    public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * allowing control over case-sensitivity.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileName matches the wildcard string\n     * @since 1.3\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n        if (fileName == null && wildcardMatcher == null) {\n            return true;\n        }\n        if (fileName == null || wildcardMatcher == null) {\n            return false;\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        final String[] wcs = splitOnTokens(wildcardMatcher);\n        boolean anyChars = false;\n        int textIdx = 0;\n        int wcsIdx = 0;\n        final Deque<int[]> backtrack = new ArrayDeque<>(wcs.length);\n\n        // loop around a backtrack stack, to handle complex * matching\n        do {\n            if (!backtrack.isEmpty()) {\n                final int[] array = backtrack.pop();\n                wcsIdx = array[0];\n                textIdx = array[1];\n                anyChars = true;\n            }\n\n            // loop whilst tokens and text left to process\n            while (wcsIdx < wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    // ? so move to next text char\n                    textIdx++;\n                    if (textIdx > fileName.length()) {\n                        break;\n                    }\n                    anyChars = false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    // set any chars status\n                    anyChars = true;\n                    if (wcsIdx == wcs.length - 1) {\n                        textIdx = fileName.length();\n                    }\n\n                } else {\n                    // matching text token\n                    if (anyChars) {\n                        // any chars then try to locate text token\n                        textIdx = caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx == NOT_FOUND) {\n                            // token not found\n                            break;\n                        }\n                        final int repeat = caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat >= 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        // matching from current position\n                        // couldn't match token\n                        break;\n                    }\n\n                    // matched text token, move text index to end of matched token\n                    textIdx += wcs[wcsIdx].length();\n                    anyChars = false;\n                }\n\n                wcsIdx++;\n            }\n\n            // full match\n            if (wcsIdx == wcs.length && textIdx == fileName.length()) {\n                return true;\n            }\n\n        } while (!backtrack.isEmpty());\n\n        return false;\n    }\n\n    /**\n     * Splits a string into a number of tokens.\n     * The text is split by '?' and '*'.\n     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n     *\n     * @param text  the text to split\n     * @return the array of tokens, never null\n     */\n    static String[] splitOnTokens(final String text) {\n        // used by wildcardMatch\n        // package level so a unit test may run on this\n\n        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array = text.toCharArray();\n        final ArrayList<String> list = new ArrayList<>();\n        final StringBuilder buffer = new StringBuilder();\n        char prevChar = 0;\n        for (final char ch : array) {\n            if (ch == '?' || ch == '*') {\n                if (buffer.length() != 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch == '?') {\n                    list.add(\"?\");\n                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar = ch;\n        }\n        if (buffer.length() != 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray(EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986.\n     *\n     * <p>Accepted are IP addresses (v4 and v6) as well as what the\n     * RFC calls a \"reg-name\". Percent encoded names don't seem to be\n     * valid names in UNC paths.</p>\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isValidHostName(final String name) {\n        return isIPv6Address(name) || isRFC3986HostName(name);\n    }\n\n    private static final Pattern IPV4_PATTERN =\n        Pattern.compile(\"^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$\");\n    private static final int IPV4_MAX_OCTET_VALUE = 255;\n\n    /**\n     * Checks whether a given string represents a valid IPv4 address.\n     *\n     * @param name the name to validate\n     * @return true if the given name is a valid IPv4 address\n     */\n    // mostly copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet4Address\n    private static boolean isIPv4Address(final String name) {\n        final Matcher m = IPV4_PATTERN.matcher(name);\n        if (!m.matches() || m.groupCount() != 4) {\n            return false;\n        }\n\n        // verify that address subgroups are legal\n        for (int i = 1; i <= 4; i++) {\n            final String ipSegment = m.group(i);\n            final int iIpSegment = Integer.parseInt(ipSegment);\n            if (iIpSegment > IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n\n            if (ipSegment.length() > 1 && ipSegment.startsWith(\"0\")) {\n                return false;\n            }\n\n        }\n\n        return true;\n    }\n\n    private static final int IPV6_MAX_HEX_GROUPS = 8;\n    private static final int IPV6_MAX_HEX_DIGITS_PER_GROUP = 4;\n    private static final int MAX_UNSIGNED_SHORT = 0xffff;\n    private static final int BASE_16 = 16;\n\n    // copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet6Address\n    /**\n     * Checks whether a given string represents a valid IPv6 address.\n     *\n     * @param inet6Address the name to validate\n     * @return true if the given name is a valid IPv6 address\n     */\n    private static boolean isIPv6Address(final String inet6Address) {\n        final boolean containsCompressedZeroes = inet6Address.contains(\"::\");\n        if (containsCompressedZeroes && (inet6Address.indexOf(\"::\") != inet6Address.lastIndexOf(\"::\"))) {\n            return false;\n        }\n        if ((inet6Address.startsWith(\":\") && !inet6Address.startsWith(\"::\"))\n                || (inet6Address.endsWith(\":\") && !inet6Address.endsWith(\"::\"))) {\n            return false;\n        }\n        String[] octets = inet6Address.split(\":\");\n        if (containsCompressedZeroes) {\n            final List<String> octetList = new ArrayList<>(Arrays.asList(octets));\n            if (inet6Address.endsWith(\"::\")) {\n                // String.split() drops ending empty segments\n                octetList.add(\"\");\n            } else if (inet6Address.startsWith(\"::\") && !octetList.isEmpty()) {\n                octetList.remove(0);\n            }\n            octets = octetList.toArray(EMPTY_STRING_ARRAY);\n        }\n        if (octets.length > IPV6_MAX_HEX_GROUPS) {\n            return false;\n        }\n        int validOctets = 0;\n        int emptyOctets = 0; // consecutive empty chunks\n        for (int index = 0; index < octets.length; index++) {\n            final String octet = octets[index];\n            if (octet.isEmpty()) {\n                emptyOctets++;\n                if (emptyOctets > 1) {\n                    return false;\n                }\n            } else {\n                emptyOctets = 0;\n                // Is last chunk an IPv4 address?\n                if (index == octets.length - 1 && octet.contains(\".\")) {\n                    if (!isIPv4Address(octet)) {\n                        return false;\n                    }\n                    validOctets += 2;\n                    continue;\n                }\n                if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) {\n                    return false;\n                }\n                final int octetInt;\n                try {\n                    octetInt = Integer.parseInt(octet, BASE_16);\n                } catch (final NumberFormatException e) {\n                    return false;\n                }\n                if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) {\n                    return false;\n                }\n            }\n            validOctets++;\n        }\n        return validOctets <= IPV6_MAX_HEX_GROUPS && (validOctets >= IPV6_MAX_HEX_GROUPS || containsCompressedZeroes);\n    }\n\n    private static final Pattern REG_NAME_PART_PATTERN = Pattern.compile(\"^[a-zA-Z0-9][a-zA-Z0-9-]*$\");\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986 - not accepting IP addresses.\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isRFC3986HostName(final String name) {\n        final String[] parts = name.split(\"\\\\.\", -1);\n        for (int i = 0; i < parts.length; i++) {\n            if (parts[i].isEmpty()) {\n                // trailing dot is legal, otherwise we've hit a .. sequence\n                return i == parts.length - 1;\n            }\n            if (!REG_NAME_PART_PATTERN.matcher(parts[i]).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/FilenameUtils.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.File;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * General file name and file path manipulation utilities.\n * <p>\n * When dealing with file names you can hit problems when moving from a Windows\n * based development machine to a Unix based production machine.\n * This class aims to help avoid those problems.\n * <p>\n * <b>NOTE</b>: You may be able to avoid using this class entirely simply by\n * using JDK {@link java.io.File File} objects and the two argument constructor\n * {@link java.io.File#File(java.io.File, java.lang.String) File(File,String)}.\n * <p>\n * Most methods on this class are designed to work the same on both Unix and Windows.\n * Those that don't include 'System', 'Unix' or 'Windows' in their name.\n * <p>\n * Most methods recognize both separators (forward and back), and both\n * sets of prefixes. See the Javadoc of each method for details.\n * <p>\n * This class defines six components within a file name\n * (example C:\\dev\\project\\file.txt):\n * <ul>\n * <li>the prefix - C:\\</li>\n * <li>the path - dev\\project\\</li>\n * <li>the full path - C:\\dev\\project\\</li>\n * <li>the name - file.txt</li>\n * <li>the base name - file</li>\n * <li>the extension - txt</li>\n * </ul>\n * Note that this class works best if directory file names end with a separator.\n * If you omit the last separator, it is impossible to determine if the file name\n * corresponds to a file or a directory. As a result, we have chosen to say\n * it corresponds to a file.\n * <p>\n * This class only supports Unix and Windows style names.\n * Prefixes are matched as follows:\n * <pre>\n * Windows:\n * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n *\n * Unix:\n * a/b/c.txt           --&gt; \"\"          --&gt; relative\n * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n * </pre>\n * Both prefix styles are matched always, irrespective of the machine that you are\n * currently running on.\n * <p>\n * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.\n *\n * @since 1.1\n */\npublic class FilenameUtils {\n\n    private static final String[] EMPTY_STRING_ARRAY = {};\n\n    private static final String EMPTY_STRING = \"\";\n\n    private static final int NOT_FOUND = -1;\n\n    /**\n     * The extension separator character.\n     * @since 1.4\n     */\n    public static final char EXTENSION_SEPARATOR = '.';\n\n    /**\n     * The extension separator String.\n     * @since 1.4\n     */\n    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n\n    /**\n     * The Unix separator character.\n     */\n    private static final char UNIX_NAME_SEPARATOR = '/';\n\n    /**\n     * The Windows separator character.\n     */\n    private static final char WINDOWS_NAME_SEPARATOR = '\\\\';\n\n    /**\n     * The system separator character.\n     */\n    private static final char SYSTEM_NAME_SEPARATOR = File.separatorChar;\n\n    /**\n     * The separator character that is the opposite of the system separator.\n     */\n    private static final char OTHER_SEPARATOR;\n\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_NAME_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_NAME_SEPARATOR;\n        }\n    }\n\n    private static final Pattern IPV4_PATTERN =\n        Pattern.compile(\"^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$\");\n\n    private static final int IPV4_MAX_OCTET_VALUE = 255;\n\n    private static final int IPV6_MAX_HEX_GROUPS = 8;\n\n    private static final int IPV6_MAX_HEX_DIGITS_PER_GROUP = 4;\n    private static final int MAX_UNSIGNED_SHORT = 0xffff;\n\n    private static final int BASE_16 = 16;\n\n    private static final Pattern REG_NAME_PART_PATTERN = Pattern.compile(\"^[a-zA-Z0-9][a-zA-Z0-9-]*$\");\n\n    /**\n     * Concatenates a fileName to a base path using normal command line style rules.\n     * <p>\n     * The effect is equivalent to resultant directory after changing\n     * directory to the first argument, followed by changing directory to\n     * the second argument.\n     * </p>\n     * <p>\n     * The first argument is the base path, the second is the path to concatenate.\n     * The returned path is always normalized via {@link #normalize(String)},\n     * thus {@code ..} is handled.\n     * </p>\n     * <p>\n     * If {@code pathToAdd} is absolute (has an absolute prefix), then\n     * it will be normalized and returned.\n     * Otherwise, the paths will be joined, normalized and returned.\n     * </p>\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * </p>\n     * <pre>\n     * /foo/      + bar        --&gt;  /foo/bar\n     * /foo       + bar        --&gt;  /foo/bar\n     * /foo       + /bar       --&gt;  /bar\n     * /foo       + C:/bar     --&gt;  C:/bar\n     * /foo       + C:bar      --&gt;  C:bar [1]\n     * /foo/a/    + ../bar     --&gt;  /foo/bar\n     * /foo/      + ../../bar  --&gt;  null\n     * /foo/      + /bar       --&gt;  /bar\n     * /foo/..    + /bar       --&gt;  /bar\n     * /foo       + bar/c.txt  --&gt;  /foo/bar/c.txt\n     * /foo/c.txt + bar        --&gt;  /foo/c.txt/bar [2]\n     * </pre>\n     * <p>\n     * [1] Note that the Windows relative drive prefix is unreliable when\n     * used with this method.\n     * </p>\n     * <p>\n     * [2] Note that the first parameter must be a path. If it ends with a name, then\n     * the name will be built into the concatenated path. If this might be a problem,\n     * use {@link #getFullPath(String)} on the base path argument.\n     * </p>\n     *\n     * @param basePath  the base path to attach to, always treated as a path\n     * @param fullFileNameToAdd  the fileName (or path) to attach to the base\n     * @return the concatenated path, or null if invalid.  Null bytes inside string will be removed\n     */\n    public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix = getPrefixLength(fullFileNameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        final int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + '/' + fullFileNameToAdd);\n    }\n\n    /**\n     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).\n     * <p>\n     * The files names are expected to be normalized.\n     * </p>\n     *\n     * Edge cases:\n     * <ul>\n     * <li>A {@code directory} must not be null: if null, throw IllegalArgumentException</li>\n     * <li>A directory does not contain itself: return false</li>\n     * <li>A null child file is not contained in any parent: return false</li>\n     * </ul>\n     *\n     * @param canonicalParent\n     *            the file to consider as the parent.\n     * @param canonicalChild\n     *            the file to consider as the child.\n     * @return true is the candidate leaf is under by the specified composite. False otherwise.\n     * @since 2.2\n     * @see FileUtils#directoryContains(File, File)\n     */\n    public static boolean directoryContains(final String canonicalParent, final String canonicalChild) {\n        if (isEmpty(canonicalParent) || isEmpty(canonicalChild)) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        final char separator = canonicalParent.charAt(0) == UNIX_NAME_SEPARATOR ? UNIX_NAME_SEPARATOR : WINDOWS_NAME_SEPARATOR;\n        final String parentWithEndSeparator = canonicalParent.charAt(canonicalParent.length() - 1) == separator ? canonicalParent : canonicalParent + separator;\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, parentWithEndSeparator);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param includeSeparator  true to include the end separator\n     * @return the path\n     */\n    private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  // add end slash if necessary\n            }\n            return fileName;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        if (index < 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param separatorAdd  0 to omit the end separator, 1 to return it\n     * @return the path. Null bytes inside string will be removed\n     */\n    private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        final int endIndex = index+separatorAdd;\n        if (prefix >= fileName.length() || index < 0 || prefix >= endIndex) {\n            return EMPTY_STRING;\n        }\n        final String path = fileName.substring(prefix, endIndex);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Internal method to perform the normalization.\n     *\n     * @param fileName  the fileName\n     * @param separator The separator character to use\n     * @param keepSeparator  true to keep the final separator\n     * @return the normalized fileName. Null bytes inside string will be removed.\n     */\n    private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n\n        requireNonNullChars(fileName);\n\n        int size = fileName.length();\n        if (size == 0) {\n            return fileName;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n\n        final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        fileName.getChars(0, fileName.length(), array, 0);\n\n        // fix separators throughout\n        final char otherSeparator = separator == SYSTEM_NAME_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_NAME_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n\n        // adjoining slashes\n        // If we get here, prefix can only be 0 or greater, size 1 or greater\n        // If prefix is 0, set loop start to 1 to prevent index errors\n        for (int i = (prefix != 0) ? prefix : 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        // dot slash\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' &&\n                    (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -=2;\n                i--;\n            }\n        }\n\n        // double dot slash\n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&\n                    (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4 ; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n\n        if (size <= 0) {  // should never be less than 0\n            return EMPTY_STRING;\n        }\n        if (size <= prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }\n\n    /**\n     * Checks whether two fileNames are equal exactly.\n     * <p>\n     * No processing is performed on the fileNames other than comparison,\n     * thus this is merely a null-safe case-sensitive equals.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal, optionally normalizing and providing\n     * control over the case-sensitivity.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @param normalized  whether to normalize the fileNames\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileNames are equal, null equals null\n     * @since 1.3\n     */\n    public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\n\n        if (fileName1 == null || fileName2 == null) {\n            return fileName1 == null && fileName2 == null;\n        }\n        if (normalized) {\n            fileName1 = normalize(fileName1);\n            if (fileName1 == null) {\n                return false;\n            }\n            fileName2 = normalize(fileName2);\n            if (fileName2 == null) {\n                return false;\n            }\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        return caseSensitivity.checkEquals(fileName1, fileName2);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed in a case-sensitive manner.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized\n     * and using the case rules of the system.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed case-sensitive on Unix and\n     * case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal using the case rules of the system.\n     * <p>\n     * No processing is performed on the fileNames other than comparison.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }\n\n    /**\n     * Special handling for NTFS ADS: Don't accept colon in the fileName.\n     *\n     * @param fileName a file name\n     * @return ADS offsets.\n     */\n    private static int getAdsCriticalOffset(final String fileName) {\n        // Step 1: Remove leading path segments.\n        final int offset1 = fileName.lastIndexOf(SYSTEM_NAME_SEPARATOR);\n        final int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 == -1) {\n            if (offset2 == -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 == -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }\n\n    /**\n     * Gets the base name, minus the full path and extension, from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash and before the last dot is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c\n     * a.txt     --&gt; a\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists. Null bytes inside string\n     * will be removed\n     */\n    public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }\n\n    /**\n     * Gets the extension of a fileName.\n     * <p>\n     * This method returns the textual part of the fileName after the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt      --&gt; \"txt\"\n     * a/b/c.jpg    --&gt; \"jpg\"\n     * a/b.txt/c    --&gt; \"\"\n     * a/b/c        --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName the fileName to retrieve the extension of.\n     * @return the extension of the file or an empty string if none exists or {@code null}\n     * if the fileName is {@code null}.\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return null;\n        }\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\\\n     * ~/a/b/c.txt  --&gt; ~/a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~/\n     * ~/           --&gt; ~/\n     * ~user        --&gt; ~user/\n     * ~user/       --&gt; ~user/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path,\n     * and also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\n     * ~/a/b/c.txt  --&gt; ~/a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~\n     * ~/           --&gt; ~\n     * ~user        --&gt; ~user\n     * ~user/       --&gt; ~user\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }\n\n    /**\n     * Gets the name minus the path from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c.txt\n     * a.txt     --&gt; a.txt\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists.\n     * Null bytes inside string will be removed\n     */\n    public static String getName(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n        final int index = indexOfLastSeparator(fileName);\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\\\n     * ~/a/b/c.txt  --&gt; a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPath(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix, and\n     * also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\n     * ~/a/b/c.txt  --&gt; a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }\n\n    /**\n     * Gets the prefix from a full fileName, such as {@code C:/}\n     * or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The prefix includes the first slash in the full fileName where applicable.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n     * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; \"\"          --&gt; relative\n     * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n     * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n     * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n     * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the prefix of the file, null if invalid. Null bytes inside string will be removed\n     */\n    public static String getPrefix(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        final int len = getPrefixLength(fileName);\n        if (len < 0) {\n            return null;\n        }\n        if (len > fileName.length()) {\n            requireNonNullChars(fileName + UNIX_NAME_SEPARATOR);\n            return fileName + UNIX_NAME_SEPARATOR;\n        }\n        final String path = fileName.substring(0, len);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Returns the length of the fileName prefix, such as {@code C:/} or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * <p>\n     * The prefix length includes the first slash in the full fileName\n     * if applicable. Thus, it is possible that the length returned is greater\n     * than the length of the input string.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; 0           --&gt; relative\n     * \\a\\b\\c.txt          --&gt; 1           --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; 2           --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; 3           --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; 9           --&gt; UNC\n     * \\\\\\a\\b\\c.txt        --&gt; -1          --&gt; error\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; 0           --&gt; relative\n     * /a/b/c.txt          --&gt; 1           --&gt; absolute\n     * ~/a/b/c.txt         --&gt; 2           --&gt; current user\n     * ~                   --&gt; 2           --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; 6           --&gt; named user\n     * ~user               --&gt; 6           --&gt; named user (slash added)\n     * //server/a/b/c.txt  --&gt; 9\n     * ///a/b/c.txt        --&gt; -1          --&gt; error\n     * C:                  --&gt; 0           --&gt; valid filename as only null byte and / are reserved characters\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * Note that a leading // (or \\\\) is used to indicate a UNC name on Windows.\n     * These must be followed by a server name, so double-slashes are not collapsed\n     * to a single slash at the start of the fileName.\n     *\n     * @param fileName  the fileName to find the prefix in, null returns -1\n     * @return the length of the prefix, -1 if invalid or null\n     */\n    public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_NAME_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_NAME_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 && !FileSystem.getCurrent().supportsDriveLetter()) {\n                    return 0;\n                }\n                if (len == 2 || !isSeparator(fileName.charAt(2))) {\n                    return 2;\n                }\n                return 3;\n            }\n            if (ch0 == UNIX_NAME_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        }\n        if (!isSeparator(ch0) || !isSeparator(ch1)) {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        int posUnix = fileName.indexOf(UNIX_NAME_SEPARATOR, 2);\n        int posWin = fileName.indexOf(WINDOWS_NAME_SEPARATOR, 2);\n        if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n            return NOT_FOUND;\n        }\n        posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n        posWin = posWin == NOT_FOUND ? posUnix : posWin;\n        final int pos = Math.min(posUnix, posWin) + 1;\n        final String hostnamePart = fileName.substring(2, pos - 1);\n        return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n    }\n\n    /**\n     * Returns the index of the last extension separator character, which is a dot.\n     * <p>\n     * This method also checks that there is no directory separator after the last dot. To do this it uses\n     * {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.\n     * </p>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName\n     *            the fileName to find the last extension separator in, null returns -1\n     * @return the index of the last extension separator character, or -1 if there is no such character\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            // Special handling for NTFS ADS: Don't accept colon in the fileName.\n            final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));\n            if (offset != -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n            }\n        }\n        final int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator = indexOfLastSeparator(fileName);\n        return lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n    }\n\n    /**\n     * Returns the index of the last directory separator character.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The position of the last forward or backslash is returned.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfLastSeparator(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos = fileName.lastIndexOf(UNIX_NAME_SEPARATOR);\n        final int lastWindowsPos = fileName.lastIndexOf(WINDOWS_NAME_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    private static boolean isEmpty(final String string) {\n        return string == null || string.isEmpty();\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final Collection<String> extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (isEmpty(extension)) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String... extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether a given string represents a valid IPv4 address.\n     *\n     * @param name the name to validate\n     * @return true if the given name is a valid IPv4 address\n     */\n    // mostly copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet4Address\n    private static boolean isIPv4Address(final String name) {\n        final Matcher m = IPV4_PATTERN.matcher(name);\n        if (!m.matches() || m.groupCount() != 4) {\n            return false;\n        }\n\n        // verify that address subgroups are legal\n        for (int i = 1; i <= 4; i++) {\n            final String ipSegment = m.group(i);\n            final int iIpSegment = Integer.parseInt(ipSegment);\n            if (iIpSegment > IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n\n            if (ipSegment.length() > 1 && ipSegment.startsWith(\"0\")) {\n                return false;\n            }\n\n        }\n\n        return true;\n    }\n\n    // copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet6Address\n    /**\n     * Checks whether a given string represents a valid IPv6 address.\n     *\n     * @param inet6Address the name to validate\n     * @return true if the given name is a valid IPv6 address\n     */\n    private static boolean isIPv6Address(final String inet6Address) {\n        final boolean containsCompressedZeroes = inet6Address.contains(\"::\");\n        if (containsCompressedZeroes && (inet6Address.indexOf(\"::\") != inet6Address.lastIndexOf(\"::\"))) {\n            return false;\n        }\n        if ((inet6Address.startsWith(\":\") && !inet6Address.startsWith(\"::\"))\n                || (inet6Address.endsWith(\":\") && !inet6Address.endsWith(\"::\"))) {\n            return false;\n        }\n        String[] octets = inet6Address.split(\":\");\n        if (containsCompressedZeroes) {\n            final List<String> octetList = new ArrayList<>(Arrays.asList(octets));\n            if (inet6Address.endsWith(\"::\")) {\n                // String.split() drops ending empty segments\n                octetList.add(\"\");\n            } else if (inet6Address.startsWith(\"::\") && !octetList.isEmpty()) {\n                octetList.remove(0);\n            }\n            octets = octetList.toArray(EMPTY_STRING_ARRAY);\n        }\n        if (octets.length > IPV6_MAX_HEX_GROUPS) {\n            return false;\n        }\n        int validOctets = 0;\n        int emptyOctets = 0; // consecutive empty chunks\n        for (int index = 0; index < octets.length; index++) {\n            final String octet = octets[index];\n            if (octet.isEmpty()) {\n                emptyOctets++;\n                if (emptyOctets > 1) {\n                    return false;\n                }\n            } else {\n                emptyOctets = 0;\n                // Is last chunk an IPv4 address?\n                if (index == octets.length - 1 && octet.contains(\".\")) {\n                    if (!isIPv4Address(octet)) {\n                        return false;\n                    }\n                    validOctets += 2;\n                    continue;\n                }\n                if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) {\n                    return false;\n                }\n                final int octetInt;\n                try {\n                    octetInt = Integer.parseInt(octet, BASE_16);\n                } catch (final NumberFormatException e) {\n                    return false;\n                }\n                if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) {\n                    return false;\n                }\n            }\n            validOctets++;\n        }\n        return validOctets <= IPV6_MAX_HEX_GROUPS && (validOctets >= IPV6_MAX_HEX_GROUPS || containsCompressedZeroes);\n    }\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986 - not accepting IP addresses.\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isRFC3986HostName(final String name) {\n        final String[] parts = name.split(\"\\\\.\", -1);\n        for (int i = 0; i < parts.length; i++) {\n            if (parts[i].isEmpty()) {\n                // trailing dot is legal, otherwise we've hit a .. sequence\n                return i == parts.length - 1;\n            }\n            if (!REG_NAME_PART_PATTERN.matcher(parts[i]).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Checks if the character is a separator.\n     *\n     * @param ch  the character to check\n     * @return true if it is a separator character\n     */\n    private static boolean isSeparator(final char ch) {\n        return ch == UNIX_NAME_SEPARATOR || ch == WINDOWS_NAME_SEPARATOR;\n    }\n\n    /**\n     * Determines if Windows file system is in use.\n     *\n     * @return true if the system is Windows\n     */\n    static boolean isSystemWindows() {\n        return SYSTEM_NAME_SEPARATOR == WINDOWS_NAME_SEPARATOR;\n    }\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986.\n     *\n     * <p>Accepted are IP addresses (v4 and v6) as well as what the\n     * RFC calls a \"reg-name\". Percent encoded names don't seem to be\n     * valid names in UNC paths.</p>\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isValidHostName(final String name) {\n        return isIPv6Address(name) || isRFC3986HostName(name);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_NAME_SEPARATOR, true);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalize(final String fileName, final boolean unixSeparator) {\n        return doNormalize(fileName, toSeparator(unixSeparator), true);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_NAME_SEPARATOR, false);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         return doNormalize(fileName, toSeparator(unixSeparator), false);\n    }\n\n    /**\n     * Removes the extension from a fileName.\n     * <p>\n     * This method returns the textual part of the fileName before the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt    --&gt; foo\n     * a\\b\\c.jpg  --&gt; a\\b\\c\n     * a\\b\\c      --&gt; a\\b\\c\n     * a.b\\c      --&gt; a.b\\c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the fileName minus the extension\n     */\n    public static String removeExtension(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }\n\n    /**\n     * Checks the input for null bytes, a sign of unsanitized data being passed to to file level functions.\n     *\n     * This may be used for poison byte attacks.\n     *\n     * @param path the path to check\n     */\n    private static void requireNonNullChars(final String path) {\n        if (path.indexOf(0) >= 0) {\n            throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \"\n                + \"known legitimate use cases for such data, but several injection attacks may use it\");\n        }\n    }\n    /**\n     * Converts all separators to the system separator.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToSystem(final String path) {\n        if (path == null) {\n            return null;\n        }\n        return isSystemWindows() ? separatorsToWindows(path) : separatorsToUnix(path);\n    }\n\n    /**\n     * Converts all separators to the Unix separator of forward slash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_NAME_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_NAME_SEPARATOR, UNIX_NAME_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the Windows separator of backslash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToWindows(final String path) {\n        if (path == null || path.indexOf(UNIX_NAME_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(UNIX_NAME_SEPARATOR, WINDOWS_NAME_SEPARATOR);\n    }\n    /**\n     * Splits a string into a number of tokens.\n     * The text is split by '?' and '*'.\n     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n     *\n     * @param text  the text to split\n     * @return the array of tokens, never null\n     */\n    static String[] splitOnTokens(final String text) {\n        // used by wildcardMatch\n        // package level so a unit test may run on this\n\n        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array = text.toCharArray();\n        final ArrayList<String> list = new ArrayList<>();\n        final StringBuilder buffer = new StringBuilder();\n        char prevChar = 0;\n        for (final char ch : array) {\n            if (ch == '?' || ch == '*') {\n                if (buffer.length() != 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch == '?') {\n                    list.add(\"?\");\n                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar = ch;\n        }\n        if (buffer.length() != 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray(EMPTY_STRING_ARRAY);\n    }\n    /**\n     * Returns '/' if given true, '\\\\' otherwise.\n     * \n     * @param unixSeparator which separator to return.\n     * @return '/' if given true, '\\\\' otherwise.\n     */\n    private static char toSeparator(final boolean unixSeparator) {\n        return unixSeparator ? UNIX_NAME_SEPARATOR : WINDOWS_NAME_SEPARATOR;\n    }\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher,\n     * always testing case-sensitive.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive always.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * allowing control over case-sensitivity.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileName matches the wildcard string\n     * @since 1.3\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n        if (fileName == null && wildcardMatcher == null) {\n            return true;\n        }\n        if (fileName == null || wildcardMatcher == null) {\n            return false;\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        final String[] wcs = splitOnTokens(wildcardMatcher);\n        boolean anyChars = false;\n        int textIdx = 0;\n        int wcsIdx = 0;\n        final Deque<int[]> backtrack = new ArrayDeque<>(wcs.length);\n\n        // loop around a backtrack stack, to handle complex * matching\n        do {\n            if (!backtrack.isEmpty()) {\n                final int[] array = backtrack.pop();\n                wcsIdx = array[0];\n                textIdx = array[1];\n                anyChars = true;\n            }\n\n            // loop whilst tokens and text left to process\n            while (wcsIdx < wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    // ? so move to next text char\n                    textIdx++;\n                    if (textIdx > fileName.length()) {\n                        break;\n                    }\n                    anyChars = false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    // set any chars status\n                    anyChars = true;\n                    if (wcsIdx == wcs.length - 1) {\n                        textIdx = fileName.length();\n                    }\n\n                } else {\n                    // matching text token\n                    if (anyChars) {\n                        // any chars then try to locate text token\n                        textIdx = caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx == NOT_FOUND) {\n                            // token not found\n                            break;\n                        }\n                        final int repeat = caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat >= 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        // matching from current position\n                        // couldn't match token\n                        break;\n                    }\n\n                    // matched text token, move text index to end of matched token\n                    textIdx += wcs[wcsIdx].length();\n                    anyChars = false;\n                }\n\n                wcsIdx++;\n            }\n\n            // full match\n            if (wcsIdx == wcs.length && textIdx == fileName.length()) {\n                return true;\n            }\n\n        } while (!backtrack.isEmpty());\n\n        return false;\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * using the case rules of the system.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SYSTEM\n     */\n    public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public FilenameUtils() {\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Returns '/' if given true, '\\\\' otherwise.\n     * \n     * @param unixSeparator which separator to return.\n     * @return '/' if given true, '\\\\' otherwise.\n     */\n    private static char toSeparator(final boolean unixSeparator) {\n        return unixSeparator ? UNIX_NAME_SEPARATOR : WINDOWS_NAME_SEPARATOR;\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.FilenameUtils#doNormalize\n methodBody: private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\nif(fileName == null){return null;\n}requireNonNullChars(fileName);\nint size=fileName.length();\nif(size == 0){return fileName;\n}final int prefix=getPrefixLength(fileName);\nif(prefix < 0){return null;\n}final char[] array=new char[size + 2];\nfileName.getChars(0,fileName.length(),array,0);\nfinal char otherSeparator=separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\nfor(int i=0; i < array.length; i++){if(array[i] == otherSeparator){array[i]=separator;\n}}boolean lastIsDirectory=true;\nif(array[size - 1] != separator){array[size++]=separator;\nlastIsDirectory=false;\n}for(int i=(prefix != 0) ? prefix : 1; i < size; i++){if(array[i] == separator && array[i - 1] == separator){System.arraycopy(array,i,array,i - 1,size - i);\nsize--;\ni--;\n}}for(int i=prefix + 1; i < size; i++){if(array[i] == separator && array[i - 1] == '.' && (i == prefix + 1 || array[i - 2] == separator)){if(i == size - 1){lastIsDirectory=true;\n}System.arraycopy(array,i + 1,array,i - 1,size - i);\nsize-=2;\ni--;\n}}outerfor(int i=prefix + 2; i < size; i++){if(array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' && (i == prefix + 2 || array[i - 3] == separator)){if(i == prefix + 2){return null;\n}if(i == size - 1){lastIsDirectory=true;\n}int j;\nfor(j=i - 4; j >= prefix; j--){if(array[j] == separator){System.arraycopy(array,i + 1,array,j + 1,size - i);\nsize-=i - j;\ni=j + 1;\ncontinue outer;\n}}System.arraycopy(array,i + 1,array,prefix,size - i);\nsize-=i + 1 - prefix;\ni=prefix + 1;\n}}if(size <= 0){return EMPTY_STRING;\n}if(size <= prefix){return new String(array,0,size);\n}if(lastIsDirectory && keepSeparator){return new String(array,0,size);\n}return new String(array,0,size - 1);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         return doNormalize(fileName, toSeparator(unixSeparator), false);\n    }\n/**\n     * Returns '/' if given true, '\\\\' otherwise.\n     * \n     * @param unixSeparator which separator to return.\n     * @return '/' if given true, '\\\\' otherwise.\n     */\n    private static char toSeparator(final boolean unixSeparator) {\n        return unixSeparator ? UNIX_NAME_SEPARATOR : WINDOWS_NAME_SEPARATOR;\n    }", "diffSourceCode": "-  295:     /**\n-  296:      * Normalizes a path, removing double and single dot path steps,\n-  297:      * and removing any final directory separator.\n-  298:      * <p>\n-  299:      * This method normalizes a path to a standard format.\n-  300:      * The input may contain separators in either Unix or Windows format.\n-  301:      * The output will contain separators in the format specified.\n-  302:      * <p>\n-  303:      * A trailing slash will be removed.\n-  304:      * A double slash will be merged to a single slash (but UNC names are handled).\n-  305:      * A single dot path segment will be removed.\n-  306:      * A double dot will cause that path segment and the one before to be removed.\n-  307:      * If the double dot has no parent path segment to work with, {@code null}\n-  308:      * is returned.\n-  309:      * <p>\n-  310:      * The output will be the same on both Unix and Windows including\n-  311:      * the separator character.\n-  312:      * <pre>\n-  313:      * /foo//               --&gt;   /foo\n-  314:      * /foo/./              --&gt;   /foo\n-  315:      * /foo/../bar          --&gt;   /bar\n-  316:      * /foo/../bar/         --&gt;   /bar\n-  317:      * /foo/../bar/../baz   --&gt;   /baz\n-  318:      * //foo//./bar         --&gt;   /foo/bar\n-  319:      * /../                 --&gt;   null\n-  320:      * ../foo               --&gt;   null\n-  321:      * foo/bar/..           --&gt;   foo\n-  322:      * foo/../../bar        --&gt;   null\n-  323:      * foo/../bar           --&gt;   bar\n-  324:      * //server/foo/../bar  --&gt;   //server/bar\n-  325:      * //server/../bar      --&gt;   null\n-  326:      * C:\\foo\\..\\bar        --&gt;   C:\\bar\n-  327:      * C:\\..\\bar            --&gt;   null\n-  328:      * ~/foo/../bar/        --&gt;   ~/bar\n-  329:      * ~/../bar             --&gt;   null\n-  330:      * </pre>\n-  331:      *\n-  332:      * @param fileName  the fileName to normalize, null returns null\n-  333:      * @param unixSeparator {@code true} if a unix separator should\n-  334:      * be used or {@code false} if a windows separator should be used.\n-  335:      * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n-  336:      * @since 2.0\n-  337:      */\n-  338:     public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n-  339:          final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n-  340:         return doNormalize(fileName, separator, false);\n-  341:     }\n- 1322:      * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n- 1323:      * </pre>\n- 1324:      * N.B. the sequence \"*?\" does not work properly at present in match strings.\n- 1325:      *\n- 1326:      * @param fileName  the fileName to match on\n- 1327:      * @param wildcardMatcher  the wildcard string to match against\n- 1328:      * @return true if the fileName matches the wildcard string\n- 1329:      * @see IOCase#SENSITIVE\n- 1330:      */\n- 1331:     public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n- 1332:         return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n- 1333:     }\n- 1334: \n- 1335:     /**\n- 1336:      * Checks a fileName to see if it matches the specified wildcard matcher\n- 1337:      * using the case rules of the system.\n- 1338:      * <p>\n- 1339:      * The wildcard matcher uses the characters '?' and '*' to represent a\n- 1340:      * single or multiple (zero or more) wildcard characters.\n- 1341:      * This is the same as often found on Dos/Unix command lines.\n- 1342:      * The check is case-sensitive on Unix and case-insensitive on Windows.\n- 1343:      * <pre>\n- 1344:      * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n- 1345:      * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n- 1346:      * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n- 1347:      * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n- 1348:      * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n- 1349:      * </pre>\n- 1350:      * N.B. the sequence \"*?\" does not work properly at present in match strings.\n- 1351:      *\n- 1352:      * @param fileName  the fileName to match on\n- 1353:      * @param wildcardMatcher  the wildcard string to match against\n- 1354:      * @return true if the fileName matches the wildcard string\n- 1355:      * @see IOCase#SYSTEM\n- 1356:      */\n- 1357:     public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n- 1358:         return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n- 1359:     }\n- 1360: \n- 1361:     /**\n- 1362:      * Checks a fileName to see if it matches the specified wildcard matcher\n- 1363:      * allowing control over case-sensitivity.\n- 1364:      * <p>\n- 1365:      * The wildcard matcher uses the characters '?' and '*' to represent a\n- 1366:      * single or multiple (zero or more) wildcard characters.\n- 1367:      * N.B. the sequence \"*?\" does not work properly at present in match strings.\n- 1492:             list.add(buffer.toString());\n- 1493:         }\n- 1494: \n- 1495:         return list.toArray(EMPTY_STRING_ARRAY);\n- 1496:     }\n- 1497: \n- 1498:     /**\n- 1499:      * Checks whether a given string is a valid host name according to\n- 1500:      * RFC 3986.\n+  295:             return null;\n+  296:         }\n+  297:         final int prefix = getPrefixLength(fileName);\n+  298:         if (prefix < 0) {\n+  299:             return null;\n+  300:         }\n+  301:         final int index = indexOfLastSeparator(fileName);\n+  302:         final int endIndex = index+separatorAdd;\n+  303:         if (prefix >= fileName.length() || index < 0 || prefix >= endIndex) {\n+  304:             return EMPTY_STRING;\n+  305:         }\n+  306:         final String path = fileName.substring(prefix, endIndex);\n+  307:         requireNonNullChars(path);\n+  308:         return path;\n+  309:     }\n+  310: \n+  311:     /**\n+  312:      * Internal method to perform the normalization.\n+  313:      *\n+  314:      * @param fileName  the fileName\n+  315:      * @param separator The separator character to use\n+  316:      * @param keepSeparator  true to keep the final separator\n+  317:      * @return the normalized fileName. Null bytes inside string will be removed.\n+  318:      */\n+  319:     private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n+  320:         if (fileName == null) {\n+  321:             return null;\n+  322:         }\n+  323: \n+  324:         requireNonNullChars(fileName);\n+  325: \n+  326:         int size = fileName.length();\n+  327:         if (size == 0) {\n+  328:             return fileName;\n+  329:         }\n+  330:         final int prefix = getPrefixLength(fileName);\n+  331:         if (prefix < 0) {\n+  332:             return null;\n+  333:         }\n+  334: \n+  335:         final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n+  336:         fileName.getChars(0, fileName.length(), array, 0);\n+  337: \n+  338:         // fix separators throughout\n+  339:         final char otherSeparator = separator == SYSTEM_NAME_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_NAME_SEPARATOR;\n+  340:         for (int i = 0; i < array.length; i++) {\n+  341:             if (array[i] == otherSeparator) {\n+ 1322:     /**\n+ 1323:      * Normalizes a path, removing double and single dot path steps,\n+ 1324:      * and removing any final directory separator.\n+ 1325:      * <p>\n+ 1326:      * This method normalizes a path to a standard format.\n+ 1327:      * The input may contain separators in either Unix or Windows format.\n+ 1328:      * The output will contain separators in the format specified.\n+ 1329:      * <p>\n+ 1330:      * A trailing slash will be removed.\n+ 1331:      * A double slash will be merged to a single slash (but UNC names are handled).\n+ 1332:      * A single dot path segment will be removed.\n+ 1333:      * A double dot will cause that path segment and the one before to be removed.\n+ 1334:      * If the double dot has no parent path segment to work with, {@code null}\n+ 1335:      * is returned.\n+ 1336:      * <p>\n+ 1337:      * The output will be the same on both Unix and Windows including\n+ 1338:      * the separator character.\n+ 1339:      * <pre>\n+ 1340:      * /foo//               --&gt;   /foo\n+ 1341:      * /foo/./              --&gt;   /foo\n+ 1342:      * /foo/../bar          --&gt;   /bar\n+ 1343:      * /foo/../bar/         --&gt;   /bar\n+ 1344:      * /foo/../bar/../baz   --&gt;   /baz\n+ 1345:      * //foo//./bar         --&gt;   /foo/bar\n+ 1346:      * /../                 --&gt;   null\n+ 1347:      * ../foo               --&gt;   null\n+ 1348:      * foo/bar/..           --&gt;   foo\n+ 1349:      * foo/../../bar        --&gt;   null\n+ 1350:      * foo/../bar           --&gt;   bar\n+ 1351:      * //server/foo/../bar  --&gt;   //server/bar\n+ 1352:      * //server/../bar      --&gt;   null\n+ 1353:      * C:\\foo\\..\\bar        --&gt;   C:\\bar\n+ 1354:      * C:\\..\\bar            --&gt;   null\n+ 1355:      * ~/foo/../bar/        --&gt;   ~/bar\n+ 1356:      * ~/../bar             --&gt;   null\n+ 1357:      * </pre>\n+ 1358:      *\n+ 1359:      * @param fileName  the fileName to normalize, null returns null\n+ 1360:      * @param unixSeparator {@code true} if a unix separator should\n+ 1361:      * be used or {@code false} if a windows separator should be used.\n+ 1362:      * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n+ 1363:      * @since 2.0\n+ 1364:      */\n+ 1365:     public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n+ 1366:          return doNormalize(fileName, toSeparator(unixSeparator), false);\n+ 1367:     }\n+ 1492:     /**\n+ 1493:      * Returns '/' if given true, '\\\\' otherwise.\n+ 1494:      * \n+ 1495:      * @param unixSeparator which separator to return.\n+ 1496:      * @return '/' if given true, '\\\\' otherwise.\n+ 1497:      */\n+ 1498:     private static char toSeparator(final boolean unixSeparator) {\n+ 1499:         return unixSeparator ? UNIX_NAME_SEPARATOR : WINDOWS_NAME_SEPARATOR;\n+ 1500:     }\n", "uniqueId": "6dd4c0850cdc0c92a8171efbd98649bb3993a8c8_295_341_1492_1500_1322_1367", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 11}, "BRANCH": {"missed": 0, "covered": 2}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 2}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `normalizeNoEndSeparator` method, we can extract the logic that determines the separator character into a separate method. This will make the code cleaner and more modular.\n\nHere\u2019s the refactored method code:\n\n```java\n##########################\npublic static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n    final char separator = getSeparator(unixSeparator);\n    return doNormalize(fileName, separator, false);\n}\n\nprivate static char getSeparator(boolean unixSeparator) {\n    return unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n}\n##########################\n```\n\nIn this refactoring:\n- The logic to determine the separator character based on the `unixSeparator` boolean has been extracted into a new method called `getSeparator`.\n- This makes the `normalizeNoEndSeparator` method cleaner and focuses on its primary responsibility, which is to normalize the file name without an end separator.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, false);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.File;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * General file name and file path manipulation utilities.\n * <p>\n * When dealing with file names you can hit problems when moving from a Windows\n * based development machine to a Unix based production machine.\n * This class aims to help avoid those problems.\n * <p>\n * <b>NOTE</b>: You may be able to avoid using this class entirely simply by\n * using JDK {@link java.io.File File} objects and the two argument constructor\n * {@link java.io.File#File(java.io.File, java.lang.String) File(File,String)}.\n * <p>\n * Most methods on this class are designed to work the same on both Unix and Windows.\n * Those that don't include 'System', 'Unix' or 'Windows' in their name.\n * <p>\n * Most methods recognize both separators (forward and back), and both\n * sets of prefixes. See the Javadoc of each method for details.\n * <p>\n * This class defines six components within a file name\n * (example C:\\dev\\project\\file.txt):\n * <ul>\n * <li>the prefix - C:\\</li>\n * <li>the path - dev\\project\\</li>\n * <li>the full path - C:\\dev\\project\\</li>\n * <li>the name - file.txt</li>\n * <li>the base name - file</li>\n * <li>the extension - txt</li>\n * </ul>\n * Note that this class works best if directory file names end with a separator.\n * If you omit the last separator, it is impossible to determine if the file name\n * corresponds to a file or a directory. As a result, we have chosen to say\n * it corresponds to a file.\n * <p>\n * This class only supports Unix and Windows style names.\n * Prefixes are matched as follows:\n * <pre>\n * Windows:\n * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n *\n * Unix:\n * a/b/c.txt           --&gt; \"\"          --&gt; relative\n * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n * </pre>\n * Both prefix styles are matched always, irrespective of the machine that you are\n * currently running on.\n * <p>\n * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.\n *\n * @since 1.1\n */\npublic class FilenameUtils {\n\n    private static final String[] EMPTY_STRING_ARRAY = {};\n\n    private static final String EMPTY_STRING = \"\";\n\n    private static final int NOT_FOUND = -1;\n\n    /**\n     * The extension separator character.\n     * @since 1.4\n     */\n    public static final char EXTENSION_SEPARATOR = '.';\n\n    /**\n     * The extension separator String.\n     * @since 1.4\n     */\n    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n\n    /**\n     * The Unix separator character.\n     */\n    private static final char UNIX_SEPARATOR = '/';\n\n    /**\n     * The Windows separator character.\n     */\n    private static final char WINDOWS_SEPARATOR = '\\\\';\n\n    /**\n     * The system separator character.\n     */\n    private static final char SYSTEM_SEPARATOR = File.separatorChar;\n\n    /**\n     * The separator character that is the opposite of the system separator.\n     */\n    private static final char OTHER_SEPARATOR;\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_SEPARATOR;\n        }\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public FilenameUtils() {\n    }\n\n    /**\n     * Determines if Windows file system is in use.\n     *\n     * @return true if the system is Windows\n     */\n    static boolean isSystemWindows() {\n        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;\n    }\n\n    /**\n     * Checks if the character is a separator.\n     *\n     * @param ch  the character to check\n     * @return true if it is a separator character\n     */\n    private static boolean isSeparator(final char ch) {\n        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, true);\n    }\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalize(final String fileName, final boolean unixSeparator) {\n        final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, true);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, false);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, false);\n    }\n\n    /**\n     * Internal method to perform the normalization.\n     *\n     * @param fileName  the fileName\n     * @param separator The separator character to use\n     * @param keepSeparator  true to keep the final separator\n     * @return the normalized fileName. Null bytes inside string will be removed.\n     */\n    private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n\n        requireNonNullChars(fileName);\n\n        int size = fileName.length();\n        if (size == 0) {\n            return fileName;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n\n        final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        fileName.getChars(0, fileName.length(), array, 0);\n\n        // fix separators throughout\n        final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n\n        // adjoining slashes\n        // If we get here, prefix can only be 0 or greater, size 1 or greater\n        // If prefix is 0, set loop start to 1 to prevent index errors\n        for (int i = (prefix != 0) ? prefix : 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        // dot slash\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' &&\n                    (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -=2;\n                i--;\n            }\n        }\n\n        // double dot slash\n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&\n                    (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4 ; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n\n        if (size <= 0) {  // should never be less than 0\n            return EMPTY_STRING;\n        }\n        if (size <= prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }\n\n    /**\n     * Concatenates a fileName to a base path using normal command line style rules.\n     * <p>\n     * The effect is equivalent to resultant directory after changing\n     * directory to the first argument, followed by changing directory to\n     * the second argument.\n     * </p>\n     * <p>\n     * The first argument is the base path, the second is the path to concatenate.\n     * The returned path is always normalized via {@link #normalize(String)},\n     * thus {@code ..} is handled.\n     * </p>\n     * <p>\n     * If {@code pathToAdd} is absolute (has an absolute prefix), then\n     * it will be normalized and returned.\n     * Otherwise, the paths will be joined, normalized and returned.\n     * </p>\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * </p>\n     * <pre>\n     * /foo/      + bar        --&gt;  /foo/bar\n     * /foo       + bar        --&gt;  /foo/bar\n     * /foo       + /bar       --&gt;  /bar\n     * /foo       + C:/bar     --&gt;  C:/bar\n     * /foo       + C:bar      --&gt;  C:bar [1]\n     * /foo/a/    + ../bar     --&gt;  /foo/bar\n     * /foo/      + ../../bar  --&gt;  null\n     * /foo/      + /bar       --&gt;  /bar\n     * /foo/..    + /bar       --&gt;  /bar\n     * /foo       + bar/c.txt  --&gt;  /foo/bar/c.txt\n     * /foo/c.txt + bar        --&gt;  /foo/c.txt/bar [2]\n     * </pre>\n     * <p>\n     * [1] Note that the Windows relative drive prefix is unreliable when\n     * used with this method.\n     * </p>\n     * <p>\n     * [2] Note that the first parameter must be a path. If it ends with a name, then\n     * the name will be built into the concatenated path. If this might be a problem,\n     * use {@link #getFullPath(String)} on the base path argument.\n     * </p>\n     *\n     * @param basePath  the base path to attach to, always treated as a path\n     * @param fullFileNameToAdd  the fileName (or path) to attach to the base\n     * @return the concatenated path, or null if invalid.  Null bytes inside string will be removed\n     */\n    public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix = getPrefixLength(fullFileNameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        final int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + '/' + fullFileNameToAdd);\n    }\n\n    /**\n     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).\n     * <p>\n     * The files names are expected to be normalized.\n     * </p>\n     *\n     * Edge cases:\n     * <ul>\n     * <li>A {@code directory} must not be null: if null, throw IllegalArgumentException</li>\n     * <li>A directory does not contain itself: return false</li>\n     * <li>A null child file is not contained in any parent: return false</li>\n     * </ul>\n     *\n     * @param canonicalParent\n     *            the file to consider as the parent.\n     * @param canonicalChild\n     *            the file to consider as the child.\n     * @return true is the candidate leaf is under by the specified composite. False otherwise.\n     * @since 2.2\n     * @see FileUtils#directoryContains(File, File)\n     */\n    public static boolean directoryContains(final String canonicalParent, final String canonicalChild) {\n        if (isEmpty(canonicalParent) || isEmpty(canonicalChild)) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        final char separator = canonicalParent.charAt(0) == UNIX_SEPARATOR ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        final String parentWithEndSeparator = canonicalParent.charAt(canonicalParent.length() - 1) == separator ? canonicalParent : canonicalParent + separator;\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, parentWithEndSeparator);\n    }\n\n    private static boolean isEmpty(final String string) {\n        return string == null || string.isEmpty();\n    }\n\n    /**\n     * Converts all separators to the Unix separator of forward slash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the Windows separator of backslash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToWindows(final String path) {\n        if (path == null || path.indexOf(UNIX_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the system separator.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToSystem(final String path) {\n        if (path == null) {\n            return null;\n        }\n        return isSystemWindows() ? separatorsToWindows(path) : separatorsToUnix(path);\n    }\n\n    /**\n     * Returns the length of the fileName prefix, such as {@code C:/} or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * <p>\n     * The prefix length includes the first slash in the full fileName\n     * if applicable. Thus, it is possible that the length returned is greater\n     * than the length of the input string.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; 0           --&gt; relative\n     * \\a\\b\\c.txt          --&gt; 1           --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; 2           --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; 3           --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; 9           --&gt; UNC\n     * \\\\\\a\\b\\c.txt        --&gt; -1          --&gt; error\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; 0           --&gt; relative\n     * /a/b/c.txt          --&gt; 1           --&gt; absolute\n     * ~/a/b/c.txt         --&gt; 2           --&gt; current user\n     * ~                   --&gt; 2           --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; 6           --&gt; named user\n     * ~user               --&gt; 6           --&gt; named user (slash added)\n     * //server/a/b/c.txt  --&gt; 9\n     * ///a/b/c.txt        --&gt; -1          --&gt; error\n     * C:                  --&gt; 0           --&gt; valid filename as only null byte and / are reserved characters\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * Note that a leading // (or \\\\) is used to indicate a UNC name on Windows.\n     * These must be followed by a server name, so double-slashes are not collapsed\n     * to a single slash at the start of the fileName.\n     *\n     * @param fileName  the fileName to find the prefix in, null returns -1\n     * @return the length of the prefix, -1 if invalid or null\n     */\n    public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 && !FileSystem.getCurrent().supportsDriveLetter()) {\n                    return 0;\n                }\n                if (len == 2 || !isSeparator(fileName.charAt(2))) {\n                    return 2;\n                }\n                return 3;\n            }\n            if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        }\n        if (!isSeparator(ch0) || !isSeparator(ch1)) {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n        int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n        if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n            return NOT_FOUND;\n        }\n        posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n        posWin = posWin == NOT_FOUND ? posUnix : posWin;\n        final int pos = Math.min(posUnix, posWin) + 1;\n        final String hostnamePart = fileName.substring(2, pos - 1);\n        return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n    }\n\n    /**\n     * Returns the index of the last directory separator character.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The position of the last forward or backslash is returned.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfLastSeparator(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos = fileName.lastIndexOf(UNIX_SEPARATOR);\n        final int lastWindowsPos = fileName.lastIndexOf(WINDOWS_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    /**\n     * Returns the index of the last extension separator character, which is a dot.\n     * <p>\n     * This method also checks that there is no directory separator after the last dot. To do this it uses\n     * {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.\n     * </p>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName\n     *            the fileName to find the last extension separator in, null returns -1\n     * @return the index of the last extension separator character, or -1 if there is no such character\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            // Special handling for NTFS ADS: Don't accept colon in the fileName.\n            final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));\n            if (offset != -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n            }\n        }\n        final int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator = indexOfLastSeparator(fileName);\n        return lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n    }\n\n    /**\n     * Gets the prefix from a full fileName, such as {@code C:/}\n     * or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The prefix includes the first slash in the full fileName where applicable.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n     * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; \"\"          --&gt; relative\n     * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n     * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n     * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n     * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the prefix of the file, null if invalid. Null bytes inside string will be removed\n     */\n    public static String getPrefix(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        final int len = getPrefixLength(fileName);\n        if (len < 0) {\n            return null;\n        }\n        if (len > fileName.length()) {\n            requireNonNullChars(fileName + UNIX_SEPARATOR);\n            return fileName + UNIX_SEPARATOR;\n        }\n        final String path = fileName.substring(0, len);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\\\n     * ~/a/b/c.txt  --&gt; a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPath(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix, and\n     * also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\n     * ~/a/b/c.txt  --&gt; a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param separatorAdd  0 to omit the end separator, 1 to return it\n     * @return the path. Null bytes inside string will be removed\n     */\n    private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        final int endIndex = index+separatorAdd;\n        if (prefix >= fileName.length() || index < 0 || prefix >= endIndex) {\n            return EMPTY_STRING;\n        }\n        final String path = fileName.substring(prefix, endIndex);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\\\n     * ~/a/b/c.txt  --&gt; ~/a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~/\n     * ~/           --&gt; ~/\n     * ~user        --&gt; ~user/\n     * ~user/       --&gt; ~user/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path,\n     * and also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\n     * ~/a/b/c.txt  --&gt; ~/a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~\n     * ~/           --&gt; ~\n     * ~user        --&gt; ~user\n     * ~user/       --&gt; ~user\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param includeSeparator  true to include the end separator\n     * @return the path\n     */\n    private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  // add end slash if necessary\n            }\n            return fileName;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        if (index < 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }\n\n    /**\n     * Gets the name minus the path from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c.txt\n     * a.txt     --&gt; a.txt\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists.\n     * Null bytes inside string will be removed\n     */\n    public static String getName(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n        final int index = indexOfLastSeparator(fileName);\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Checks the input for null bytes, a sign of unsanitized data being passed to to file level functions.\n     *\n     * This may be used for poison byte attacks.\n     *\n     * @param path the path to check\n     */\n    private static void requireNonNullChars(final String path) {\n        if (path.indexOf(0) >= 0) {\n            throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \"\n                + \"known legitimate use cases for such data, but several injection attacks may use it\");\n        }\n    }\n\n    /**\n     * Gets the base name, minus the full path and extension, from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash and before the last dot is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c\n     * a.txt     --&gt; a\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists. Null bytes inside string\n     * will be removed\n     */\n    public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }\n\n    /**\n     * Gets the extension of a fileName.\n     * <p>\n     * This method returns the textual part of the fileName after the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt      --&gt; \"txt\"\n     * a/b/c.jpg    --&gt; \"jpg\"\n     * a/b.txt/c    --&gt; \"\"\n     * a/b/c        --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName the fileName to retrieve the extension of.\n     * @return the extension of the file or an empty string if none exists or {@code null}\n     * if the fileName is {@code null}.\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return null;\n        }\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Special handling for NTFS ADS: Don't accept colon in the fileName.\n     *\n     * @param fileName a file name\n     * @return ADS offsets.\n     */\n    private static int getAdsCriticalOffset(final String fileName) {\n        // Step 1: Remove leading path segments.\n        final int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);\n        final int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 == -1) {\n            if (offset2 == -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 == -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }\n\n    /**\n     * Removes the extension from a fileName.\n     * <p>\n     * This method returns the textual part of the fileName before the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt    --&gt; foo\n     * a\\b\\c.jpg  --&gt; a\\b\\c\n     * a\\b\\c      --&gt; a\\b\\c\n     * a.b\\c      --&gt; a.b\\c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the fileName minus the extension\n     */\n    public static String removeExtension(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }\n\n    /**\n     * Checks whether two fileNames are equal exactly.\n     * <p>\n     * No processing is performed on the fileNames other than comparison,\n     * thus this is merely a null-safe case-sensitive equals.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal using the case rules of the system.\n     * <p>\n     * No processing is performed on the fileNames other than comparison.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed in a case-sensitive manner.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized\n     * and using the case rules of the system.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed case-sensitive on Unix and\n     * case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal, optionally normalizing and providing\n     * control over the case-sensitivity.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @param normalized  whether to normalize the fileNames\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileNames are equal, null equals null\n     * @since 1.3\n     */\n    public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\n\n        if (fileName1 == null || fileName2 == null) {\n            return fileName1 == null && fileName2 == null;\n        }\n        if (normalized) {\n            fileName1 = normalize(fileName1);\n            if (fileName1 == null) {\n                return false;\n            }\n            fileName2 = normalize(fileName2);\n            if (fileName2 == null) {\n                return false;\n            }\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        return caseSensitivity.checkEquals(fileName1, fileName2);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (isEmpty(extension)) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String... extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final Collection<String> extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher,\n     * always testing case-sensitive.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive always.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * using the case rules of the system.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SYSTEM\n     */\n    public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * allowing control over case-sensitivity.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileName matches the wildcard string\n     * @since 1.3\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n        if (fileName == null && wildcardMatcher == null) {\n            return true;\n        }\n        if (fileName == null || wildcardMatcher == null) {\n            return false;\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        final String[] wcs = splitOnTokens(wildcardMatcher);\n        boolean anyChars = false;\n        int textIdx = 0;\n        int wcsIdx = 0;\n        final Deque<int[]> backtrack = new ArrayDeque<>(wcs.length);\n\n        // loop around a backtrack stack, to handle complex * matching\n        do {\n            if (!backtrack.isEmpty()) {\n                final int[] array = backtrack.pop();\n                wcsIdx = array[0];\n                textIdx = array[1];\n                anyChars = true;\n            }\n\n            // loop whilst tokens and text left to process\n            while (wcsIdx < wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    // ? so move to next text char\n                    textIdx++;\n                    if (textIdx > fileName.length()) {\n                        break;\n                    }\n                    anyChars = false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    // set any chars status\n                    anyChars = true;\n                    if (wcsIdx == wcs.length - 1) {\n                        textIdx = fileName.length();\n                    }\n\n                } else {\n                    // matching text token\n                    if (anyChars) {\n                        // any chars then try to locate text token\n                        textIdx = caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx == NOT_FOUND) {\n                            // token not found\n                            break;\n                        }\n                        final int repeat = caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat >= 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        // matching from current position\n                        // couldn't match token\n                        break;\n                    }\n\n                    // matched text token, move text index to end of matched token\n                    textIdx += wcs[wcsIdx].length();\n                    anyChars = false;\n                }\n\n                wcsIdx++;\n            }\n\n            // full match\n            if (wcsIdx == wcs.length && textIdx == fileName.length()) {\n                return true;\n            }\n\n        } while (!backtrack.isEmpty());\n\n        return false;\n    }\n\n    /**\n     * Splits a string into a number of tokens.\n     * The text is split by '?' and '*'.\n     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n     *\n     * @param text  the text to split\n     * @return the array of tokens, never null\n     */\n    static String[] splitOnTokens(final String text) {\n        // used by wildcardMatch\n        // package level so a unit test may run on this\n\n        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array = text.toCharArray();\n        final ArrayList<String> list = new ArrayList<>();\n        final StringBuilder buffer = new StringBuilder();\n        char prevChar = 0;\n        for (final char ch : array) {\n            if (ch == '?' || ch == '*') {\n                if (buffer.length() != 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch == '?') {\n                    list.add(\"?\");\n                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar = ch;\n        }\n        if (buffer.length() != 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray(EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986.\n     *\n     * <p>Accepted are IP addresses (v4 and v6) as well as what the\n     * RFC calls a \"reg-name\". Percent encoded names don't seem to be\n     * valid names in UNC paths.</p>\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isValidHostName(final String name) {\n        return isIPv6Address(name) || isRFC3986HostName(name);\n    }\n\n    private static final Pattern IPV4_PATTERN =\n        Pattern.compile(\"^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$\");\n    private static final int IPV4_MAX_OCTET_VALUE = 255;\n\n    /**\n     * Checks whether a given string represents a valid IPv4 address.\n     *\n     * @param name the name to validate\n     * @return true if the given name is a valid IPv4 address\n     */\n    // mostly copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet4Address\n    private static boolean isIPv4Address(final String name) {\n        final Matcher m = IPV4_PATTERN.matcher(name);\n        if (!m.matches() || m.groupCount() != 4) {\n            return false;\n        }\n\n        // verify that address subgroups are legal\n        for (int i = 1; i <= 4; i++) {\n            final String ipSegment = m.group(i);\n            final int iIpSegment = Integer.parseInt(ipSegment);\n            if (iIpSegment > IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n\n            if (ipSegment.length() > 1 && ipSegment.startsWith(\"0\")) {\n                return false;\n            }\n\n        }\n\n        return true;\n    }\n\n    private static final int IPV6_MAX_HEX_GROUPS = 8;\n    private static final int IPV6_MAX_HEX_DIGITS_PER_GROUP = 4;\n    private static final int MAX_UNSIGNED_SHORT = 0xffff;\n    private static final int BASE_16 = 16;\n\n    // copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet6Address\n    /**\n     * Checks whether a given string represents a valid IPv6 address.\n     *\n     * @param inet6Address the name to validate\n     * @return true if the given name is a valid IPv6 address\n     */\n    private static boolean isIPv6Address(final String inet6Address) {\n        final boolean containsCompressedZeroes = inet6Address.contains(\"::\");\n        if (containsCompressedZeroes && (inet6Address.indexOf(\"::\") != inet6Address.lastIndexOf(\"::\"))) {\n            return false;\n        }\n        if ((inet6Address.startsWith(\":\") && !inet6Address.startsWith(\"::\"))\n                || (inet6Address.endsWith(\":\") && !inet6Address.endsWith(\"::\"))) {\n            return false;\n        }\n        String[] octets = inet6Address.split(\":\");\n        if (containsCompressedZeroes) {\n            final List<String> octetList = new ArrayList<>(Arrays.asList(octets));\n            if (inet6Address.endsWith(\"::\")) {\n                // String.split() drops ending empty segments\n                octetList.add(\"\");\n            } else if (inet6Address.startsWith(\"::\") && !octetList.isEmpty()) {\n                octetList.remove(0);\n            }\n            octets = octetList.toArray(EMPTY_STRING_ARRAY);\n        }\n        if (octets.length > IPV6_MAX_HEX_GROUPS) {\n            return false;\n        }\n        int validOctets = 0;\n        int emptyOctets = 0; // consecutive empty chunks\n        for (int index = 0; index < octets.length; index++) {\n            final String octet = octets[index];\n            if (octet.isEmpty()) {\n                emptyOctets++;\n                if (emptyOctets > 1) {\n                    return false;\n                }\n            } else {\n                emptyOctets = 0;\n                // Is last chunk an IPv4 address?\n                if (index == octets.length - 1 && octet.contains(\".\")) {\n                    if (!isIPv4Address(octet)) {\n                        return false;\n                    }\n                    validOctets += 2;\n                    continue;\n                }\n                if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) {\n                    return false;\n                }\n                final int octetInt;\n                try {\n                    octetInt = Integer.parseInt(octet, BASE_16);\n                } catch (final NumberFormatException e) {\n                    return false;\n                }\n                if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) {\n                    return false;\n                }\n            }\n            validOctets++;\n        }\n        return validOctets <= IPV6_MAX_HEX_GROUPS && (validOctets >= IPV6_MAX_HEX_GROUPS || containsCompressedZeroes);\n    }\n\n    private static final Pattern REG_NAME_PART_PATTERN = Pattern.compile(\"^[a-zA-Z0-9][a-zA-Z0-9-]*$\");\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986 - not accepting IP addresses.\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isRFC3986HostName(final String name) {\n        final String[] parts = name.split(\"\\\\.\", -1);\n        for (int i = 0; i < parts.length; i++) {\n            if (parts[i].isEmpty()) {\n                // trailing dot is legal, otherwise we've hit a .. sequence\n                return i == parts.length - 1;\n            }\n            if (!REG_NAME_PART_PATTERN.matcher(parts[i]).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate isEmpty(string String) : boolean extracted from public isExtension(fileName String, extension String) : boolean in class org.apache.commons.io.FilenameUtils", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/FilenameUtils.java", "startLine": 1220, "endLine": 1243, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/FilenameUtils.java", "startLine": 1224, "endLine": 1247, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/FilenameUtils.java", "startLine": 555, "endLine": 557, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extension == null || extension.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/FilenameUtils.java", "isPureRefactoring": true, "commitId": "d42b9286eb7a534f1b2b6243858ff7ef6fcac14c", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.FilenameUtils", "methodNameBefore": "org.apache.commons.io.FilenameUtils#isExtension", "invokedMethod": "methodSignature: org.apache.commons.io.FilenameUtils#getExtension\n methodBody: public static String getExtension(final String fileName) throws IllegalArgumentException {\nif(fileName == null){return null;\n}final int index=indexOfExtension(fileName);\nif(index == NOT_FOUND){return EMPTY_STRING;\n}return fileName.substring(index + 1);\n}\nmethodSignature: org.apache.commons.io.FilenameUtils#requireNonNullChars\n methodBody: private static void requireNonNullChars(final String path) {\nif(path.indexOf(0) >= 0){throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");\n}}\nmethodSignature: org.apache.commons.io.FilenameUtils#indexOfExtension\n methodBody: public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\nif(fileName == null){return NOT_FOUND;\n}if(isSystemWindows()){final int offset=fileName.indexOf(':',getAdsCriticalOffset(fileName));\nif(offset != -1){throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n}}final int extensionPos=fileName.lastIndexOf(EXTENSION_SEPARATOR);\nfinal int lastSeparator=indexOfLastSeparator(fileName);\nreturn lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n}\nmethodSignature: org.apache.commons.io.FilenameUtils#equals\n methodBody: public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\nif(fileName1 == null || fileName2 == null){return fileName1 == null && fileName2 == null;\n}if(normalized){fileName1=normalize(fileName1);\nif(fileName1 == null){return false;\n}fileName2=normalize(fileName2);\nif(fileName2 == null){return false;\n}}if(caseSensitivity == null){caseSensitivity=IOCase.SENSITIVE;\n}return caseSensitivity.checkEquals(fileName1,fileName2);\n}", "classSignatureBefore": "public class FilenameUtils ", "methodNameBeforeSet": ["org.apache.commons.io.FilenameUtils#isExtension"], "classNameBeforeSet": ["org.apache.commons.io.FilenameUtils"], "classSignatureBeforeSet": ["public class FilenameUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.File;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * General file name and file path manipulation utilities.\n * <p>\n * When dealing with file names you can hit problems when moving from a Windows\n * based development machine to a Unix based production machine.\n * This class aims to help avoid those problems.\n * <p>\n * <b>NOTE</b>: You may be able to avoid using this class entirely simply by\n * using JDK {@link java.io.File File} objects and the two argument constructor\n * {@link java.io.File#File(java.io.File, java.lang.String) File(File,String)}.\n * <p>\n * Most methods on this class are designed to work the same on both Unix and Windows.\n * Those that don't include 'System', 'Unix' or 'Windows' in their name.\n * <p>\n * Most methods recognize both separators (forward and back), and both\n * sets of prefixes. See the Javadoc of each method for details.\n * <p>\n * This class defines six components within a file name\n * (example C:\\dev\\project\\file.txt):\n * <ul>\n * <li>the prefix - C:\\</li>\n * <li>the path - dev\\project\\</li>\n * <li>the full path - C:\\dev\\project\\</li>\n * <li>the name - file.txt</li>\n * <li>the base name - file</li>\n * <li>the extension - txt</li>\n * </ul>\n * Note that this class works best if directory file names end with a separator.\n * If you omit the last separator, it is impossible to determine if the file name\n * corresponds to a file or a directory. As a result, we have chosen to say\n * it corresponds to a file.\n * <p>\n * This class only supports Unix and Windows style names.\n * Prefixes are matched as follows:\n * <pre>\n * Windows:\n * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n *\n * Unix:\n * a/b/c.txt           --&gt; \"\"          --&gt; relative\n * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n * </pre>\n * Both prefix styles are matched always, irrespective of the machine that you are\n * currently running on.\n * <p>\n * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.\n *\n * @since 1.1\n */\npublic class FilenameUtils {\n\n    private static final String[] EMPTY_STRING_ARRAY = {};\n\n    private static final String EMPTY_STRING = \"\";\n\n    private static final int NOT_FOUND = -1;\n\n    /**\n     * The extension separator character.\n     * @since 1.4\n     */\n    public static final char EXTENSION_SEPARATOR = '.';\n\n    /**\n     * The extension separator String.\n     * @since 1.4\n     */\n    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n\n    /**\n     * The Unix separator character.\n     */\n    private static final char UNIX_SEPARATOR = '/';\n\n    /**\n     * The Windows separator character.\n     */\n    private static final char WINDOWS_SEPARATOR = '\\\\';\n\n    /**\n     * The system separator character.\n     */\n    private static final char SYSTEM_SEPARATOR = File.separatorChar;\n\n    /**\n     * The separator character that is the opposite of the system separator.\n     */\n    private static final char OTHER_SEPARATOR;\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_SEPARATOR;\n        }\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public FilenameUtils() {\n    }\n\n    /**\n     * Determines if Windows file system is in use.\n     *\n     * @return true if the system is Windows\n     */\n    static boolean isSystemWindows() {\n        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;\n    }\n\n    /**\n     * Checks if the character is a separator.\n     *\n     * @param ch  the character to check\n     * @return true if it is a separator character\n     */\n    private static boolean isSeparator(final char ch) {\n        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, true);\n    }\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalize(final String fileName, final boolean unixSeparator) {\n        final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, true);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, false);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, false);\n    }\n\n    /**\n     * Internal method to perform the normalization.\n     *\n     * @param fileName  the fileName\n     * @param separator The separator character to use\n     * @param keepSeparator  true to keep the final separator\n     * @return the normalized fileName. Null bytes inside string will be removed.\n     */\n    private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n\n        requireNonNullChars(fileName);\n\n        int size = fileName.length();\n        if (size == 0) {\n            return fileName;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n\n        final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        fileName.getChars(0, fileName.length(), array, 0);\n\n        // fix separators throughout\n        final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n\n        // adjoining slashes\n        // If we get here, prefix can only be 0 or greater, size 1 or greater\n        // If prefix is 0, set loop start to 1 to prevent index errors\n        for (int i = (prefix != 0) ? prefix : 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        // dot slash\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' &&\n                    (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -=2;\n                i--;\n            }\n        }\n\n        // double dot slash\n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&\n                    (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4 ; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n\n        if (size <= 0) {  // should never be less than 0\n            return EMPTY_STRING;\n        }\n        if (size <= prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }\n\n    /**\n     * Concatenates a fileName to a base path using normal command line style rules.\n     * <p>\n     * The effect is equivalent to resultant directory after changing\n     * directory to the first argument, followed by changing directory to\n     * the second argument.\n     * </p>\n     * <p>\n     * The first argument is the base path, the second is the path to concatenate.\n     * The returned path is always normalized via {@link #normalize(String)},\n     * thus {@code ..} is handled.\n     * </p>\n     * <p>\n     * If {@code pathToAdd} is absolute (has an absolute prefix), then\n     * it will be normalized and returned.\n     * Otherwise, the paths will be joined, normalized and returned.\n     * </p>\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * </p>\n     * <pre>\n     * /foo/      + bar        --&gt;  /foo/bar\n     * /foo       + bar        --&gt;  /foo/bar\n     * /foo       + /bar       --&gt;  /bar\n     * /foo       + C:/bar     --&gt;  C:/bar\n     * /foo       + C:bar      --&gt;  C:bar [1]\n     * /foo/a/    + ../bar     --&gt;  /foo/bar\n     * /foo/      + ../../bar  --&gt;  null\n     * /foo/      + /bar       --&gt;  /bar\n     * /foo/..    + /bar       --&gt;  /bar\n     * /foo       + bar/c.txt  --&gt;  /foo/bar/c.txt\n     * /foo/c.txt + bar        --&gt;  /foo/c.txt/bar [2]\n     * </pre>\n     * <p>\n     * [1] Note that the Windows relative drive prefix is unreliable when\n     * used with this method.\n     * </p>\n     * <p>\n     * [2] Note that the first parameter must be a path. If it ends with a name, then\n     * the name will be built into the concatenated path. If this might be a problem,\n     * use {@link #getFullPath(String)} on the base path argument.\n     * </p>\n     *\n     * @param basePath  the base path to attach to, always treated as a path\n     * @param fullFileNameToAdd  the fileName (or path) to attach to the base\n     * @return the concatenated path, or null if invalid.  Null bytes inside string will be removed\n     */\n    public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix = getPrefixLength(fullFileNameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        final int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + '/' + fullFileNameToAdd);\n    }\n\n    /**\n     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).\n     * <p>\n     * The files names are expected to be normalized.\n     * </p>\n     *\n     * Edge cases:\n     * <ul>\n     * <li>A {@code directory} must not be null: if null, throw IllegalArgumentException</li>\n     * <li>A directory does not contain itself: return false</li>\n     * <li>A null child file is not contained in any parent: return false</li>\n     * </ul>\n     *\n     * @param canonicalParent\n     *            the file to consider as the parent.\n     * @param canonicalChild\n     *            the file to consider as the child.\n     * @return true is the candidate leaf is under by the specified composite. False otherwise.\n     * @since 2.2\n     * @see FileUtils#directoryContains(File, File)\n     */\n    public static boolean directoryContains(final String canonicalParent, final String canonicalChild) {\n        Objects.requireNonNull(canonicalParent, \"canonicalParent\");\n\n        if (canonicalChild == null) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, canonicalParent);\n    }\n\n    /**\n     * Converts all separators to the Unix separator of forward slash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the Windows separator of backslash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToWindows(final String path) {\n        if (path == null || path.indexOf(UNIX_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the system separator.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToSystem(final String path) {\n        if (path == null) {\n            return null;\n        }\n        return isSystemWindows() ? separatorsToWindows(path) : separatorsToUnix(path);\n    }\n\n    /**\n     * Returns the length of the fileName prefix, such as {@code C:/} or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * <p>\n     * The prefix length includes the first slash in the full fileName\n     * if applicable. Thus, it is possible that the length returned is greater\n     * than the length of the input string.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; 0           --&gt; relative\n     * \\a\\b\\c.txt          --&gt; 1           --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; 2           --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; 3           --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; 9           --&gt; UNC\n     * \\\\\\a\\b\\c.txt        --&gt; -1          --&gt; error\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; 0           --&gt; relative\n     * /a/b/c.txt          --&gt; 1           --&gt; absolute\n     * ~/a/b/c.txt         --&gt; 2           --&gt; current user\n     * ~                   --&gt; 2           --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; 6           --&gt; named user\n     * ~user               --&gt; 6           --&gt; named user (slash added)\n     * //server/a/b/c.txt  --&gt; 9\n     * ///a/b/c.txt        --&gt; -1          --&gt; error\n     * C:                  --&gt; 0           --&gt; valid filename as only null byte and / are reserved characters\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * Note that a leading // (or \\\\) is used to indicate a UNC name on Windows.\n     * These must be followed by a server name, so double-slashes are not collapsed\n     * to a single slash at the start of the fileName.\n     *\n     * @param fileName  the fileName to find the prefix in, null returns -1\n     * @return the length of the prefix, -1 if invalid or null\n     */\n    public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 && !FileSystem.getCurrent().supportsDriveLetter()) {\n                    return 0;\n                }\n                if (len == 2 || !isSeparator(fileName.charAt(2))) {\n                    return 2;\n                }\n                return 3;\n            }\n            if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        }\n        if (!isSeparator(ch0) || !isSeparator(ch1)) {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n        int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n        if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n            return NOT_FOUND;\n        }\n        posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n        posWin = posWin == NOT_FOUND ? posUnix : posWin;\n        final int pos = Math.min(posUnix, posWin) + 1;\n        final String hostnamePart = fileName.substring(2, pos - 1);\n        return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n    }\n\n    /**\n     * Returns the index of the last directory separator character.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The position of the last forward or backslash is returned.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfLastSeparator(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos = fileName.lastIndexOf(UNIX_SEPARATOR);\n        final int lastWindowsPos = fileName.lastIndexOf(WINDOWS_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    /**\n     * Returns the index of the last extension separator character, which is a dot.\n     * <p>\n     * This method also checks that there is no directory separator after the last dot. To do this it uses\n     * {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.\n     * </p>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName\n     *            the fileName to find the last extension separator in, null returns -1\n     * @return the index of the last extension separator character, or -1 if there is no such character\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            // Special handling for NTFS ADS: Don't accept colon in the fileName.\n            final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));\n            if (offset != -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n            }\n        }\n        final int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator = indexOfLastSeparator(fileName);\n        return lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n    }\n\n    /**\n     * Gets the prefix from a full fileName, such as {@code C:/}\n     * or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The prefix includes the first slash in the full fileName where applicable.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n     * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; \"\"          --&gt; relative\n     * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n     * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n     * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n     * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the prefix of the file, null if invalid. Null bytes inside string will be removed\n     */\n    public static String getPrefix(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        final int len = getPrefixLength(fileName);\n        if (len < 0) {\n            return null;\n        }\n        if (len > fileName.length()) {\n            requireNonNullChars(fileName + UNIX_SEPARATOR);\n            return fileName + UNIX_SEPARATOR;\n        }\n        final String path = fileName.substring(0, len);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\\\n     * ~/a/b/c.txt  --&gt; a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPath(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix, and\n     * also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\n     * ~/a/b/c.txt  --&gt; a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param separatorAdd  0 to omit the end separator, 1 to return it\n     * @return the path. Null bytes inside string will be removed\n     */\n    private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        final int endIndex = index+separatorAdd;\n        if (prefix >= fileName.length() || index < 0 || prefix >= endIndex) {\n            return EMPTY_STRING;\n        }\n        final String path = fileName.substring(prefix, endIndex);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\\\n     * ~/a/b/c.txt  --&gt; ~/a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~/\n     * ~/           --&gt; ~/\n     * ~user        --&gt; ~user/\n     * ~user/       --&gt; ~user/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path,\n     * and also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\n     * ~/a/b/c.txt  --&gt; ~/a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~\n     * ~/           --&gt; ~\n     * ~user        --&gt; ~user\n     * ~user/       --&gt; ~user\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param includeSeparator  true to include the end separator\n     * @return the path\n     */\n    private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  // add end slash if necessary\n            }\n            return fileName;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        if (index < 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }\n\n    /**\n     * Gets the name minus the path from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c.txt\n     * a.txt     --&gt; a.txt\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists.\n     * Null bytes inside string will be removed\n     */\n    public static String getName(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n        final int index = indexOfLastSeparator(fileName);\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Checks the input for null bytes, a sign of unsanitized data being passed to to file level functions.\n     *\n     * This may be used for poison byte attacks.\n     *\n     * @param path the path to check\n     */\n    private static void requireNonNullChars(final String path) {\n        if (path.indexOf(0) >= 0) {\n            throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \"\n                + \"known legitimate use cases for such data, but several injection attacks may use it\");\n        }\n    }\n\n    /**\n     * Gets the base name, minus the full path and extension, from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash and before the last dot is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c\n     * a.txt     --&gt; a\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists. Null bytes inside string\n     * will be removed\n     */\n    public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }\n\n    /**\n     * Gets the extension of a fileName.\n     * <p>\n     * This method returns the textual part of the fileName after the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt      --&gt; \"txt\"\n     * a/b/c.jpg    --&gt; \"jpg\"\n     * a/b.txt/c    --&gt; \"\"\n     * a/b/c        --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName the fileName to retrieve the extension of.\n     * @return the extension of the file or an empty string if none exists or {@code null}\n     * if the fileName is {@code null}.\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return null;\n        }\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Special handling for NTFS ADS: Don't accept colon in the fileName.\n     *\n     * @param fileName a file name\n     * @return ADS offsets.\n     */\n    private static int getAdsCriticalOffset(final String fileName) {\n        // Step 1: Remove leading path segments.\n        final int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);\n        final int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 == -1) {\n            if (offset2 == -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 == -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }\n\n    /**\n     * Removes the extension from a fileName.\n     * <p>\n     * This method returns the textual part of the fileName before the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt    --&gt; foo\n     * a\\b\\c.jpg  --&gt; a\\b\\c\n     * a\\b\\c      --&gt; a\\b\\c\n     * a.b\\c      --&gt; a.b\\c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the fileName minus the extension\n     */\n    public static String removeExtension(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }\n\n    /**\n     * Checks whether two fileNames are equal exactly.\n     * <p>\n     * No processing is performed on the fileNames other than comparison,\n     * thus this is merely a null-safe case-sensitive equals.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal using the case rules of the system.\n     * <p>\n     * No processing is performed on the fileNames other than comparison.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed in a case-sensitive manner.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized\n     * and using the case rules of the system.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed case-sensitive on Unix and\n     * case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal, optionally normalizing and providing\n     * control over the case-sensitivity.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @param normalized  whether to normalize the fileNames\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileNames are equal, null equals null\n     * @since 1.3\n     */\n    public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\n\n        if (fileName1 == null || fileName2 == null) {\n            return fileName1 == null && fileName2 == null;\n        }\n        if (normalized) {\n            fileName1 = normalize(fileName1);\n            if (fileName1 == null) {\n                return false;\n            }\n            fileName2 = normalize(fileName2);\n            if (fileName2 == null) {\n                return false;\n            }\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        return caseSensitivity.checkEquals(fileName1, fileName2);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extension == null || extension.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String... extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final Collection<String> extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher,\n     * always testing case-sensitive.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive always.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * using the case rules of the system.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SYSTEM\n     */\n    public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * allowing control over case-sensitivity.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileName matches the wildcard string\n     * @since 1.3\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n        if (fileName == null && wildcardMatcher == null) {\n            return true;\n        }\n        if (fileName == null || wildcardMatcher == null) {\n            return false;\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        final String[] wcs = splitOnTokens(wildcardMatcher);\n        boolean anyChars = false;\n        int textIdx = 0;\n        int wcsIdx = 0;\n        final Deque<int[]> backtrack = new ArrayDeque<>(wcs.length);\n\n        // loop around a backtrack stack, to handle complex * matching\n        do {\n            if (!backtrack.isEmpty()) {\n                final int[] array = backtrack.pop();\n                wcsIdx = array[0];\n                textIdx = array[1];\n                anyChars = true;\n            }\n\n            // loop whilst tokens and text left to process\n            while (wcsIdx < wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    // ? so move to next text char\n                    textIdx++;\n                    if (textIdx > fileName.length()) {\n                        break;\n                    }\n                    anyChars = false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    // set any chars status\n                    anyChars = true;\n                    if (wcsIdx == wcs.length - 1) {\n                        textIdx = fileName.length();\n                    }\n\n                } else {\n                    // matching text token\n                    if (anyChars) {\n                        // any chars then try to locate text token\n                        textIdx = caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx == NOT_FOUND) {\n                            // token not found\n                            break;\n                        }\n                        final int repeat = caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat >= 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        // matching from current position\n                        // couldn't match token\n                        break;\n                    }\n\n                    // matched text token, move text index to end of matched token\n                    textIdx += wcs[wcsIdx].length();\n                    anyChars = false;\n                }\n\n                wcsIdx++;\n            }\n\n            // full match\n            if (wcsIdx == wcs.length && textIdx == fileName.length()) {\n                return true;\n            }\n\n        } while (!backtrack.isEmpty());\n\n        return false;\n    }\n\n    /**\n     * Splits a string into a number of tokens.\n     * The text is split by '?' and '*'.\n     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n     *\n     * @param text  the text to split\n     * @return the array of tokens, never null\n     */\n    static String[] splitOnTokens(final String text) {\n        // used by wildcardMatch\n        // package level so a unit test may run on this\n\n        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array = text.toCharArray();\n        final ArrayList<String> list = new ArrayList<>();\n        final StringBuilder buffer = new StringBuilder();\n        char prevChar = 0;\n        for (final char ch : array) {\n            if (ch == '?' || ch == '*') {\n                if (buffer.length() != 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch == '?') {\n                    list.add(\"?\");\n                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar = ch;\n        }\n        if (buffer.length() != 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray(EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986.\n     *\n     * <p>Accepted are IP addresses (v4 and v6) as well as what the\n     * RFC calls a \"reg-name\". Percent encoded names don't seem to be\n     * valid names in UNC paths.</p>\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isValidHostName(final String name) {\n        return isIPv6Address(name) || isRFC3986HostName(name);\n    }\n\n    private static final Pattern IPV4_PATTERN =\n        Pattern.compile(\"^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$\");\n    private static final int IPV4_MAX_OCTET_VALUE = 255;\n\n    /**\n     * Checks whether a given string represents a valid IPv4 address.\n     *\n     * @param name the name to validate\n     * @return true if the given name is a valid IPv4 address\n     */\n    // mostly copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet4Address\n    private static boolean isIPv4Address(final String name) {\n        final Matcher m = IPV4_PATTERN.matcher(name);\n        if (!m.matches() || m.groupCount() != 4) {\n            return false;\n        }\n\n        // verify that address subgroups are legal\n        for (int i = 1; i <= 4; i++) {\n            final String ipSegment = m.group(i);\n            final int iIpSegment = Integer.parseInt(ipSegment);\n            if (iIpSegment > IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n\n            if (ipSegment.length() > 1 && ipSegment.startsWith(\"0\")) {\n                return false;\n            }\n\n        }\n\n        return true;\n    }\n\n    private static final int IPV6_MAX_HEX_GROUPS = 8;\n    private static final int IPV6_MAX_HEX_DIGITS_PER_GROUP = 4;\n    private static final int MAX_UNSIGNED_SHORT = 0xffff;\n    private static final int BASE_16 = 16;\n\n    // copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet6Address\n    /**\n     * Checks whether a given string represents a valid IPv6 address.\n     *\n     * @param inet6Address the name to validate\n     * @return true if the given name is a valid IPv6 address\n     */\n    private static boolean isIPv6Address(final String inet6Address) {\n        final boolean containsCompressedZeroes = inet6Address.contains(\"::\");\n        if (containsCompressedZeroes && (inet6Address.indexOf(\"::\") != inet6Address.lastIndexOf(\"::\"))) {\n            return false;\n        }\n        if ((inet6Address.startsWith(\":\") && !inet6Address.startsWith(\"::\"))\n                || (inet6Address.endsWith(\":\") && !inet6Address.endsWith(\"::\"))) {\n            return false;\n        }\n        String[] octets = inet6Address.split(\":\");\n        if (containsCompressedZeroes) {\n            final List<String> octetList = new ArrayList<>(Arrays.asList(octets));\n            if (inet6Address.endsWith(\"::\")) {\n                // String.split() drops ending empty segments\n                octetList.add(\"\");\n            } else if (inet6Address.startsWith(\"::\") && !octetList.isEmpty()) {\n                octetList.remove(0);\n            }\n            octets = octetList.toArray(EMPTY_STRING_ARRAY);\n        }\n        if (octets.length > IPV6_MAX_HEX_GROUPS) {\n            return false;\n        }\n        int validOctets = 0;\n        int emptyOctets = 0; // consecutive empty chunks\n        for (int index = 0; index < octets.length; index++) {\n            final String octet = octets[index];\n            if (octet.isEmpty()) {\n                emptyOctets++;\n                if (emptyOctets > 1) {\n                    return false;\n                }\n            } else {\n                emptyOctets = 0;\n                // Is last chunk an IPv4 address?\n                if (index == octets.length - 1 && octet.contains(\".\")) {\n                    if (!isIPv4Address(octet)) {\n                        return false;\n                    }\n                    validOctets += 2;\n                    continue;\n                }\n                if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) {\n                    return false;\n                }\n                final int octetInt;\n                try {\n                    octetInt = Integer.parseInt(octet, BASE_16);\n                } catch (final NumberFormatException e) {\n                    return false;\n                }\n                if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) {\n                    return false;\n                }\n            }\n            validOctets++;\n        }\n        return validOctets <= IPV6_MAX_HEX_GROUPS && (validOctets >= IPV6_MAX_HEX_GROUPS || containsCompressedZeroes);\n    }\n\n    private static final Pattern REG_NAME_PART_PATTERN = Pattern.compile(\"^[a-zA-Z0-9][a-zA-Z0-9-]*$\");\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986 - not accepting IP addresses.\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isRFC3986HostName(final String name) {\n        final String[] parts = name.split(\"\\\\.\", -1);\n        for (int i = 0; i < parts.length; i++) {\n            if (parts[i].isEmpty()) {\n                // trailing dot is legal, otherwise we've hit a .. sequence\n                return i == parts.length - 1;\n            }\n            if (!REG_NAME_PART_PATTERN.matcher(parts[i]).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/FilenameUtils.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.File;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * General file name and file path manipulation utilities.\n * <p>\n * When dealing with file names you can hit problems when moving from a Windows\n * based development machine to a Unix based production machine.\n * This class aims to help avoid those problems.\n * <p>\n * <b>NOTE</b>: You may be able to avoid using this class entirely simply by\n * using JDK {@link java.io.File File} objects and the two argument constructor\n * {@link java.io.File#File(java.io.File, java.lang.String) File(File,String)}.\n * <p>\n * Most methods on this class are designed to work the same on both Unix and Windows.\n * Those that don't include 'System', 'Unix' or 'Windows' in their name.\n * <p>\n * Most methods recognize both separators (forward and back), and both\n * sets of prefixes. See the Javadoc of each method for details.\n * <p>\n * This class defines six components within a file name\n * (example C:\\dev\\project\\file.txt):\n * <ul>\n * <li>the prefix - C:\\</li>\n * <li>the path - dev\\project\\</li>\n * <li>the full path - C:\\dev\\project\\</li>\n * <li>the name - file.txt</li>\n * <li>the base name - file</li>\n * <li>the extension - txt</li>\n * </ul>\n * Note that this class works best if directory file names end with a separator.\n * If you omit the last separator, it is impossible to determine if the file name\n * corresponds to a file or a directory. As a result, we have chosen to say\n * it corresponds to a file.\n * <p>\n * This class only supports Unix and Windows style names.\n * Prefixes are matched as follows:\n * <pre>\n * Windows:\n * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n *\n * Unix:\n * a/b/c.txt           --&gt; \"\"          --&gt; relative\n * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n * </pre>\n * Both prefix styles are matched always, irrespective of the machine that you are\n * currently running on.\n * <p>\n * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.\n *\n * @since 1.1\n */\npublic class FilenameUtils {\n\n    private static final String[] EMPTY_STRING_ARRAY = {};\n\n    private static final String EMPTY_STRING = \"\";\n\n    private static final int NOT_FOUND = -1;\n\n    /**\n     * The extension separator character.\n     * @since 1.4\n     */\n    public static final char EXTENSION_SEPARATOR = '.';\n\n    /**\n     * The extension separator String.\n     * @since 1.4\n     */\n    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n\n    /**\n     * The Unix separator character.\n     */\n    private static final char UNIX_SEPARATOR = '/';\n\n    /**\n     * The Windows separator character.\n     */\n    private static final char WINDOWS_SEPARATOR = '\\\\';\n\n    /**\n     * The system separator character.\n     */\n    private static final char SYSTEM_SEPARATOR = File.separatorChar;\n\n    /**\n     * The separator character that is the opposite of the system separator.\n     */\n    private static final char OTHER_SEPARATOR;\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_SEPARATOR;\n        }\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public FilenameUtils() {\n    }\n\n    /**\n     * Determines if Windows file system is in use.\n     *\n     * @return true if the system is Windows\n     */\n    static boolean isSystemWindows() {\n        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;\n    }\n\n    /**\n     * Checks if the character is a separator.\n     *\n     * @param ch  the character to check\n     * @return true if it is a separator character\n     */\n    private static boolean isSeparator(final char ch) {\n        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, true);\n    }\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalize(final String fileName, final boolean unixSeparator) {\n        final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, true);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, false);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, false);\n    }\n\n    /**\n     * Internal method to perform the normalization.\n     *\n     * @param fileName  the fileName\n     * @param separator The separator character to use\n     * @param keepSeparator  true to keep the final separator\n     * @return the normalized fileName. Null bytes inside string will be removed.\n     */\n    private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n\n        requireNonNullChars(fileName);\n\n        int size = fileName.length();\n        if (size == 0) {\n            return fileName;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n\n        final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        fileName.getChars(0, fileName.length(), array, 0);\n\n        // fix separators throughout\n        final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n\n        // adjoining slashes\n        // If we get here, prefix can only be 0 or greater, size 1 or greater\n        // If prefix is 0, set loop start to 1 to prevent index errors\n        for (int i = (prefix != 0) ? prefix : 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        // dot slash\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' &&\n                    (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -=2;\n                i--;\n            }\n        }\n\n        // double dot slash\n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&\n                    (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4 ; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n\n        if (size <= 0) {  // should never be less than 0\n            return EMPTY_STRING;\n        }\n        if (size <= prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }\n\n    /**\n     * Concatenates a fileName to a base path using normal command line style rules.\n     * <p>\n     * The effect is equivalent to resultant directory after changing\n     * directory to the first argument, followed by changing directory to\n     * the second argument.\n     * </p>\n     * <p>\n     * The first argument is the base path, the second is the path to concatenate.\n     * The returned path is always normalized via {@link #normalize(String)},\n     * thus {@code ..} is handled.\n     * </p>\n     * <p>\n     * If {@code pathToAdd} is absolute (has an absolute prefix), then\n     * it will be normalized and returned.\n     * Otherwise, the paths will be joined, normalized and returned.\n     * </p>\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * </p>\n     * <pre>\n     * /foo/      + bar        --&gt;  /foo/bar\n     * /foo       + bar        --&gt;  /foo/bar\n     * /foo       + /bar       --&gt;  /bar\n     * /foo       + C:/bar     --&gt;  C:/bar\n     * /foo       + C:bar      --&gt;  C:bar [1]\n     * /foo/a/    + ../bar     --&gt;  /foo/bar\n     * /foo/      + ../../bar  --&gt;  null\n     * /foo/      + /bar       --&gt;  /bar\n     * /foo/..    + /bar       --&gt;  /bar\n     * /foo       + bar/c.txt  --&gt;  /foo/bar/c.txt\n     * /foo/c.txt + bar        --&gt;  /foo/c.txt/bar [2]\n     * </pre>\n     * <p>\n     * [1] Note that the Windows relative drive prefix is unreliable when\n     * used with this method.\n     * </p>\n     * <p>\n     * [2] Note that the first parameter must be a path. If it ends with a name, then\n     * the name will be built into the concatenated path. If this might be a problem,\n     * use {@link #getFullPath(String)} on the base path argument.\n     * </p>\n     *\n     * @param basePath  the base path to attach to, always treated as a path\n     * @param fullFileNameToAdd  the fileName (or path) to attach to the base\n     * @return the concatenated path, or null if invalid.  Null bytes inside string will be removed\n     */\n    public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix = getPrefixLength(fullFileNameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        final int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + '/' + fullFileNameToAdd);\n    }\n\n    /**\n     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).\n     * <p>\n     * The files names are expected to be normalized.\n     * </p>\n     *\n     * Edge cases:\n     * <ul>\n     * <li>A {@code directory} must not be null: if null, throw IllegalArgumentException</li>\n     * <li>A directory does not contain itself: return false</li>\n     * <li>A null child file is not contained in any parent: return false</li>\n     * </ul>\n     *\n     * @param canonicalParent\n     *            the file to consider as the parent.\n     * @param canonicalChild\n     *            the file to consider as the child.\n     * @return true is the candidate leaf is under by the specified composite. False otherwise.\n     * @since 2.2\n     * @see FileUtils#directoryContains(File, File)\n     */\n    public static boolean directoryContains(final String canonicalParent, final String canonicalChild) {\n        if (isEmpty(canonicalParent) || isEmpty(canonicalChild)) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        final char separator = canonicalParent.charAt(0) == UNIX_SEPARATOR ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        final String parentWithEndSeparator = canonicalParent.charAt(canonicalParent.length() - 1) == separator ? canonicalParent : canonicalParent + separator;\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, parentWithEndSeparator);\n    }\n\n    private static boolean isEmpty(final String string) {\n        return string == null || string.isEmpty();\n    }\n\n    /**\n     * Converts all separators to the Unix separator of forward slash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the Windows separator of backslash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToWindows(final String path) {\n        if (path == null || path.indexOf(UNIX_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the system separator.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToSystem(final String path) {\n        if (path == null) {\n            return null;\n        }\n        return isSystemWindows() ? separatorsToWindows(path) : separatorsToUnix(path);\n    }\n\n    /**\n     * Returns the length of the fileName prefix, such as {@code C:/} or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * <p>\n     * The prefix length includes the first slash in the full fileName\n     * if applicable. Thus, it is possible that the length returned is greater\n     * than the length of the input string.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; 0           --&gt; relative\n     * \\a\\b\\c.txt          --&gt; 1           --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; 2           --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; 3           --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; 9           --&gt; UNC\n     * \\\\\\a\\b\\c.txt        --&gt; -1          --&gt; error\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; 0           --&gt; relative\n     * /a/b/c.txt          --&gt; 1           --&gt; absolute\n     * ~/a/b/c.txt         --&gt; 2           --&gt; current user\n     * ~                   --&gt; 2           --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; 6           --&gt; named user\n     * ~user               --&gt; 6           --&gt; named user (slash added)\n     * //server/a/b/c.txt  --&gt; 9\n     * ///a/b/c.txt        --&gt; -1          --&gt; error\n     * C:                  --&gt; 0           --&gt; valid filename as only null byte and / are reserved characters\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * Note that a leading // (or \\\\) is used to indicate a UNC name on Windows.\n     * These must be followed by a server name, so double-slashes are not collapsed\n     * to a single slash at the start of the fileName.\n     *\n     * @param fileName  the fileName to find the prefix in, null returns -1\n     * @return the length of the prefix, -1 if invalid or null\n     */\n    public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 && !FileSystem.getCurrent().supportsDriveLetter()) {\n                    return 0;\n                }\n                if (len == 2 || !isSeparator(fileName.charAt(2))) {\n                    return 2;\n                }\n                return 3;\n            }\n            if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        }\n        if (!isSeparator(ch0) || !isSeparator(ch1)) {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n        int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n        if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n            return NOT_FOUND;\n        }\n        posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n        posWin = posWin == NOT_FOUND ? posUnix : posWin;\n        final int pos = Math.min(posUnix, posWin) + 1;\n        final String hostnamePart = fileName.substring(2, pos - 1);\n        return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n    }\n\n    /**\n     * Returns the index of the last directory separator character.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The position of the last forward or backslash is returned.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfLastSeparator(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos = fileName.lastIndexOf(UNIX_SEPARATOR);\n        final int lastWindowsPos = fileName.lastIndexOf(WINDOWS_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    /**\n     * Returns the index of the last extension separator character, which is a dot.\n     * <p>\n     * This method also checks that there is no directory separator after the last dot. To do this it uses\n     * {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.\n     * </p>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName\n     *            the fileName to find the last extension separator in, null returns -1\n     * @return the index of the last extension separator character, or -1 if there is no such character\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            // Special handling for NTFS ADS: Don't accept colon in the fileName.\n            final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));\n            if (offset != -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n            }\n        }\n        final int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator = indexOfLastSeparator(fileName);\n        return lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n    }\n\n    /**\n     * Gets the prefix from a full fileName, such as {@code C:/}\n     * or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The prefix includes the first slash in the full fileName where applicable.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n     * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; \"\"          --&gt; relative\n     * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n     * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n     * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n     * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the prefix of the file, null if invalid. Null bytes inside string will be removed\n     */\n    public static String getPrefix(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        final int len = getPrefixLength(fileName);\n        if (len < 0) {\n            return null;\n        }\n        if (len > fileName.length()) {\n            requireNonNullChars(fileName + UNIX_SEPARATOR);\n            return fileName + UNIX_SEPARATOR;\n        }\n        final String path = fileName.substring(0, len);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\\\n     * ~/a/b/c.txt  --&gt; a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPath(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix, and\n     * also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\n     * ~/a/b/c.txt  --&gt; a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param separatorAdd  0 to omit the end separator, 1 to return it\n     * @return the path. Null bytes inside string will be removed\n     */\n    private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        final int endIndex = index+separatorAdd;\n        if (prefix >= fileName.length() || index < 0 || prefix >= endIndex) {\n            return EMPTY_STRING;\n        }\n        final String path = fileName.substring(prefix, endIndex);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\\\n     * ~/a/b/c.txt  --&gt; ~/a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~/\n     * ~/           --&gt; ~/\n     * ~user        --&gt; ~user/\n     * ~user/       --&gt; ~user/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path,\n     * and also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\n     * ~/a/b/c.txt  --&gt; ~/a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~\n     * ~/           --&gt; ~\n     * ~user        --&gt; ~user\n     * ~user/       --&gt; ~user\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param includeSeparator  true to include the end separator\n     * @return the path\n     */\n    private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  // add end slash if necessary\n            }\n            return fileName;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        if (index < 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }\n\n    /**\n     * Gets the name minus the path from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c.txt\n     * a.txt     --&gt; a.txt\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists.\n     * Null bytes inside string will be removed\n     */\n    public static String getName(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n        final int index = indexOfLastSeparator(fileName);\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Checks the input for null bytes, a sign of unsanitized data being passed to to file level functions.\n     *\n     * This may be used for poison byte attacks.\n     *\n     * @param path the path to check\n     */\n    private static void requireNonNullChars(final String path) {\n        if (path.indexOf(0) >= 0) {\n            throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \"\n                + \"known legitimate use cases for such data, but several injection attacks may use it\");\n        }\n    }\n\n    /**\n     * Gets the base name, minus the full path and extension, from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash and before the last dot is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c\n     * a.txt     --&gt; a\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists. Null bytes inside string\n     * will be removed\n     */\n    public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }\n\n    /**\n     * Gets the extension of a fileName.\n     * <p>\n     * This method returns the textual part of the fileName after the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt      --&gt; \"txt\"\n     * a/b/c.jpg    --&gt; \"jpg\"\n     * a/b.txt/c    --&gt; \"\"\n     * a/b/c        --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName the fileName to retrieve the extension of.\n     * @return the extension of the file or an empty string if none exists or {@code null}\n     * if the fileName is {@code null}.\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return null;\n        }\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Special handling for NTFS ADS: Don't accept colon in the fileName.\n     *\n     * @param fileName a file name\n     * @return ADS offsets.\n     */\n    private static int getAdsCriticalOffset(final String fileName) {\n        // Step 1: Remove leading path segments.\n        final int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);\n        final int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 == -1) {\n            if (offset2 == -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 == -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }\n\n    /**\n     * Removes the extension from a fileName.\n     * <p>\n     * This method returns the textual part of the fileName before the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt    --&gt; foo\n     * a\\b\\c.jpg  --&gt; a\\b\\c\n     * a\\b\\c      --&gt; a\\b\\c\n     * a.b\\c      --&gt; a.b\\c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the fileName minus the extension\n     */\n    public static String removeExtension(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }\n\n    /**\n     * Checks whether two fileNames are equal exactly.\n     * <p>\n     * No processing is performed on the fileNames other than comparison,\n     * thus this is merely a null-safe case-sensitive equals.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal using the case rules of the system.\n     * <p>\n     * No processing is performed on the fileNames other than comparison.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed in a case-sensitive manner.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized\n     * and using the case rules of the system.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed case-sensitive on Unix and\n     * case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal, optionally normalizing and providing\n     * control over the case-sensitivity.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @param normalized  whether to normalize the fileNames\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileNames are equal, null equals null\n     * @since 1.3\n     */\n    public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\n\n        if (fileName1 == null || fileName2 == null) {\n            return fileName1 == null && fileName2 == null;\n        }\n        if (normalized) {\n            fileName1 = normalize(fileName1);\n            if (fileName1 == null) {\n                return false;\n            }\n            fileName2 = normalize(fileName2);\n            if (fileName2 == null) {\n                return false;\n            }\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        return caseSensitivity.checkEquals(fileName1, fileName2);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (isEmpty(extension)) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String... extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final Collection<String> extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher,\n     * always testing case-sensitive.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive always.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * using the case rules of the system.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SYSTEM\n     */\n    public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * allowing control over case-sensitivity.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileName matches the wildcard string\n     * @since 1.3\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n        if (fileName == null && wildcardMatcher == null) {\n            return true;\n        }\n        if (fileName == null || wildcardMatcher == null) {\n            return false;\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        final String[] wcs = splitOnTokens(wildcardMatcher);\n        boolean anyChars = false;\n        int textIdx = 0;\n        int wcsIdx = 0;\n        final Deque<int[]> backtrack = new ArrayDeque<>(wcs.length);\n\n        // loop around a backtrack stack, to handle complex * matching\n        do {\n            if (!backtrack.isEmpty()) {\n                final int[] array = backtrack.pop();\n                wcsIdx = array[0];\n                textIdx = array[1];\n                anyChars = true;\n            }\n\n            // loop whilst tokens and text left to process\n            while (wcsIdx < wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    // ? so move to next text char\n                    textIdx++;\n                    if (textIdx > fileName.length()) {\n                        break;\n                    }\n                    anyChars = false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    // set any chars status\n                    anyChars = true;\n                    if (wcsIdx == wcs.length - 1) {\n                        textIdx = fileName.length();\n                    }\n\n                } else {\n                    // matching text token\n                    if (anyChars) {\n                        // any chars then try to locate text token\n                        textIdx = caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx == NOT_FOUND) {\n                            // token not found\n                            break;\n                        }\n                        final int repeat = caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat >= 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        // matching from current position\n                        // couldn't match token\n                        break;\n                    }\n\n                    // matched text token, move text index to end of matched token\n                    textIdx += wcs[wcsIdx].length();\n                    anyChars = false;\n                }\n\n                wcsIdx++;\n            }\n\n            // full match\n            if (wcsIdx == wcs.length && textIdx == fileName.length()) {\n                return true;\n            }\n\n        } while (!backtrack.isEmpty());\n\n        return false;\n    }\n\n    /**\n     * Splits a string into a number of tokens.\n     * The text is split by '?' and '*'.\n     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n     *\n     * @param text  the text to split\n     * @return the array of tokens, never null\n     */\n    static String[] splitOnTokens(final String text) {\n        // used by wildcardMatch\n        // package level so a unit test may run on this\n\n        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array = text.toCharArray();\n        final ArrayList<String> list = new ArrayList<>();\n        final StringBuilder buffer = new StringBuilder();\n        char prevChar = 0;\n        for (final char ch : array) {\n            if (ch == '?' || ch == '*') {\n                if (buffer.length() != 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch == '?') {\n                    list.add(\"?\");\n                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar = ch;\n        }\n        if (buffer.length() != 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray(EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986.\n     *\n     * <p>Accepted are IP addresses (v4 and v6) as well as what the\n     * RFC calls a \"reg-name\". Percent encoded names don't seem to be\n     * valid names in UNC paths.</p>\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isValidHostName(final String name) {\n        return isIPv6Address(name) || isRFC3986HostName(name);\n    }\n\n    private static final Pattern IPV4_PATTERN =\n        Pattern.compile(\"^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$\");\n    private static final int IPV4_MAX_OCTET_VALUE = 255;\n\n    /**\n     * Checks whether a given string represents a valid IPv4 address.\n     *\n     * @param name the name to validate\n     * @return true if the given name is a valid IPv4 address\n     */\n    // mostly copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet4Address\n    private static boolean isIPv4Address(final String name) {\n        final Matcher m = IPV4_PATTERN.matcher(name);\n        if (!m.matches() || m.groupCount() != 4) {\n            return false;\n        }\n\n        // verify that address subgroups are legal\n        for (int i = 1; i <= 4; i++) {\n            final String ipSegment = m.group(i);\n            final int iIpSegment = Integer.parseInt(ipSegment);\n            if (iIpSegment > IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n\n            if (ipSegment.length() > 1 && ipSegment.startsWith(\"0\")) {\n                return false;\n            }\n\n        }\n\n        return true;\n    }\n\n    private static final int IPV6_MAX_HEX_GROUPS = 8;\n    private static final int IPV6_MAX_HEX_DIGITS_PER_GROUP = 4;\n    private static final int MAX_UNSIGNED_SHORT = 0xffff;\n    private static final int BASE_16 = 16;\n\n    // copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet6Address\n    /**\n     * Checks whether a given string represents a valid IPv6 address.\n     *\n     * @param inet6Address the name to validate\n     * @return true if the given name is a valid IPv6 address\n     */\n    private static boolean isIPv6Address(final String inet6Address) {\n        final boolean containsCompressedZeroes = inet6Address.contains(\"::\");\n        if (containsCompressedZeroes && (inet6Address.indexOf(\"::\") != inet6Address.lastIndexOf(\"::\"))) {\n            return false;\n        }\n        if ((inet6Address.startsWith(\":\") && !inet6Address.startsWith(\"::\"))\n                || (inet6Address.endsWith(\":\") && !inet6Address.endsWith(\"::\"))) {\n            return false;\n        }\n        String[] octets = inet6Address.split(\":\");\n        if (containsCompressedZeroes) {\n            final List<String> octetList = new ArrayList<>(Arrays.asList(octets));\n            if (inet6Address.endsWith(\"::\")) {\n                // String.split() drops ending empty segments\n                octetList.add(\"\");\n            } else if (inet6Address.startsWith(\"::\") && !octetList.isEmpty()) {\n                octetList.remove(0);\n            }\n            octets = octetList.toArray(EMPTY_STRING_ARRAY);\n        }\n        if (octets.length > IPV6_MAX_HEX_GROUPS) {\n            return false;\n        }\n        int validOctets = 0;\n        int emptyOctets = 0; // consecutive empty chunks\n        for (int index = 0; index < octets.length; index++) {\n            final String octet = octets[index];\n            if (octet.isEmpty()) {\n                emptyOctets++;\n                if (emptyOctets > 1) {\n                    return false;\n                }\n            } else {\n                emptyOctets = 0;\n                // Is last chunk an IPv4 address?\n                if (index == octets.length - 1 && octet.contains(\".\")) {\n                    if (!isIPv4Address(octet)) {\n                        return false;\n                    }\n                    validOctets += 2;\n                    continue;\n                }\n                if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) {\n                    return false;\n                }\n                final int octetInt;\n                try {\n                    octetInt = Integer.parseInt(octet, BASE_16);\n                } catch (final NumberFormatException e) {\n                    return false;\n                }\n                if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) {\n                    return false;\n                }\n            }\n            validOctets++;\n        }\n        return validOctets <= IPV6_MAX_HEX_GROUPS && (validOctets >= IPV6_MAX_HEX_GROUPS || containsCompressedZeroes);\n    }\n\n    private static final Pattern REG_NAME_PART_PATTERN = Pattern.compile(\"^[a-zA-Z0-9][a-zA-Z0-9-]*$\");\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986 - not accepting IP addresses.\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isRFC3986HostName(final String name) {\n        final String[] parts = name.split(\"\\\\.\", -1);\n        for (int i = 0; i < parts.length; i++) {\n            if (parts[i].isEmpty()) {\n                // trailing dot is legal, otherwise we've hit a .. sequence\n                return i == parts.length - 1;\n            }\n            if (!REG_NAME_PART_PATTERN.matcher(parts[i]).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "diffSourceCodeSet": ["private static boolean isEmpty(final String string) {\n        return string == null || string.isEmpty();\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.FilenameUtils#getExtension\n methodBody: public static String getExtension(final String fileName) throws IllegalArgumentException {\nif(fileName == null){return null;\n}final int index=indexOfExtension(fileName);\nif(index == NOT_FOUND){return EMPTY_STRING;\n}return fileName.substring(index + 1);\n}", "methodSignature: org.apache.commons.io.FilenameUtils#requireNonNullChars\n methodBody: private static void requireNonNullChars(final String path) {\nif(path.indexOf(0) >= 0){throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" + \"known legitimate use cases for such data, but several injection attacks may use it\");\n}}", "methodSignature: org.apache.commons.io.FilenameUtils#indexOfExtension\n methodBody: public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\nif(fileName == null){return NOT_FOUND;\n}if(isSystemWindows()){final int offset=fileName.indexOf(':',getAdsCriticalOffset(fileName));\nif(offset != -1){throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n}}final int extensionPos=fileName.lastIndexOf(EXTENSION_SEPARATOR);\nfinal int lastSeparator=indexOfLastSeparator(fileName);\nreturn lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n}", "methodSignature: org.apache.commons.io.FilenameUtils#equals\n methodBody: public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\nif(fileName1 == null || fileName2 == null){return fileName1 == null && fileName2 == null;\n}if(normalized){fileName1=normalize(fileName1);\nif(fileName1 == null){return false;\n}fileName2=normalize(fileName2);\nif(fileName2 == null){return false;\n}}if(caseSensitivity == null){caseSensitivity=IOCase.SENSITIVE;\n}return caseSensitivity.checkEquals(fileName1,fileName2);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (isEmpty(extension)) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\nprivate static boolean isEmpty(final String string) {\n        return string == null || string.isEmpty();\n    }", "diffSourceCode": "-  555:     /**\n-  556:      * Converts all separators to the Unix separator of forward slash.\n-  557:      *\n- 1220:     /**\n- 1221:      * Checks whether the extension of the fileName is that specified.\n- 1222:      * <p>\n- 1223:      * This method obtains the extension as the textual part of the fileName\n- 1224:      * after the last dot. There must be no directory separator after the dot.\n- 1225:      * The extension check is case-sensitive on all platforms.\n- 1226:      *\n- 1227:      * @param fileName  the fileName to query, null returns false\n- 1228:      * @param extension  the extension to check for, null or empty checks for no extension\n- 1229:      * @return true if the fileName has the specified extension\n- 1230:      * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n- 1231:      */\n- 1232:     public static boolean isExtension(final String fileName, final String extension) {\n- 1233:         if (fileName == null) {\n- 1234:             return false;\n- 1235:         }\n- 1236:         requireNonNullChars(fileName);\n- 1237: \n- 1238:         if (extension == null || extension.isEmpty()) {\n- 1239:             return indexOfExtension(fileName) == NOT_FOUND;\n- 1240:         }\n- 1241:         final String fileExt = getExtension(fileName);\n- 1242:         return fileExt.equals(extension);\n- 1243:     }\n- 1244: \n- 1245:     /**\n- 1246:      * Checks whether the extension of the fileName is one of those specified.\n- 1247:      * <p>\n+  555:     private static boolean isEmpty(final String string) {\n+  556:         return string == null || string.isEmpty();\n+  557:     }\n+ 1220:         }\n+ 1221:         return caseSensitivity.checkEquals(fileName1, fileName2);\n+ 1222:     }\n+ 1223: \n+ 1224:     /**\n+ 1225:      * Checks whether the extension of the fileName is that specified.\n+ 1226:      * <p>\n+ 1227:      * This method obtains the extension as the textual part of the fileName\n+ 1228:      * after the last dot. There must be no directory separator after the dot.\n+ 1229:      * The extension check is case-sensitive on all platforms.\n+ 1230:      *\n+ 1231:      * @param fileName  the fileName to query, null returns false\n+ 1232:      * @param extension  the extension to check for, null or empty checks for no extension\n+ 1233:      * @return true if the fileName has the specified extension\n+ 1234:      * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n+ 1235:      */\n+ 1236:     public static boolean isExtension(final String fileName, final String extension) {\n+ 1237:         if (fileName == null) {\n+ 1238:             return false;\n+ 1239:         }\n+ 1240:         requireNonNullChars(fileName);\n+ 1241: \n+ 1242:         if (isEmpty(extension)) {\n+ 1243:             return indexOfExtension(fileName) == NOT_FOUND;\n+ 1244:         }\n+ 1245:         final String fileExt = getExtension(fileName);\n+ 1246:         return fileExt.equals(extension);\n+ 1247:     }\n", "uniqueId": "d42b9286eb7a534f1b2b6243858ff7ef6fcac14c_1220_1243_555_557_1224_1247", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 41}, "BRANCH": {"missed": 0, "covered": 12}, "LINE": {"missed": 0, "covered": 11}, "COMPLEXITY": {"missed": 0, "covered": 7}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `isExtension` method, we can extract the logic that checks for null or empty extensions into a separate method. This will make the `isExtension` method cleaner and more focused on its primary responsibility.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\npublic static boolean isExtension(final String fileName, final String extension) {\n    if (fileName == null) {\n        return false;\n    }\n    requireNonNullChars(fileName);\n\n    if (isNullOrEmpty(extension)) {\n        return indexOfExtension(fileName) == NOT_FOUND;\n    }\n    final String fileExt = getExtension(fileName);\n    return fileExt.equals(extension);\n}\n\nprivate static boolean isNullOrEmpty(String str) {\n    return str == null || str.isEmpty();\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic that checks if the `extension` is null or empty has been moved to a new private method called `isNullOrEmpty`. This method encapsulates the check and improves the readability of the `isExtension` method.\n2. **Simplified Logic**: The `isExtension` method now reads more clearly, focusing on its main purpose without being cluttered by the null/empty check logic. \n\nThis refactoring enhances the modularity of the code, making it easier to test and maintain.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extension == null || extension.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.File;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * General file name and file path manipulation utilities.\n * <p>\n * When dealing with file names you can hit problems when moving from a Windows\n * based development machine to a Unix based production machine.\n * This class aims to help avoid those problems.\n * <p>\n * <b>NOTE</b>: You may be able to avoid using this class entirely simply by\n * using JDK {@link java.io.File File} objects and the two argument constructor\n * {@link java.io.File#File(java.io.File, java.lang.String) File(File,String)}.\n * <p>\n * Most methods on this class are designed to work the same on both Unix and Windows.\n * Those that don't include 'System', 'Unix' or 'Windows' in their name.\n * <p>\n * Most methods recognize both separators (forward and back), and both\n * sets of prefixes. See the Javadoc of each method for details.\n * <p>\n * This class defines six components within a file name\n * (example C:\\dev\\project\\file.txt):\n * <ul>\n * <li>the prefix - C:\\</li>\n * <li>the path - dev\\project\\</li>\n * <li>the full path - C:\\dev\\project\\</li>\n * <li>the name - file.txt</li>\n * <li>the base name - file</li>\n * <li>the extension - txt</li>\n * </ul>\n * Note that this class works best if directory file names end with a separator.\n * If you omit the last separator, it is impossible to determine if the file name\n * corresponds to a file or a directory. As a result, we have chosen to say\n * it corresponds to a file.\n * <p>\n * This class only supports Unix and Windows style names.\n * Prefixes are matched as follows:\n * <pre>\n * Windows:\n * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n *\n * Unix:\n * a/b/c.txt           --&gt; \"\"          --&gt; relative\n * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n * </pre>\n * Both prefix styles are matched always, irrespective of the machine that you are\n * currently running on.\n * <p>\n * Origin of code: Excalibur, Alexandria, Tomcat, Commons-Utils.\n *\n * @since 1.1\n */\npublic class FilenameUtils {\n\n    private static final String[] EMPTY_STRING_ARRAY = {};\n\n    private static final String EMPTY_STRING = \"\";\n\n    private static final int NOT_FOUND = -1;\n\n    /**\n     * The extension separator character.\n     * @since 1.4\n     */\n    public static final char EXTENSION_SEPARATOR = '.';\n\n    /**\n     * The extension separator String.\n     * @since 1.4\n     */\n    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n\n    /**\n     * The Unix separator character.\n     */\n    private static final char UNIX_SEPARATOR = '/';\n\n    /**\n     * The Windows separator character.\n     */\n    private static final char WINDOWS_SEPARATOR = '\\\\';\n\n    /**\n     * The system separator character.\n     */\n    private static final char SYSTEM_SEPARATOR = File.separatorChar;\n\n    /**\n     * The separator character that is the opposite of the system separator.\n     */\n    private static final char OTHER_SEPARATOR;\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_SEPARATOR;\n        }\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public FilenameUtils() {\n    }\n\n    /**\n     * Determines if Windows file system is in use.\n     *\n     * @return true if the system is Windows\n     */\n    static boolean isSystemWindows() {\n        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;\n    }\n\n    /**\n     * Checks if the character is a separator.\n     *\n     * @param ch  the character to check\n     * @return true if it is a separator character\n     */\n    private static boolean isSeparator(final char ch) {\n        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, true);\n    }\n    /**\n     * Normalizes a path, removing double and single dot path steps.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be retained.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo/\n     * /foo/./              --&gt;   /foo/\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar/\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo/\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar/\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalize(final String fileName, final boolean unixSeparator) {\n        final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, true);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format of the system.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     * (Note the file separator returned will be correct for Windows/Unix)\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     */\n    public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, false);\n    }\n\n    /**\n     * Normalizes a path, removing double and single dot path steps,\n     * and removing any final directory separator.\n     * <p>\n     * This method normalizes a path to a standard format.\n     * The input may contain separators in either Unix or Windows format.\n     * The output will contain separators in the format specified.\n     * <p>\n     * A trailing slash will be removed.\n     * A double slash will be merged to a single slash (but UNC names are handled).\n     * A single dot path segment will be removed.\n     * A double dot will cause that path segment and the one before to be removed.\n     * If the double dot has no parent path segment to work with, {@code null}\n     * is returned.\n     * <p>\n     * The output will be the same on both Unix and Windows including\n     * the separator character.\n     * <pre>\n     * /foo//               --&gt;   /foo\n     * /foo/./              --&gt;   /foo\n     * /foo/../bar          --&gt;   /bar\n     * /foo/../bar/         --&gt;   /bar\n     * /foo/../bar/../baz   --&gt;   /baz\n     * //foo//./bar         --&gt;   /foo/bar\n     * /../                 --&gt;   null\n     * ../foo               --&gt;   null\n     * foo/bar/..           --&gt;   foo\n     * foo/../../bar        --&gt;   null\n     * foo/../bar           --&gt;   bar\n     * //server/foo/../bar  --&gt;   //server/bar\n     * //server/../bar      --&gt;   null\n     * C:\\foo\\..\\bar        --&gt;   C:\\bar\n     * C:\\..\\bar            --&gt;   null\n     * ~/foo/../bar/        --&gt;   ~/bar\n     * ~/../bar             --&gt;   null\n     * </pre>\n     *\n     * @param fileName  the fileName to normalize, null returns null\n     * @param unixSeparator {@code true} if a unix separator should\n     * be used or {@code false} if a windows separator should be used.\n     * @return the normalized fileName, or null if invalid. Null bytes inside string will be removed\n     * @since 2.0\n     */\n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, false);\n    }\n\n    /**\n     * Internal method to perform the normalization.\n     *\n     * @param fileName  the fileName\n     * @param separator The separator character to use\n     * @param keepSeparator  true to keep the final separator\n     * @return the normalized fileName. Null bytes inside string will be removed.\n     */\n    private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n\n        requireNonNullChars(fileName);\n\n        int size = fileName.length();\n        if (size == 0) {\n            return fileName;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n\n        final char[] array = new char[size + 2];  // +1 for possible extra slash, +2 for arraycopy\n        fileName.getChars(0, fileName.length(), array, 0);\n\n        // fix separators throughout\n        final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n\n        // add extra separator on the end to simplify code below\n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n\n        // adjoining slashes\n        // If we get here, prefix can only be 0 or greater, size 1 or greater\n        // If prefix is 0, set loop start to 1 to prevent index errors\n        for (int i = (prefix != 0) ? prefix : 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        // dot slash\n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' &&\n                    (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -=2;\n                i--;\n            }\n        }\n\n        // double dot slash\n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&\n                    (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4 ; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        // remove b/../ from a/b/../c\n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                // remove a/../ from a/../c\n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n\n        if (size <= 0) {  // should never be less than 0\n            return EMPTY_STRING;\n        }\n        if (size <= prefix) {  // should never be less than prefix\n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  // keep trailing separator\n        }\n        return new String(array, 0, size - 1);  // lose trailing separator\n    }\n\n    /**\n     * Concatenates a fileName to a base path using normal command line style rules.\n     * <p>\n     * The effect is equivalent to resultant directory after changing\n     * directory to the first argument, followed by changing directory to\n     * the second argument.\n     * </p>\n     * <p>\n     * The first argument is the base path, the second is the path to concatenate.\n     * The returned path is always normalized via {@link #normalize(String)},\n     * thus {@code ..} is handled.\n     * </p>\n     * <p>\n     * If {@code pathToAdd} is absolute (has an absolute prefix), then\n     * it will be normalized and returned.\n     * Otherwise, the paths will be joined, normalized and returned.\n     * </p>\n     * <p>\n     * The output will be the same on both Unix and Windows except\n     * for the separator character.\n     * </p>\n     * <pre>\n     * /foo/      + bar        --&gt;  /foo/bar\n     * /foo       + bar        --&gt;  /foo/bar\n     * /foo       + /bar       --&gt;  /bar\n     * /foo       + C:/bar     --&gt;  C:/bar\n     * /foo       + C:bar      --&gt;  C:bar [1]\n     * /foo/a/    + ../bar     --&gt;  /foo/bar\n     * /foo/      + ../../bar  --&gt;  null\n     * /foo/      + /bar       --&gt;  /bar\n     * /foo/..    + /bar       --&gt;  /bar\n     * /foo       + bar/c.txt  --&gt;  /foo/bar/c.txt\n     * /foo/c.txt + bar        --&gt;  /foo/c.txt/bar [2]\n     * </pre>\n     * <p>\n     * [1] Note that the Windows relative drive prefix is unreliable when\n     * used with this method.\n     * </p>\n     * <p>\n     * [2] Note that the first parameter must be a path. If it ends with a name, then\n     * the name will be built into the concatenated path. If this might be a problem,\n     * use {@link #getFullPath(String)} on the base path argument.\n     * </p>\n     *\n     * @param basePath  the base path to attach to, always treated as a path\n     * @param fullFileNameToAdd  the fileName (or path) to attach to the base\n     * @return the concatenated path, or null if invalid.  Null bytes inside string will be removed\n     */\n    public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix = getPrefixLength(fullFileNameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        final int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + '/' + fullFileNameToAdd);\n    }\n\n    /**\n     * Determines whether the {@code parent} directory contains the {@code child} element (a file or directory).\n     * <p>\n     * The files names are expected to be normalized.\n     * </p>\n     *\n     * Edge cases:\n     * <ul>\n     * <li>A {@code directory} must not be null: if null, throw IllegalArgumentException</li>\n     * <li>A directory does not contain itself: return false</li>\n     * <li>A null child file is not contained in any parent: return false</li>\n     * </ul>\n     *\n     * @param canonicalParent\n     *            the file to consider as the parent.\n     * @param canonicalChild\n     *            the file to consider as the child.\n     * @return true is the candidate leaf is under by the specified composite. False otherwise.\n     * @since 2.2\n     * @see FileUtils#directoryContains(File, File)\n     */\n    public static boolean directoryContains(final String canonicalParent, final String canonicalChild) {\n        Objects.requireNonNull(canonicalParent, \"canonicalParent\");\n\n        if (canonicalChild == null) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, canonicalParent);\n    }\n\n    /**\n     * Converts all separators to the Unix separator of forward slash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the Windows separator of backslash.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToWindows(final String path) {\n        if (path == null || path.indexOf(UNIX_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);\n    }\n\n    /**\n     * Converts all separators to the system separator.\n     *\n     * @param path  the path to be changed, null ignored\n     * @return the updated path\n     */\n    public static String separatorsToSystem(final String path) {\n        if (path == null) {\n            return null;\n        }\n        return isSystemWindows() ? separatorsToWindows(path) : separatorsToUnix(path);\n    }\n\n    /**\n     * Returns the length of the fileName prefix, such as {@code C:/} or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * <p>\n     * The prefix length includes the first slash in the full fileName\n     * if applicable. Thus, it is possible that the length returned is greater\n     * than the length of the input string.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; 0           --&gt; relative\n     * \\a\\b\\c.txt          --&gt; 1           --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; 2           --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; 3           --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; 9           --&gt; UNC\n     * \\\\\\a\\b\\c.txt        --&gt; -1          --&gt; error\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; 0           --&gt; relative\n     * /a/b/c.txt          --&gt; 1           --&gt; absolute\n     * ~/a/b/c.txt         --&gt; 2           --&gt; current user\n     * ~                   --&gt; 2           --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; 6           --&gt; named user\n     * ~user               --&gt; 6           --&gt; named user (slash added)\n     * //server/a/b/c.txt  --&gt; 9\n     * ///a/b/c.txt        --&gt; -1          --&gt; error\n     * C:                  --&gt; 0           --&gt; valid filename as only null byte and / are reserved characters\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * Note that a leading // (or \\\\) is used to indicate a UNC name on Windows.\n     * These must be followed by a server name, so double-slashes are not collapsed\n     * to a single slash at the start of the fileName.\n     *\n     * @param fileName  the fileName to find the prefix in, null returns -1\n     * @return the length of the prefix, -1 if invalid or null\n     */\n    public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  // return a length greater than the input\n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  // return a length greater than the input\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 && !FileSystem.getCurrent().supportsDriveLetter()) {\n                    return 0;\n                }\n                if (len == 2 || !isSeparator(fileName.charAt(2))) {\n                    return 2;\n                }\n                return 3;\n            }\n            if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        }\n        if (!isSeparator(ch0) || !isSeparator(ch1)) {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n        int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n        if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n            return NOT_FOUND;\n        }\n        posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n        posWin = posWin == NOT_FOUND ? posUnix : posWin;\n        final int pos = Math.min(posUnix, posWin) + 1;\n        final String hostnamePart = fileName.substring(2, pos - 1);\n        return isValidHostName(hostnamePart) ? pos : NOT_FOUND;\n    }\n\n    /**\n     * Returns the index of the last directory separator character.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The position of the last forward or backslash is returned.\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to find the last path separator in, null returns -1\n     * @return the index of the last separator character, or -1 if there\n     * is no such character\n     */\n    public static int indexOfLastSeparator(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos = fileName.lastIndexOf(UNIX_SEPARATOR);\n        final int lastWindowsPos = fileName.lastIndexOf(WINDOWS_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    /**\n     * Returns the index of the last extension separator character, which is a dot.\n     * <p>\n     * This method also checks that there is no directory separator after the last dot. To do this it uses\n     * {@link #indexOfLastSeparator(String)} which will handle a file in either Unix or Windows format.\n     * </p>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName\n     *            the fileName to find the last extension separator in, null returns -1\n     * @return the index of the last extension separator character, or -1 if there is no such character\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            // Special handling for NTFS ADS: Don't accept colon in the fileName.\n            final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));\n            if (offset != -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n            }\n        }\n        final int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator = indexOfLastSeparator(fileName);\n        return lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n    }\n\n    /**\n     * Gets the prefix from a full fileName, such as {@code C:/}\n     * or {@code ~/}.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The prefix includes the first slash in the full fileName where applicable.\n     * <pre>\n     * Windows:\n     * a\\b\\c.txt           --&gt; \"\"          --&gt; relative\n     * \\a\\b\\c.txt          --&gt; \"\\\"         --&gt; current drive absolute\n     * C:a\\b\\c.txt         --&gt; \"C:\"        --&gt; drive relative\n     * C:\\a\\b\\c.txt        --&gt; \"C:\\\"       --&gt; absolute\n     * \\\\server\\a\\b\\c.txt  --&gt; \"\\\\server\\\" --&gt; UNC\n     *\n     * Unix:\n     * a/b/c.txt           --&gt; \"\"          --&gt; relative\n     * /a/b/c.txt          --&gt; \"/\"         --&gt; absolute\n     * ~/a/b/c.txt         --&gt; \"~/\"        --&gt; current user\n     * ~                   --&gt; \"~/\"        --&gt; current user (slash added)\n     * ~user/a/b/c.txt     --&gt; \"~user/\"    --&gt; named user\n     * ~user               --&gt; \"~user/\"    --&gt; named user (slash added)\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * ie. both Unix and Windows prefixes are matched regardless.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the prefix of the file, null if invalid. Null bytes inside string will be removed\n     */\n    public static String getPrefix(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        final int len = getPrefixLength(fileName);\n        if (len < 0) {\n            return null;\n        }\n        if (len > fileName.length()) {\n            requireNonNullChars(fileName + UNIX_SEPARATOR);\n            return fileName + UNIX_SEPARATOR;\n        }\n        final String path = fileName.substring(0, len);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\\\n     * ~/a/b/c.txt  --&gt; a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPath(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }\n\n    /**\n     * Gets the path from a full fileName, which excludes the prefix, and\n     * also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; a\\b\n     * ~/a/b/c.txt  --&gt; a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     * <p>\n     * This method drops the prefix from the result.\n     * See {@link #getFullPathNoEndSeparator(String)} for the method that retains the prefix.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid.\n     * Null bytes inside string will be removed\n     */\n    public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param separatorAdd  0 to omit the end separator, 1 to return it\n     * @return the path. Null bytes inside string will be removed\n     */\n    private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        final int endIndex = index+separatorAdd;\n        if (prefix >= fileName.length() || index < 0 || prefix >= endIndex) {\n            return EMPTY_STRING;\n        }\n        final String path = fileName.substring(prefix, endIndex);\n        requireNonNullChars(path);\n        return path;\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before and\n     * including the last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\\\n     * ~/a/b/c.txt  --&gt; ~/a/b/\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b/\n     * a/b/c/       --&gt; a/b/c/\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~/\n     * ~/           --&gt; ~/\n     * ~user        --&gt; ~user/\n     * ~user/       --&gt; ~user/\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }\n\n    /**\n     * Gets the full path from a full fileName, which is the prefix + path,\n     * and also excluding the final directory separator.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The method is entirely text based, and returns the text before the\n     * last forward or backslash.\n     * <pre>\n     * C:\\a\\b\\c.txt --&gt; C:\\a\\b\n     * ~/a/b/c.txt  --&gt; ~/a/b\n     * a.txt        --&gt; \"\"\n     * a/b/c        --&gt; a/b\n     * a/b/c/       --&gt; a/b/c\n     * C:           --&gt; C:\n     * C:\\          --&gt; C:\\\n     * ~            --&gt; ~\n     * ~/           --&gt; ~\n     * ~user        --&gt; ~user\n     * ~user/       --&gt; ~user\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the path of the file, an empty string if none exists, null if invalid\n     */\n    public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }\n\n    /**\n     * Does the work of getting the path.\n     *\n     * @param fileName  the fileName\n     * @param includeSeparator  true to include the end separator\n     * @return the path\n     */\n    private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  // add end slash if necessary\n            }\n            return fileName;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        if (index < 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }\n\n    /**\n     * Gets the name minus the path from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c.txt\n     * a.txt     --&gt; a.txt\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists.\n     * Null bytes inside string will be removed\n     */\n    public static String getName(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n        final int index = indexOfLastSeparator(fileName);\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Checks the input for null bytes, a sign of unsanitized data being passed to to file level functions.\n     *\n     * This may be used for poison byte attacks.\n     *\n     * @param path the path to check\n     */\n    private static void requireNonNullChars(final String path) {\n        if (path.indexOf(0) >= 0) {\n            throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \"\n                + \"known legitimate use cases for such data, but several injection attacks may use it\");\n        }\n    }\n\n    /**\n     * Gets the base name, minus the full path and extension, from a full fileName.\n     * <p>\n     * This method will handle a file in either Unix or Windows format.\n     * The text after the last forward or backslash and before the last dot is returned.\n     * <pre>\n     * a/b/c.txt --&gt; c\n     * a.txt     --&gt; a\n     * a/b/c     --&gt; c\n     * a/b/c/    --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the name of the file without the path, or an empty string if none exists. Null bytes inside string\n     * will be removed\n     */\n    public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }\n\n    /**\n     * Gets the extension of a fileName.\n     * <p>\n     * This method returns the textual part of the fileName after the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt      --&gt; \"txt\"\n     * a/b/c.jpg    --&gt; \"jpg\"\n     * a/b.txt/c    --&gt; \"\"\n     * a/b/c        --&gt; \"\"\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on, with the\n     * exception of a possible {@link IllegalArgumentException} on Windows (see below).\n     * </p>\n     * <p>\n     * <b>Note:</b> This method used to have a hidden problem for names like \"foo.exe:bar.txt\".\n     * In this case, the name wouldn't be the name of a file, but the identifier of an\n     * alternate data stream (bar.txt) on the file foo.exe. The method used to return\n     * \".txt\" here, which would be misleading. Commons IO 2.7, and later versions, are throwing\n     * an {@link IllegalArgumentException} for names like this.\n     *\n     * @param fileName the fileName to retrieve the extension of.\n     * @return the extension of the file or an empty string if none exists or {@code null}\n     * if the fileName is {@code null}.\n     * @throws IllegalArgumentException <b>Windows only:</b> The fileName parameter is, in fact,\n     * the identifier of an Alternate Data Stream, for example \"foo.exe:bar.txt\".\n     */\n    public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return null;\n        }\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }\n\n    /**\n     * Special handling for NTFS ADS: Don't accept colon in the fileName.\n     *\n     * @param fileName a file name\n     * @return ADS offsets.\n     */\n    private static int getAdsCriticalOffset(final String fileName) {\n        // Step 1: Remove leading path segments.\n        final int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);\n        final int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 == -1) {\n            if (offset2 == -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 == -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }\n\n    /**\n     * Removes the extension from a fileName.\n     * <p>\n     * This method returns the textual part of the fileName before the last dot.\n     * There must be no directory separator after the dot.\n     * <pre>\n     * foo.txt    --&gt; foo\n     * a\\b\\c.jpg  --&gt; a\\b\\c\n     * a\\b\\c      --&gt; a\\b\\c\n     * a.b\\c      --&gt; a.b\\c\n     * </pre>\n     * <p>\n     * The output will be the same irrespective of the machine that the code is running on.\n     *\n     * @param fileName  the fileName to query, null returns null\n     * @return the fileName minus the extension\n     */\n    public static String removeExtension(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        requireNonNullChars(fileName);\n\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }\n\n    /**\n     * Checks whether two fileNames are equal exactly.\n     * <p>\n     * No processing is performed on the fileNames other than comparison,\n     * thus this is merely a null-safe case-sensitive equals.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal using the case rules of the system.\n     * <p>\n     * No processing is performed on the fileNames other than comparison.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed in a case-sensitive manner.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks whether two fileNames are equal after both have been normalized\n     * and using the case rules of the system.\n     * <p>\n     * Both fileNames are first passed to {@link #normalize(String)}.\n     * The check is then performed case-sensitive on Unix and\n     * case-insensitive on Windows.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @return true if the fileNames are equal, null equals null\n     * @see IOCase#SYSTEM\n     */\n    public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks whether two fileNames are equal, optionally normalizing and providing\n     * control over the case-sensitivity.\n     *\n     * @param fileName1  the first fileName to query, may be null\n     * @param fileName2  the second fileName to query, may be null\n     * @param normalized  whether to normalize the fileNames\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileNames are equal, null equals null\n     * @since 1.3\n     */\n    public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\n\n        if (fileName1 == null || fileName2 == null) {\n            return fileName1 == null && fileName2 == null;\n        }\n        if (normalized) {\n            fileName1 = normalize(fileName1);\n            if (fileName1 == null) {\n                return false;\n            }\n            fileName2 = normalize(fileName2);\n            if (fileName2 == null) {\n                return false;\n            }\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        return caseSensitivity.checkEquals(fileName1, fileName2);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is that specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extension  the extension to check for, null or empty checks for no extension\n     * @return true if the fileName has the specified extension\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extension == null || extension.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final String... extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the extension of the fileName is one of those specified.\n     * <p>\n     * This method obtains the extension as the textual part of the fileName\n     * after the last dot. There must be no directory separator after the dot.\n     * The extension check is case-sensitive on all platforms.\n     *\n     * @param fileName  the fileName to query, null returns false\n     * @param extensions  the extensions to check for, null checks for no extension\n     * @return true if the fileName is one of the extensions\n     * @throws java.lang.IllegalArgumentException if the supplied fileName contains null bytes\n     */\n    public static boolean isExtension(final String fileName, final Collection<String> extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        requireNonNullChars(fileName);\n\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher,\n     * always testing case-sensitive.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive always.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SENSITIVE\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * using the case rules of the system.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * This is the same as often found on Dos/Unix command lines.\n     * The check is case-sensitive on Unix and case-insensitive on Windows.\n     * <pre>\n     * wildcardMatch(\"c.txt\", \"*.txt\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.jpg\")      --&gt; false\n     * wildcardMatch(\"a/b/c.txt\", \"a/b/*\")  --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.???\")      --&gt; true\n     * wildcardMatch(\"c.txt\", \"*.????\")     --&gt; false\n     * </pre>\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @return true if the fileName matches the wildcard string\n     * @see IOCase#SYSTEM\n     */\n    public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }\n\n    /**\n     * Checks a fileName to see if it matches the specified wildcard matcher\n     * allowing control over case-sensitivity.\n     * <p>\n     * The wildcard matcher uses the characters '?' and '*' to represent a\n     * single or multiple (zero or more) wildcard characters.\n     * N.B. the sequence \"*?\" does not work properly at present in match strings.\n     *\n     * @param fileName  the fileName to match on\n     * @param wildcardMatcher  the wildcard string to match against\n     * @param caseSensitivity  what case sensitivity rule to use, null means case-sensitive\n     * @return true if the fileName matches the wildcard string\n     * @since 1.3\n     */\n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n        if (fileName == null && wildcardMatcher == null) {\n            return true;\n        }\n        if (fileName == null || wildcardMatcher == null) {\n            return false;\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        final String[] wcs = splitOnTokens(wildcardMatcher);\n        boolean anyChars = false;\n        int textIdx = 0;\n        int wcsIdx = 0;\n        final Deque<int[]> backtrack = new ArrayDeque<>(wcs.length);\n\n        // loop around a backtrack stack, to handle complex * matching\n        do {\n            if (!backtrack.isEmpty()) {\n                final int[] array = backtrack.pop();\n                wcsIdx = array[0];\n                textIdx = array[1];\n                anyChars = true;\n            }\n\n            // loop whilst tokens and text left to process\n            while (wcsIdx < wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    // ? so move to next text char\n                    textIdx++;\n                    if (textIdx > fileName.length()) {\n                        break;\n                    }\n                    anyChars = false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    // set any chars status\n                    anyChars = true;\n                    if (wcsIdx == wcs.length - 1) {\n                        textIdx = fileName.length();\n                    }\n\n                } else {\n                    // matching text token\n                    if (anyChars) {\n                        // any chars then try to locate text token\n                        textIdx = caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx == NOT_FOUND) {\n                            // token not found\n                            break;\n                        }\n                        final int repeat = caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat >= 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                        // matching from current position\n                        // couldn't match token\n                        break;\n                    }\n\n                    // matched text token, move text index to end of matched token\n                    textIdx += wcs[wcsIdx].length();\n                    anyChars = false;\n                }\n\n                wcsIdx++;\n            }\n\n            // full match\n            if (wcsIdx == wcs.length && textIdx == fileName.length()) {\n                return true;\n            }\n\n        } while (!backtrack.isEmpty());\n\n        return false;\n    }\n\n    /**\n     * Splits a string into a number of tokens.\n     * The text is split by '?' and '*'.\n     * Where multiple '*' occur consecutively they are collapsed into a single '*'.\n     *\n     * @param text  the text to split\n     * @return the array of tokens, never null\n     */\n    static String[] splitOnTokens(final String text) {\n        // used by wildcardMatch\n        // package level so a unit test may run on this\n\n        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array = text.toCharArray();\n        final ArrayList<String> list = new ArrayList<>();\n        final StringBuilder buffer = new StringBuilder();\n        char prevChar = 0;\n        for (final char ch : array) {\n            if (ch == '?' || ch == '*') {\n                if (buffer.length() != 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch == '?') {\n                    list.add(\"?\");\n                } else if (prevChar != '*') {// ch == '*' here; check if previous char was '*'\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar = ch;\n        }\n        if (buffer.length() != 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray(EMPTY_STRING_ARRAY);\n    }\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986.\n     *\n     * <p>Accepted are IP addresses (v4 and v6) as well as what the\n     * RFC calls a \"reg-name\". Percent encoded names don't seem to be\n     * valid names in UNC paths.</p>\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isValidHostName(final String name) {\n        return isIPv6Address(name) || isRFC3986HostName(name);\n    }\n\n    private static final Pattern IPV4_PATTERN =\n        Pattern.compile(\"^(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})$\");\n    private static final int IPV4_MAX_OCTET_VALUE = 255;\n\n    /**\n     * Checks whether a given string represents a valid IPv4 address.\n     *\n     * @param name the name to validate\n     * @return true if the given name is a valid IPv4 address\n     */\n    // mostly copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet4Address\n    private static boolean isIPv4Address(final String name) {\n        final Matcher m = IPV4_PATTERN.matcher(name);\n        if (!m.matches() || m.groupCount() != 4) {\n            return false;\n        }\n\n        // verify that address subgroups are legal\n        for (int i = 1; i <= 4; i++) {\n            final String ipSegment = m.group(i);\n            final int iIpSegment = Integer.parseInt(ipSegment);\n            if (iIpSegment > IPV4_MAX_OCTET_VALUE) {\n                return false;\n            }\n\n            if (ipSegment.length() > 1 && ipSegment.startsWith(\"0\")) {\n                return false;\n            }\n\n        }\n\n        return true;\n    }\n\n    private static final int IPV6_MAX_HEX_GROUPS = 8;\n    private static final int IPV6_MAX_HEX_DIGITS_PER_GROUP = 4;\n    private static final int MAX_UNSIGNED_SHORT = 0xffff;\n    private static final int BASE_16 = 16;\n\n    // copied from org.apache.commons.validator.routines.InetAddressValidator#isValidInet6Address\n    /**\n     * Checks whether a given string represents a valid IPv6 address.\n     *\n     * @param inet6Address the name to validate\n     * @return true if the given name is a valid IPv6 address\n     */\n    private static boolean isIPv6Address(final String inet6Address) {\n        final boolean containsCompressedZeroes = inet6Address.contains(\"::\");\n        if (containsCompressedZeroes && (inet6Address.indexOf(\"::\") != inet6Address.lastIndexOf(\"::\"))) {\n            return false;\n        }\n        if ((inet6Address.startsWith(\":\") && !inet6Address.startsWith(\"::\"))\n                || (inet6Address.endsWith(\":\") && !inet6Address.endsWith(\"::\"))) {\n            return false;\n        }\n        String[] octets = inet6Address.split(\":\");\n        if (containsCompressedZeroes) {\n            final List<String> octetList = new ArrayList<>(Arrays.asList(octets));\n            if (inet6Address.endsWith(\"::\")) {\n                // String.split() drops ending empty segments\n                octetList.add(\"\");\n            } else if (inet6Address.startsWith(\"::\") && !octetList.isEmpty()) {\n                octetList.remove(0);\n            }\n            octets = octetList.toArray(EMPTY_STRING_ARRAY);\n        }\n        if (octets.length > IPV6_MAX_HEX_GROUPS) {\n            return false;\n        }\n        int validOctets = 0;\n        int emptyOctets = 0; // consecutive empty chunks\n        for (int index = 0; index < octets.length; index++) {\n            final String octet = octets[index];\n            if (octet.isEmpty()) {\n                emptyOctets++;\n                if (emptyOctets > 1) {\n                    return false;\n                }\n            } else {\n                emptyOctets = 0;\n                // Is last chunk an IPv4 address?\n                if (index == octets.length - 1 && octet.contains(\".\")) {\n                    if (!isIPv4Address(octet)) {\n                        return false;\n                    }\n                    validOctets += 2;\n                    continue;\n                }\n                if (octet.length() > IPV6_MAX_HEX_DIGITS_PER_GROUP) {\n                    return false;\n                }\n                final int octetInt;\n                try {\n                    octetInt = Integer.parseInt(octet, BASE_16);\n                } catch (final NumberFormatException e) {\n                    return false;\n                }\n                if (octetInt < 0 || octetInt > MAX_UNSIGNED_SHORT) {\n                    return false;\n                }\n            }\n            validOctets++;\n        }\n        return validOctets <= IPV6_MAX_HEX_GROUPS && (validOctets >= IPV6_MAX_HEX_GROUPS || containsCompressedZeroes);\n    }\n\n    private static final Pattern REG_NAME_PART_PATTERN = Pattern.compile(\"^[a-zA-Z0-9][a-zA-Z0-9-]*$\");\n\n    /**\n     * Checks whether a given string is a valid host name according to\n     * RFC 3986 - not accepting IP addresses.\n     *\n     * @see \"https://tools.ietf.org/html/rfc3986#section-3.2.2\"\n     * @param name the hostname to validate\n     * @return true if the given name is a valid host name\n     */\n    private static boolean isRFC3986HostName(final String name) {\n        final String[] parts = name.split(\"\\\\.\", -1);\n        for (int i = 0; i < parts.length; i++) {\n            if (parts[i].isEmpty()) {\n                // trailing dot is legal, otherwise we've hit a .. sequence\n                return i == parts.length - 1;\n            }\n            if (!REG_NAME_PART_PATTERN.matcher(parts[i]).matches()) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate uncheck(e IOException) : UncheckedIOException extracted from public skip(n long) : long in class org.apache.commons.io.input.UncheckedFilterReader", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/input/UncheckedFilterReader.java", "startLine": 153, "endLine": 163, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/input/UncheckedFilterReader.java", "startLine": 153, "endLine": 163, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/input/UncheckedFilterReader.java", "startLine": 165, "endLine": 167, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public long skip(final long n) throws UncheckedIOException {\n        try {\n            return super.skip(n);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/input/UncheckedFilterReader.java", "isPureRefactoring": true, "commitId": "d269f164b3e24a92cc33d759d8bcf3eedb37f576", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.UncheckedFilterReader", "methodNameBefore": "org.apache.commons.io.input.UncheckedFilterReader#skip", "invokedMethod": "methodSignature: org.apache.commons.io.input.UncheckedFilterReader#skip\n methodBody: public long skip(final long n) throws UncheckedIOException {\ntryreturn super.skip(n);\ncatch(final IOException e)throw new UncheckedIOException(e);\n}\nmethodSignature: org.apache.commons.io.input.UncheckedBufferedReader#skip\n methodBody: public long skip(final long n) throws UncheckedIOException {\ntryreturn super.skip(n);\ncatch(final IOException e)throw new UncheckedIOException(e);\n}", "classSignatureBefore": "public class UncheckedFilterReader extends FilterReader ", "methodNameBeforeSet": ["org.apache.commons.io.input.UncheckedFilterReader#skip"], "classNameBeforeSet": ["org.apache.commons.io.input.UncheckedFilterReader"], "classSignatureBeforeSet": ["public class UncheckedFilterReader extends FilterReader "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport java.io.FilterReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.nio.CharBuffer;\n\n/**\n * A {@link FilterReader} that throws {@link UncheckedIOException} instead of {@link IOException}.\n *\n * @see FilterReader\n * @see IOException\n * @see UncheckedIOException\n * @since 2.12.0\n */\npublic class UncheckedFilterReader extends FilterReader {\n\n    /**\n     * Creates a new filtered reader.\n     *\n     * @param reader a Reader object providing the underlying stream.\n     * @return a new UncheckedFilterReader.\n     * @throws NullPointerException if {@code reader} is {@code null}.\n     */\n    public static UncheckedFilterReader on(final Reader reader) {\n        return new UncheckedFilterReader(reader);\n    }\n\n    /**\n     * Creates a new filtered reader.\n     *\n     * @param reader a Reader object providing the underlying stream.\n     * @throws NullPointerException if {@code reader} is {@code null}.\n     */\n    public UncheckedFilterReader(final Reader reader) {\n        super(reader);\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public void close() throws UncheckedIOException {\n        try {\n            super.close();\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public void mark(final int readAheadLimit) throws UncheckedIOException {\n        try {\n            super.mark(readAheadLimit);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read() throws UncheckedIOException {\n        try {\n            return super.read();\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read(final char[] cbuf) throws UncheckedIOException {\n        try {\n            return super.read(cbuf);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read(final char[] cbuf, final int off, final int len) throws UncheckedIOException {\n        try {\n            return super.read(cbuf, off, len);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read(final CharBuffer target) throws UncheckedIOException {\n        try {\n            return super.read(target);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public boolean ready() throws UncheckedIOException {\n        try {\n            return super.ready();\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public void reset() throws UncheckedIOException {\n        try {\n            super.reset();\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public long skip(final long n) throws UncheckedIOException {\n        try {\n            return super.skip(n);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/input/UncheckedFilterReader.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport java.io.FilterReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.nio.CharBuffer;\n\n/**\n * A {@link FilterReader} that throws {@link UncheckedIOException} instead of {@link IOException}.\n *\n * @see FilterReader\n * @see IOException\n * @see UncheckedIOException\n * @since 2.12.0\n */\npublic class UncheckedFilterReader extends FilterReader {\n\n    /**\n     * Creates a new filtered reader.\n     *\n     * @param reader a Reader object providing the underlying stream.\n     * @return a new UncheckedFilterReader.\n     * @throws NullPointerException if {@code reader} is {@code null}.\n     */\n    public static UncheckedFilterReader on(final Reader reader) {\n        return new UncheckedFilterReader(reader);\n    }\n\n    /**\n     * Creates a new filtered reader.\n     *\n     * @param reader a Reader object providing the underlying stream.\n     * @throws NullPointerException if {@code reader} is {@code null}.\n     */\n    public UncheckedFilterReader(final Reader reader) {\n        super(reader);\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public void close() throws UncheckedIOException {\n        try {\n            super.close();\n        } catch (final IOException e) {\n            throw uncheck(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public void mark(final int readAheadLimit) throws UncheckedIOException {\n        try {\n            super.mark(readAheadLimit);\n        } catch (final IOException e) {\n            throw uncheck(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read() throws UncheckedIOException {\n        try {\n            return super.read();\n        } catch (final IOException e) {\n            throw uncheck(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read(final char[] cbuf) throws UncheckedIOException {\n        try {\n            return super.read(cbuf);\n        } catch (final IOException e) {\n            throw uncheck(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read(final char[] cbuf, final int off, final int len) throws UncheckedIOException {\n        try {\n            return super.read(cbuf, off, len);\n        } catch (final IOException e) {\n            throw uncheck(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read(final CharBuffer target) throws UncheckedIOException {\n        try {\n            return super.read(target);\n        } catch (final IOException e) {\n            throw uncheck(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public boolean ready() throws UncheckedIOException {\n        try {\n            return super.ready();\n        } catch (final IOException e) {\n            throw uncheck(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public void reset() throws UncheckedIOException {\n        try {\n            super.reset();\n        } catch (final IOException e) {\n            throw uncheck(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public long skip(final long n) throws UncheckedIOException {\n        try {\n            return super.skip(n);\n        } catch (final IOException e) {\n            throw uncheck(e);\n        }\n    }\n\n    private UncheckedIOException uncheck(final IOException e) {\n        return new UncheckedIOException(e);\n    }\n\n}\n", "diffSourceCodeSet": ["private UncheckedIOException uncheck(final IOException e) {\n        return new UncheckedIOException(e);\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.UncheckedFilterReader#skip\n methodBody: public long skip(final long n) throws UncheckedIOException {\ntryreturn super.skip(n);\ncatch(final IOException e)throw new UncheckedIOException(e);\n}", "methodSignature: org.apache.commons.io.input.UncheckedBufferedReader#skip\n methodBody: public long skip(final long n) throws UncheckedIOException {\ntryreturn super.skip(n);\ncatch(final IOException e)throw new UncheckedIOException(e);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public long skip(final long n) throws UncheckedIOException {\n        try {\n            return super.skip(n);\n        } catch (final IOException e) {\n            throw uncheck(e);\n        }\n    }\nprivate UncheckedIOException uncheck(final IOException e) {\n        return new UncheckedIOException(e);\n    }", "diffSourceCode": "   153:     /**\n   154:      * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n   155:      */\n   156:     @Override\n   157:     public long skip(final long n) throws UncheckedIOException {\n   158:         try {\n   159:             return super.skip(n);\n   160:         } catch (final IOException e) {\n-  161:             throw new UncheckedIOException(e);\n+  161:             throw uncheck(e);\n   162:         }\n   163:     }\n-  165: }\n+  165:     private UncheckedIOException uncheck(final IOException e) {\n+  166:         return new UncheckedIOException(e);\n+  167:     }\n", "uniqueId": "d269f164b3e24a92cc33d759d8bcf3eedb37f576_153_163_165_167_153_163", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 10}, "LINE": {"missed": 0, "covered": 3}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `UncheckedFilterReader` class, we can extract the repeated error handling logic into a separate method. This will reduce code duplication and make it easier to manage changes in the future.\n\nHere's the refactored code for the `skip` method, along with the new helper method `handleIOException` that encapsulates the error handling logic:\n\n```java\n##########################\nprivate <T> T handleIOException(Callable<T> callable) throws UncheckedIOException {\n    try {\n        return callable.call();\n    } catch (final IOException e) {\n        throw new UncheckedIOException(e);\n    }\n}\n\n@Override\npublic long skip(final long n) throws UncheckedIOException {\n    return handleIOException(() -> super.skip(n));\n}\n##########################\n```\n\nIn this refactoring:\n- We created a private method `handleIOException` that takes a `Callable<T>` as a parameter. This method handles the `IOException` and rethrows it as `UncheckedIOException`.\n- The `skip` method now calls `handleIOException`, passing a lambda expression that calls `super.skip(n)`. \n\nThis pattern can be applied to other methods in the class to further reduce duplication.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public long skip(final long n) throws UncheckedIOException {\n        try {\n            return super.skip(n);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport java.io.FilterReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.UncheckedIOException;\nimport java.nio.CharBuffer;\n\n/**\n * A {@link FilterReader} that throws {@link UncheckedIOException} instead of {@link IOException}.\n *\n * @see FilterReader\n * @see IOException\n * @see UncheckedIOException\n * @since 2.12.0\n */\npublic class UncheckedFilterReader extends FilterReader {\n\n    /**\n     * Creates a new filtered reader.\n     *\n     * @param reader a Reader object providing the underlying stream.\n     * @return a new UncheckedFilterReader.\n     * @throws NullPointerException if {@code reader} is {@code null}.\n     */\n    public static UncheckedFilterReader on(final Reader reader) {\n        return new UncheckedFilterReader(reader);\n    }\n\n    /**\n     * Creates a new filtered reader.\n     *\n     * @param reader a Reader object providing the underlying stream.\n     * @throws NullPointerException if {@code reader} is {@code null}.\n     */\n    public UncheckedFilterReader(final Reader reader) {\n        super(reader);\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public void close() throws UncheckedIOException {\n        try {\n            super.close();\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public void mark(final int readAheadLimit) throws UncheckedIOException {\n        try {\n            super.mark(readAheadLimit);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read() throws UncheckedIOException {\n        try {\n            return super.read();\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read(final char[] cbuf) throws UncheckedIOException {\n        try {\n            return super.read(cbuf);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read(final char[] cbuf, final int off, final int len) throws UncheckedIOException {\n        try {\n            return super.read(cbuf, off, len);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public int read(final CharBuffer target) throws UncheckedIOException {\n        try {\n            return super.read(target);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public boolean ready() throws UncheckedIOException {\n        try {\n            return super.ready();\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public void reset() throws UncheckedIOException {\n        try {\n            super.reset();\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n    /**\n     * Calls this method's super and rethrow {@link IOException} as {@link UncheckedIOException}.\n     */\n    @Override\n    public long skip(final long n) throws UncheckedIOException {\n        try {\n            return super.skip(n);\n        } catch (final IOException e) {\n            throw new UncheckedIOException(e);\n        }\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate notify(buffer byte[], offset int, result int, ioe IOException) : void extracted from public read(buffer byte[], offset int, length int) : int in class org.apache.commons.io.input.ObservableInputStream", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/input/ObservableInputStream.java", "startLine": 177, "endLine": 194, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/input/ObservableInputStream.java", "startLine": 262, "endLine": 273, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/input/ObservableInputStream.java", "startLine": 220, "endLine": 228, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read(buffer, offset, length);\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else if (result > 0) {\n            noteDataBytes(buffer, offset, result);\n        }\n        return result;\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/input/ObservableInputStream.java", "isPureRefactoring": true, "commitId": "a304a37c7f8c4f745bab92393b08f11c4b403830", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.ObservableInputStream", "methodNameBefore": "org.apache.commons.io.input.ObservableInputStream#read", "invokedMethod": "methodSignature: org.apache.commons.io.input.ObservableInputStream#noteError\n methodBody: protected void noteError(final IOException exception) throws IOException {\nfor(final Observer observer: getObservers()){observer.error(exception);\n}}\nmethodSignature: org.apache.commons.io.input.ObservableInputStream#noteFinished\n methodBody: protected void noteFinished() throws IOException {\nfor(final Observer observer: getObservers()){observer.finished();\n}}\nmethodSignature: org.apache.commons.io.input.ObservableInputStream#read\n methodBody: public int read(final byte[] buffer, final int offset, final int length) throws IOException {\nint result=0;\nIOException ioe=null;\ntryresult=super.read(buffer,offset,length);\ncatch(final IOException pException)ioe=pException;\nif(ioe != null){noteError(ioe);\n}if(result == EOF){noteFinished();\n}if(result > 0){noteDataBytes(buffer,offset,result);\n}return result;\n}\nmethodSignature: org.apache.commons.io.input.ObservableInputStream#noteDataBytes\n methodBody: protected void noteDataBytes(final byte[] buffer, final int offset, final int length) throws IOException {\nfor(final Observer observer: getObservers()){observer.data(buffer,offset,length);\n}}", "classSignatureBefore": "public class ObservableInputStream extends ProxyInputStream ", "methodNameBeforeSet": ["org.apache.commons.io.input.ObservableInputStream#read"], "classNameBeforeSet": ["org.apache.commons.io.input.ObservableInputStream"], "classSignatureBeforeSet": ["public class ObservableInputStream extends ProxyInputStream "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.apache.commons.io.IOUtils.EOF;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.IOUtils;\n\n/**\n * The {@link ObservableInputStream} allows, that an InputStream may be consumed by other receivers, apart from the\n * thread, which is reading it. The other consumers are implemented as instances of {@link Observer}. A typical\n * application may be the generation of a {@link java.security.MessageDigest} on the fly. {@code Note}: The\n * {@link ObservableInputStream} is <em>not</em> thread safe, as instances of InputStream usually aren't. If you must\n * access the stream from multiple threads, then synchronization, locking, or a similar means must be used.\n * \n * @see MessageDigestCalculatingInputStream\n */\npublic class ObservableInputStream extends ProxyInputStream {\n\n    /**\n     * Abstracts observer callback for {@code ObservableInputStream}s.\n     */\n    public static abstract class Observer {\n\n        /**\n         * Called to indicate, that {@link InputStream#read()} has been invoked on the {@link ObservableInputStream},\n         * and will return a value.\n         * \n         * @param value The value, which is being returned. This will never be -1 (EOF), because, in that case,\n         *        {@link #finished()} will be invoked instead.\n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void data(final int value) throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate that {@link InputStream#read(byte[])}, or {@link InputStream#read(byte[], int, int)} have\n         * been called, and are about to invoke data.\n         * \n         * @param buffer The byte array, which has been passed to the read call, and where data has been stored.\n         * @param offset The offset within the byte array, where data has been stored.\n         * @param length The number of bytes, which have been stored in the byte array.\n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate that EOF has been seen on the underlying stream. This method may be called multiple times,\n         * if the reader keeps invoking either of the read methods, and they will consequently keep returning EOF.\n         * \n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void finished() throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate that the {@link ObservableInputStream} has been closed.\n         * \n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void closed() throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate that an error occurred on the underlying stream.\n         * \n         * @param exception the exception to throw\n         * @throws IOException if an I/O error occurs.\n         */\n        public void error(final IOException exception) throws IOException {\n            throw exception;\n        }\n    }\n\n    private final List<Observer> observers = new ArrayList<>();\n\n    /**\n     * Creates a new ObservableInputStream for the given InputStream.\n     * \n     * @param inputStream the input stream to proxy.\n     */\n    public ObservableInputStream(final InputStream inputStream) {\n        super(inputStream);\n    }\n\n    /**\n     * Adds an Observer.\n     * \n     * @param observer the observer to add\n     */\n    public void add(final Observer observer) {\n        observers.add(observer);\n    }\n\n    /**\n     * Removes an Observer.\n     * \n     * @param observer the observer to remove\n     */\n    public void remove(final Observer observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * Removes all Observers.\n     */\n    public void removeAllObservers() {\n        observers.clear();\n    }\n\n    @Override\n    public int read() throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read();\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else {\n            noteDataByte(result);\n        }\n        return result;\n    }\n\n    @Override\n    public int read(final byte[] buffer) throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read(buffer);\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else if (result > 0) {\n            noteDataBytes(buffer, 0, result);\n        }\n        return result;\n    }\n\n    @Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read(buffer, offset, length);\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else if (result > 0) {\n            noteDataBytes(buffer, offset, result);\n        }\n        return result;\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#data(byte[],int,int)} with the given arguments.\n     * \n     * @param buffer Passed to the observers.\n     * @param offset Passed to the observers.\n     * @param length Passed to the observers.\n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteDataBytes(final byte[] buffer, final int offset, final int length) throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.data(buffer, offset, length);\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#finished()}.\n     * \n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteFinished() throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.finished();\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#data(int)} with the given arguments.\n     * \n     * @param value Passed to the observers.\n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteDataByte(final int value) throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.data(value);\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#error(IOException)} with the given argument.\n     * \n     * @param exception Passed to the observers.\n     * @throws IOException Some observer has thrown an exception, which is being passed down. This may be the same\n     *         exception, which has been passed as an argument.\n     */\n    protected void noteError(final IOException exception) throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.error(exception);\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#finished()}.\n     * \n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteClosed() throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.closed();\n        }\n    }\n\n    /**\n     * Gets all currently registered observers.\n     * \n     * @return a list of the currently registered observers\n     */\n    protected List<Observer> getObservers() {\n        return observers;\n    }\n\n    @Override\n    public void close() throws IOException {\n        IOException ioe = null;\n        try {\n            super.close();\n        } catch (final IOException e) {\n            ioe = e;\n        }\n        if (ioe == null) {\n            noteClosed();\n        } else {\n            noteError(ioe);\n        }\n    }\n\n    /**\n     * Reads all data from the underlying {@link InputStream}, while notifying the observers.\n     * \n     * @throws IOException The underlying {@link InputStream}, or either of the observers has thrown an exception.\n     */\n    public void consume() throws IOException {\n        final byte[] buffer = new byte[IOUtils.DEFAULT_BUFFER_SIZE];\n        while (read(buffer) != EOF) {\n            // empty\n        }\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/input/ObservableInputStream.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.apache.commons.io.IOUtils.EOF;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.IOUtils;\n\n/**\n * The {@link ObservableInputStream} allows, that an InputStream may be consumed by other receivers, apart from the\n * thread, which is reading it. The other consumers are implemented as instances of {@link Observer}. A typical\n * application may be the generation of a {@link java.security.MessageDigest} on the fly. {@code Note}: The\n * {@link ObservableInputStream} is <em>not</em> thread safe, as instances of InputStream usually aren't. If you must\n * access the stream from multiple threads, then synchronization, locking, or a similar means must be used.\n * \n * @see MessageDigestCalculatingInputStream\n */\npublic class ObservableInputStream extends ProxyInputStream {\n\n    /**\n     * Abstracts observer callback for {@code ObservableInputStream}s.\n     */\n    public static abstract class Observer {\n\n        /**\n         * Called to indicate that the {@link ObservableInputStream} has been closed.\n         * \n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void closed() throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate that {@link InputStream#read(byte[])}, or {@link InputStream#read(byte[], int, int)} have\n         * been called, and are about to invoke data.\n         * \n         * @param buffer The byte array, which has been passed to the read call, and where data has been stored.\n         * @param offset The offset within the byte array, where data has been stored.\n         * @param length The number of bytes, which have been stored in the byte array.\n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate, that {@link InputStream#read()} has been invoked on the {@link ObservableInputStream},\n         * and will return a value.\n         * \n         * @param value The value, which is being returned. This will never be -1 (EOF), because, in that case,\n         *        {@link #finished()} will be invoked instead.\n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void data(final int value) throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate that an error occurred on the underlying stream.\n         * \n         * @param exception the exception to throw\n         * @throws IOException if an I/O error occurs.\n         */\n        public void error(final IOException exception) throws IOException {\n            throw exception;\n        }\n\n        /**\n         * Called to indicate that EOF has been seen on the underlying stream. This method may be called multiple times,\n         * if the reader keeps invoking either of the read methods, and they will consequently keep returning EOF.\n         * \n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void finished() throws IOException {\n            // noop\n        }\n    }\n\n    private final List<Observer> observers = new ArrayList<>();\n\n    /**\n     * Creates a new ObservableInputStream for the given InputStream.\n     * \n     * @param inputStream the input stream to proxy.\n     */\n    public ObservableInputStream(final InputStream inputStream) {\n        super(inputStream);\n    }\n\n    /**\n     * Adds an Observer.\n     * \n     * @param observer the observer to add\n     */\n    public void add(final Observer observer) {\n        observers.add(observer);\n    }\n\n    @Override\n    public void close() throws IOException {\n        IOException ioe = null;\n        try {\n            super.close();\n        } catch (final IOException e) {\n            ioe = e;\n        }\n        if (ioe == null) {\n            noteClosed();\n        } else {\n            noteError(ioe);\n        }\n    }\n\n    /**\n     * Reads all data from the underlying {@link InputStream}, while notifying the observers.\n     * \n     * @throws IOException The underlying {@link InputStream}, or either of the observers has thrown an exception.\n     */\n    public void consume() throws IOException {\n        final byte[] buffer = new byte[IOUtils.DEFAULT_BUFFER_SIZE];\n        while (read(buffer) != EOF) {\n            // empty\n        }\n    }\n\n    /**\n     * Gets all currently registered observers.\n     * \n     * @return a list of the currently registered observers\n     */\n    protected List<Observer> getObservers() {\n        return observers;\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#finished()}.\n     * \n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteClosed() throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.closed();\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#data(int)} with the given arguments.\n     * \n     * @param value Passed to the observers.\n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteDataByte(final int value) throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.data(value);\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#data(byte[],int,int)} with the given arguments.\n     * \n     * @param buffer Passed to the observers.\n     * @param offset Passed to the observers.\n     * @param length Passed to the observers.\n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteDataBytes(final byte[] buffer, final int offset, final int length) throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.data(buffer, offset, length);\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#error(IOException)} with the given argument.\n     * \n     * @param exception Passed to the observers.\n     * @throws IOException Some observer has thrown an exception, which is being passed down. This may be the same\n     *         exception, which has been passed as an argument.\n     */\n    protected void noteError(final IOException exception) throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.error(exception);\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#finished()}.\n     * \n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteFinished() throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.finished();\n        }\n    }\n\n    private void notify(final byte[] buffer, final int offset, int result, IOException ioe) throws IOException {\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else if (result > 0) {\n            noteDataBytes(buffer, offset, result);\n        }\n    }\n\n    @Override\n    public int read() throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read();\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else {\n            noteDataByte(result);\n        }\n        return result;\n    }\n\n    @Override\n    public int read(final byte[] buffer) throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read(buffer);\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        notify(buffer, 0, result, ioe);\n        return result;\n    }\n\n    @Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read(buffer, offset, length);\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        notify(buffer, offset, result, ioe);\n        return result;\n    }\n\n    /**\n     * Removes an Observer.\n     * \n     * @param observer the observer to remove\n     */\n    public void remove(final Observer observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * Removes all Observers.\n     */\n    public void removeAllObservers() {\n        observers.clear();\n    }\n\n}\n", "diffSourceCodeSet": ["private void notify(final byte[] buffer, final int offset, int result, IOException ioe) throws IOException {\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else if (result > 0) {\n            noteDataBytes(buffer, offset, result);\n        }\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.ObservableInputStream#noteError\n methodBody: protected void noteError(final IOException exception) throws IOException {\nfor(final Observer observer: getObservers()){observer.error(exception);\n}}", "methodSignature: org.apache.commons.io.input.ObservableInputStream#noteFinished\n methodBody: protected void noteFinished() throws IOException {\nfor(final Observer observer: getObservers()){observer.finished();\n}}", "methodSignature: org.apache.commons.io.input.ObservableInputStream#read\n methodBody: public int read(final byte[] buffer, final int offset, final int length) throws IOException {\nint result=0;\nIOException ioe=null;\ntryresult=super.read(buffer,offset,length);\ncatch(final IOException pException)ioe=pException;\nif(ioe != null){noteError(ioe);\n}if(result == EOF){noteFinished();\n}if(result > 0){noteDataBytes(buffer,offset,result);\n}return result;\n}", "methodSignature: org.apache.commons.io.input.ObservableInputStream#noteDataBytes\n methodBody: protected void noteDataBytes(final byte[] buffer, final int offset, final int length) throws IOException {\nfor(final Observer observer: getObservers()){observer.data(buffer,offset,length);\n}}"], "sourceCodeAfterRefactoring": "@Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read(buffer, offset, length);\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        notify(buffer, offset, result, ioe);\n        return result;\n    }\nprivate void notify(final byte[] buffer, final int offset, int result, IOException ioe) throws IOException {\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else if (result > 0) {\n            noteDataBytes(buffer, offset, result);\n        }\n    }", "diffSourceCode": "-  177:     @Override\n-  178:     public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n-  179:         int result = 0;\n-  180:         IOException ioe = null;\n-  181:         try {\n-  182:             result = super.read(buffer, offset, length);\n-  183:         } catch (final IOException pException) {\n-  184:             ioe = pException;\n-  185:         }\n-  186:         if (ioe != null) {\n-  187:             noteError(ioe);\n-  188:         } else if (result == EOF) {\n-  189:             noteFinished();\n-  190:         } else if (result > 0) {\n-  191:             noteDataBytes(buffer, offset, result);\n-  192:         }\n-  193:         return result;\n+  177:         for (final Observer observer : getObservers()) {\n+  178:             observer.data(value);\n+  179:         }\n+  180:     }\n+  181: \n+  182:     /**\n+  183:      * Notifies the observers by invoking {@link Observer#data(byte[],int,int)} with the given arguments.\n+  184:      * \n+  185:      * @param buffer Passed to the observers.\n+  186:      * @param offset Passed to the observers.\n+  187:      * @param length Passed to the observers.\n+  188:      * @throws IOException Some observer has thrown an exception, which is being passed down.\n+  189:      */\n+  190:     protected void noteDataBytes(final byte[] buffer, final int offset, final int length) throws IOException {\n+  191:         for (final Observer observer : getObservers()) {\n+  192:             observer.data(buffer, offset, length);\n+  193:         }\n   194:     }\n-  220: \n-  221:     /**\n-  222:      * Notifies the observers by invoking {@link Observer#data(int)} with the given arguments.\n-  223:      * \n-  224:      * @param value Passed to the observers.\n-  225:      * @throws IOException Some observer has thrown an exception, which is being passed down.\n-  226:      */\n-  227:     protected void noteDataByte(final int value) throws IOException {\n-  228:         for (final Observer observer : getObservers()) {\n-  262:     protected List<Observer> getObservers() {\n-  263:         return observers;\n-  264:     }\n-  265: \n-  266:     @Override\n-  267:     public void close() throws IOException {\n-  268:         IOException ioe = null;\n-  269:         try {\n-  270:             super.close();\n-  271:         } catch (final IOException e) {\n-  272:             ioe = e;\n-  273:         }\n+  220:     private void notify(final byte[] buffer, final int offset, int result, IOException ioe) throws IOException {\n+  221:         if (ioe != null) {\n+  222:             noteError(ioe);\n+  223:         } else if (result == EOF) {\n+  224:             noteFinished();\n+  225:         } else if (result > 0) {\n+  226:             noteDataBytes(buffer, offset, result);\n+  227:         }\n+  228:     }\n+  262:     @Override\n+  263:     public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n+  264:         int result = 0;\n+  265:         IOException ioe = null;\n+  266:         try {\n+  267:             result = super.read(buffer, offset, length);\n+  268:         } catch (final IOException pException) {\n+  269:             ioe = pException;\n+  270:         }\n+  271:         notify(buffer, offset, result, ioe);\n+  272:         return result;\n+  273:     }\n", "uniqueId": "a304a37c7f8c4f745bab92393b08f11c4b403830_177_194_220_228_262_273", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 7, "covered": 28}, "BRANCH": {"missed": 2, "covered": 4}, "LINE": {"missed": 3, "covered": 10}, "COMPLEXITY": {"missed": 2, "covered": 2}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `read` method in the `ObservableInputStream` class, we can extract the error handling and notification logic into a separate method. This will help to reduce the complexity of the `read` method and make it clearer.\n\nHere\u2019s the refactored code for the `read` method:\n\n```java\n@Override\npublic int read(final byte[] buffer, final int offset, final int length) throws IOException {\n    int result = 0;\n    IOException ioe = null;\n    try {\n        result = super.read(buffer, offset, length);\n    } catch (final IOException pException) {\n        ioe = pException;\n    }\n    handleReadResult(ioe, result, buffer, offset);\n    return result;\n}\n\nprivate void handleReadResult(IOException ioe, int result, byte[] buffer, int offset) throws IOException {\n    if (ioe != null) {\n        noteError(ioe);\n    } else if (result == EOF) {\n        noteFinished();\n    } else if (result > 0) {\n        noteDataBytes(buffer, offset, result);\n    }\n}\n```\n\nThis refactoring extracts the logic that handles the result of the read operation into a new method called `handleReadResult`. This method takes care of notifying observers based on whether an exception occurred, if the end of the file was reached, or if data was read successfully. \n\nThe refactored method code is as follows:\n\n##########################\n```java\nprivate void handleReadResult(IOException ioe, int result, byte[] buffer, int offset) throws IOException {\n    if (ioe != null) {\n        noteError(ioe);\n    } else if (result == EOF) {\n        noteFinished();\n    } else if (result > 0) {\n        noteDataBytes(buffer, offset, result);\n    }\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read(buffer, offset, length);\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else if (result > 0) {\n            noteDataBytes(buffer, offset, result);\n        }\n        return result;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.apache.commons.io.IOUtils.EOF;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.IOUtils;\n\n/**\n * The {@link ObservableInputStream} allows, that an InputStream may be consumed by other receivers, apart from the\n * thread, which is reading it. The other consumers are implemented as instances of {@link Observer}. A typical\n * application may be the generation of a {@link java.security.MessageDigest} on the fly. {@code Note}: The\n * {@link ObservableInputStream} is <em>not</em> thread safe, as instances of InputStream usually aren't. If you must\n * access the stream from multiple threads, then synchronization, locking, or a similar means must be used.\n * \n * @see MessageDigestCalculatingInputStream\n */\npublic class ObservableInputStream extends ProxyInputStream {\n\n    /**\n     * Abstracts observer callback for {@code ObservableInputStream}s.\n     */\n    public static abstract class Observer {\n\n        /**\n         * Called to indicate, that {@link InputStream#read()} has been invoked on the {@link ObservableInputStream},\n         * and will return a value.\n         * \n         * @param value The value, which is being returned. This will never be -1 (EOF), because, in that case,\n         *        {@link #finished()} will be invoked instead.\n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void data(final int value) throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate that {@link InputStream#read(byte[])}, or {@link InputStream#read(byte[], int, int)} have\n         * been called, and are about to invoke data.\n         * \n         * @param buffer The byte array, which has been passed to the read call, and where data has been stored.\n         * @param offset The offset within the byte array, where data has been stored.\n         * @param length The number of bytes, which have been stored in the byte array.\n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void data(final byte[] buffer, final int offset, final int length) throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate that EOF has been seen on the underlying stream. This method may be called multiple times,\n         * if the reader keeps invoking either of the read methods, and they will consequently keep returning EOF.\n         * \n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void finished() throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate that the {@link ObservableInputStream} has been closed.\n         * \n         * @throws IOException if an I/O error occurs.\n         */\n        @SuppressWarnings(\"unused\") // Possibly thrown from subclasses.\n        public void closed() throws IOException {\n            // noop\n        }\n\n        /**\n         * Called to indicate that an error occurred on the underlying stream.\n         * \n         * @param exception the exception to throw\n         * @throws IOException if an I/O error occurs.\n         */\n        public void error(final IOException exception) throws IOException {\n            throw exception;\n        }\n    }\n\n    private final List<Observer> observers = new ArrayList<>();\n\n    /**\n     * Creates a new ObservableInputStream for the given InputStream.\n     * \n     * @param inputStream the input stream to proxy.\n     */\n    public ObservableInputStream(final InputStream inputStream) {\n        super(inputStream);\n    }\n\n    /**\n     * Adds an Observer.\n     * \n     * @param observer the observer to add\n     */\n    public void add(final Observer observer) {\n        observers.add(observer);\n    }\n\n    /**\n     * Removes an Observer.\n     * \n     * @param observer the observer to remove\n     */\n    public void remove(final Observer observer) {\n        observers.remove(observer);\n    }\n\n    /**\n     * Removes all Observers.\n     */\n    public void removeAllObservers() {\n        observers.clear();\n    }\n\n    @Override\n    public int read() throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read();\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else {\n            noteDataByte(result);\n        }\n        return result;\n    }\n\n    @Override\n    public int read(final byte[] buffer) throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read(buffer);\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else if (result > 0) {\n            noteDataBytes(buffer, 0, result);\n        }\n        return result;\n    }\n\n    @Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n        int result = 0;\n        IOException ioe = null;\n        try {\n            result = super.read(buffer, offset, length);\n        } catch (final IOException pException) {\n            ioe = pException;\n        }\n        if (ioe != null) {\n            noteError(ioe);\n        } else if (result == EOF) {\n            noteFinished();\n        } else if (result > 0) {\n            noteDataBytes(buffer, offset, result);\n        }\n        return result;\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#data(byte[],int,int)} with the given arguments.\n     * \n     * @param buffer Passed to the observers.\n     * @param offset Passed to the observers.\n     * @param length Passed to the observers.\n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteDataBytes(final byte[] buffer, final int offset, final int length) throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.data(buffer, offset, length);\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#finished()}.\n     * \n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteFinished() throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.finished();\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#data(int)} with the given arguments.\n     * \n     * @param value Passed to the observers.\n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteDataByte(final int value) throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.data(value);\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#error(IOException)} with the given argument.\n     * \n     * @param exception Passed to the observers.\n     * @throws IOException Some observer has thrown an exception, which is being passed down. This may be the same\n     *         exception, which has been passed as an argument.\n     */\n    protected void noteError(final IOException exception) throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.error(exception);\n        }\n    }\n\n    /**\n     * Notifies the observers by invoking {@link Observer#finished()}.\n     * \n     * @throws IOException Some observer has thrown an exception, which is being passed down.\n     */\n    protected void noteClosed() throws IOException {\n        for (final Observer observer : getObservers()) {\n            observer.closed();\n        }\n    }\n\n    /**\n     * Gets all currently registered observers.\n     * \n     * @return a list of the currently registered observers\n     */\n    protected List<Observer> getObservers() {\n        return observers;\n    }\n\n    @Override\n    public void close() throws IOException {\n        IOException ioe = null;\n        try {\n            super.close();\n        } catch (final IOException e) {\n            ioe = e;\n        }\n        if (ioe == null) {\n            noteClosed();\n        } else {\n            noteError(ioe);\n        }\n    }\n\n    /**\n     * Reads all data from the underlying {@link InputStream}, while notifying the observers.\n     * \n     * @throws IOException The underlying {@link InputStream}, or either of the observers has thrown an exception.\n     */\n    public void consume() throws IOException {\n        final byte[] buffer = new byte[IOUtils.DEFAULT_BUFFER_SIZE];\n        while (read(buffer) != EOF) {\n            // empty\n        }\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}]