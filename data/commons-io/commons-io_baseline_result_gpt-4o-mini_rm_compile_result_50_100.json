[{"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic wrap(outputStream OutputStream) : CloseShieldOutputStream extracted from public setUp() : void in class org.apache.commons.io.output.CloseShieldOutputStreamTest & moved to class org.apache.commons.io.output.CloseShieldOutputStream", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java", "startLine": 40, "endLine": 50, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java", "startLine": 40, "endLine": 50, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java", "startLine": 57, "endLine": 67, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@BeforeEach\n    public void setUp() {\n        original = new ByteArrayOutputStream() {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = new CloseShieldOutputStream(original);\n        closed = false;\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java", "isPureRefactoring": true, "commitId": "8a786abb5e2cc04568517f1f8c053578c3e313a6", "packageNameBefore": "org.apache.commons.io.output", "classNameBefore": "org.apache.commons.io.output.CloseShieldOutputStreamTest", "methodNameBefore": "org.apache.commons.io.output.CloseShieldOutputStreamTest#setUp", "classSignatureBefore": "public class CloseShieldOutputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.output.CloseShieldOutputStreamTest#setUp"], "classNameBeforeSet": ["org.apache.commons.io.output.CloseShieldOutputStreamTest"], "classSignatureBeforeSet": ["public class CloseShieldOutputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * JUnit Test Case for {@link CloseShieldOutputStream}.\n */\npublic class CloseShieldOutputStreamTest {\n\n    private ByteArrayOutputStream original;\n\n    private OutputStream shielded;\n\n    private boolean closed;\n\n    @BeforeEach\n    public void setUp() {\n        original = new ByteArrayOutputStream() {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = new CloseShieldOutputStream(original);\n        closed = false;\n    }\n\n    @Test\n    public void testClose() throws IOException {\n        shielded.close();\n        assertFalse(closed, \"closed\");\n        try {\n            shielded.write('x');\n            fail(\"write(b)\");\n        } catch (final IOException ignore) {\n            // expected\n        }\n        original.write('y');\n        assertEquals(1, original.size());\n        assertEquals('y', original.toByteArray()[0]);\n    }\n\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * JUnit Test Case for {@link CloseShieldOutputStream}.\n */\npublic class CloseShieldOutputStreamTest {\n\n    private ByteArrayOutputStream original;\n\n    private OutputStream shielded;\n\n    private boolean closed;\n\n    @BeforeEach\n    public void setUp() {\n        original = new ByteArrayOutputStream() {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = CloseShieldOutputStream.wrap(original);\n        closed = false;\n    }\n\n    @Test\n    public void testClose() throws IOException {\n        shielded.close();\n        assertFalse(closed, \"closed\");\n        assertThrows(IOException.class, () -> shielded.write('x'), \"write(b)\");\n        original.write('y');\n        assertEquals(1, original.size());\n        assertEquals('y', original.toByteArray()[0]);\n    }\n\n}\n", "diffSourceCodeSet": [""], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@BeforeEach\n    public void setUp() {\n        original = new ByteArrayOutputStream() {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = CloseShieldOutputStream.wrap(original);\n        closed = false;\n    }\n", "diffSourceCode": "    40:     @BeforeEach\n    41:     public void setUp() {\n    42:         original = new ByteArrayOutputStream() {\n    43:             @Override\n    44:             public void close() {\n    45:                 closed = true;\n    46:             }\n    47:         };\n-   48:         shielded = new CloseShieldOutputStream(original);\n+   48:         shielded = CloseShieldOutputStream.wrap(original);\n    49:         closed = false;\n    50:     }\n-   57:             shielded.write('x');\n-   58:             fail(\"write(b)\");\n-   59:         } catch (final IOException ignore) {\n-   60:             // expected\n-   61:         }\n-   62:         original.write('y');\n-   63:         assertEquals(1, original.size());\n-   64:         assertEquals('y', original.toByteArray()[0]);\n-   65:     }\n-   66: \n-   67: }\n+   57:         original.write('y');\n+   58:         assertEquals(1, original.size());\n+   59:         assertEquals('y', original.toByteArray()[0]);\n+   60:     }\n+   61: \n+   62: }\n", "uniqueId": "8a786abb5e2cc04568517f1f8c053578c3e313a6_40_50_57_67_40_50", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code, we will extract the logic for creating the `ByteArrayOutputStream` and the `CloseShieldOutputStream` into a separate static method. This method will be moved to the `TestUtils` class, which is a common utility class in the project structure. \n\n### Step 1: Analyze the Code\nThe `setUp` method initializes two streams and a boolean flag. We can extract the initialization logic into a separate method that returns an array containing the `ByteArrayOutputStream` and the `CloseShieldOutputStream`.\n\n### Step 2: Extract and Move Method\nWe will create a new static method in the `TestUtils` class that initializes the streams and returns them.\n\n### Step 3: Update the `setUp` Method\nThe `setUp` method will be updated to call the new static method from `TestUtils`.\n\n### Target File Path\nThe target file path for the extracted method will be:\n```\nsrc/test/java/org/apache/commons/io/test/TestUtils.java\n```\n\n### Extracted Method Code\nHere is the extracted method code that will be added to `TestUtils`:\n```java\npublic static OutputStream[] createShieldedOutputStream() {\n    ByteArrayOutputStream original = new ByteArrayOutputStream() {\n        @Override\n        public void close() {\n            closed = true;\n        }\n    };\n    OutputStream shielded = new CloseShieldOutputStream(original);\n    return new OutputStream[]{original, shielded};\n}\n```\n\n### Refactored Method Code\nHere is the refactored `setUp` method in `CloseShieldOutputStreamTest`:\n```java\n@BeforeEach\npublic void setUp() {\n    OutputStream[] streams = TestUtils.createShieldedOutputStream();\n    original = (ByteArrayOutputStream) streams[0];\n    shielded = streams[1];\n    closed = false;\n}\n```\n\n### Final Output\nHere is the complete output as per your request:\n\n##########################\nsrc/test/java/org/apache/commons/io/test/TestUtils.java\n##########################\npublic static OutputStream[] createShieldedOutputStream() {\n    ByteArrayOutputStream original = new ByteArrayOutputStream() {\n        @Override\n        public void close() {\n            closed = true;\n        }\n    };\n    OutputStream shielded = new CloseShieldOutputStream(original);\n    return new OutputStream[]{original, shielded};\n}\n##########################\n@BeforeEach\npublic void setUp() {\n    OutputStream[] streams = TestUtils.createShieldedOutputStream();\n    original = (ByteArrayOutputStream) streams[0];\n    shielded = streams[1];\n    closed = false;\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@BeforeEach\n    public void setUp() {\n        original = new ByteArrayOutputStream() {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = new CloseShieldOutputStream(original);\n        closed = false;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * JUnit Test Case for {@link CloseShieldOutputStream}.\n */\npublic class CloseShieldOutputStreamTest {\n\n    private ByteArrayOutputStream original;\n\n    private OutputStream shielded;\n\n    private boolean closed;\n\n    @BeforeEach\n    public void setUp() {\n        original = new ByteArrayOutputStream() {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = new CloseShieldOutputStream(original);\n        closed = false;\n    }\n\n    @Test\n    public void testClose() throws IOException {\n        shielded.close();\n        assertFalse(closed, \"closed\");\n        try {\n            shielded.write('x');\n            fail(\"write(b)\");\n        } catch (final IOException ignore) {\n            // expected\n        }\n        original.write('y');\n        assertEquals(1, original.size());\n        assertEquals('y', original.toByteArray()[0]);\n    }\n\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTestCase.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTestCase.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DemuxTestCase.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCase.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTestCase.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTestCase.java', 'src/test/java/org/apache/commons/io/FileSystemTestCase.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTestCase.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTestCase.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTestCase.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTestCase.java', 'src/test/java/org/apache/commons/io/IOExceptionListTestCase.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTestCase.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTestCase.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTestCase.java', 'src/test/java/org/apache/commons/io/IOUtilsTestCase.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTestCase.java', 'src/test/java/org/apache/commons/io/LineIteratorTestCase.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTestCase.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTestCase.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTestCase.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTestCase.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTestCase.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTestCase.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTestCase.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTestCase.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTestCase.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTestCase.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTestCase.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/ClosingBase.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nFile Path Before Refactoring:\nsrc/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpublic wrap(inputStream InputStream) : CloseShieldInputStream extracted from public setUp() : void in class org.apache.commons.io.input.CloseShieldInputStreamTest & moved to class org.apache.commons.io.input.CloseShieldInputStream", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java", "startLine": 42, "endLine": 53, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java", "startLine": 42, "endLine": 53, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java", "startLine": 57, "endLine": 67, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@BeforeEach\n    public void setUp() {\n        data = new byte[] { 'x', 'y', 'z' };\n        original = new ByteArrayInputStream(data) {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = new CloseShieldInputStream(original);\n        closed = false;\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java", "isPureRefactoring": true, "commitId": "8a786abb5e2cc04568517f1f8c053578c3e313a6", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.CloseShieldInputStreamTest", "methodNameBefore": "org.apache.commons.io.input.CloseShieldInputStreamTest#setUp", "classSignatureBefore": "public class CloseShieldInputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.input.CloseShieldInputStreamTest#setUp"], "classNameBeforeSet": ["org.apache.commons.io.input.CloseShieldInputStreamTest"], "classSignatureBeforeSet": ["public class CloseShieldInputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * JUnit Test Case for {@link CloseShieldInputStream}.\n */\npublic class CloseShieldInputStreamTest {\n\n    private byte[] data;\n\n    private InputStream original;\n\n    private InputStream shielded;\n\n    private boolean closed;\n\n    @BeforeEach\n    public void setUp() {\n        data = new byte[] { 'x', 'y', 'z' };\n        original = new ByteArrayInputStream(data) {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = new CloseShieldInputStream(original);\n        closed = false;\n    }\n\n    @Test\n    public void testClose() throws IOException {\n        shielded.close();\n        assertFalse(closed, \"closed\");\n        assertEquals(-1, shielded.read(), \"read()\");\n        assertEquals(data[0], original.read(), \"read()\");\n    }\n\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * JUnit Test Case for {@link CloseShieldInputStream}.\n */\npublic class CloseShieldInputStreamTest {\n\n    private byte[] data;\n\n    private InputStream original;\n\n    private InputStream shielded;\n\n    private boolean closed;\n\n    @BeforeEach\n    public void setUp() {\n        data = new byte[] { 'x', 'y', 'z' };\n        original = new ByteArrayInputStream(data) {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = CloseShieldInputStream.wrap(original);\n        closed = false;\n    }\n\n    @Test\n    public void testClose() throws IOException {\n        shielded.close();\n        assertFalse(closed, \"closed\");\n        assertEquals(-1, shielded.read(), \"read()\");\n        assertEquals(data[0], original.read(), \"read()\");\n    }\n\n}\n", "diffSourceCodeSet": [""], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@BeforeEach\n    public void setUp() {\n        data = new byte[] { 'x', 'y', 'z' };\n        original = new ByteArrayInputStream(data) {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = CloseShieldInputStream.wrap(original);\n        closed = false;\n    }\n", "diffSourceCode": "    42:     @BeforeEach\n    43:     public void setUp() {\n    44:         data = new byte[] { 'x', 'y', 'z' };\n    45:         original = new ByteArrayInputStream(data) {\n    46:             @Override\n    47:             public void close() {\n    48:                 closed = true;\n    49:             }\n    50:         };\n-   51:         shielded = new CloseShieldInputStream(original);\n+   51:         shielded = CloseShieldInputStream.wrap(original);\n    52:         closed = false;\n    53:     }\n    57:         shielded.close();\n    58:         assertFalse(closed, \"closed\");\n    59:         assertEquals(-1, shielded.read(), \"read()\");\n    60:         assertEquals(data[0], original.read(), \"read()\");\n    61:     }\n    62: \n    63: }\n", "uniqueId": "8a786abb5e2cc04568517f1f8c053578c3e313a6_42_53_57_67_42_53", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code, we will extract the initialization of the `original` and `shielded` input streams into a separate static method. This method will be moved to the `TestUtils` class, which is a common utility class in the project structure. \n\n### Step 1: Analyze the Code\nThe `setUp` method initializes the `data`, `original`, `shielded`, and `closed` variables. The initialization of `original` and `shielded` can be encapsulated into a separate method for better readability and maintainability.\n\n### Step 2: Extract and Move Method\nWe will create a static method in the `TestUtils` class that initializes the `original` and `shielded` streams. \n\n### Step 3: Update the `setUp` Method\nThe `setUp` method will be updated to call the new static method from `TestUtils`.\n\n### Target File Path\nThe target file path for the extracted method will be:\n```\nsrc/test/java/org/apache/commons/io/test/TestUtils.java\n```\n\n### Extracted Method Code\nHere is the extracted method code that will be added to `TestUtils`:\n```java\npublic static InputStream[] createShieldedInputStream(byte[] data) {\n    ByteArrayInputStream original = new ByteArrayInputStream(data) {\n        @Override\n        public void close() {\n            closed = true;\n        }\n    };\n    InputStream shielded = new CloseShieldInputStream(original);\n    return new InputStream[] { original, shielded };\n}\n```\n\n### Refactored Method Code\nHere is the refactored `setUp` method in `CloseShieldInputStreamTest`:\n```java\n@BeforeEach\npublic void setUp() {\n    data = new byte[] { 'x', 'y', 'z' };\n    InputStream[] streams = TestUtils.createShieldedInputStream(data);\n    original = streams[0];\n    shielded = streams[1];\n    closed = false;\n}\n```\n\n### Final Output\nHere is the complete output as per the requested format:\n\n##########################\nsrc/test/java/org/apache/commons/io/test/TestUtils.java\n##########################\npublic static InputStream[] createShieldedInputStream(byte[] data) {\n    ByteArrayInputStream original = new ByteArrayInputStream(data) {\n        @Override\n        public void close() {\n            closed = true;\n        }\n    };\n    InputStream shielded = new CloseShieldInputStream(original);\n    return new InputStream[] { original, shielded };\n}\n##########################\n@BeforeEach\npublic void setUp() {\n    data = new byte[] { 'x', 'y', 'z' };\n    InputStream[] streams = TestUtils.createShieldedInputStream(data);\n    original = streams[0];\n    shielded = streams[1];\n    closed = false;\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@BeforeEach\n    public void setUp() {\n        data = new byte[] { 'x', 'y', 'z' };\n        original = new ByteArrayInputStream(data) {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = new CloseShieldInputStream(original);\n        closed = false;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * JUnit Test Case for {@link CloseShieldInputStream}.\n */\npublic class CloseShieldInputStreamTest {\n\n    private byte[] data;\n\n    private InputStream original;\n\n    private InputStream shielded;\n\n    private boolean closed;\n\n    @BeforeEach\n    public void setUp() {\n        data = new byte[] { 'x', 'y', 'z' };\n        original = new ByteArrayInputStream(data) {\n            @Override\n            public void close() {\n                closed = true;\n            }\n        };\n        shielded = new CloseShieldInputStream(original);\n        closed = false;\n    }\n\n    @Test\n    public void testClose() throws IOException {\n        shielded.close();\n        assertFalse(closed, \"closed\");\n        assertEquals(-1, shielded.read(), \"read()\");\n        assertEquals(data[0], original.read(), \"read()\");\n    }\n\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTestCase.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTestCase.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DemuxTestCase.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCase.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTestCase.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTestCase.java', 'src/test/java/org/apache/commons/io/FileSystemTestCase.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsTestCase.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTestCase.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTestCase.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTestCase.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTestCase.java', 'src/test/java/org/apache/commons/io/IOExceptionListTestCase.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTestCase.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTestCase.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTestCase.java', 'src/test/java/org/apache/commons/io/IOUtilsTestCase.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTestCase.java', 'src/test/java/org/apache/commons/io/LineIteratorTestCase.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTestCase.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTestCase.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTestCase.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTestCase.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTestCase.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTestCase.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTestCase.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTestCase.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTestCase.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTestCase.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTestCase.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/ClosingBase.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nFile Path Before Refactoring:\nsrc/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertFooBarFileFiltering(filter IOFileFilter) : void extracted from public testNameFilter() : void in class org.apache.commons.io.filefilter.FileFilterTestCase", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java", "startLine": 1166, "endLine": 1254, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java", "startLine": 1165, "endLine": 1168, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java", "startLine": 1182, "endLine": 1268, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void testNameFilter() throws Exception {\n        IOFileFilter filter = new NameFileFilter(new String[] {\"foo\", \"bar\"});\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true);\n        assertFiltering(filter, new File(\"BAR\"), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true);\n        assertFiltering(filter, new File(\"BAR\").toPath(), true);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\"), WINDOWS);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\").toPath(), WINDOWS);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, null);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        // repeat for a List\n        final java.util.ArrayList<String> list = new java.util.ArrayList<>();\n        list.add(\"foo\");\n        list.add(\"bar\");\n        filter = new NameFileFilter(list);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(\"foo\");\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        // FileFilterUtils.nameFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.nameFileFilter(\"foo\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java", "isPureRefactoring": true, "commitId": "4a514d3306b55b3667d1449ebd4cbe5f19dd7af0", "packageNameBefore": "org.apache.commons.io.filefilter", "classNameBefore": "org.apache.commons.io.filefilter.FileFilterTestCase", "methodNameBefore": "org.apache.commons.io.filefilter.FileFilterTestCase#testNameFilter", "invokedMethod": "methodSignature: org.apache.commons.io.filefilter.FileFilterUtils#nameFileFilter\n methodBody: public static IOFileFilter nameFileFilter(final String name, final IOCase caseSensitivity) {\nreturn new NameFileFilter(name,caseSensitivity);\n}\nmethodSignature: org.apache.commons.io.file.AccumulatorPathVisitor#add\n methodBody: private void add(final List<Path> list, final Path dir) {\nlist.add(dir.normalize());\n}\nmethodSignature: org.apache.commons.io.filefilter.FileFilterTestCase#assertFiltering\n methodBody: public void assertFiltering(final IOFileFilter filter, final Path path, final boolean expected) throws Exception {\nfinal FileVisitResult expectedFileVisitResult=AbstractFileFilter.toFileVisitResult(expected);\nassertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\nif(path != null && path.getParent() != null){assertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\n}if(path == null){assertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for null\");\n}assertNotNull(filter.toString());\n}\nmethodSignature: org.apache.commons.io.filefilter.RegexFileFilterTestCase#assertFiltering\n methodBody: public void assertFiltering(final IOFileFilter filter, final Path path, final boolean expected) throws Exception {\nfinal FileVisitResult expectedFileVisitResult=AbstractFileFilter.toFileVisitResult(expected);\nassertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\nif(path != null && path.getParent() != null){assertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\n}if(path == null){assertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for null\");\n}}", "classSignatureBefore": "public class FileFilterTestCase ", "methodNameBeforeSet": ["org.apache.commons.io.filefilter.FileFilterTestCase#testNameFilter"], "classNameBeforeSet": ["org.apache.commons.io.filefilter.FileFilterTestCase"], "classSignatureBeforeSet": ["public class FileFilterTestCase "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.junit.jupiter.api.Assumptions.assumeTrue;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOCase;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.file.PathUtils;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Used to test FileFilterUtils.\n */\npublic class FileFilterTestCase {\n\n    /**\n     * The subversion directory name.\n     */\n    static final String SVN_DIR_NAME = \".svn\";\n\n    private static final boolean WINDOWS = File.separatorChar == '\\\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    public void assertFiltering(final IOFileFilter filter, final File file, final boolean expected) throws Exception {\n        // Note. This only tests the (File, String) version if the parent of\n        // the File passed in is not null\n        assertEquals(expected, filter.accept(file),\n            \"Filter(File) \" + filter.getClass().getName() + \" not \" + expected + \" for \" + file);\n\n        if (file != null && file.getParentFile() != null) {\n            assertEquals(expected, filter.accept(file.getParentFile(), file.getName()),\n                \"Filter(File, String) \" + filter.getClass().getName() + \" not \" + expected + \" for \" + file);\n        } else if (file == null) {\n            assertEquals(expected, filter.accept(file),\n                \"Filter(File, String) \" + filter.getClass().getName() + \" not \" + expected + \" for null\");\n        }\n        assertNotNull(filter.toString());\n    }\n\n    public void assertFiltering(final IOFileFilter filter, final Path path, final boolean expected) throws Exception {\n        // Note. This only tests the (Path, Path) version if the parent of\n        // the File passed in is not null\n        final FileVisitResult expectedFileVisitResult = AbstractFileFilter.toFileVisitResult(expected);\n        assertEquals(expectedFileVisitResult, filter.accept(path, null),\n            \"Filter(Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\n\n        if (path != null && path.getParent() != null) {\n            assertEquals(expectedFileVisitResult, filter.accept(path, null),\n                \"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \"\n                    + path);\n        } else if (path == null) {\n            assertEquals(expectedFileVisitResult, filter.accept(path, null),\n                \"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for null\");\n        }\n        assertNotNull(filter.toString());\n    }\n\n    @Test\n    public void testAgeFilter() throws Exception {\n        final File oldFile = new File(temporaryFolder, \"old.txt\");\n        final Path oldPath = oldFile.toPath();\n        final File reference = new File(temporaryFolder, \"reference.txt\");\n        final File newFile = new File(temporaryFolder, \"new.txt\");\n        final Path newPath = newFile.toPath();\n\n        if (!oldFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + oldFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(oldFile))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n\n        do {\n            try {\n                TestUtils.sleep(1000);\n            } catch (final InterruptedException ie) {\n                // ignore\n            }\n            if (!reference.getParentFile().exists()) {\n                throw new IOException(\"Cannot create file \" + reference + \" as the parent directory does not exist\");\n            }\n            try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(reference))) {\n                TestUtils.generateTestData(output, 0);\n            }\n        } while (oldFile.lastModified() == reference.lastModified());\n\n        final Date date = new Date();\n        final long now = date.getTime();\n\n        do {\n            try {\n                TestUtils.sleep(1000);\n            } catch (final InterruptedException ie) {\n                // ignore\n            }\n            if (!newFile.getParentFile().exists()) {\n                throw new IOException(\"Cannot create file \" + newFile + \" as the parent directory does not exist\");\n            }\n            try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(newFile))) {\n                TestUtils.generateTestData(output, 0);\n            }\n        } while (reference.lastModified() == newFile.lastModified());\n\n        final IOFileFilter filter1 = FileFilterUtils.ageFileFilter(now);\n        final IOFileFilter filter2 = FileFilterUtils.ageFileFilter(now, true);\n        final IOFileFilter filter3 = FileFilterUtils.ageFileFilter(now, false);\n        final IOFileFilter filter4 = FileFilterUtils.ageFileFilter(date);\n        final IOFileFilter filter5 = FileFilterUtils.ageFileFilter(date, true);\n        final IOFileFilter filter6 = FileFilterUtils.ageFileFilter(date, false);\n        final IOFileFilter filter7 = FileFilterUtils.ageFileFilter(reference);\n        final IOFileFilter filter8 = FileFilterUtils.ageFileFilter(reference, true);\n        final IOFileFilter filter9 = FileFilterUtils.ageFileFilter(reference, false);\n\n        assertFiltering(filter1, oldFile, true);\n        assertFiltering(filter2, oldFile, true);\n        assertFiltering(filter3, oldFile, false);\n        assertFiltering(filter4, oldFile, true);\n        assertFiltering(filter5, oldFile, true);\n        assertFiltering(filter6, oldFile, false);\n        assertFiltering(filter7, oldFile, true);\n        assertFiltering(filter8, oldFile, true);\n        assertFiltering(filter9, oldFile, false);\n        assertFiltering(filter1, newFile, false);\n        assertFiltering(filter2, newFile, false);\n        assertFiltering(filter3, newFile, true);\n        assertFiltering(filter4, newFile, false);\n        assertFiltering(filter5, newFile, false);\n        assertFiltering(filter6, newFile, true);\n        assertFiltering(filter7, newFile, false);\n        assertFiltering(filter8, newFile, false);\n        assertFiltering(filter9, newFile, true);\n        //\n        assertFiltering(filter1, oldPath, true);\n        assertFiltering(filter2, oldPath, true);\n        assertFiltering(filter3, oldPath, false);\n        assertFiltering(filter4, oldPath, true);\n        assertFiltering(filter5, oldPath, true);\n        assertFiltering(filter6, oldPath, false);\n        assertFiltering(filter7, oldPath, true);\n        assertFiltering(filter8, oldPath, true);\n        assertFiltering(filter9, oldPath, false);\n        assertFiltering(filter1, newPath, false);\n        assertFiltering(filter2, newPath, false);\n        assertFiltering(filter3, newPath, true);\n        assertFiltering(filter4, newPath, false);\n        assertFiltering(filter5, newPath, false);\n        assertFiltering(filter6, newPath, true);\n        assertFiltering(filter7, newPath, false);\n        assertFiltering(filter8, newPath, false);\n        assertFiltering(filter9, newPath, true);\n    }\n\n    @Test\n    public void testAnd() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(trueFilter.and(trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(trueFilter.and(falseFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter, trueFilter, trueFilter), new File(\"foo.test\"), false);\n    }\n\n    @Test\n    public void testAnd2() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(new AndFileFilter(trueFilter, trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(new AndFileFilter(trueFilter, falseFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, falseFilter), new File(\"foo.test\"), false);\n\n        final List<IOFileFilter> filters = new ArrayList<>();\n        assertFiltering(new AndFileFilter(filters), new File(\"test\"), false);\n        assertFiltering(new AndFileFilter(), new File(\"test\"), false);\n\n        assertThrows(IllegalArgumentException.class, () -> new AndFileFilter(falseFilter, (IOFileFilter) null));\n        assertThrows(IllegalArgumentException.class, () -> new AndFileFilter(null, falseFilter));\n\n        final AndFileFilter f = new AndFileFilter((List) null);\n        assertTrue(f.getFileFilters().isEmpty());\n\n        assertNotNull(f.toString()); // TODO better tests\n    }\n\n    @Test\n    public void testAndArray() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(new AndFileFilter(trueFilter, trueFilter, trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(new AndFileFilter(trueFilter, falseFilter, falseFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, trueFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, falseFilter, falseFilter), new File(\"foo.test\"), false);\n\n        final List<IOFileFilter> filters = new ArrayList<>();\n        assertFiltering(new AndFileFilter(filters), new File(\"test\"), false);\n        assertFiltering(new AndFileFilter(), new File(\"test\"), false);\n    }\n\n    @Test\n    public void testCanExecute() throws Exception {\n        assumeTrue(SystemUtils.IS_OS_WINDOWS);\n        final File executableFile = File.createTempFile(getClass().getSimpleName(), \".temp\");\n        final Path executablePath = executableFile.toPath();\n        try {\n            try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(executableFile))) {\n                TestUtils.generateTestData(output, 32);\n            }\n            assertTrue(executableFile.setExecutable(true));\n            assertFiltering(CanExecuteFileFilter.CAN_EXECUTE, executableFile, true);\n            assertFiltering(CanExecuteFileFilter.CAN_EXECUTE, executablePath, true);\n            executableFile.setExecutable(false);\n            assertFiltering(CanExecuteFileFilter.CANNOT_EXECUTE, executableFile, false);\n            assertFiltering(CanExecuteFileFilter.CANNOT_EXECUTE, executablePath, false);\n        } finally {\n            executableFile.delete();\n        }\n    }\n\n    @Test\n    public void testCanRead() throws Exception {\n        final File readOnlyFile = new File(temporaryFolder, \"read-only-file1.txt\");\n        final Path readOnlyPath = readOnlyFile.toPath();\n        if (!readOnlyFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + readOnlyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(readOnlyFile))) {\n            TestUtils.generateTestData(output, 32);\n        }\n        assertTrue(readOnlyFile.setReadOnly());\n        assertFiltering(CanReadFileFilter.CAN_READ, readOnlyFile, true);\n        assertFiltering(CanReadFileFilter.CAN_READ, readOnlyPath, true);\n        assertFiltering(CanReadFileFilter.CANNOT_READ, readOnlyFile, false);\n        assertFiltering(CanReadFileFilter.CANNOT_READ, readOnlyPath, false);\n        assertFiltering(CanReadFileFilter.READ_ONLY, readOnlyFile, true);\n        assertFiltering(CanReadFileFilter.READ_ONLY, readOnlyPath, true);\n        readOnlyFile.delete();\n    }\n\n    @Test\n    public void testCanWrite() throws Exception {\n        final File readOnlyFile = new File(temporaryFolder, \"read-only-file2.txt\");\n        final Path readOnlyPath = readOnlyFile.toPath();\n        if (!readOnlyFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + readOnlyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(readOnlyFile))) {\n            TestUtils.generateTestData(output, 32);\n        }\n        assertTrue(readOnlyFile.setReadOnly());\n        assertFiltering(CanWriteFileFilter.CAN_WRITE, temporaryFolder, true);\n        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, temporaryFolder, false);\n        assertFiltering(CanWriteFileFilter.CAN_WRITE, readOnlyFile, false);\n        assertFiltering(CanWriteFileFilter.CAN_WRITE, readOnlyPath, false);\n        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, readOnlyFile, true);\n        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, readOnlyPath, true);\n        readOnlyFile.delete();\n    }\n\n    @Test\n    public void testDelegateFileFilter() throws Exception {\n        final OrFileFilter orFilter = new OrFileFilter();\n        final File testFile = new File(\"test.txt\");\n\n        IOFileFilter filter = new DelegateFileFilter((FileFilter) orFilter);\n        assertFiltering(filter, testFile, false);\n        assertNotNull(filter.toString()); // TODO better test\n\n        filter = new DelegateFileFilter((FilenameFilter) orFilter);\n        assertFiltering(filter, testFile, false);\n        assertNotNull(filter.toString()); // TODO better test\n\n        try {\n            new DelegateFileFilter((FileFilter) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new DelegateFileFilter((FilenameFilter) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n    }\n\n    @Test\n    public void testDelegation() { // TODO improve these tests\n        assertNotNull(FileFilterUtils.asFileFilter((FileFilter) FalseFileFilter.INSTANCE));\n        assertNotNull(FileFilterUtils.asFileFilter((FilenameFilter) FalseFileFilter.INSTANCE).toString());\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testDeprecatedWildcard() throws Exception {\n        IOFileFilter filter = new WildcardFilter(\"*.txt\");\n        final List<String> patternList = Arrays.asList(\"*.txt\", \"*.xml\", \"*.gif\");\n        final IOFileFilter listFilter = new WildcardFilter(patternList);\n        final File txtFile = new File(\"test.txt\");\n        final Path txtPath = txtFile.toPath();\n        final File bmpFile = new File(\"test.bmp\");\n        final Path bmpPath = bmpFile.toPath();\n        final File dirFile = new File(\"src/java\");\n        final Path dirPath = dirFile.toPath();\n\n        assertFiltering(filter, new File(\"log.txt\"), true);\n//        assertFiltering(filter, new File(\"log.txt.bak\"), false);\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n\n        filter = new WildcardFilter(\"log?.txt\");\n        assertFiltering(filter, new File(\"log1.txt\"), true);\n        assertFiltering(filter, new File(\"log12.txt\"), false);\n        //\n        assertFiltering(filter, new File(\"log1.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log12.txt\").toPath(), false);\n\n        filter = new WildcardFilter(\"open??.????04\");\n        assertFiltering(filter, new File(\"openAB.102504\"), true);\n        assertFiltering(filter, new File(\"openA.102504\"), false);\n        assertFiltering(filter, new File(\"openXY.123103\"), false);\n//        assertFiltering(filter, new File(\"openAB.102504.old\"), false);\n        //\n        assertFiltering(filter, new File(\"openAB.102504\").toPath(), true);\n        assertFiltering(filter, new File(\"openA.102504\").toPath(), false);\n        assertFiltering(filter, new File(\"openXY.123103\").toPath(), false);\n//        assertFiltering(filter, new File(\"openAB.102504.old\").toPath(), false);\n\n        filter = new WildcardFilter(new String[] {\"*.java\", \"*.class\"});\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.class\"), true);\n        assertFiltering(filter, new File(\"Test.jsp\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.class\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.jsp\").toPath(), false);\n\n        assertFiltering(listFilter, new File(\"Test.txt\"), true);\n        assertFiltering(listFilter, new File(\"Test.xml\"), true);\n        assertFiltering(listFilter, new File(\"Test.gif\"), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\"), false);\n        //\n        assertFiltering(listFilter, new File(\"Test.txt\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.xml\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.gif\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\").toPath(), false);\n\n        assertTrue(listFilter.accept(txtFile));\n        assertTrue(!listFilter.accept(bmpFile));\n        assertTrue(!listFilter.accept(dirFile));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirPath, null));\n\n        assertTrue(listFilter.accept(txtFile.getParentFile(), txtFile.getName()));\n        assertTrue(!listFilter.accept(bmpFile.getParentFile(), bmpFile.getName()));\n        assertTrue(!listFilter.accept(dirFile.getParentFile(), dirFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirPath, null));\n\n        try {\n            new WildcardFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n\n        try {\n            new WildcardFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n\n        try {\n            new WildcardFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testDirectory() throws Exception {\n        // XXX: This test presumes the current working dir is the base dir of the source checkout.\n        final IOFileFilter filter = new DirectoryFileFilter();\n\n        assertFiltering(filter, new File(\"src/\"), true);\n        assertFiltering(filter, new File(\"src/\").toPath(), true);\n        assertFiltering(filter, new File(\"src/main/java/\"), true);\n        assertFiltering(filter, new File(\"src/main/java/\").toPath(), true);\n\n        assertFiltering(filter, new File(\"pom.xml\"), false);\n        assertFiltering(filter, new File(\"pom.xml\").toPath(), false);\n\n        assertFiltering(filter, new File(\"imaginary\"), false);\n        assertFiltering(filter, new File(\"imaginary\").toPath(), false);\n        assertFiltering(filter, new File(\"imaginary/\"), false);\n        assertFiltering(filter, new File(\"imaginary/\").toPath(), false);\n\n        assertFiltering(filter, new File(\"LICENSE.txt\"), false);\n        assertFiltering(filter, new File(\"LICENSE.txt\").toPath(), false);\n\n        assertSame(DirectoryFileFilter.DIRECTORY, DirectoryFileFilter.INSTANCE);\n    }\n\n    @Test\n    public void testEmpty() throws Exception {\n\n        // Empty Dir\n        final File emptyDirFile = new File(temporaryFolder, \"empty-dir\");\n        final Path emptyDirPath = emptyDirFile.toPath();\n        emptyDirFile.mkdirs();\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirFile, true);\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirPath, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirFile, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirPath, false);\n\n        // Empty File\n        final File emptyFile = new File(emptyDirFile, \"empty-file.txt\");\n        final Path emptyPath = emptyFile.toPath();\n        if (!emptyFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + emptyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(emptyFile))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n        assertFiltering(EmptyFileFilter.EMPTY, emptyFile, true);\n        assertFiltering(EmptyFileFilter.EMPTY, emptyPath, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyFile, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyPath, false);\n\n        // Not Empty Dir\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirFile, false);\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirPath, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirFile, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirPath, true);\n\n        // Not Empty File\n        final File notEmptyFile = new File(emptyDirFile, \"not-empty-file.txt\");\n        final Path notEmptyPath = notEmptyFile.toPath();\n        if (!notEmptyFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + notEmptyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(notEmptyFile))) {\n            TestUtils.generateTestData(output, 32);\n        }\n        assertFiltering(EmptyFileFilter.EMPTY, notEmptyFile, false);\n        assertFiltering(EmptyFileFilter.EMPTY, notEmptyPath, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, notEmptyFile, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, notEmptyPath, true);\n        FileUtils.forceDelete(emptyDirFile);\n    }\n\n    @Test\n    public void testEnsureTestCoverage() {\n        assertNotNull(new FileFilterUtils()); // dummy for test coverage\n    }\n\n    @Test\n    public void testFalse() throws Exception {\n        final IOFileFilter filter = FileFilterUtils.falseFileFilter();\n        assertFiltering(filter, new File(\"foo.test\"), false);\n        assertFiltering(filter, new File(\"foo.test\").toPath(), false);\n        assertFiltering(filter, new File(\"foo\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), false);\n        assertFiltering(filter, (File) null, false);\n        assertFiltering(filter, (Path) null, false);\n        assertSame(FalseFileFilter.FALSE, FalseFileFilter.INSTANCE);\n        assertSame(TrueFileFilter.TRUE, FalseFileFilter.INSTANCE.negate());\n        assertSame(TrueFileFilter.INSTANCE, FalseFileFilter.INSTANCE.negate());\n    }\n\n    @Test\n    public void testFileFilterUtils_and() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(FileFilterUtils.and(trueFilter, trueFilter, trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(FileFilterUtils.and(trueFilter, falseFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(FileFilterUtils.and(falseFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(FileFilterUtils.and(falseFilter, falseFilter), new File(\"foo.test\"), false);\n    }\n\n    @Test\n    public void testFileFilterUtils_or() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        final File testFile = new File(\"foo.test\");\n        assertFiltering(FileFilterUtils.or(trueFilter, trueFilter), testFile, true);\n        assertFiltering(FileFilterUtils.or(trueFilter, trueFilter, falseFilter), testFile, true);\n        assertFiltering(FileFilterUtils.or(falseFilter, trueFilter), testFile, true);\n        assertFiltering(FileFilterUtils.or(falseFilter, falseFilter, falseFilter), testFile, false);\n    }\n\n    @Test\n    public void testFiles() throws Exception {\n        // XXX: This test presumes the current working dir is the base dir of the source checkout.\n        final IOFileFilter filter = FileFileFilter.FILE;\n\n        assertFiltering(filter, new File(\"src/\"), false);\n        assertFiltering(filter, new File(\"src/\").toPath(), false);\n        assertFiltering(filter, new File(\"src/java/\"), false);\n        assertFiltering(filter, new File(\"src/java/\").toPath(), false);\n\n        assertFiltering(filter, new File(\"pom.xml\"), true);\n        assertFiltering(filter, new File(\"pom.xml\").toPath(), true);\n\n        assertFiltering(filter, new File(\"imaginary\"), false);\n        assertFiltering(filter, new File(\"imaginary\").toPath(), false);\n        assertFiltering(filter, new File(\"imaginary/\"), false);\n        assertFiltering(filter, new File(\"imaginary/\").toPath(), false);\n\n        assertFiltering(filter, new File(\"LICENSE.txt\"), true);\n        assertFiltering(filter, new File(\"LICENSE.txt\").toPath(), true);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, java.lang.Iterable)} that tests that the method\n     * properly filters files from the list.\n     */\n    @Test\n    public void testFilterArray_fromList() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        final List<File> fileList = Arrays.asList(fileA, fileB);\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileList);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests that the method properly filters\n     * files from the list.\n     */\n    @Test\n    public void testFilterArray_IOFileFilter() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileA, fileB);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests that the method properly filters\n     * files from the list.\n     */\n    @Test\n    public void testFilterArray_PathVisitorFileFilter_FileExistsNo() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = new PathVisitorFileFilter(new NameFileFilter(\"A\"));\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileA, fileB);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests that the method properly filters\n     * files from the list.\n     */\n    @Test\n    public void testFilterArray_PathVisitorFileFilter_FileExistsYes() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        FileUtils.write(fileA, \"test\", StandardCharsets.US_ASCII);\n\n        final IOFileFilter filter = new PathVisitorFileFilter(new NameFileFilter(\"A\"));\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileA, fileB);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests {@code null} parameters.\n     */\n    @Test\n    public void testFilterFilesArrayNullParameters() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        try {\n            FileFilterUtils.filter(null, fileA, fileB);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        FileFilterUtils.filter(filter, fileA, null);\n\n        final File[] filtered = FileFilterUtils.filter(filter, (File[]) null);\n        assertEquals(0, filtered.length);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterList(IOFileFilter, java.lang.Iterable)} that tests that the method\n     * properly filters files from the list.\n     */\n    @Test\n    public void testFilterList() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        final List<File> fileList = Arrays.asList(fileA, fileB);\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final List<File> filteredList = FileFilterUtils.filterList(filter, fileList);\n\n        assertTrue(filteredList.contains(fileA));\n        assertFalse(filteredList.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterList(IOFileFilter, File...)} that tests that the method properly\n     * filters files from the list.\n     */\n    @Test\n    public void testFilterList_fromArray() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final List<File> filteredList = FileFilterUtils.filterList(filter, fileA, fileB);\n\n        assertTrue(filteredList.contains(fileA));\n        assertFalse(filteredList.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterList(IOFileFilter, java.lang.Iterable)} that tests {@code null}\n     * parameters and {@code null} elements in the provided list.\n     */\n    @Test\n    public void testFilterListNullParameters() {\n        try {\n            FileFilterUtils.filterList(null, Collections.<File>emptyList());\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        try {\n            FileFilterUtils.filterList(filter, Collections.singletonList((File) null));\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for list containing null\n        }\n\n        final List<File> filteredList = FileFilterUtils.filterList(filter, (List<File>) null);\n        assertEquals(0, filteredList.size());\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, Path...)}.\n     */\n    @Test\n    public void testFilterPathsArrayNullParameters() throws Exception {\n        final Path fileA = TestUtils.newFile(temporaryFolder, \"A\").toPath();\n        final Path fileB = TestUtils.newFile(temporaryFolder, \"B\").toPath();\n        try {\n            PathUtils.filter(null, fileA, fileB);\n            fail();\n        } catch (final NullPointerException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        PathUtils.filter(filter, fileA, null);\n\n        final File[] filtered = FileFilterUtils.filter(filter, (File[]) null);\n        assertEquals(0, filtered.length);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterSet(IOFileFilter, java.lang.Iterable)} that tests that the method\n     * properly filters files from the set.\n     */\n    @Test\n    public void testFilterSet() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        final Set<File> fileList = new HashSet<>(Arrays.asList(fileA, fileB));\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final Set<File> filteredSet = FileFilterUtils.filterSet(filter, fileList);\n\n        assertTrue(filteredSet.contains(fileA));\n        assertFalse(filteredSet.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterSet(IOFileFilter, File...)} that tests that the method properly\n     * filters files from the set.\n     */\n    @Test\n    public void testFilterSet_fromArray() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final Set<File> filteredSet = FileFilterUtils.filterSet(filter, fileA, fileB);\n\n        assertTrue(filteredSet.contains(fileA));\n        assertFalse(filteredSet.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterSet(IOFileFilter, java.lang.Iterable)} that tests {@code null}\n     * parameters and {@code null} elements in the provided set.\n     */\n    @Test\n    public void testFilterSetNullParameters() {\n        try {\n            FileFilterUtils.filterSet(null, Collections.<File>emptySet());\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        try {\n            FileFilterUtils.filterSet(filter, new HashSet<>(Collections.singletonList((File) null)));\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for set containing null\n        }\n\n        final Set<File> filteredSet = FileFilterUtils.filterSet(filter, (Set<File>) null);\n        assertEquals(0, filteredSet.size());\n    }\n\n    @Test\n    public void testHidden() throws Exception {\n        final File hiddenDirFile = new File(SVN_DIR_NAME);\n        final Path hiddenDirPath = hiddenDirFile.toPath();\n        if (hiddenDirFile.exists()) {\n            assertFiltering(HiddenFileFilter.HIDDEN, hiddenDirFile, hiddenDirFile.isHidden());\n            assertFiltering(HiddenFileFilter.HIDDEN, hiddenDirPath, hiddenDirFile.isHidden());\n            assertFiltering(HiddenFileFilter.VISIBLE, hiddenDirFile, !hiddenDirFile.isHidden());\n            assertFiltering(HiddenFileFilter.VISIBLE, hiddenDirPath, !hiddenDirFile.isHidden());\n        }\n        final Path path = temporaryFolder.toPath();\n        assertFiltering(HiddenFileFilter.HIDDEN, temporaryFolder, false);\n        assertFiltering(HiddenFileFilter.HIDDEN, path, false);\n        assertFiltering(HiddenFileFilter.VISIBLE, temporaryFolder, true);\n        assertFiltering(HiddenFileFilter.VISIBLE, path, true);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterBytes() throws Exception {\n        final byte[] classFileMagicNumber = new byte[] {(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE};\n        final String xmlFileContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\">\\n\" + \"<element>text</element>\";\n\n        final File classAFile = new File(temporaryFolder, \"A.class\");\n        final Path classAPath = classAFile.toPath();\n        final File xmlBFile = new File(temporaryFolder, \"B.xml\");\n        final Path xmlBPath = xmlBFile.toPath();\n        final File emptyFile = new File(temporaryFolder, \"C.xml\");\n        final Path emptyPath = emptyFile.toPath();\n        final File dirFile = new File(temporaryFolder, \"D\");\n        final Path dirPath = dirFile.toPath();\n        dirFile.mkdirs();\n\n        try (final OutputStream classFileAStream = FileUtils.openOutputStream(classAFile)) {\n            IOUtils.write(classFileMagicNumber, classFileAStream);\n            TestUtils.generateTestData(classFileAStream, 32);\n        }\n\n        FileUtils.write(xmlBFile, xmlFileContent, StandardCharsets.UTF_8);\n        FileUtils.touch(emptyFile);\n\n        IOFileFilter filter = new MagicNumberFileFilter(classFileMagicNumber);\n\n        assertFiltering(filter, classAFile, true);\n        assertFiltering(filter, classAPath, true);\n        assertFiltering(filter, xmlBFile, false);\n        assertFiltering(filter, xmlBPath, false);\n        assertFiltering(filter, emptyFile, false);\n        assertFiltering(filter, emptyPath, false);\n        assertFiltering(filter, dirFile, false);\n        assertFiltering(filter, dirPath, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(classFileMagicNumber);\n\n        assertFiltering(filter, classAFile, true);\n        assertFiltering(filter, classAPath, true);\n        assertFiltering(filter, xmlBFile, false);\n        assertFiltering(filter, xmlBPath, false);\n        assertFiltering(filter, emptyFile, false);\n        assertFiltering(filter, emptyPath, false);\n        assertFiltering(filter, dirFile, false);\n        assertFiltering(filter, dirPath, false);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterBytesOffset() throws Exception {\n        final byte[] tarMagicNumber = new byte[] {0x75, 0x73, 0x74, 0x61, 0x72};\n        final long tarMagicNumberOffset = 257;\n\n        final File tarFileA = new File(temporaryFolder, \"A.tar\");\n        final File randomFileB = new File(temporaryFolder, \"B.txt\");\n        final File dir = new File(temporaryFolder, \"D\");\n        dir.mkdirs();\n\n        try (final OutputStream tarFileAStream = FileUtils.openOutputStream(tarFileA)) {\n            TestUtils.generateTestData(tarFileAStream, tarMagicNumberOffset);\n            IOUtils.write(tarMagicNumber, tarFileAStream);\n        }\n\n        if (!randomFileB.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + randomFileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(randomFileB))) {\n            TestUtils.generateTestData(output, 2 * tarMagicNumberOffset);\n        }\n\n        IOFileFilter filter = new MagicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterString() throws Exception {\n        final byte[] classFileMagicNumber = new byte[] {(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE};\n        final String xmlFileContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\">\\n\" + \"<element>text</element>\";\n        final String xmlMagicNumber = \"<?xml version=\\\"1.0\\\"\";\n\n        final File classFileA = new File(temporaryFolder, \"A.class\");\n        final File xmlFileB = new File(temporaryFolder, \"B.xml\");\n        final File dir = new File(temporaryFolder, \"D\");\n        dir.mkdirs();\n\n        try (final OutputStream classFileAStream = FileUtils.openOutputStream(classFileA)) {\n            IOUtils.write(classFileMagicNumber, classFileAStream);\n            TestUtils.generateTestData(classFileAStream, 32);\n        }\n\n        FileUtils.write(xmlFileB, xmlFileContent, StandardCharsets.UTF_8);\n\n        IOFileFilter filter = new MagicNumberFileFilter(xmlMagicNumber);\n\n        assertFiltering(filter, classFileA, false);\n        assertFiltering(filter, xmlFileB, true);\n        assertFiltering(filter, dir, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(xmlMagicNumber);\n\n        assertFiltering(filter, classFileA, false);\n        assertFiltering(filter, xmlFileB, true);\n        assertFiltering(filter, dir, false);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterStringOffset() throws Exception {\n        final String tarMagicNumber = \"ustar\";\n        final long tarMagicNumberOffset = 257;\n\n        final File tarFileA = new File(temporaryFolder, \"A.tar\");\n        final File randomFileB = new File(temporaryFolder, \"B.txt\");\n        final File dir = new File(temporaryFolder, \"D\");\n        dir.mkdirs();\n\n        try (final OutputStream tarFileAStream = FileUtils.openOutputStream(tarFileA)) {\n            TestUtils.generateTestData(tarFileAStream, tarMagicNumberOffset);\n            IOUtils.write(tarMagicNumber, tarFileAStream, StandardCharsets.UTF_8);\n        }\n\n        if (!randomFileB.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + randomFileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(randomFileB))) {\n            TestUtils.generateTestData(output, 2 * tarMagicNumberOffset);\n        }\n\n        IOFileFilter filter = new MagicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n    }\n\n    // -----------------------------------------------------------------------\n\n    @Test\n    public void testMagicNumberFileFilterValidation() {\n        try {\n            new MagicNumberFileFilter((String) null, 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(\"0\", -1);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(\"\", 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter((byte[]) null, 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(new byte[] {0}, -1);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(new byte[] {}, 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testMakeCVSAware() throws Exception {\n        final IOFileFilter filter1 = FileFilterUtils.makeCVSAware(null);\n        final IOFileFilter filter2 = FileFilterUtils.makeCVSAware(FileFilterUtils.nameFileFilter(\"test-file1.txt\"));\n\n        File file = new File(temporaryFolder, \"CVS\");\n        file.mkdirs();\n        assertFiltering(filter1, file, false);\n        assertFiltering(filter2, file, false);\n        FileUtils.deleteDirectory(file);\n\n        file = new File(temporaryFolder, \"test-file1.txt\");\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output2 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output2, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, true);\n\n        file = new File(temporaryFolder, \"test-file2.log\");\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n\n        file = new File(temporaryFolder, \"CVS\");\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n    }\n\n    // -----------------------------------------------------------------------\n    @Test\n    public void testMakeDirectoryOnly() throws Exception {\n        assertSame(DirectoryFileFilter.DIRECTORY, FileFilterUtils.makeDirectoryOnly(null));\n\n        final IOFileFilter filter = FileFilterUtils.makeDirectoryOnly(FileFilterUtils.nameFileFilter(\"B\"));\n\n        final File fileA = new File(temporaryFolder, \"A\");\n        final File fileB = new File(temporaryFolder, \"B\");\n\n        fileA.mkdirs();\n        fileB.mkdirs();\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, true);\n\n        FileUtils.deleteDirectory(fileA);\n        FileUtils.deleteDirectory(fileB);\n\n        if (!fileA.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + fileA + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(fileA))) {\n            TestUtils.generateTestData(output1, 32);\n        }\n        if (!fileB.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + fileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(fileB))) {\n            TestUtils.generateTestData(output, 32);\n        }\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, false);\n\n        fileA.delete();\n        fileB.delete();\n    }\n\n    // -----------------------------------------------------------------------\n    @Test\n    public void testMakeFileOnly() throws Exception {\n        assertSame(FileFileFilter.FILE, FileFilterUtils.makeFileOnly(null));\n\n        final IOFileFilter filter = FileFilterUtils.makeFileOnly(FileFilterUtils.nameFileFilter(\"B\"));\n\n        final File fileA = new File(temporaryFolder, \"A\");\n        final File fileB = new File(temporaryFolder, \"B\");\n\n        fileA.mkdirs();\n        fileB.mkdirs();\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, false);\n\n        FileUtils.deleteDirectory(fileA);\n        FileUtils.deleteDirectory(fileB);\n\n        if (!fileA.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + fileA + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(fileA))) {\n            TestUtils.generateTestData(output1, 32);\n        }\n        if (!fileB.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + fileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(fileB))) {\n            TestUtils.generateTestData(output, 32);\n        }\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, true);\n\n        fileA.delete();\n        fileB.delete();\n    }\n\n    @Test\n    public void testMakeSVNAware() throws Exception {\n        final IOFileFilter filter1 = FileFilterUtils.makeSVNAware(null);\n        final IOFileFilter filter2 = FileFilterUtils.makeSVNAware(FileFilterUtils.nameFileFilter(\"test-file1.txt\"));\n\n        File file = new File(temporaryFolder, SVN_DIR_NAME);\n        file.mkdirs();\n        assertFiltering(filter1, file, false);\n        assertFiltering(filter2, file, false);\n        FileUtils.deleteDirectory(file);\n\n        file = new File(temporaryFolder, \"test-file1.txt\");\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output2 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output2, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, true);\n\n        file = new File(temporaryFolder, \"test-file2.log\");\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n\n        file = new File(temporaryFolder, SVN_DIR_NAME);\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n    }\n\n    @Test\n    public void testNameFilter() throws Exception {\n        IOFileFilter filter = new NameFileFilter(new String[] {\"foo\", \"bar\"});\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true);\n        assertFiltering(filter, new File(\"BAR\"), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true);\n        assertFiltering(filter, new File(\"BAR\").toPath(), true);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\"), WINDOWS);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\").toPath(), WINDOWS);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, null);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        // repeat for a List\n        final java.util.ArrayList<String> list = new java.util.ArrayList<>();\n        list.add(\"foo\");\n        list.add(\"bar\");\n        filter = new NameFileFilter(list);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(\"foo\");\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        // FileFilterUtils.nameFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.nameFileFilter(\"foo\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n    }\n\n    @Test\n    public void testNameFilterNullArgument() throws Exception {\n        final String test = null;\n        try {\n            new NameFileFilter(test);\n            fail(\"constructing a NameFileFilter with a null String argument should fail.\");\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            FileFilterUtils.nameFileFilter(test, IOCase.INSENSITIVE);\n            fail(\"constructing a NameFileFilter with a null String argument should fail.\");\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testNameFilterNullArrayArgument() {\n        assertThrows(IllegalArgumentException.class, () -> new NameFileFilter((String[]) null));\n    }\n\n    @Test\n    public void testNameFilterNullListArgument() {\n        final List<String> test = null;\n        assertThrows(IllegalArgumentException.class, () -> new NameFileFilter(test));\n    }\n\n    @Test\n    public void testNegate() throws Exception {\n        final IOFileFilter filter = FileFilterUtils.notFileFilter(FileFilterUtils.trueFileFilter());\n        assertFiltering(filter, new File(\"foo.test\"), false);\n        assertFiltering(filter, new File(\"foo\"), false);\n        assertFiltering(filter.negate(), new File(\"foo\"), true);\n        assertFiltering(filter, (File) null, false);\n        assertThrows(IllegalArgumentException.class, () -> new NotFileFilter(null));\n    }\n\n    @Test\n    public void testNullFilters() {\n        try {\n            FileFilterUtils.toList((IOFileFilter) null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException ignore) {\n            // expected\n        }\n        try {\n            FileFilterUtils.toList(new IOFileFilter[] {null});\n            fail(\"Expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException ignore) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testOr() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        final File testFile = new File(\"foo.test\");\n        final Path testPath = testFile.toPath();\n        assertFiltering(new OrFileFilter(trueFilter, trueFilter), testFile, true);\n        assertFiltering(new OrFileFilter(trueFilter, falseFilter), testFile, true);\n        assertFiltering(new OrFileFilter(falseFilter, trueFilter), testFile, true);\n        assertFiltering(new OrFileFilter(falseFilter, falseFilter), testFile, false);\n        assertFiltering(new OrFileFilter(), testFile, false);\n        //\n        assertFiltering(new OrFileFilter(trueFilter, trueFilter), testPath, true);\n        assertFiltering(new OrFileFilter(trueFilter, falseFilter), testPath, true);\n        assertFiltering(new OrFileFilter(falseFilter, trueFilter), testPath, true);\n        assertFiltering(new OrFileFilter(falseFilter, falseFilter), testPath, false);\n        assertFiltering(new OrFileFilter(), testPath, false);\n        //\n        assertFiltering(falseFilter.or(trueFilter), testPath, true);\n        assertFiltering(falseFilter.or(falseFilter, trueFilter), testPath, true);\n        assertFiltering(falseFilter.or(falseFilter, falseFilter, trueFilter), testPath, true);\n\n        final List<IOFileFilter> filters = new ArrayList<>();\n        filters.add(trueFilter);\n        filters.add(falseFilter);\n\n        final OrFileFilter orFilter = new OrFileFilter(filters);\n\n        assertFiltering(orFilter, testFile, true);\n        assertFiltering(orFilter, testPath, true);\n        assertEquals(orFilter.getFileFilters(), filters);\n        orFilter.removeFileFilter(trueFilter);\n        assertFiltering(orFilter, testFile, false);\n        assertFiltering(orFilter, testPath, false);\n        orFilter.setFileFilters(filters);\n        assertFiltering(orFilter, testFile, true);\n        assertFiltering(orFilter, testPath, true);\n\n        assertTrue(orFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertEquals(FileVisitResult.CONTINUE, orFilter.accept(testPath, null));\n        orFilter.removeFileFilter(trueFilter);\n        assertTrue(!orFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertEquals(FileVisitResult.TERMINATE, orFilter.accept(testPath, null));\n\n        try {\n            new OrFileFilter(falseFilter, (IOFileFilter) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n        }\n\n        final OrFileFilter f = new OrFileFilter((List<IOFileFilter>) null);\n        assertTrue(f.getFileFilters().isEmpty());\n    }\n\n    @Test\n    public void testPrefix() throws Exception {\n        IOFileFilter filter = new PrefixFileFilter(new String[] {\"foo\", \"bar\"});\n        final File testFile = new File(\"test\");\n        final Path testPath = testFile.toPath();\n        final File fredFile = new File(\"fred\");\n        final Path fredPath = fredFile.toPath();\n\n        assertFiltering(filter, new File(\"foo.test\"), true);\n        assertFiltering(filter, new File(\"FOO.test\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"food/\"), true);\n        //\n        assertFiltering(filter, new File(\"foo.test\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO.test\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"food/\").toPath(), true);\n\n        filter = FileFilterUtils.prefixFileFilter(\"bar\");\n        assertFiltering(filter, new File(\"barred\\\\\"), true);\n        assertFiltering(filter, new File(\"test\"), false);\n        assertFiltering(filter, new File(\"fo_o.test\"), false);\n        assertFiltering(filter, new File(\"abar.exe\"), false);\n        //\n        assertFiltering(filter, new File(\"barred\\\\\").toPath(), true);\n        assertFiltering(filter, new File(\"test\").toPath(), false);\n        assertFiltering(filter, new File(\"fo_o.test\").toPath(), false);\n        assertFiltering(filter, new File(\"abar.exe\").toPath(), false);\n\n        filter = new PrefixFileFilter(\"tes\");\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        //\n        assertFiltering(filter, new File(\"test\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        assertTrue(filter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(!filter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, filter.accept(testPath, null));\n        assertEquals(FileVisitResult.TERMINATE, filter.accept(fredPath, null));\n\n        final List<String> prefixes = Arrays.asList(\"foo\", \"fre\");\n        final IOFileFilter listFilter = new PrefixFileFilter(prefixes);\n\n        assertTrue(!listFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(listFilter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(testPath, null));\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(fredPath, null));\n\n        try {\n            new PrefixFileFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testPrefixCaseInsensitive() throws Exception {\n\n        IOFileFilter filter = new PrefixFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test1\"), true);\n        assertFiltering(filter, new File(\"bar.test1\"), true);\n        assertFiltering(filter, new File(\"FOO.test1\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test1\"), true); // case-sensitive\n\n        filter = new PrefixFileFilter(\"bar\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test2\"), false);\n        assertFiltering(filter, new File(\"bar.test2\"), true);\n        assertFiltering(filter, new File(\"FOO.test2\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test2\"), true); // case-sensitive\n\n        final List<String> prefixes = Arrays.asList(\"foo\", \"bar\");\n        filter = new PrefixFileFilter(prefixes, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test3\"), true);\n        assertFiltering(filter, new File(\"bar.test3\"), true);\n        assertFiltering(filter, new File(\"FOO.test3\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test3\"), true); // case-sensitive\n\n        try {\n            new PrefixFileFilter((String) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((String[]) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((List<String>) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        // FileFilterUtils.prefixFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.prefixFileFilter(\"bar\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test2\"), false);\n        assertFiltering(filter, new File(\"bar.test2\"), true);\n        assertFiltering(filter, new File(\"FOO.test2\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test2\"), true); // case-sensitive\n\n        try {\n            FileFilterUtils.prefixFileFilter(null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testSizeFilterOnFiles() throws Exception {\n        final File smallFile = new File(temporaryFolder, \"small.txt\");\n        if (!smallFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + smallFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(smallFile))) {\n            TestUtils.generateTestData(output1, 32);\n        }\n        final File largeFile = new File(temporaryFolder, \"large.txt\");\n        if (!largeFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + largeFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(largeFile))) {\n            TestUtils.generateTestData(output, 128);\n        }\n        final IOFileFilter filter1 = FileFilterUtils.sizeFileFilter(64);\n        final IOFileFilter filter2 = FileFilterUtils.sizeFileFilter(64, true);\n        final IOFileFilter filter3 = FileFilterUtils.sizeFileFilter(64, false);\n\n        assertFiltering(filter1, smallFile, false);\n        assertFiltering(filter2, smallFile, false);\n        assertFiltering(filter3, smallFile, true);\n        assertFiltering(filter1, largeFile, true);\n        assertFiltering(filter2, largeFile, true);\n        assertFiltering(filter3, largeFile, false);\n\n        // size range tests\n        final IOFileFilter filter4 = FileFilterUtils.sizeRangeFileFilter(33, 127);\n        final IOFileFilter filter5 = FileFilterUtils.sizeRangeFileFilter(32, 127);\n        final IOFileFilter filter6 = FileFilterUtils.sizeRangeFileFilter(33, 128);\n        final IOFileFilter filter7 = FileFilterUtils.sizeRangeFileFilter(31, 129);\n        final IOFileFilter filter8 = FileFilterUtils.sizeRangeFileFilter(128, 128);\n\n        assertFiltering(filter4, smallFile, false);\n        assertFiltering(filter4, largeFile, false);\n        assertFiltering(filter5, smallFile, true);\n        assertFiltering(filter5, largeFile, false);\n        assertFiltering(filter6, smallFile, false);\n        assertFiltering(filter6, largeFile, true);\n        assertFiltering(filter7, smallFile, true);\n        assertFiltering(filter7, largeFile, true);\n        assertFiltering(filter8, largeFile, true);\n\n        try {\n            FileFilterUtils.sizeFileFilter(-1);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testSizeFilterOnPaths() throws Exception {\n        final Path smallFile = Paths.get(temporaryFolder.toString(), \"small.txt\");\n        if (!Files.exists(smallFile.getParent())) {\n            throw new IOException(\"Cannot create file \" + smallFile + \" as the parent directory does not exist\");\n        }\n        try (OutputStream output = Files.newOutputStream(smallFile)) {\n            TestUtils.generateTestData(output, 32);\n        }\n        final Path largeFile = Paths.get(temporaryFolder.toString(), \"large.txt\");\n        if (!Files.exists(largeFile.getParent())) {\n            throw new IOException(\"Cannot create file \" + largeFile + \" as the parent directory does not exist\");\n        }\n        try (OutputStream output = Files.newOutputStream(largeFile)) {\n            TestUtils.generateTestData(output, 128);\n        }\n        final IOFileFilter filter1 = FileFilterUtils.sizeFileFilter(64);\n        final IOFileFilter filter2 = FileFilterUtils.sizeFileFilter(64, true);\n        final IOFileFilter filter3 = FileFilterUtils.sizeFileFilter(64, false);\n\n        assertFiltering(filter1, smallFile, false);\n        assertFiltering(filter2, smallFile, false);\n        assertFiltering(filter3, smallFile, true);\n        assertFiltering(filter1, largeFile, true);\n        assertFiltering(filter2, largeFile, true);\n        assertFiltering(filter3, largeFile, false);\n\n        // size range tests\n        final IOFileFilter filter4 = FileFilterUtils.sizeRangeFileFilter(33, 127);\n        final IOFileFilter filter5 = FileFilterUtils.sizeRangeFileFilter(32, 127);\n        final IOFileFilter filter6 = FileFilterUtils.sizeRangeFileFilter(33, 128);\n        final IOFileFilter filter7 = FileFilterUtils.sizeRangeFileFilter(31, 129);\n        final IOFileFilter filter8 = FileFilterUtils.sizeRangeFileFilter(128, 128);\n\n        assertFiltering(filter4, smallFile, false);\n        assertFiltering(filter4, largeFile, false);\n        assertFiltering(filter5, smallFile, true);\n        assertFiltering(filter5, largeFile, false);\n        assertFiltering(filter6, smallFile, false);\n        assertFiltering(filter6, largeFile, true);\n        assertFiltering(filter7, smallFile, true);\n        assertFiltering(filter7, largeFile, true);\n        assertFiltering(filter8, largeFile, true);\n\n        try {\n            FileFilterUtils.sizeFileFilter(-1);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testSuffix() throws Exception {\n        IOFileFilter filter = new SuffixFileFilter(new String[] {\"tes\", \"est\"});\n        final File testFile = new File(\"test\");\n        final Path testPath = testFile.toPath();\n        final File fredFile = new File(\"fred\");\n        final Path fredPath = fredFile.toPath();\n        //\n        assertFiltering(filter, new File(\"fred.tes\"), true);\n        assertFiltering(filter, new File(\"fred.est\"), true);\n        assertFiltering(filter, new File(\"fred.EST\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"fred.exe\"), false);\n        //\n        assertFiltering(filter, new File(\"fred.tes\").toPath(), true);\n        assertFiltering(filter, new File(\"fred.est\").toPath(), true);\n        assertFiltering(filter, new File(\"fred.EST\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"fred.exe\").toPath(), false);\n\n        filter = FileFilterUtils.or(FileFilterUtils.suffixFileFilter(\"tes\"), FileFilterUtils.suffixFileFilter(\"est\"));\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\".tes\"), true);\n        assertFiltering(filter, new File(\"fred.test\"), true);\n        //\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n        assertFiltering(filter, new File(\".tes\").toPath(), true);\n        assertFiltering(filter, new File(\"fred.test\").toPath(), true);\n\n        filter = new SuffixFileFilter(\"est\");\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        //\n        assertFiltering(filter, new File(\"test\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        assertTrue(filter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(!filter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, filter.accept(testPath, null));\n        assertEquals(FileVisitResult.TERMINATE, filter.accept(fredPath, null));\n\n        final List<String> prefixes = Arrays.asList(\"ood\", \"red\");\n        final IOFileFilter listFilter = new SuffixFileFilter(prefixes);\n\n        assertTrue(!listFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(listFilter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(testPath, null));\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(fredPath, null));\n\n        try {\n            new SuffixFileFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testSuffixCaseInsensitive() throws Exception {\n\n        IOFileFilter filter = new SuffixFileFilter(new String[] {\"tes\", \"est\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.tes\"), true);\n        assertFiltering(filter, new File(\"foo.est\"), true);\n        assertFiltering(filter, new File(\"foo.EST\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"foo.TES\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"foo.exe\"), false);\n\n        filter = new SuffixFileFilter(\"est\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"TEST\"), true);\n\n        final List<String> suffixes = Arrays.asList(\"tes\", \"est\");\n        filter = new SuffixFileFilter(suffixes, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"bar.tes\"), true);\n        assertFiltering(filter, new File(\"bar.est\"), true);\n        assertFiltering(filter, new File(\"bar.EST\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"bar.TES\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"bar.exe\"), false);\n\n        try {\n            new SuffixFileFilter((String) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((String[]) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((List<String>) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        // FileFilterUtils.suffixFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.suffixFileFilter(\"est\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"TEST\"), true);\n\n        try {\n            FileFilterUtils.suffixFileFilter(null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n        }\n    }\n\n    @Test\n    public void testTrue() throws Exception {\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        assertFiltering(filter, new File(\"foo.test\"), true);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, (File) null, true);\n        //\n        assertFiltering(filter, new File(\"foo.test\").toPath(), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, (Path) null, true);\n        //\n        assertSame(TrueFileFilter.TRUE, TrueFileFilter.INSTANCE);\n        assertSame(FalseFileFilter.FALSE, TrueFileFilter.INSTANCE.negate());\n        assertSame(FalseFileFilter.INSTANCE, TrueFileFilter.INSTANCE.negate());\n    }\n\n    @Test\n    public void testWildcard() throws Exception {\n        IOFileFilter filter = new WildcardFileFilter(\"*.txt\");\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), false);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), false);\n\n        filter = new WildcardFileFilter(\"*.txt\", IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), false);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), false);\n\n        filter = new WildcardFileFilter(\"*.txt\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), true);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), true);\n\n        filter = new WildcardFileFilter(\"*.txt\", IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), WINDOWS);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), WINDOWS);\n\n        filter = new WildcardFileFilter(\"*.txt\", null);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), false);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), false);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"});\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.class\"), true);\n        assertFiltering(filter, new File(\"Test.jsp\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.class\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.jsp\").toPath(), false);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), false);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), true);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), true);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), WINDOWS);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), WINDOWS);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, null);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), false);\n\n        final List<String> patternList = Arrays.asList(\"*.txt\", \"*.xml\", \"*.gif\");\n        final IOFileFilter listFilter = new WildcardFileFilter(patternList);\n        assertFiltering(listFilter, new File(\"Test.txt\"), true);\n        assertFiltering(listFilter, new File(\"Test.xml\"), true);\n        assertFiltering(listFilter, new File(\"Test.gif\"), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\"), false);\n        //\n        assertFiltering(listFilter, new File(\"Test.txt\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.xml\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.gif\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\").toPath(), false);\n\n        final File txtFile = new File(\"test.txt\");\n        final Path txtPath = txtFile.toPath();\n        final File bmpFile = new File(\"test.bmp\");\n        final Path bmpPath = bmpFile.toPath();\n        final File dirFile = new File(\"src/java\");\n        final Path dirPath = dirFile.toPath();\n        assertTrue(listFilter.accept(txtFile));\n        assertTrue(!listFilter.accept(bmpFile));\n        assertTrue(!listFilter.accept(dirFile));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtFile.toPath(), null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpFile.toPath(), null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirFile.toPath(), null));\n\n        assertTrue(listFilter.accept(txtFile.getParentFile(), txtFile.getName()));\n        assertTrue(!listFilter.accept(bmpFile.getParentFile(), bmpFile.getName()));\n        assertTrue(!listFilter.accept(dirFile.getParentFile(), dirFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirPath, null));\n\n        try {\n            new WildcardFileFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n        try {\n            new WildcardFileFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n        try {\n            new WildcardFileFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/filefilter/FileFilterTestCase.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.junit.jupiter.api.Assumptions.assumeTrue;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOCase;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.file.PathUtils;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Used to test FileFilterUtils.\n */\npublic class FileFilterTestCase {\n\n    /**\n     * The subversion directory name.\n     */\n    static final String SVN_DIR_NAME = \".svn\";\n\n    private static final boolean WINDOWS = File.separatorChar == '\\\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    void assertFiltering(final IOFileFilter filter, final File file, final boolean expected) {\n        // Note. This only tests the (File, String) version if the parent of\n        // the File passed in is not null\n        assertEquals(expected, filter.accept(file),\n            \"Filter(File) \" + filter.getClass().getName() + \" not \" + expected + \" for \" + file);\n\n        if (file != null && file.getParentFile() != null) {\n            assertEquals(expected, filter.accept(file.getParentFile(), file.getName()),\n                \"Filter(File, String) \" + filter.getClass().getName() + \" not \" + expected + \" for \" + file);\n        } else if (file == null) {\n            assertEquals(expected, filter.accept(file),\n                \"Filter(File, String) \" + filter.getClass().getName() + \" not \" + expected + \" for null\");\n        }\n        assertNotNull(filter.toString());\n    }\n\n    void assertFiltering(final IOFileFilter filter, final Path path, final boolean expected) {\n        // Note. This only tests the (Path, Path) version if the parent of\n        // the File passed in is not null\n        final FileVisitResult expectedFileVisitResult = AbstractFileFilter.toFileVisitResult(expected, path);\n        assertEquals(expectedFileVisitResult, filter.accept(path, null),\n            \"Filter(Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\n\n        if (path != null && path.getParent() != null) {\n            assertEquals(expectedFileVisitResult, filter.accept(path, null),\n                \"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \"\n                    + path);\n        } else if (path == null) {\n            assertEquals(expectedFileVisitResult, filter.accept(path, null),\n                \"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for null\");\n        }\n        assertNotNull(filter.toString());\n    }\n\n    @Test\n    public void testAgeFilter() throws Exception {\n        final File oldFile = new File(temporaryFolder, \"old.txt\");\n        final Path oldPath = oldFile.toPath();\n        final File reference = new File(temporaryFolder, \"reference.txt\");\n        final File newFile = new File(temporaryFolder, \"new.txt\");\n        final Path newPath = newFile.toPath();\n\n        if (!oldFile.getParentFile().exists()) {\n            fail(\"Cannot create file \" + oldFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(oldFile))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n\n        do {\n            try {\n                TestUtils.sleep(1000);\n            } catch (final InterruptedException ie) {\n                // ignore\n            }\n            if (!reference.getParentFile().exists()) {\n                fail(\"Cannot create file \" + reference + \" as the parent directory does not exist\");\n            }\n            try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(reference))) {\n                TestUtils.generateTestData(output, 0);\n            }\n        } while (oldFile.lastModified() == reference.lastModified());\n\n        final Date date = new Date();\n        final long now = date.getTime();\n\n        do {\n            try {\n                TestUtils.sleep(1000);\n            } catch (final InterruptedException ie) {\n                // ignore\n            }\n            if (!newFile.getParentFile().exists()) {\n                fail(\"Cannot create file \" + newFile + \" as the parent directory does not exist\");\n            }\n            try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(newFile))) {\n                TestUtils.generateTestData(output, 0);\n            }\n        } while (reference.lastModified() == newFile.lastModified());\n\n        final IOFileFilter filter1 = FileFilterUtils.ageFileFilter(now);\n        final IOFileFilter filter2 = FileFilterUtils.ageFileFilter(now, true);\n        final IOFileFilter filter3 = FileFilterUtils.ageFileFilter(now, false);\n        final IOFileFilter filter4 = FileFilterUtils.ageFileFilter(date);\n        final IOFileFilter filter5 = FileFilterUtils.ageFileFilter(date, true);\n        final IOFileFilter filter6 = FileFilterUtils.ageFileFilter(date, false);\n        final IOFileFilter filter7 = FileFilterUtils.ageFileFilter(reference);\n        final IOFileFilter filter8 = FileFilterUtils.ageFileFilter(reference, true);\n        final IOFileFilter filter9 = FileFilterUtils.ageFileFilter(reference, false);\n\n        assertFiltering(filter1, oldFile, true);\n        assertFiltering(filter2, oldFile, true);\n        assertFiltering(filter3, oldFile, false);\n        assertFiltering(filter4, oldFile, true);\n        assertFiltering(filter5, oldFile, true);\n        assertFiltering(filter6, oldFile, false);\n        assertFiltering(filter7, oldFile, true);\n        assertFiltering(filter8, oldFile, true);\n        assertFiltering(filter9, oldFile, false);\n        assertFiltering(filter1, newFile, false);\n        assertFiltering(filter2, newFile, false);\n        assertFiltering(filter3, newFile, true);\n        assertFiltering(filter4, newFile, false);\n        assertFiltering(filter5, newFile, false);\n        assertFiltering(filter6, newFile, true);\n        assertFiltering(filter7, newFile, false);\n        assertFiltering(filter8, newFile, false);\n        assertFiltering(filter9, newFile, true);\n        //\n        assertFiltering(filter1, oldPath, true);\n        assertFiltering(filter2, oldPath, true);\n        assertFiltering(filter3, oldPath, false);\n        assertFiltering(filter4, oldPath, true);\n        assertFiltering(filter5, oldPath, true);\n        assertFiltering(filter6, oldPath, false);\n        assertFiltering(filter7, oldPath, true);\n        assertFiltering(filter8, oldPath, true);\n        assertFiltering(filter9, oldPath, false);\n        assertFiltering(filter1, newPath, false);\n        assertFiltering(filter2, newPath, false);\n        assertFiltering(filter3, newPath, true);\n        assertFiltering(filter4, newPath, false);\n        assertFiltering(filter5, newPath, false);\n        assertFiltering(filter6, newPath, true);\n        assertFiltering(filter7, newPath, false);\n        assertFiltering(filter8, newPath, false);\n        assertFiltering(filter9, newPath, true);\n    }\n\n    @Test\n    public void testAnd() {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(trueFilter.and(trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(trueFilter.and(falseFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter, trueFilter, trueFilter), new File(\"foo.test\"), false);\n    }\n\n    @Test\n    public void testAnd2() {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(new AndFileFilter(trueFilter, trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(new AndFileFilter(trueFilter, falseFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, falseFilter), new File(\"foo.test\"), false);\n\n        final List<IOFileFilter> filters = new ArrayList<>();\n        assertFiltering(new AndFileFilter(filters), new File(\"test\"), false);\n        assertFiltering(new AndFileFilter(), new File(\"test\"), false);\n\n        assertThrows(IllegalArgumentException.class, () -> new AndFileFilter(falseFilter, (IOFileFilter) null));\n        assertThrows(IllegalArgumentException.class, () -> new AndFileFilter(null, falseFilter));\n\n        final AndFileFilter f = new AndFileFilter((List<IOFileFilter>) null);\n        assertTrue(f.getFileFilters().isEmpty());\n\n        assertNotNull(f.toString()); // TODO better tests\n    }\n\n    @Test\n    public void testAndArray() {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(new AndFileFilter(trueFilter, trueFilter, trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(new AndFileFilter(trueFilter, falseFilter, falseFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, trueFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, falseFilter, falseFilter), new File(\"foo.test\"), false);\n\n        final List<IOFileFilter> filters = new ArrayList<>();\n        assertFiltering(new AndFileFilter(filters), new File(\"test\"), false);\n        assertFiltering(new AndFileFilter(), new File(\"test\"), false);\n    }\n\n    @Test\n    public void testCanExecute() throws Exception {\n        assumeTrue(SystemUtils.IS_OS_WINDOWS);\n        final File executableFile = File.createTempFile(getClass().getSimpleName(), \".temp\");\n        final Path executablePath = executableFile.toPath();\n        try {\n            try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(executableFile))) {\n                TestUtils.generateTestData(output, 32);\n            }\n            assertTrue(executableFile.setExecutable(true));\n            assertFiltering(CanExecuteFileFilter.CAN_EXECUTE, executableFile, true);\n            assertFiltering(CanExecuteFileFilter.CAN_EXECUTE, executablePath, true);\n            executableFile.setExecutable(false);\n            assertFiltering(CanExecuteFileFilter.CANNOT_EXECUTE, executableFile, false);\n            assertFiltering(CanExecuteFileFilter.CANNOT_EXECUTE, executablePath, false);\n        } finally {\n            executableFile.delete();\n        }\n    }\n\n    @Test\n    public void testCanRead() throws Exception {\n        final File readOnlyFile = new File(temporaryFolder, \"read-only-file1.txt\");\n        final Path readOnlyPath = readOnlyFile.toPath();\n        if (!readOnlyFile.getParentFile().exists()) {\n            fail(\"Cannot create file \" + readOnlyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(readOnlyFile))) {\n            TestUtils.generateTestData(output, 32);\n        }\n        assertTrue(readOnlyFile.setReadOnly());\n        assertFiltering(CanReadFileFilter.CAN_READ, readOnlyFile, true);\n        assertFiltering(CanReadFileFilter.CAN_READ, readOnlyPath, true);\n        assertFiltering(CanReadFileFilter.CANNOT_READ, readOnlyFile, false);\n        assertFiltering(CanReadFileFilter.CANNOT_READ, readOnlyPath, false);\n        assertFiltering(CanReadFileFilter.READ_ONLY, readOnlyFile, true);\n        assertFiltering(CanReadFileFilter.READ_ONLY, readOnlyPath, true);\n        readOnlyFile.delete();\n    }\n\n    @Test\n    public void testCanWrite() throws Exception {\n        final File readOnlyFile = new File(temporaryFolder, \"read-only-file2.txt\");\n        final Path readOnlyPath = readOnlyFile.toPath();\n        if (!readOnlyFile.getParentFile().exists()) {\n            fail(\"Cannot create file \" + readOnlyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(readOnlyFile))) {\n            TestUtils.generateTestData(output, 32);\n        }\n        assertTrue(readOnlyFile.setReadOnly());\n        assertFiltering(CanWriteFileFilter.CAN_WRITE, temporaryFolder, true);\n        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, temporaryFolder, false);\n        assertFiltering(CanWriteFileFilter.CAN_WRITE, readOnlyFile, false);\n        assertFiltering(CanWriteFileFilter.CAN_WRITE, readOnlyPath, false);\n        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, readOnlyFile, true);\n        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, readOnlyPath, true);\n        readOnlyFile.delete();\n    }\n\n    @Test\n    public void testDelegateFileFilter() {\n        final OrFileFilter orFilter = new OrFileFilter();\n        final File testFile = new File(\"test.txt\");\n\n        IOFileFilter filter = new DelegateFileFilter((FileFilter) orFilter);\n        assertFiltering(filter, testFile, false);\n        assertNotNull(filter.toString()); // TODO better test\n\n        filter = new DelegateFileFilter((FilenameFilter) orFilter);\n        assertFiltering(filter, testFile, false);\n        assertNotNull(filter.toString()); // TODO better test\n\n        try {\n            new DelegateFileFilter((FileFilter) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new DelegateFileFilter((FilenameFilter) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n    }\n\n    @Test\n    public void testDelegation() { // TODO improve these tests\n        assertNotNull(FileFilterUtils.asFileFilter((FileFilter) FalseFileFilter.INSTANCE));\n        assertNotNull(FileFilterUtils.asFileFilter((FilenameFilter) FalseFileFilter.INSTANCE).toString());\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testDeprecatedWildcard() {\n        IOFileFilter filter = new WildcardFilter(\"*.txt\");\n        final List<String> patternList = Arrays.asList(\"*.txt\", \"*.xml\", \"*.gif\");\n        final IOFileFilter listFilter = new WildcardFilter(patternList);\n        final File txtFile = new File(\"test.txt\");\n        final Path txtPath = txtFile.toPath();\n        final File bmpFile = new File(\"test.bmp\");\n        final Path bmpPath = bmpFile.toPath();\n        final File dirFile = new File(\"src/java\");\n        final Path dirPath = dirFile.toPath();\n\n        assertFiltering(filter, new File(\"log.txt\"), true);\n//        assertFiltering(filter, new File(\"log.txt.bak\"), false);\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n\n        filter = new WildcardFilter(\"log?.txt\");\n        assertFiltering(filter, new File(\"log1.txt\"), true);\n        assertFiltering(filter, new File(\"log12.txt\"), false);\n        //\n        assertFiltering(filter, new File(\"log1.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log12.txt\").toPath(), false);\n\n        filter = new WildcardFilter(\"open??.????04\");\n        assertFiltering(filter, new File(\"openAB.102504\"), true);\n        assertFiltering(filter, new File(\"openA.102504\"), false);\n        assertFiltering(filter, new File(\"openXY.123103\"), false);\n//        assertFiltering(filter, new File(\"openAB.102504.old\"), false);\n        //\n        assertFiltering(filter, new File(\"openAB.102504\").toPath(), true);\n        assertFiltering(filter, new File(\"openA.102504\").toPath(), false);\n        assertFiltering(filter, new File(\"openXY.123103\").toPath(), false);\n//        assertFiltering(filter, new File(\"openAB.102504.old\").toPath(), false);\n\n        filter = new WildcardFilter(new String[] {\"*.java\", \"*.class\"});\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.class\"), true);\n        assertFiltering(filter, new File(\"Test.jsp\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.class\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.jsp\").toPath(), false);\n\n        assertFiltering(listFilter, new File(\"Test.txt\"), true);\n        assertFiltering(listFilter, new File(\"Test.xml\"), true);\n        assertFiltering(listFilter, new File(\"Test.gif\"), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\"), false);\n        //\n        assertFiltering(listFilter, new File(\"Test.txt\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.xml\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.gif\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\").toPath(), false);\n\n        assertTrue(listFilter.accept(txtFile));\n        assertTrue(!listFilter.accept(bmpFile));\n        assertTrue(!listFilter.accept(dirFile));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirPath, null));\n\n        assertTrue(listFilter.accept(txtFile.getParentFile(), txtFile.getName()));\n        assertTrue(!listFilter.accept(bmpFile.getParentFile(), bmpFile.getName()));\n        assertTrue(!listFilter.accept(dirFile.getParentFile(), dirFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirPath, null));\n\n        try {\n            new WildcardFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n\n        try {\n            new WildcardFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n\n        try {\n            new WildcardFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testDirectory() {\n        // XXX: This test presumes the current working dir is the base dir of the source checkout.\n        final IOFileFilter filter = new DirectoryFileFilter();\n\n        assertFiltering(filter, new File(\"src/\"), true);\n        assertFiltering(filter, new File(\"src/\").toPath(), true);\n        assertFiltering(filter, new File(\"src/main/java/\"), true);\n        assertFiltering(filter, new File(\"src/main/java/\").toPath(), true);\n\n        assertFiltering(filter, new File(\"pom.xml\"), false);\n        assertFiltering(filter, new File(\"pom.xml\").toPath(), false);\n\n        assertFiltering(filter, new File(\"imaginary\"), false);\n        assertFiltering(filter, new File(\"imaginary\").toPath(), false);\n        assertFiltering(filter, new File(\"imaginary/\"), false);\n        assertFiltering(filter, new File(\"imaginary/\").toPath(), false);\n\n        assertFiltering(filter, new File(\"LICENSE.txt\"), false);\n        assertFiltering(filter, new File(\"LICENSE.txt\").toPath(), false);\n\n        assertSame(DirectoryFileFilter.DIRECTORY, DirectoryFileFilter.INSTANCE);\n    }\n\n    @Test\n    public void testEmpty() throws Exception {\n\n        // Empty Dir\n        final File emptyDirFile = new File(temporaryFolder, \"empty-dir\");\n        final Path emptyDirPath = emptyDirFile.toPath();\n        emptyDirFile.mkdirs();\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirFile, true);\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirPath, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirFile, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirPath, false);\n\n        // Empty File\n        final File emptyFile = new File(emptyDirFile, \"empty-file.txt\");\n        final Path emptyPath = emptyFile.toPath();\n        if (!emptyFile.getParentFile().exists()) {\n            fail(\"Cannot create file \" + emptyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(emptyFile))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n        assertFiltering(EmptyFileFilter.EMPTY, emptyFile, true);\n        assertFiltering(EmptyFileFilter.EMPTY, emptyPath, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyFile, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyPath, false);\n\n        // Not Empty Dir\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirFile, false);\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirPath, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirFile, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirPath, true);\n\n        // Not Empty File\n        final File notEmptyFile = new File(emptyDirFile, \"not-empty-file.txt\");\n        final Path notEmptyPath = notEmptyFile.toPath();\n        if (!notEmptyFile.getParentFile().exists()) {\n            fail(\"Cannot create file \" + notEmptyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(notEmptyFile))) {\n            TestUtils.generateTestData(output, 32);\n        }\n        assertFiltering(EmptyFileFilter.EMPTY, notEmptyFile, false);\n        assertFiltering(EmptyFileFilter.EMPTY, notEmptyPath, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, notEmptyFile, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, notEmptyPath, true);\n        FileUtils.forceDelete(emptyDirFile);\n    }\n\n    @Test\n    public void testEnsureTestCoverage() {\n        assertNotNull(new FileFilterUtils()); // dummy for test coverage\n    }\n\n    @Test\n    public void testFalse() {\n        final IOFileFilter filter = FileFilterUtils.falseFileFilter();\n        assertFiltering(filter, new File(\"foo.test\"), false);\n        assertFiltering(filter, new File(\"foo.test\").toPath(), false);\n        assertFiltering(filter, new File(\"foo\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), false);\n        assertFiltering(filter, (File) null, false);\n        assertFiltering(filter, (Path) null, false);\n        assertSame(FalseFileFilter.FALSE, FalseFileFilter.INSTANCE);\n        assertSame(TrueFileFilter.TRUE, FalseFileFilter.INSTANCE.negate());\n        assertSame(TrueFileFilter.INSTANCE, FalseFileFilter.INSTANCE.negate());\n    }\n\n    @Test\n    public void testFileFilterUtils_and() {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(FileFilterUtils.and(trueFilter, trueFilter, trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(FileFilterUtils.and(trueFilter, falseFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(FileFilterUtils.and(falseFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(FileFilterUtils.and(falseFilter, falseFilter), new File(\"foo.test\"), false);\n    }\n\n    @Test\n    public void testFileFilterUtils_or() {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        final File testFile = new File(\"foo.test\");\n        assertFiltering(FileFilterUtils.or(trueFilter, trueFilter), testFile, true);\n        assertFiltering(FileFilterUtils.or(trueFilter, trueFilter, falseFilter), testFile, true);\n        assertFiltering(FileFilterUtils.or(falseFilter, trueFilter), testFile, true);\n        assertFiltering(FileFilterUtils.or(falseFilter, falseFilter, falseFilter), testFile, false);\n    }\n\n    @Test\n    public void testFiles() {\n        // XXX: This test presumes the current working dir is the base dir of the source checkout.\n        final IOFileFilter filter = FileFileFilter.INSTANCE;\n\n        assertFiltering(filter, new File(\"src/\"), false);\n        assertFiltering(filter, new File(\"src/\").toPath(), false);\n        assertFiltering(filter, new File(\"src/java/\"), false);\n        assertFiltering(filter, new File(\"src/java/\").toPath(), false);\n\n        assertFiltering(filter, new File(\"pom.xml\"), true);\n        assertFiltering(filter, new File(\"pom.xml\").toPath(), true);\n\n        assertFiltering(filter, new File(\"imaginary\"), false);\n        assertFiltering(filter, new File(\"imaginary\").toPath(), false);\n        assertFiltering(filter, new File(\"imaginary/\"), false);\n        assertFiltering(filter, new File(\"imaginary/\").toPath(), false);\n\n        assertFiltering(filter, new File(\"LICENSE.txt\"), true);\n        assertFiltering(filter, new File(\"LICENSE.txt\").toPath(), true);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, java.lang.Iterable)} that tests that the method\n     * properly filters files from the list.\n     */\n    @Test\n    public void testFilterArray_fromList() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        final List<File> fileList = Arrays.asList(fileA, fileB);\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileList);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests that the method properly filters\n     * files from the list.\n     */\n    @Test\n    public void testFilterArray_IOFileFilter() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileA, fileB);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests that the method properly filters\n     * files from the list.\n     */\n    @Test\n    public void testFilterArray_PathVisitorFileFilter_FileExistsNo() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = new PathVisitorFileFilter(new NameFileFilter(\"A\"));\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileA, fileB);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests that the method properly filters\n     * files from the list.\n     */\n    @Test\n    public void testFilterArray_PathVisitorFileFilter_FileExistsYes() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        FileUtils.write(fileA, \"test\", StandardCharsets.US_ASCII);\n\n        final IOFileFilter filter = new PathVisitorFileFilter(new NameFileFilter(\"A\"));\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileA, fileB);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests {@code null} parameters.\n     */\n    @Test\n    public void testFilterFilesArrayNullParameters() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        try {\n            FileFilterUtils.filter(null, fileA, fileB);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        FileFilterUtils.filter(filter, fileA, null);\n\n        final File[] filtered = FileFilterUtils.filter(filter, (File[]) null);\n        assertEquals(0, filtered.length);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterList(IOFileFilter, java.lang.Iterable)} that tests that the method\n     * properly filters files from the list.\n     */\n    @Test\n    public void testFilterList() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        final List<File> fileList = Arrays.asList(fileA, fileB);\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final List<File> filteredList = FileFilterUtils.filterList(filter, fileList);\n\n        assertTrue(filteredList.contains(fileA));\n        assertFalse(filteredList.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterList(IOFileFilter, File...)} that tests that the method properly\n     * filters files from the list.\n     */\n    @Test\n    public void testFilterList_fromArray() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final List<File> filteredList = FileFilterUtils.filterList(filter, fileA, fileB);\n\n        assertTrue(filteredList.contains(fileA));\n        assertFalse(filteredList.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterList(IOFileFilter, java.lang.Iterable)} that tests {@code null}\n     * parameters and {@code null} elements in the provided list.\n     */\n    @Test\n    public void testFilterListNullParameters() {\n        try {\n            FileFilterUtils.filterList(null, Collections.<File>emptyList());\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        try {\n            FileFilterUtils.filterList(filter, Collections.singletonList((File) null));\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for list containing null\n        }\n\n        final List<File> filteredList = FileFilterUtils.filterList(filter, (List<File>) null);\n        assertEquals(0, filteredList.size());\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, Path...)}.\n     */\n    @Test\n    public void testFilterPathsArrayNullParameters() throws Exception {\n        final Path fileA = TestUtils.newFile(temporaryFolder, \"A\").toPath();\n        final Path fileB = TestUtils.newFile(temporaryFolder, \"B\").toPath();\n        try {\n            PathUtils.filter(null, fileA, fileB);\n            fail();\n        } catch (final NullPointerException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        PathUtils.filter(filter, fileA, null);\n\n        final File[] filtered = FileFilterUtils.filter(filter, (File[]) null);\n        assertEquals(0, filtered.length);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterSet(IOFileFilter, java.lang.Iterable)} that tests that the method\n     * properly filters files from the set.\n     */\n    @Test\n    public void testFilterSet() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        final Set<File> fileList = new HashSet<>(Arrays.asList(fileA, fileB));\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final Set<File> filteredSet = FileFilterUtils.filterSet(filter, fileList);\n\n        assertTrue(filteredSet.contains(fileA));\n        assertFalse(filteredSet.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterSet(IOFileFilter, File...)} that tests that the method properly\n     * filters files from the set.\n     */\n    @Test\n    public void testFilterSet_fromArray() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final Set<File> filteredSet = FileFilterUtils.filterSet(filter, fileA, fileB);\n\n        assertTrue(filteredSet.contains(fileA));\n        assertFalse(filteredSet.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterSet(IOFileFilter, java.lang.Iterable)} that tests {@code null}\n     * parameters and {@code null} elements in the provided set.\n     */\n    @Test\n    public void testFilterSetNullParameters() {\n        try {\n            FileFilterUtils.filterSet(null, Collections.<File>emptySet());\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        try {\n            FileFilterUtils.filterSet(filter, new HashSet<>(Collections.singletonList((File) null)));\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for set containing null\n        }\n\n        final Set<File> filteredSet = FileFilterUtils.filterSet(filter, (Set<File>) null);\n        assertEquals(0, filteredSet.size());\n    }\n\n    @Test\n    public void testHidden() {\n        final File hiddenDirFile = new File(SVN_DIR_NAME);\n        final Path hiddenDirPath = hiddenDirFile.toPath();\n        if (hiddenDirFile.exists()) {\n            assertFiltering(HiddenFileFilter.HIDDEN, hiddenDirFile, hiddenDirFile.isHidden());\n            assertFiltering(HiddenFileFilter.HIDDEN, hiddenDirPath, hiddenDirFile.isHidden());\n            assertFiltering(HiddenFileFilter.VISIBLE, hiddenDirFile, !hiddenDirFile.isHidden());\n            assertFiltering(HiddenFileFilter.VISIBLE, hiddenDirPath, !hiddenDirFile.isHidden());\n        }\n        final Path path = temporaryFolder.toPath();\n        assertFiltering(HiddenFileFilter.HIDDEN, temporaryFolder, false);\n        assertFiltering(HiddenFileFilter.HIDDEN, path, false);\n        assertFiltering(HiddenFileFilter.VISIBLE, temporaryFolder, true);\n        assertFiltering(HiddenFileFilter.VISIBLE, path, true);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterBytes() throws Exception {\n        final byte[] classFileMagicNumber = new byte[] {(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE};\n        final String xmlFileContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\">\\n\" + \"<element>text</element>\";\n\n        final File classAFile = new File(temporaryFolder, \"A.class\");\n        final Path classAPath = classAFile.toPath();\n        final File xmlBFile = new File(temporaryFolder, \"B.xml\");\n        final Path xmlBPath = xmlBFile.toPath();\n        final File emptyFile = new File(temporaryFolder, \"C.xml\");\n        final Path emptyPath = emptyFile.toPath();\n        final File dirFile = new File(temporaryFolder, \"D\");\n        final Path dirPath = dirFile.toPath();\n        dirFile.mkdirs();\n\n        try (final OutputStream classFileAStream = FileUtils.openOutputStream(classAFile)) {\n            IOUtils.write(classFileMagicNumber, classFileAStream);\n            TestUtils.generateTestData(classFileAStream, 32);\n        }\n\n        FileUtils.write(xmlBFile, xmlFileContent, StandardCharsets.UTF_8);\n        FileUtils.touch(emptyFile);\n\n        IOFileFilter filter = new MagicNumberFileFilter(classFileMagicNumber);\n\n        assertFiltering(filter, classAFile, true);\n        assertFiltering(filter, classAPath, true);\n        assertFiltering(filter, xmlBFile, false);\n        assertFiltering(filter, xmlBPath, false);\n        assertFiltering(filter, emptyFile, false);\n        assertFiltering(filter, emptyPath, false);\n        assertFiltering(filter, dirFile, false);\n        assertFiltering(filter, dirPath, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(classFileMagicNumber);\n\n        assertFiltering(filter, classAFile, true);\n        assertFiltering(filter, classAPath, true);\n        assertFiltering(filter, xmlBFile, false);\n        assertFiltering(filter, xmlBPath, false);\n        assertFiltering(filter, emptyFile, false);\n        assertFiltering(filter, emptyPath, false);\n        assertFiltering(filter, dirFile, false);\n        assertFiltering(filter, dirPath, false);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterBytesOffset() throws Exception {\n        final byte[] tarMagicNumber = new byte[] {0x75, 0x73, 0x74, 0x61, 0x72};\n        final long tarMagicNumberOffset = 257;\n\n        final File tarFileA = new File(temporaryFolder, \"A.tar\");\n        final File randomFileB = new File(temporaryFolder, \"B.txt\");\n        final File dir = new File(temporaryFolder, \"D\");\n        dir.mkdirs();\n\n        try (final OutputStream tarFileAStream = FileUtils.openOutputStream(tarFileA)) {\n            TestUtils.generateTestData(tarFileAStream, tarMagicNumberOffset);\n            IOUtils.write(tarMagicNumber, tarFileAStream);\n        }\n\n        if (!randomFileB.getParentFile().exists()) {\n            fail(\"Cannot create file \" + randomFileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(randomFileB))) {\n            TestUtils.generateTestData(output, 2 * tarMagicNumberOffset);\n        }\n\n        IOFileFilter filter = new MagicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterString() throws Exception {\n        final byte[] classFileMagicNumber = new byte[] {(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE};\n        final String xmlFileContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\">\\n\" + \"<element>text</element>\";\n        final String xmlMagicNumber = \"<?xml version=\\\"1.0\\\"\";\n\n        final File classFileA = new File(temporaryFolder, \"A.class\");\n        final File xmlFileB = new File(temporaryFolder, \"B.xml\");\n        final File dir = new File(temporaryFolder, \"D\");\n        dir.mkdirs();\n\n        try (final OutputStream classFileAStream = FileUtils.openOutputStream(classFileA)) {\n            IOUtils.write(classFileMagicNumber, classFileAStream);\n            TestUtils.generateTestData(classFileAStream, 32);\n        }\n\n        FileUtils.write(xmlFileB, xmlFileContent, StandardCharsets.UTF_8);\n\n        IOFileFilter filter = new MagicNumberFileFilter(xmlMagicNumber);\n\n        assertFiltering(filter, classFileA, false);\n        assertFiltering(filter, xmlFileB, true);\n        assertFiltering(filter, dir, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(xmlMagicNumber);\n\n        assertFiltering(filter, classFileA, false);\n        assertFiltering(filter, xmlFileB, true);\n        assertFiltering(filter, dir, false);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterStringOffset() throws Exception {\n        final String tarMagicNumber = \"ustar\";\n        final long tarMagicNumberOffset = 257;\n\n        final File tarFileA = new File(temporaryFolder, \"A.tar\");\n        final File randomFileB = new File(temporaryFolder, \"B.txt\");\n        final File dir = new File(temporaryFolder, \"D\");\n        dir.mkdirs();\n\n        try (final OutputStream tarFileAStream = FileUtils.openOutputStream(tarFileA)) {\n            TestUtils.generateTestData(tarFileAStream, tarMagicNumberOffset);\n            IOUtils.write(tarMagicNumber, tarFileAStream, StandardCharsets.UTF_8);\n        }\n\n        if (!randomFileB.getParentFile().exists()) {\n            fail(\"Cannot create file \" + randomFileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(randomFileB))) {\n            TestUtils.generateTestData(output, 2 * tarMagicNumberOffset);\n        }\n\n        IOFileFilter filter = new MagicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n    }\n\n    // -----------------------------------------------------------------------\n\n    @Test\n    public void testMagicNumberFileFilterValidation() {\n        try {\n            new MagicNumberFileFilter((String) null, 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(\"0\", -1);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(\"\", 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter((byte[]) null, 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(new byte[] {0}, -1);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(new byte[] {}, 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testMakeCVSAware() throws Exception {\n        final IOFileFilter filter1 = FileFilterUtils.makeCVSAware(null);\n        final IOFileFilter filter2 = FileFilterUtils.makeCVSAware(FileFilterUtils.nameFileFilter(\"test-file1.txt\"));\n\n        File file = new File(temporaryFolder, \"CVS\");\n        file.mkdirs();\n        assertFiltering(filter1, file, false);\n        assertFiltering(filter2, file, false);\n        FileUtils.deleteDirectory(file);\n\n        file = new File(temporaryFolder, \"test-file1.txt\");\n        if (!file.getParentFile().exists()) {\n            fail(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output2 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output2, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, true);\n\n        file = new File(temporaryFolder, \"test-file2.log\");\n        if (!file.getParentFile().exists()) {\n            fail(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n\n        file = new File(temporaryFolder, \"CVS\");\n        if (!file.getParentFile().exists()) {\n            fail(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n    }\n\n    // -----------------------------------------------------------------------\n    @Test\n    public void testMakeDirectoryOnly() throws Exception {\n        assertSame(DirectoryFileFilter.DIRECTORY, FileFilterUtils.makeDirectoryOnly(null));\n\n        final IOFileFilter filter = FileFilterUtils.makeDirectoryOnly(FileFilterUtils.nameFileFilter(\"B\"));\n\n        final File fileA = new File(temporaryFolder, \"A\");\n        final File fileB = new File(temporaryFolder, \"B\");\n\n        fileA.mkdirs();\n        fileB.mkdirs();\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, true);\n\n        FileUtils.deleteDirectory(fileA);\n        FileUtils.deleteDirectory(fileB);\n\n        if (!fileA.getParentFile().exists()) {\n            fail(\"Cannot create file \" + fileA + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(fileA))) {\n            TestUtils.generateTestData(output1, 32);\n        }\n        if (!fileB.getParentFile().exists()) {\n            fail(\"Cannot create file \" + fileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(fileB))) {\n            TestUtils.generateTestData(output, 32);\n        }\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, false);\n\n        fileA.delete();\n        fileB.delete();\n    }\n\n    // -----------------------------------------------------------------------\n    @Test\n    public void testMakeFileOnly() throws Exception {\n        assertSame(FileFileFilter.INSTANCE, FileFilterUtils.makeFileOnly(null));\n\n        final IOFileFilter filter = FileFilterUtils.makeFileOnly(FileFilterUtils.nameFileFilter(\"B\"));\n\n        final File fileA = new File(temporaryFolder, \"A\");\n        final File fileB = new File(temporaryFolder, \"B\");\n\n        fileA.mkdirs();\n        fileB.mkdirs();\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, false);\n\n        FileUtils.deleteDirectory(fileA);\n        FileUtils.deleteDirectory(fileB);\n\n        if (!fileA.getParentFile().exists()) {\n            fail(\"Cannot create file \" + fileA + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(fileA))) {\n            TestUtils.generateTestData(output1, 32);\n        }\n        if (!fileB.getParentFile().exists()) {\n            fail(\"Cannot create file \" + fileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(fileB))) {\n            TestUtils.generateTestData(output, 32);\n        }\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, true);\n\n        fileA.delete();\n        fileB.delete();\n    }\n\n    @Test\n    public void testMakeSVNAware() throws Exception {\n        final IOFileFilter filter1 = FileFilterUtils.makeSVNAware(null);\n        final IOFileFilter filter2 = FileFilterUtils.makeSVNAware(FileFilterUtils.nameFileFilter(\"test-file1.txt\"));\n\n        File file = new File(temporaryFolder, SVN_DIR_NAME);\n        file.mkdirs();\n        assertFiltering(filter1, file, false);\n        assertFiltering(filter2, file, false);\n        FileUtils.deleteDirectory(file);\n\n        file = new File(temporaryFolder, \"test-file1.txt\");\n        if (!file.getParentFile().exists()) {\n            fail(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output2 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output2, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, true);\n\n        file = new File(temporaryFolder, \"test-file2.log\");\n        if (!file.getParentFile().exists()) {\n            fail(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n\n        file = new File(temporaryFolder, SVN_DIR_NAME);\n        if (!file.getParentFile().exists()) {\n            fail(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n    }\n\n    @Test\n    public void testNameFilter() {\n        assertFooBarFileFiltering(new NameFileFilter(new String[] {\"foo\", \"bar\"}));\n    }\n\n    @Test\n    public void testFileEqualsFilter() {\n        assertFooBarFileFiltering(\n            new FileEqualsFileFilter(new File(\"foo\")).or(new FileEqualsFileFilter(new File(\"bar\"))));\n    }\n\n    @Test\n    public void testPathEqualsFilter() {\n        assertFooBarFileFiltering(\n            new PathEqualsFileFilter(Paths.get(\"foo\")).or(new PathEqualsFileFilter(Paths.get(\"bar\"))));\n    }\n\n    private void assertFooBarFileFiltering(IOFileFilter filter) {\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true);\n        assertFiltering(filter, new File(\"BAR\"), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true);\n        assertFiltering(filter, new File(\"BAR\").toPath(), true);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\"), WINDOWS);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\").toPath(), WINDOWS);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, null);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        // repeat for a List\n        final java.util.ArrayList<String> list = new java.util.ArrayList<>();\n        list.add(\"foo\");\n        list.add(\"bar\");\n        filter = new NameFileFilter(list);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(\"foo\");\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        // FileFilterUtils.nameFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.nameFileFilter(\"foo\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n    }\n\n    @Test\n    public void testNameFilterNullArgument() {\n        final String test = null;\n        try {\n            new NameFileFilter(test);\n            fail(\"constructing a NameFileFilter with a null String argument should fail.\");\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            FileFilterUtils.nameFileFilter(test, IOCase.INSENSITIVE);\n            fail(\"constructing a NameFileFilter with a null String argument should fail.\");\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testNameFilterNullArrayArgument() {\n        assertThrows(IllegalArgumentException.class, () -> new NameFileFilter((String[]) null));\n    }\n\n    @Test\n    public void testNameFilterNullListArgument() {\n        final List<String> test = null;\n        assertThrows(IllegalArgumentException.class, () -> new NameFileFilter(test));\n    }\n\n    @Test\n    public void testNegate() {\n        final IOFileFilter filter = FileFilterUtils.notFileFilter(FileFilterUtils.trueFileFilter());\n        assertFiltering(filter, new File(\"foo.test\"), false);\n        assertFiltering(filter, new File(\"foo\"), false);\n        assertFiltering(filter.negate(), new File(\"foo\"), true);\n        assertFiltering(filter, (File) null, false);\n        assertThrows(IllegalArgumentException.class, () -> new NotFileFilter(null));\n    }\n\n    @Test\n    public void testNullFilters() {\n        try {\n            FileFilterUtils.toList((IOFileFilter) null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException ignore) {\n            // expected\n        }\n        try {\n            FileFilterUtils.toList(new IOFileFilter[] {null});\n            fail(\"Expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException ignore) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testOr() {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        final File testFile = new File(\"foo.test\");\n        final Path testPath = testFile.toPath();\n        assertFiltering(new OrFileFilter(trueFilter, trueFilter), testFile, true);\n        assertFiltering(new OrFileFilter(trueFilter, falseFilter), testFile, true);\n        assertFiltering(new OrFileFilter(falseFilter, trueFilter), testFile, true);\n        assertFiltering(new OrFileFilter(falseFilter, falseFilter), testFile, false);\n        assertFiltering(new OrFileFilter(), testFile, false);\n        //\n        assertFiltering(new OrFileFilter(trueFilter, trueFilter), testPath, true);\n        assertFiltering(new OrFileFilter(trueFilter, falseFilter), testPath, true);\n        assertFiltering(new OrFileFilter(falseFilter, trueFilter), testPath, true);\n        assertFiltering(new OrFileFilter(falseFilter, falseFilter), testPath, false);\n        assertFiltering(new OrFileFilter(), testPath, false);\n        //\n        assertFiltering(falseFilter.or(trueFilter), testPath, true);\n        assertFiltering(falseFilter.or(falseFilter, trueFilter), testPath, true);\n        assertFiltering(falseFilter.or(falseFilter, falseFilter, trueFilter), testPath, true);\n\n        final List<IOFileFilter> filters = new ArrayList<>();\n        filters.add(trueFilter);\n        filters.add(falseFilter);\n\n        final OrFileFilter orFilter = new OrFileFilter(filters);\n\n        assertFiltering(orFilter, testFile, true);\n        assertFiltering(orFilter, testPath, true);\n        assertEquals(orFilter.getFileFilters(), filters);\n        orFilter.removeFileFilter(trueFilter);\n        assertFiltering(orFilter, testFile, false);\n        assertFiltering(orFilter, testPath, false);\n        orFilter.setFileFilters(filters);\n        assertFiltering(orFilter, testFile, true);\n        assertFiltering(orFilter, testPath, true);\n\n        assertTrue(orFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertEquals(FileVisitResult.CONTINUE, orFilter.accept(testPath, null));\n        orFilter.removeFileFilter(trueFilter);\n        assertTrue(!orFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertEquals(FileVisitResult.TERMINATE, orFilter.accept(testPath, null));\n\n        try {\n            new OrFileFilter(falseFilter, (IOFileFilter) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n        }\n\n        final OrFileFilter f = new OrFileFilter((List<IOFileFilter>) null);\n        assertTrue(f.getFileFilters().isEmpty());\n    }\n\n    @Test\n    public void testPrefix() {\n        IOFileFilter filter = new PrefixFileFilter(new String[] {\"foo\", \"bar\"});\n        final File testFile = new File(\"test\");\n        final Path testPath = testFile.toPath();\n        final File fredFile = new File(\"fred\");\n        final Path fredPath = fredFile.toPath();\n\n        assertFiltering(filter, new File(\"foo.test\"), true);\n        assertFiltering(filter, new File(\"FOO.test\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"food/\"), true);\n        //\n        assertFiltering(filter, new File(\"foo.test\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO.test\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"food/\").toPath(), true);\n\n        filter = FileFilterUtils.prefixFileFilter(\"bar\");\n        assertFiltering(filter, new File(\"barred\\\\\"), true);\n        assertFiltering(filter, new File(\"test\"), false);\n        assertFiltering(filter, new File(\"fo_o.test\"), false);\n        assertFiltering(filter, new File(\"abar.exe\"), false);\n        //\n        assertFiltering(filter, new File(\"barred\\\\\").toPath(), true);\n        assertFiltering(filter, new File(\"test\").toPath(), false);\n        assertFiltering(filter, new File(\"fo_o.test\").toPath(), false);\n        assertFiltering(filter, new File(\"abar.exe\").toPath(), false);\n\n        filter = new PrefixFileFilter(\"tes\");\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        //\n        assertFiltering(filter, new File(\"test\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        assertTrue(filter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(!filter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, filter.accept(testPath, null));\n        assertEquals(FileVisitResult.TERMINATE, filter.accept(fredPath, null));\n\n        final List<String> prefixes = Arrays.asList(\"foo\", \"fre\");\n        final IOFileFilter listFilter = new PrefixFileFilter(prefixes);\n\n        assertTrue(!listFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(listFilter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(testPath, null));\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(fredPath, null));\n\n        try {\n            new PrefixFileFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testPrefixCaseInsensitive() {\n\n        IOFileFilter filter = new PrefixFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test1\"), true);\n        assertFiltering(filter, new File(\"bar.test1\"), true);\n        assertFiltering(filter, new File(\"FOO.test1\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test1\"), true); // case-sensitive\n\n        filter = new PrefixFileFilter(\"bar\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test2\"), false);\n        assertFiltering(filter, new File(\"bar.test2\"), true);\n        assertFiltering(filter, new File(\"FOO.test2\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test2\"), true); // case-sensitive\n\n        final List<String> prefixes = Arrays.asList(\"foo\", \"bar\");\n        filter = new PrefixFileFilter(prefixes, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test3\"), true);\n        assertFiltering(filter, new File(\"bar.test3\"), true);\n        assertFiltering(filter, new File(\"FOO.test3\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test3\"), true); // case-sensitive\n\n        try {\n            new PrefixFileFilter((String) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((String[]) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((List<String>) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        // FileFilterUtils.prefixFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.prefixFileFilter(\"bar\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test2\"), false);\n        assertFiltering(filter, new File(\"bar.test2\"), true);\n        assertFiltering(filter, new File(\"FOO.test2\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test2\"), true); // case-sensitive\n\n        try {\n            FileFilterUtils.prefixFileFilter(null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testSizeFilterOnFiles() throws Exception {\n        final File smallFile = new File(temporaryFolder, \"small.txt\");\n        if (!smallFile.getParentFile().exists()) {\n            fail(\"Cannot create file \" + smallFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(smallFile))) {\n            TestUtils.generateTestData(output1, 32);\n        }\n        final File largeFile = new File(temporaryFolder, \"large.txt\");\n        if (!largeFile.getParentFile().exists()) {\n            fail(\"Cannot create file \" + largeFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(largeFile))) {\n            TestUtils.generateTestData(output, 128);\n        }\n        final IOFileFilter filter1 = FileFilterUtils.sizeFileFilter(64);\n        final IOFileFilter filter2 = FileFilterUtils.sizeFileFilter(64, true);\n        final IOFileFilter filter3 = FileFilterUtils.sizeFileFilter(64, false);\n\n        assertFiltering(filter1, smallFile, false);\n        assertFiltering(filter2, smallFile, false);\n        assertFiltering(filter3, smallFile, true);\n        assertFiltering(filter1, largeFile, true);\n        assertFiltering(filter2, largeFile, true);\n        assertFiltering(filter3, largeFile, false);\n\n        // size range tests\n        final IOFileFilter filter4 = FileFilterUtils.sizeRangeFileFilter(33, 127);\n        final IOFileFilter filter5 = FileFilterUtils.sizeRangeFileFilter(32, 127);\n        final IOFileFilter filter6 = FileFilterUtils.sizeRangeFileFilter(33, 128);\n        final IOFileFilter filter7 = FileFilterUtils.sizeRangeFileFilter(31, 129);\n        final IOFileFilter filter8 = FileFilterUtils.sizeRangeFileFilter(128, 128);\n\n        assertFiltering(filter4, smallFile, false);\n        assertFiltering(filter4, largeFile, false);\n        assertFiltering(filter5, smallFile, true);\n        assertFiltering(filter5, largeFile, false);\n        assertFiltering(filter6, smallFile, false);\n        assertFiltering(filter6, largeFile, true);\n        assertFiltering(filter7, smallFile, true);\n        assertFiltering(filter7, largeFile, true);\n        assertFiltering(filter8, largeFile, true);\n\n        try {\n            FileFilterUtils.sizeFileFilter(-1);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testSizeFilterOnPaths() throws Exception {\n        final Path smallFile = Paths.get(temporaryFolder.toString(), \"small.txt\");\n        if (!Files.exists(smallFile.getParent())) {\n            fail(\"Cannot create file \" + smallFile + \" as the parent directory does not exist\");\n        }\n        try (OutputStream output = Files.newOutputStream(smallFile)) {\n            TestUtils.generateTestData(output, 32);\n        }\n        final Path largeFile = Paths.get(temporaryFolder.toString(), \"large.txt\");\n        if (!Files.exists(largeFile.getParent())) {\n            fail(\"Cannot create file \" + largeFile + \" as the parent directory does not exist\");\n        }\n        try (OutputStream output = Files.newOutputStream(largeFile)) {\n            TestUtils.generateTestData(output, 128);\n        }\n        final IOFileFilter filter1 = FileFilterUtils.sizeFileFilter(64);\n        final IOFileFilter filter2 = FileFilterUtils.sizeFileFilter(64, true);\n        final IOFileFilter filter3 = FileFilterUtils.sizeFileFilter(64, false);\n\n        assertFiltering(filter1, smallFile, false);\n        assertFiltering(filter2, smallFile, false);\n        assertFiltering(filter3, smallFile, true);\n        assertFiltering(filter1, largeFile, true);\n        assertFiltering(filter2, largeFile, true);\n        assertFiltering(filter3, largeFile, false);\n\n        // size range tests\n        final IOFileFilter filter4 = FileFilterUtils.sizeRangeFileFilter(33, 127);\n        final IOFileFilter filter5 = FileFilterUtils.sizeRangeFileFilter(32, 127);\n        final IOFileFilter filter6 = FileFilterUtils.sizeRangeFileFilter(33, 128);\n        final IOFileFilter filter7 = FileFilterUtils.sizeRangeFileFilter(31, 129);\n        final IOFileFilter filter8 = FileFilterUtils.sizeRangeFileFilter(128, 128);\n\n        assertFiltering(filter4, smallFile, false);\n        assertFiltering(filter4, largeFile, false);\n        assertFiltering(filter5, smallFile, true);\n        assertFiltering(filter5, largeFile, false);\n        assertFiltering(filter6, smallFile, false);\n        assertFiltering(filter6, largeFile, true);\n        assertFiltering(filter7, smallFile, true);\n        assertFiltering(filter7, largeFile, true);\n        assertFiltering(filter8, largeFile, true);\n\n        try {\n            FileFilterUtils.sizeFileFilter(-1);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testSuffix() {\n        IOFileFilter filter = new SuffixFileFilter(new String[] {\"tes\", \"est\"});\n        final File testFile = new File(\"test\");\n        final Path testPath = testFile.toPath();\n        final File fredFile = new File(\"fred\");\n        final Path fredPath = fredFile.toPath();\n        //\n        assertFiltering(filter, new File(\"fred.tes\"), true);\n        assertFiltering(filter, new File(\"fred.est\"), true);\n        assertFiltering(filter, new File(\"fred.EST\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"fred.exe\"), false);\n        //\n        assertFiltering(filter, new File(\"fred.tes\").toPath(), true);\n        assertFiltering(filter, new File(\"fred.est\").toPath(), true);\n        assertFiltering(filter, new File(\"fred.EST\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"fred.exe\").toPath(), false);\n\n        filter = FileFilterUtils.or(FileFilterUtils.suffixFileFilter(\"tes\"), FileFilterUtils.suffixFileFilter(\"est\"));\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\".tes\"), true);\n        assertFiltering(filter, new File(\"fred.test\"), true);\n        //\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n        assertFiltering(filter, new File(\".tes\").toPath(), true);\n        assertFiltering(filter, new File(\"fred.test\").toPath(), true);\n\n        filter = new SuffixFileFilter(\"est\");\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        //\n        assertFiltering(filter, new File(\"test\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        assertTrue(filter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(!filter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, filter.accept(testPath, null));\n        assertEquals(FileVisitResult.TERMINATE, filter.accept(fredPath, null));\n\n        final List<String> prefixes = Arrays.asList(\"ood\", \"red\");\n        final IOFileFilter listFilter = new SuffixFileFilter(prefixes);\n\n        assertTrue(!listFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(listFilter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(testPath, null));\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(fredPath, null));\n\n        try {\n            new SuffixFileFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testSuffixCaseInsensitive() {\n\n        IOFileFilter filter = new SuffixFileFilter(new String[] {\"tes\", \"est\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.tes\"), true);\n        assertFiltering(filter, new File(\"foo.est\"), true);\n        assertFiltering(filter, new File(\"foo.EST\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"foo.TES\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"foo.exe\"), false);\n\n        filter = new SuffixFileFilter(\"est\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"TEST\"), true);\n\n        final List<String> suffixes = Arrays.asList(\"tes\", \"est\");\n        filter = new SuffixFileFilter(suffixes, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"bar.tes\"), true);\n        assertFiltering(filter, new File(\"bar.est\"), true);\n        assertFiltering(filter, new File(\"bar.EST\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"bar.TES\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"bar.exe\"), false);\n\n        try {\n            new SuffixFileFilter((String) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((String[]) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((List<String>) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        // FileFilterUtils.suffixFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.suffixFileFilter(\"est\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"TEST\"), true);\n\n        try {\n            FileFilterUtils.suffixFileFilter(null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n        }\n    }\n\n    @Test\n    public void testTrue() {\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        assertFiltering(filter, new File(\"foo.test\"), true);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, (File) null, true);\n        //\n        assertFiltering(filter, new File(\"foo.test\").toPath(), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, (Path) null, true);\n        //\n        assertSame(TrueFileFilter.TRUE, TrueFileFilter.INSTANCE);\n        assertSame(FalseFileFilter.FALSE, TrueFileFilter.INSTANCE.negate());\n        assertSame(FalseFileFilter.INSTANCE, TrueFileFilter.INSTANCE.negate());\n    }\n\n    @Test\n    public void testWildcard() {\n        IOFileFilter filter = new WildcardFileFilter(\"*.txt\");\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), false);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), false);\n\n        filter = new WildcardFileFilter(\"*.txt\", IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), false);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), false);\n\n        filter = new WildcardFileFilter(\"*.txt\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), true);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), true);\n\n        filter = new WildcardFileFilter(\"*.txt\", IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), WINDOWS);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), WINDOWS);\n\n        filter = new WildcardFileFilter(\"*.txt\", null);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), false);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), false);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"});\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.class\"), true);\n        assertFiltering(filter, new File(\"Test.jsp\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.class\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.jsp\").toPath(), false);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), false);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), true);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), true);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), WINDOWS);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), WINDOWS);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, null);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), false);\n\n        final List<String> patternList = Arrays.asList(\"*.txt\", \"*.xml\", \"*.gif\");\n        final IOFileFilter listFilter = new WildcardFileFilter(patternList);\n        assertFiltering(listFilter, new File(\"Test.txt\"), true);\n        assertFiltering(listFilter, new File(\"Test.xml\"), true);\n        assertFiltering(listFilter, new File(\"Test.gif\"), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\"), false);\n        //\n        assertFiltering(listFilter, new File(\"Test.txt\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.xml\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.gif\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\").toPath(), false);\n\n        final File txtFile = new File(\"test.txt\");\n        final Path txtPath = txtFile.toPath();\n        final File bmpFile = new File(\"test.bmp\");\n        final Path bmpPath = bmpFile.toPath();\n        final File dirFile = new File(\"src/java\");\n        final Path dirPath = dirFile.toPath();\n        assertTrue(listFilter.accept(txtFile));\n        assertTrue(!listFilter.accept(bmpFile));\n        assertTrue(!listFilter.accept(dirFile));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtFile.toPath(), null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpFile.toPath(), null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirFile.toPath(), null));\n\n        assertTrue(listFilter.accept(txtFile.getParentFile(), txtFile.getName()));\n        assertTrue(!listFilter.accept(bmpFile.getParentFile(), bmpFile.getName()));\n        assertTrue(!listFilter.accept(dirFile.getParentFile(), dirFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirPath, null));\n\n        try {\n            new WildcardFileFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n        try {\n            new WildcardFileFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n        try {\n            new WildcardFileFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n}\n", "diffSourceCodeSet": ["private void assertFooBarFileFiltering(IOFileFilter filter) {\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true);\n        assertFiltering(filter, new File(\"BAR\"), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true);\n        assertFiltering(filter, new File(\"BAR\").toPath(), true);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\"), WINDOWS);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\").toPath(), WINDOWS);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, null);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        // repeat for a List\n        final java.util.ArrayList<String> list = new java.util.ArrayList<>();\n        list.add(\"foo\");\n        list.add(\"bar\");\n        filter = new NameFileFilter(list);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(\"foo\");\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        // FileFilterUtils.nameFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.nameFileFilter(\"foo\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.filefilter.FileFilterUtils#nameFileFilter\n methodBody: public static IOFileFilter nameFileFilter(final String name, final IOCase caseSensitivity) {\nreturn new NameFileFilter(name,caseSensitivity);\n}", "methodSignature: org.apache.commons.io.file.AccumulatorPathVisitor#add\n methodBody: private void add(final List<Path> list, final Path dir) {\nlist.add(dir.normalize());\n}", "methodSignature: org.apache.commons.io.filefilter.FileFilterTestCase#assertFiltering\n methodBody: public void assertFiltering(final IOFileFilter filter, final Path path, final boolean expected) throws Exception {\nfinal FileVisitResult expectedFileVisitResult=AbstractFileFilter.toFileVisitResult(expected);\nassertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\nif(path != null && path.getParent() != null){assertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\n}if(path == null){assertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for null\");\n}assertNotNull(filter.toString());\n}", "methodSignature: org.apache.commons.io.filefilter.RegexFileFilterTestCase#assertFiltering\n methodBody: public void assertFiltering(final IOFileFilter filter, final Path path, final boolean expected) throws Exception {\nfinal FileVisitResult expectedFileVisitResult=AbstractFileFilter.toFileVisitResult(expected);\nassertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\nif(path != null && path.getParent() != null){assertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\n}if(path == null){assertEquals(expectedFileVisitResult,filter.accept(path,null),\"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for null\");\n}}"], "sourceCodeAfterRefactoring": "@Test\n    public void testNameFilter() {\n        assertFooBarFileFiltering(new NameFileFilter(new String[] {\"foo\", \"bar\"}));\n    }\nprivate void assertFooBarFileFiltering(IOFileFilter filter) {\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true);\n        assertFiltering(filter, new File(\"BAR\"), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true);\n        assertFiltering(filter, new File(\"BAR\").toPath(), true);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\"), WINDOWS);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\").toPath(), WINDOWS);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, null);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        // repeat for a List\n        final java.util.ArrayList<String> list = new java.util.ArrayList<>();\n        list.add(\"foo\");\n        list.add(\"bar\");\n        filter = new NameFileFilter(list);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(\"foo\");\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        // FileFilterUtils.nameFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.nameFileFilter(\"foo\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n    }", "diffSourceCode": "- 1165: \n- 1166:     @Test\n- 1167:     public void testNameFilter() throws Exception {\n- 1168:         IOFileFilter filter = new NameFileFilter(new String[] {\"foo\", \"bar\"});\n- 1169:         assertFiltering(filter, new File(\"foo\"), true);\n- 1170:         assertFiltering(filter, new File(\"foo\"), true);\n- 1171:         assertFiltering(filter, new File(\"bar\"), true);\n- 1172:         assertFiltering(filter, new File(\"fred\"), false);\n- 1173:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n- 1174:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n- 1175:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n- 1176:         assertFiltering(filter, new File(\"fred\").toPath(), false);\n- 1177: \n- 1178:         filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SENSITIVE);\n- 1179:         assertFiltering(filter, new File(\"foo\"), true);\n- 1180:         assertFiltering(filter, new File(\"bar\"), true);\n- 1181:         assertFiltering(filter, new File(\"FOO\"), false);\n- 1182:         assertFiltering(filter, new File(\"BAR\"), false);\n- 1183:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n- 1184:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n- 1185:         assertFiltering(filter, new File(\"FOO\").toPath(), false);\n- 1186:         assertFiltering(filter, new File(\"BAR\").toPath(), false);\n- 1187: \n- 1188:         filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n- 1189:         assertFiltering(filter, new File(\"foo\"), true);\n- 1190:         assertFiltering(filter, new File(\"bar\"), true);\n- 1191:         assertFiltering(filter, new File(\"FOO\"), true);\n- 1192:         assertFiltering(filter, new File(\"BAR\"), true);\n- 1193:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n- 1194:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n- 1195:         assertFiltering(filter, new File(\"FOO\").toPath(), true);\n- 1196:         assertFiltering(filter, new File(\"BAR\").toPath(), true);\n- 1197: \n- 1198:         filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SYSTEM);\n- 1199:         assertFiltering(filter, new File(\"foo\"), true);\n- 1200:         assertFiltering(filter, new File(\"bar\"), true);\n- 1201:         assertFiltering(filter, new File(\"FOO\"), WINDOWS);\n- 1202:         assertFiltering(filter, new File(\"BAR\"), WINDOWS);\n- 1203:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n- 1204:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n- 1205:         assertFiltering(filter, new File(\"FOO\").toPath(), WINDOWS);\n- 1206:         assertFiltering(filter, new File(\"BAR\").toPath(), WINDOWS);\n- 1207: \n- 1208:         filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, null);\n- 1209:         assertFiltering(filter, new File(\"foo\"), true);\n- 1210:         assertFiltering(filter, new File(\"bar\"), true);\n- 1211:         assertFiltering(filter, new File(\"FOO\"), false);\n- 1212:         assertFiltering(filter, new File(\"BAR\"), false);\n- 1213:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n- 1214:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n- 1215:         assertFiltering(filter, new File(\"FOO\").toPath(), false);\n- 1216:         assertFiltering(filter, new File(\"BAR\").toPath(), false);\n- 1217: \n- 1218:         // repeat for a List\n- 1219:         final java.util.ArrayList<String> list = new java.util.ArrayList<>();\n- 1220:         list.add(\"foo\");\n- 1221:         list.add(\"bar\");\n- 1222:         filter = new NameFileFilter(list);\n+ 1165:     @Test\n+ 1166:     public void testNameFilter() {\n+ 1167:         assertFooBarFileFiltering(new NameFileFilter(new String[] {\"foo\", \"bar\"}));\n+ 1168:     }\n+ 1169: \n+ 1170:     @Test\n+ 1171:     public void testFileEqualsFilter() {\n+ 1172:         assertFooBarFileFiltering(\n+ 1173:             new FileEqualsFileFilter(new File(\"foo\")).or(new FileEqualsFileFilter(new File(\"bar\"))));\n+ 1174:     }\n+ 1175: \n+ 1176:     @Test\n+ 1177:     public void testPathEqualsFilter() {\n+ 1178:         assertFooBarFileFiltering(\n+ 1179:             new PathEqualsFileFilter(Paths.get(\"foo\")).or(new PathEqualsFileFilter(Paths.get(\"bar\"))));\n+ 1180:     }\n+ 1181: \n+ 1182:     private void assertFooBarFileFiltering(IOFileFilter filter) {\n+ 1183:         assertFiltering(filter, new File(\"foo\"), true);\n+ 1184:         assertFiltering(filter, new File(\"foo\"), true);\n+ 1185:         assertFiltering(filter, new File(\"bar\"), true);\n+ 1186:         assertFiltering(filter, new File(\"fred\"), false);\n+ 1187:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n+ 1188:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n+ 1189:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n+ 1190:         assertFiltering(filter, new File(\"fred\").toPath(), false);\n+ 1191: \n+ 1192:         filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SENSITIVE);\n+ 1193:         assertFiltering(filter, new File(\"foo\"), true);\n+ 1194:         assertFiltering(filter, new File(\"bar\"), true);\n+ 1195:         assertFiltering(filter, new File(\"FOO\"), false);\n+ 1196:         assertFiltering(filter, new File(\"BAR\"), false);\n+ 1197:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n+ 1198:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n+ 1199:         assertFiltering(filter, new File(\"FOO\").toPath(), false);\n+ 1200:         assertFiltering(filter, new File(\"BAR\").toPath(), false);\n+ 1201: \n+ 1202:         filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n+ 1203:         assertFiltering(filter, new File(\"foo\"), true);\n+ 1204:         assertFiltering(filter, new File(\"bar\"), true);\n+ 1205:         assertFiltering(filter, new File(\"FOO\"), true);\n+ 1206:         assertFiltering(filter, new File(\"BAR\"), true);\n+ 1207:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n+ 1208:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n+ 1209:         assertFiltering(filter, new File(\"FOO\").toPath(), true);\n+ 1210:         assertFiltering(filter, new File(\"BAR\").toPath(), true);\n+ 1211: \n+ 1212:         filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SYSTEM);\n+ 1213:         assertFiltering(filter, new File(\"foo\"), true);\n+ 1214:         assertFiltering(filter, new File(\"bar\"), true);\n+ 1215:         assertFiltering(filter, new File(\"FOO\"), WINDOWS);\n+ 1216:         assertFiltering(filter, new File(\"BAR\"), WINDOWS);\n+ 1217:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n+ 1218:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n+ 1219:         assertFiltering(filter, new File(\"FOO\").toPath(), WINDOWS);\n+ 1220:         assertFiltering(filter, new File(\"BAR\").toPath(), WINDOWS);\n+ 1221: \n+ 1222:         filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, null);\n  1223:         assertFiltering(filter, new File(\"foo\"), true);\n  1224:         assertFiltering(filter, new File(\"bar\"), true);\n- 1225:         assertFiltering(filter, new File(\"fred\"), false);\n- 1226:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n- 1227:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n- 1228:         assertFiltering(filter, new File(\"fred\").toPath(), false);\n- 1229: \n- 1230:         filter = new NameFileFilter(\"foo\");\n- 1231:         assertFiltering(filter, new File(\"foo\"), true);\n- 1232:         assertFiltering(filter, new File(\"FOO\"), false); // case-sensitive\n- 1233:         assertFiltering(filter, new File(\"barfoo\"), false);\n- 1234:         assertFiltering(filter, new File(\"foobar\"), false);\n- 1235:         assertFiltering(filter, new File(\"fred\"), false);\n- 1236:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n- 1237:         assertFiltering(filter, new File(\"FOO\").toPath(), false); // case-sensitive\n- 1238:         assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n- 1239:         assertFiltering(filter, new File(\"foobar\").toPath(), false);\n- 1240:         assertFiltering(filter, new File(\"fred\").toPath(), false);\n- 1241: \n- 1242:         // FileFilterUtils.nameFileFilter(String, IOCase) tests\n- 1243:         filter = FileFilterUtils.nameFileFilter(\"foo\", IOCase.INSENSITIVE);\n- 1244:         assertFiltering(filter, new File(\"foo\"), true);\n- 1245:         assertFiltering(filter, new File(\"FOO\"), true); // case-insensitive\n- 1246:         assertFiltering(filter, new File(\"barfoo\"), false);\n- 1247:         assertFiltering(filter, new File(\"foobar\"), false);\n- 1248:         assertFiltering(filter, new File(\"fred\"), false);\n- 1249:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n- 1250:         assertFiltering(filter, new File(\"FOO\").toPath(), true); // case-insensitive\n- 1251:         assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n- 1252:         assertFiltering(filter, new File(\"foobar\").toPath(), false);\n- 1253:         assertFiltering(filter, new File(\"fred\").toPath(), false);\n- 1254:     }\n+ 1225:         assertFiltering(filter, new File(\"FOO\"), false);\n+ 1226:         assertFiltering(filter, new File(\"BAR\"), false);\n+ 1227:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n+ 1228:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n+ 1229:         assertFiltering(filter, new File(\"FOO\").toPath(), false);\n+ 1230:         assertFiltering(filter, new File(\"BAR\").toPath(), false);\n+ 1231: \n+ 1232:         // repeat for a List\n+ 1233:         final java.util.ArrayList<String> list = new java.util.ArrayList<>();\n+ 1234:         list.add(\"foo\");\n+ 1235:         list.add(\"bar\");\n+ 1236:         filter = new NameFileFilter(list);\n+ 1237:         assertFiltering(filter, new File(\"foo\"), true);\n+ 1238:         assertFiltering(filter, new File(\"bar\"), true);\n+ 1239:         assertFiltering(filter, new File(\"fred\"), false);\n+ 1240:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n+ 1241:         assertFiltering(filter, new File(\"bar\").toPath(), true);\n+ 1242:         assertFiltering(filter, new File(\"fred\").toPath(), false);\n+ 1243: \n+ 1244:         filter = new NameFileFilter(\"foo\");\n+ 1245:         assertFiltering(filter, new File(\"foo\"), true);\n+ 1246:         assertFiltering(filter, new File(\"FOO\"), false); // case-sensitive\n+ 1247:         assertFiltering(filter, new File(\"barfoo\"), false);\n+ 1248:         assertFiltering(filter, new File(\"foobar\"), false);\n+ 1249:         assertFiltering(filter, new File(\"fred\"), false);\n+ 1250:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n+ 1251:         assertFiltering(filter, new File(\"FOO\").toPath(), false); // case-sensitive\n+ 1252:         assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n+ 1253:         assertFiltering(filter, new File(\"foobar\").toPath(), false);\n+ 1254:         assertFiltering(filter, new File(\"fred\").toPath(), false);\n  1255: \n- 1256:     @Test\n- 1257:     public void testNameFilterNullArgument() throws Exception {\n- 1258:         final String test = null;\n- 1259:         try {\n- 1260:             new NameFileFilter(test);\n- 1261:             fail(\"constructing a NameFileFilter with a null String argument should fail.\");\n- 1262:         } catch (final IllegalArgumentException ignore) {\n- 1263:         }\n- 1264: \n- 1265:         try {\n- 1266:             FileFilterUtils.nameFileFilter(test, IOCase.INSENSITIVE);\n- 1267:             fail(\"constructing a NameFileFilter with a null String argument should fail.\");\n- 1268:         } catch (final IllegalArgumentException ignore) {\n+ 1256:         // FileFilterUtils.nameFileFilter(String, IOCase) tests\n+ 1257:         filter = FileFilterUtils.nameFileFilter(\"foo\", IOCase.INSENSITIVE);\n+ 1258:         assertFiltering(filter, new File(\"foo\"), true);\n+ 1259:         assertFiltering(filter, new File(\"FOO\"), true); // case-insensitive\n+ 1260:         assertFiltering(filter, new File(\"barfoo\"), false);\n+ 1261:         assertFiltering(filter, new File(\"foobar\"), false);\n+ 1262:         assertFiltering(filter, new File(\"fred\"), false);\n+ 1263:         assertFiltering(filter, new File(\"foo\").toPath(), true);\n+ 1264:         assertFiltering(filter, new File(\"FOO\").toPath(), true); // case-insensitive\n+ 1265:         assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n+ 1266:         assertFiltering(filter, new File(\"foobar\").toPath(), false);\n+ 1267:         assertFiltering(filter, new File(\"fred\").toPath(), false);\n+ 1268:     }\n", "uniqueId": "4a514d3306b55b3667d1449ebd4cbe5f19dd7af0_1166_1254_1182_1268_1165_1168", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testNameFilter` method, we can extract repeated code into separate methods. This will help reduce duplication and make the test cases easier to understand.\n\nHere's the refactored code with the extracted methods:\n\n```java\n@Test\npublic void testNameFilter() throws Exception {\n    testNameFilterWithArray(new String[] {\"foo\", \"bar\"}, IOCase.SENSITIVE, true);\n    testNameFilterWithArray(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE, true);\n    testNameFilterWithArray(new String[] {\"foo\", \"bar\"}, IOCase.SYSTEM, true);\n    testNameFilterWithArray(new String[] {\"foo\", \"bar\"}, null, false);\n    \n    // repeat for a List\n    final List<String> list = Arrays.asList(\"foo\", \"bar\");\n    testNameFilterWithList(list, true);\n    \n    testNameFilterWithSingle(\"foo\", true, false);\n    \n    // FileFilterUtils.nameFileFilter(String, IOCase) tests\n    testNameFileFilter(\"foo\", IOCase.INSENSITIVE, true);\n}\n\nprivate void testNameFilterWithArray(String[] names, IOCase ioCase, boolean expectMatch) throws Exception {\n    IOFileFilter filter = new NameFileFilter(names, ioCase);\n    assertFiltering(filter, new File(\"foo\"), expectMatch);\n    assertFiltering(filter, new File(\"bar\"), expectMatch);\n    assertFiltering(filter, new File(\"fred\"), !expectMatch);\n    assertFiltering(filter, new File(\"foo\").toPath(), expectMatch);\n    assertFiltering(filter, new File(\"bar\").toPath(), expectMatch);\n    assertFiltering(filter, new File(\"fred\").toPath(), !expectMatch);\n}\n\nprivate void testNameFilterWithList(List<String> names, boolean expectMatch) throws Exception {\n    IOFileFilter filter = new NameFileFilter(names);\n    assertFiltering(filter, new File(\"foo\"), expectMatch);\n    assertFiltering(filter, new File(\"bar\"), expectMatch);\n    assertFiltering(filter, new File(\"fred\"), !expectMatch);\n    assertFiltering(filter, new File(\"foo\").toPath(), expectMatch);\n    assertFiltering(filter, new File(\"bar\").toPath(), expectMatch);\n    assertFiltering(filter, new File(\"fred\").toPath(), !expectMatch);\n}\n\nprivate void testNameFilterWithSingle(String name, boolean expectMatch, boolean caseSensitive) throws Exception {\n    IOFileFilter filter = new NameFileFilter(name);\n    assertFiltering(filter, new File(name), expectMatch);\n    assertFiltering(filter, new File(name.toUpperCase()), !caseSensitive); // case-sensitive\n    assertFiltering(filter, new File(\"barfoo\"), false);\n    assertFiltering(filter, new File(\"foobar\"), false);\n    assertFiltering(filter, new File(\"fred\"), false);\n    assertFiltering(filter, new File(name).toPath(), expectMatch);\n    assertFiltering(filter, new File(name.toUpperCase()).toPath(), !caseSensitive); // case-sensitive\n    assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n    assertFiltering(filter, new File(\"foobar\").toPath(), false);\n    assertFiltering(filter, new File(\"fred\").toPath(), false);\n}\n\nprivate void testNameFileFilter(String name, IOCase ioCase, boolean expectMatch) throws Exception {\n    IOFileFilter filter = FileFilterUtils.nameFileFilter(name, ioCase);\n    assertFiltering(filter, new File(name), expectMatch);\n    assertFiltering(filter, new File(name.toUpperCase()), expectMatch); // case-insensitive\n    assertFiltering(filter, new File(\"barfoo\"), false);\n    assertFiltering(filter, new File(\"foobar\"), false);\n    assertFiltering(filter, new File(\"fred\"), false);\n    assertFiltering(filter, new File(name).toPath(), expectMatch);\n    assertFiltering(filter, new File(name.toUpperCase()).toPath(), expectMatch); // case-insensitive\n    assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n    assertFiltering(filter, new File(\"foobar\").toPath(), false);\n}\n```\n\nThis refactoring extracts the logic for testing the `NameFileFilter` into separate methods, which reduces duplication and improves clarity. Each extracted method handles a specific aspect of the tests, making it easier to understand what each part of the test is doing.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void testNameFilter() throws Exception {\n        IOFileFilter filter = new NameFileFilter(new String[] {\"foo\", \"bar\"});\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true);\n        assertFiltering(filter, new File(\"BAR\"), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true);\n        assertFiltering(filter, new File(\"BAR\").toPath(), true);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\"), WINDOWS);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\").toPath(), WINDOWS);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, null);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        // repeat for a List\n        final java.util.ArrayList<String> list = new java.util.ArrayList<>();\n        list.add(\"foo\");\n        list.add(\"bar\");\n        filter = new NameFileFilter(list);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(\"foo\");\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        // FileFilterUtils.nameFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.nameFileFilter(\"foo\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\nimport static org.junit.jupiter.api.Assumptions.assumeTrue;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.IOCase;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.file.PathUtils;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * Used to test FileFilterUtils.\n */\npublic class FileFilterTestCase {\n\n    /**\n     * The subversion directory name.\n     */\n    static final String SVN_DIR_NAME = \".svn\";\n\n    private static final boolean WINDOWS = File.separatorChar == '\\\\';\n\n    @TempDir\n    public File temporaryFolder;\n\n    public void assertFiltering(final IOFileFilter filter, final File file, final boolean expected) throws Exception {\n        // Note. This only tests the (File, String) version if the parent of\n        // the File passed in is not null\n        assertEquals(expected, filter.accept(file),\n            \"Filter(File) \" + filter.getClass().getName() + \" not \" + expected + \" for \" + file);\n\n        if (file != null && file.getParentFile() != null) {\n            assertEquals(expected, filter.accept(file.getParentFile(), file.getName()),\n                \"Filter(File, String) \" + filter.getClass().getName() + \" not \" + expected + \" for \" + file);\n        } else if (file == null) {\n            assertEquals(expected, filter.accept(file),\n                \"Filter(File, String) \" + filter.getClass().getName() + \" not \" + expected + \" for null\");\n        }\n        assertNotNull(filter.toString());\n    }\n\n    public void assertFiltering(final IOFileFilter filter, final Path path, final boolean expected) throws Exception {\n        // Note. This only tests the (Path, Path) version if the parent of\n        // the File passed in is not null\n        final FileVisitResult expectedFileVisitResult = AbstractFileFilter.toFileVisitResult(expected);\n        assertEquals(expectedFileVisitResult, filter.accept(path, null),\n            \"Filter(Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \" + path);\n\n        if (path != null && path.getParent() != null) {\n            assertEquals(expectedFileVisitResult, filter.accept(path, null),\n                \"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for \"\n                    + path);\n        } else if (path == null) {\n            assertEquals(expectedFileVisitResult, filter.accept(path, null),\n                \"Filter(Path, Path) \" + filter.getClass().getName() + \" not \" + expectedFileVisitResult + \" for null\");\n        }\n        assertNotNull(filter.toString());\n    }\n\n    @Test\n    public void testAgeFilter() throws Exception {\n        final File oldFile = new File(temporaryFolder, \"old.txt\");\n        final Path oldPath = oldFile.toPath();\n        final File reference = new File(temporaryFolder, \"reference.txt\");\n        final File newFile = new File(temporaryFolder, \"new.txt\");\n        final Path newPath = newFile.toPath();\n\n        if (!oldFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + oldFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(oldFile))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n\n        do {\n            try {\n                TestUtils.sleep(1000);\n            } catch (final InterruptedException ie) {\n                // ignore\n            }\n            if (!reference.getParentFile().exists()) {\n                throw new IOException(\"Cannot create file \" + reference + \" as the parent directory does not exist\");\n            }\n            try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(reference))) {\n                TestUtils.generateTestData(output, 0);\n            }\n        } while (oldFile.lastModified() == reference.lastModified());\n\n        final Date date = new Date();\n        final long now = date.getTime();\n\n        do {\n            try {\n                TestUtils.sleep(1000);\n            } catch (final InterruptedException ie) {\n                // ignore\n            }\n            if (!newFile.getParentFile().exists()) {\n                throw new IOException(\"Cannot create file \" + newFile + \" as the parent directory does not exist\");\n            }\n            try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(newFile))) {\n                TestUtils.generateTestData(output, 0);\n            }\n        } while (reference.lastModified() == newFile.lastModified());\n\n        final IOFileFilter filter1 = FileFilterUtils.ageFileFilter(now);\n        final IOFileFilter filter2 = FileFilterUtils.ageFileFilter(now, true);\n        final IOFileFilter filter3 = FileFilterUtils.ageFileFilter(now, false);\n        final IOFileFilter filter4 = FileFilterUtils.ageFileFilter(date);\n        final IOFileFilter filter5 = FileFilterUtils.ageFileFilter(date, true);\n        final IOFileFilter filter6 = FileFilterUtils.ageFileFilter(date, false);\n        final IOFileFilter filter7 = FileFilterUtils.ageFileFilter(reference);\n        final IOFileFilter filter8 = FileFilterUtils.ageFileFilter(reference, true);\n        final IOFileFilter filter9 = FileFilterUtils.ageFileFilter(reference, false);\n\n        assertFiltering(filter1, oldFile, true);\n        assertFiltering(filter2, oldFile, true);\n        assertFiltering(filter3, oldFile, false);\n        assertFiltering(filter4, oldFile, true);\n        assertFiltering(filter5, oldFile, true);\n        assertFiltering(filter6, oldFile, false);\n        assertFiltering(filter7, oldFile, true);\n        assertFiltering(filter8, oldFile, true);\n        assertFiltering(filter9, oldFile, false);\n        assertFiltering(filter1, newFile, false);\n        assertFiltering(filter2, newFile, false);\n        assertFiltering(filter3, newFile, true);\n        assertFiltering(filter4, newFile, false);\n        assertFiltering(filter5, newFile, false);\n        assertFiltering(filter6, newFile, true);\n        assertFiltering(filter7, newFile, false);\n        assertFiltering(filter8, newFile, false);\n        assertFiltering(filter9, newFile, true);\n        //\n        assertFiltering(filter1, oldPath, true);\n        assertFiltering(filter2, oldPath, true);\n        assertFiltering(filter3, oldPath, false);\n        assertFiltering(filter4, oldPath, true);\n        assertFiltering(filter5, oldPath, true);\n        assertFiltering(filter6, oldPath, false);\n        assertFiltering(filter7, oldPath, true);\n        assertFiltering(filter8, oldPath, true);\n        assertFiltering(filter9, oldPath, false);\n        assertFiltering(filter1, newPath, false);\n        assertFiltering(filter2, newPath, false);\n        assertFiltering(filter3, newPath, true);\n        assertFiltering(filter4, newPath, false);\n        assertFiltering(filter5, newPath, false);\n        assertFiltering(filter6, newPath, true);\n        assertFiltering(filter7, newPath, false);\n        assertFiltering(filter8, newPath, false);\n        assertFiltering(filter9, newPath, true);\n    }\n\n    @Test\n    public void testAnd() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(trueFilter.and(trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(trueFilter.and(falseFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(falseFilter.and(trueFilter, trueFilter, trueFilter), new File(\"foo.test\"), false);\n    }\n\n    @Test\n    public void testAnd2() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(new AndFileFilter(trueFilter, trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(new AndFileFilter(trueFilter, falseFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, falseFilter), new File(\"foo.test\"), false);\n\n        final List<IOFileFilter> filters = new ArrayList<>();\n        assertFiltering(new AndFileFilter(filters), new File(\"test\"), false);\n        assertFiltering(new AndFileFilter(), new File(\"test\"), false);\n\n        assertThrows(IllegalArgumentException.class, () -> new AndFileFilter(falseFilter, (IOFileFilter) null));\n        assertThrows(IllegalArgumentException.class, () -> new AndFileFilter(null, falseFilter));\n\n        final AndFileFilter f = new AndFileFilter((List) null);\n        assertTrue(f.getFileFilters().isEmpty());\n\n        assertNotNull(f.toString()); // TODO better tests\n    }\n\n    @Test\n    public void testAndArray() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(new AndFileFilter(trueFilter, trueFilter, trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(new AndFileFilter(trueFilter, falseFilter, falseFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, trueFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(new AndFileFilter(falseFilter, falseFilter, falseFilter), new File(\"foo.test\"), false);\n\n        final List<IOFileFilter> filters = new ArrayList<>();\n        assertFiltering(new AndFileFilter(filters), new File(\"test\"), false);\n        assertFiltering(new AndFileFilter(), new File(\"test\"), false);\n    }\n\n    @Test\n    public void testCanExecute() throws Exception {\n        assumeTrue(SystemUtils.IS_OS_WINDOWS);\n        final File executableFile = File.createTempFile(getClass().getSimpleName(), \".temp\");\n        final Path executablePath = executableFile.toPath();\n        try {\n            try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(executableFile))) {\n                TestUtils.generateTestData(output, 32);\n            }\n            assertTrue(executableFile.setExecutable(true));\n            assertFiltering(CanExecuteFileFilter.CAN_EXECUTE, executableFile, true);\n            assertFiltering(CanExecuteFileFilter.CAN_EXECUTE, executablePath, true);\n            executableFile.setExecutable(false);\n            assertFiltering(CanExecuteFileFilter.CANNOT_EXECUTE, executableFile, false);\n            assertFiltering(CanExecuteFileFilter.CANNOT_EXECUTE, executablePath, false);\n        } finally {\n            executableFile.delete();\n        }\n    }\n\n    @Test\n    public void testCanRead() throws Exception {\n        final File readOnlyFile = new File(temporaryFolder, \"read-only-file1.txt\");\n        final Path readOnlyPath = readOnlyFile.toPath();\n        if (!readOnlyFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + readOnlyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(readOnlyFile))) {\n            TestUtils.generateTestData(output, 32);\n        }\n        assertTrue(readOnlyFile.setReadOnly());\n        assertFiltering(CanReadFileFilter.CAN_READ, readOnlyFile, true);\n        assertFiltering(CanReadFileFilter.CAN_READ, readOnlyPath, true);\n        assertFiltering(CanReadFileFilter.CANNOT_READ, readOnlyFile, false);\n        assertFiltering(CanReadFileFilter.CANNOT_READ, readOnlyPath, false);\n        assertFiltering(CanReadFileFilter.READ_ONLY, readOnlyFile, true);\n        assertFiltering(CanReadFileFilter.READ_ONLY, readOnlyPath, true);\n        readOnlyFile.delete();\n    }\n\n    @Test\n    public void testCanWrite() throws Exception {\n        final File readOnlyFile = new File(temporaryFolder, \"read-only-file2.txt\");\n        final Path readOnlyPath = readOnlyFile.toPath();\n        if (!readOnlyFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + readOnlyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(readOnlyFile))) {\n            TestUtils.generateTestData(output, 32);\n        }\n        assertTrue(readOnlyFile.setReadOnly());\n        assertFiltering(CanWriteFileFilter.CAN_WRITE, temporaryFolder, true);\n        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, temporaryFolder, false);\n        assertFiltering(CanWriteFileFilter.CAN_WRITE, readOnlyFile, false);\n        assertFiltering(CanWriteFileFilter.CAN_WRITE, readOnlyPath, false);\n        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, readOnlyFile, true);\n        assertFiltering(CanWriteFileFilter.CANNOT_WRITE, readOnlyPath, true);\n        readOnlyFile.delete();\n    }\n\n    @Test\n    public void testDelegateFileFilter() throws Exception {\n        final OrFileFilter orFilter = new OrFileFilter();\n        final File testFile = new File(\"test.txt\");\n\n        IOFileFilter filter = new DelegateFileFilter((FileFilter) orFilter);\n        assertFiltering(filter, testFile, false);\n        assertNotNull(filter.toString()); // TODO better test\n\n        filter = new DelegateFileFilter((FilenameFilter) orFilter);\n        assertFiltering(filter, testFile, false);\n        assertNotNull(filter.toString()); // TODO better test\n\n        try {\n            new DelegateFileFilter((FileFilter) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new DelegateFileFilter((FilenameFilter) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n    }\n\n    @Test\n    public void testDelegation() { // TODO improve these tests\n        assertNotNull(FileFilterUtils.asFileFilter((FileFilter) FalseFileFilter.INSTANCE));\n        assertNotNull(FileFilterUtils.asFileFilter((FilenameFilter) FalseFileFilter.INSTANCE).toString());\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testDeprecatedWildcard() throws Exception {\n        IOFileFilter filter = new WildcardFilter(\"*.txt\");\n        final List<String> patternList = Arrays.asList(\"*.txt\", \"*.xml\", \"*.gif\");\n        final IOFileFilter listFilter = new WildcardFilter(patternList);\n        final File txtFile = new File(\"test.txt\");\n        final Path txtPath = txtFile.toPath();\n        final File bmpFile = new File(\"test.bmp\");\n        final Path bmpPath = bmpFile.toPath();\n        final File dirFile = new File(\"src/java\");\n        final Path dirPath = dirFile.toPath();\n\n        assertFiltering(filter, new File(\"log.txt\"), true);\n//        assertFiltering(filter, new File(\"log.txt.bak\"), false);\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n\n        filter = new WildcardFilter(\"log?.txt\");\n        assertFiltering(filter, new File(\"log1.txt\"), true);\n        assertFiltering(filter, new File(\"log12.txt\"), false);\n        //\n        assertFiltering(filter, new File(\"log1.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log12.txt\").toPath(), false);\n\n        filter = new WildcardFilter(\"open??.????04\");\n        assertFiltering(filter, new File(\"openAB.102504\"), true);\n        assertFiltering(filter, new File(\"openA.102504\"), false);\n        assertFiltering(filter, new File(\"openXY.123103\"), false);\n//        assertFiltering(filter, new File(\"openAB.102504.old\"), false);\n        //\n        assertFiltering(filter, new File(\"openAB.102504\").toPath(), true);\n        assertFiltering(filter, new File(\"openA.102504\").toPath(), false);\n        assertFiltering(filter, new File(\"openXY.123103\").toPath(), false);\n//        assertFiltering(filter, new File(\"openAB.102504.old\").toPath(), false);\n\n        filter = new WildcardFilter(new String[] {\"*.java\", \"*.class\"});\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.class\"), true);\n        assertFiltering(filter, new File(\"Test.jsp\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.class\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.jsp\").toPath(), false);\n\n        assertFiltering(listFilter, new File(\"Test.txt\"), true);\n        assertFiltering(listFilter, new File(\"Test.xml\"), true);\n        assertFiltering(listFilter, new File(\"Test.gif\"), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\"), false);\n        //\n        assertFiltering(listFilter, new File(\"Test.txt\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.xml\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.gif\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\").toPath(), false);\n\n        assertTrue(listFilter.accept(txtFile));\n        assertTrue(!listFilter.accept(bmpFile));\n        assertTrue(!listFilter.accept(dirFile));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirPath, null));\n\n        assertTrue(listFilter.accept(txtFile.getParentFile(), txtFile.getName()));\n        assertTrue(!listFilter.accept(bmpFile.getParentFile(), bmpFile.getName()));\n        assertTrue(!listFilter.accept(dirFile.getParentFile(), dirFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirPath, null));\n\n        try {\n            new WildcardFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n\n        try {\n            new WildcardFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n\n        try {\n            new WildcardFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testDirectory() throws Exception {\n        // XXX: This test presumes the current working dir is the base dir of the source checkout.\n        final IOFileFilter filter = new DirectoryFileFilter();\n\n        assertFiltering(filter, new File(\"src/\"), true);\n        assertFiltering(filter, new File(\"src/\").toPath(), true);\n        assertFiltering(filter, new File(\"src/main/java/\"), true);\n        assertFiltering(filter, new File(\"src/main/java/\").toPath(), true);\n\n        assertFiltering(filter, new File(\"pom.xml\"), false);\n        assertFiltering(filter, new File(\"pom.xml\").toPath(), false);\n\n        assertFiltering(filter, new File(\"imaginary\"), false);\n        assertFiltering(filter, new File(\"imaginary\").toPath(), false);\n        assertFiltering(filter, new File(\"imaginary/\"), false);\n        assertFiltering(filter, new File(\"imaginary/\").toPath(), false);\n\n        assertFiltering(filter, new File(\"LICENSE.txt\"), false);\n        assertFiltering(filter, new File(\"LICENSE.txt\").toPath(), false);\n\n        assertSame(DirectoryFileFilter.DIRECTORY, DirectoryFileFilter.INSTANCE);\n    }\n\n    @Test\n    public void testEmpty() throws Exception {\n\n        // Empty Dir\n        final File emptyDirFile = new File(temporaryFolder, \"empty-dir\");\n        final Path emptyDirPath = emptyDirFile.toPath();\n        emptyDirFile.mkdirs();\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirFile, true);\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirPath, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirFile, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirPath, false);\n\n        // Empty File\n        final File emptyFile = new File(emptyDirFile, \"empty-file.txt\");\n        final Path emptyPath = emptyFile.toPath();\n        if (!emptyFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + emptyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(emptyFile))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n        assertFiltering(EmptyFileFilter.EMPTY, emptyFile, true);\n        assertFiltering(EmptyFileFilter.EMPTY, emptyPath, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyFile, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyPath, false);\n\n        // Not Empty Dir\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirFile, false);\n        assertFiltering(EmptyFileFilter.EMPTY, emptyDirPath, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirFile, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, emptyDirPath, true);\n\n        // Not Empty File\n        final File notEmptyFile = new File(emptyDirFile, \"not-empty-file.txt\");\n        final Path notEmptyPath = notEmptyFile.toPath();\n        if (!notEmptyFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + notEmptyFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(notEmptyFile))) {\n            TestUtils.generateTestData(output, 32);\n        }\n        assertFiltering(EmptyFileFilter.EMPTY, notEmptyFile, false);\n        assertFiltering(EmptyFileFilter.EMPTY, notEmptyPath, false);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, notEmptyFile, true);\n        assertFiltering(EmptyFileFilter.NOT_EMPTY, notEmptyPath, true);\n        FileUtils.forceDelete(emptyDirFile);\n    }\n\n    @Test\n    public void testEnsureTestCoverage() {\n        assertNotNull(new FileFilterUtils()); // dummy for test coverage\n    }\n\n    @Test\n    public void testFalse() throws Exception {\n        final IOFileFilter filter = FileFilterUtils.falseFileFilter();\n        assertFiltering(filter, new File(\"foo.test\"), false);\n        assertFiltering(filter, new File(\"foo.test\").toPath(), false);\n        assertFiltering(filter, new File(\"foo\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), false);\n        assertFiltering(filter, (File) null, false);\n        assertFiltering(filter, (Path) null, false);\n        assertSame(FalseFileFilter.FALSE, FalseFileFilter.INSTANCE);\n        assertSame(TrueFileFilter.TRUE, FalseFileFilter.INSTANCE.negate());\n        assertSame(TrueFileFilter.INSTANCE, FalseFileFilter.INSTANCE.negate());\n    }\n\n    @Test\n    public void testFileFilterUtils_and() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        assertFiltering(FileFilterUtils.and(trueFilter, trueFilter, trueFilter), new File(\"foo.test\"), true);\n        assertFiltering(FileFilterUtils.and(trueFilter, falseFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(FileFilterUtils.and(falseFilter, trueFilter), new File(\"foo.test\"), false);\n        assertFiltering(FileFilterUtils.and(falseFilter, falseFilter), new File(\"foo.test\"), false);\n    }\n\n    @Test\n    public void testFileFilterUtils_or() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        final File testFile = new File(\"foo.test\");\n        assertFiltering(FileFilterUtils.or(trueFilter, trueFilter), testFile, true);\n        assertFiltering(FileFilterUtils.or(trueFilter, trueFilter, falseFilter), testFile, true);\n        assertFiltering(FileFilterUtils.or(falseFilter, trueFilter), testFile, true);\n        assertFiltering(FileFilterUtils.or(falseFilter, falseFilter, falseFilter), testFile, false);\n    }\n\n    @Test\n    public void testFiles() throws Exception {\n        // XXX: This test presumes the current working dir is the base dir of the source checkout.\n        final IOFileFilter filter = FileFileFilter.FILE;\n\n        assertFiltering(filter, new File(\"src/\"), false);\n        assertFiltering(filter, new File(\"src/\").toPath(), false);\n        assertFiltering(filter, new File(\"src/java/\"), false);\n        assertFiltering(filter, new File(\"src/java/\").toPath(), false);\n\n        assertFiltering(filter, new File(\"pom.xml\"), true);\n        assertFiltering(filter, new File(\"pom.xml\").toPath(), true);\n\n        assertFiltering(filter, new File(\"imaginary\"), false);\n        assertFiltering(filter, new File(\"imaginary\").toPath(), false);\n        assertFiltering(filter, new File(\"imaginary/\"), false);\n        assertFiltering(filter, new File(\"imaginary/\").toPath(), false);\n\n        assertFiltering(filter, new File(\"LICENSE.txt\"), true);\n        assertFiltering(filter, new File(\"LICENSE.txt\").toPath(), true);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, java.lang.Iterable)} that tests that the method\n     * properly filters files from the list.\n     */\n    @Test\n    public void testFilterArray_fromList() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        final List<File> fileList = Arrays.asList(fileA, fileB);\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileList);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests that the method properly filters\n     * files from the list.\n     */\n    @Test\n    public void testFilterArray_IOFileFilter() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileA, fileB);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests that the method properly filters\n     * files from the list.\n     */\n    @Test\n    public void testFilterArray_PathVisitorFileFilter_FileExistsNo() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = new PathVisitorFileFilter(new NameFileFilter(\"A\"));\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileA, fileB);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests that the method properly filters\n     * files from the list.\n     */\n    @Test\n    public void testFilterArray_PathVisitorFileFilter_FileExistsYes() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        FileUtils.write(fileA, \"test\", StandardCharsets.US_ASCII);\n\n        final IOFileFilter filter = new PathVisitorFileFilter(new NameFileFilter(\"A\"));\n\n        final File[] filtered = FileFilterUtils.filter(filter, fileA, fileB);\n\n        assertEquals(1, filtered.length);\n        assertEquals(fileA, filtered[0]);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, File...)} that tests {@code null} parameters.\n     */\n    @Test\n    public void testFilterFilesArrayNullParameters() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        try {\n            FileFilterUtils.filter(null, fileA, fileB);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        FileFilterUtils.filter(filter, fileA, null);\n\n        final File[] filtered = FileFilterUtils.filter(filter, (File[]) null);\n        assertEquals(0, filtered.length);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterList(IOFileFilter, java.lang.Iterable)} that tests that the method\n     * properly filters files from the list.\n     */\n    @Test\n    public void testFilterList() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        final List<File> fileList = Arrays.asList(fileA, fileB);\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final List<File> filteredList = FileFilterUtils.filterList(filter, fileList);\n\n        assertTrue(filteredList.contains(fileA));\n        assertFalse(filteredList.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterList(IOFileFilter, File...)} that tests that the method properly\n     * filters files from the list.\n     */\n    @Test\n    public void testFilterList_fromArray() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final List<File> filteredList = FileFilterUtils.filterList(filter, fileA, fileB);\n\n        assertTrue(filteredList.contains(fileA));\n        assertFalse(filteredList.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterList(IOFileFilter, java.lang.Iterable)} that tests {@code null}\n     * parameters and {@code null} elements in the provided list.\n     */\n    @Test\n    public void testFilterListNullParameters() {\n        try {\n            FileFilterUtils.filterList(null, Collections.<File>emptyList());\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        try {\n            FileFilterUtils.filterList(filter, Collections.singletonList((File) null));\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for list containing null\n        }\n\n        final List<File> filteredList = FileFilterUtils.filterList(filter, (List<File>) null);\n        assertEquals(0, filteredList.size());\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filter(IOFileFilter, Path...)}.\n     */\n    @Test\n    public void testFilterPathsArrayNullParameters() throws Exception {\n        final Path fileA = TestUtils.newFile(temporaryFolder, \"A\").toPath();\n        final Path fileB = TestUtils.newFile(temporaryFolder, \"B\").toPath();\n        try {\n            PathUtils.filter(null, fileA, fileB);\n            fail();\n        } catch (final NullPointerException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        PathUtils.filter(filter, fileA, null);\n\n        final File[] filtered = FileFilterUtils.filter(filter, (File[]) null);\n        assertEquals(0, filtered.length);\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterSet(IOFileFilter, java.lang.Iterable)} that tests that the method\n     * properly filters files from the set.\n     */\n    @Test\n    public void testFilterSet() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n        final Set<File> fileList = new HashSet<>(Arrays.asList(fileA, fileB));\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final Set<File> filteredSet = FileFilterUtils.filterSet(filter, fileList);\n\n        assertTrue(filteredSet.contains(fileA));\n        assertFalse(filteredSet.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterSet(IOFileFilter, File...)} that tests that the method properly\n     * filters files from the set.\n     */\n    @Test\n    public void testFilterSet_fromArray() throws Exception {\n        final File fileA = TestUtils.newFile(temporaryFolder, \"A\");\n        final File fileB = TestUtils.newFile(temporaryFolder, \"B\");\n\n        final IOFileFilter filter = FileFilterUtils.nameFileFilter(\"A\");\n\n        final Set<File> filteredSet = FileFilterUtils.filterSet(filter, fileA, fileB);\n\n        assertTrue(filteredSet.contains(fileA));\n        assertFalse(filteredSet.contains(fileB));\n    }\n\n    /*\n     * Test method for {@link FileFilterUtils#filterSet(IOFileFilter, java.lang.Iterable)} that tests {@code null}\n     * parameters and {@code null} elements in the provided set.\n     */\n    @Test\n    public void testFilterSetNullParameters() {\n        try {\n            FileFilterUtils.filterSet(null, Collections.<File>emptySet());\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for null filter\n        }\n\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        try {\n            FileFilterUtils.filterSet(filter, new HashSet<>(Collections.singletonList((File) null)));\n        } catch (final IllegalArgumentException iae) {\n            // Test passes, exception thrown for set containing null\n        }\n\n        final Set<File> filteredSet = FileFilterUtils.filterSet(filter, (Set<File>) null);\n        assertEquals(0, filteredSet.size());\n    }\n\n    @Test\n    public void testHidden() throws Exception {\n        final File hiddenDirFile = new File(SVN_DIR_NAME);\n        final Path hiddenDirPath = hiddenDirFile.toPath();\n        if (hiddenDirFile.exists()) {\n            assertFiltering(HiddenFileFilter.HIDDEN, hiddenDirFile, hiddenDirFile.isHidden());\n            assertFiltering(HiddenFileFilter.HIDDEN, hiddenDirPath, hiddenDirFile.isHidden());\n            assertFiltering(HiddenFileFilter.VISIBLE, hiddenDirFile, !hiddenDirFile.isHidden());\n            assertFiltering(HiddenFileFilter.VISIBLE, hiddenDirPath, !hiddenDirFile.isHidden());\n        }\n        final Path path = temporaryFolder.toPath();\n        assertFiltering(HiddenFileFilter.HIDDEN, temporaryFolder, false);\n        assertFiltering(HiddenFileFilter.HIDDEN, path, false);\n        assertFiltering(HiddenFileFilter.VISIBLE, temporaryFolder, true);\n        assertFiltering(HiddenFileFilter.VISIBLE, path, true);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterBytes() throws Exception {\n        final byte[] classFileMagicNumber = new byte[] {(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE};\n        final String xmlFileContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\">\\n\" + \"<element>text</element>\";\n\n        final File classAFile = new File(temporaryFolder, \"A.class\");\n        final Path classAPath = classAFile.toPath();\n        final File xmlBFile = new File(temporaryFolder, \"B.xml\");\n        final Path xmlBPath = xmlBFile.toPath();\n        final File emptyFile = new File(temporaryFolder, \"C.xml\");\n        final Path emptyPath = emptyFile.toPath();\n        final File dirFile = new File(temporaryFolder, \"D\");\n        final Path dirPath = dirFile.toPath();\n        dirFile.mkdirs();\n\n        try (final OutputStream classFileAStream = FileUtils.openOutputStream(classAFile)) {\n            IOUtils.write(classFileMagicNumber, classFileAStream);\n            TestUtils.generateTestData(classFileAStream, 32);\n        }\n\n        FileUtils.write(xmlBFile, xmlFileContent, StandardCharsets.UTF_8);\n        FileUtils.touch(emptyFile);\n\n        IOFileFilter filter = new MagicNumberFileFilter(classFileMagicNumber);\n\n        assertFiltering(filter, classAFile, true);\n        assertFiltering(filter, classAPath, true);\n        assertFiltering(filter, xmlBFile, false);\n        assertFiltering(filter, xmlBPath, false);\n        assertFiltering(filter, emptyFile, false);\n        assertFiltering(filter, emptyPath, false);\n        assertFiltering(filter, dirFile, false);\n        assertFiltering(filter, dirPath, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(classFileMagicNumber);\n\n        assertFiltering(filter, classAFile, true);\n        assertFiltering(filter, classAPath, true);\n        assertFiltering(filter, xmlBFile, false);\n        assertFiltering(filter, xmlBPath, false);\n        assertFiltering(filter, emptyFile, false);\n        assertFiltering(filter, emptyPath, false);\n        assertFiltering(filter, dirFile, false);\n        assertFiltering(filter, dirPath, false);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterBytesOffset() throws Exception {\n        final byte[] tarMagicNumber = new byte[] {0x75, 0x73, 0x74, 0x61, 0x72};\n        final long tarMagicNumberOffset = 257;\n\n        final File tarFileA = new File(temporaryFolder, \"A.tar\");\n        final File randomFileB = new File(temporaryFolder, \"B.txt\");\n        final File dir = new File(temporaryFolder, \"D\");\n        dir.mkdirs();\n\n        try (final OutputStream tarFileAStream = FileUtils.openOutputStream(tarFileA)) {\n            TestUtils.generateTestData(tarFileAStream, tarMagicNumberOffset);\n            IOUtils.write(tarMagicNumber, tarFileAStream);\n        }\n\n        if (!randomFileB.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + randomFileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(randomFileB))) {\n            TestUtils.generateTestData(output, 2 * tarMagicNumberOffset);\n        }\n\n        IOFileFilter filter = new MagicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterString() throws Exception {\n        final byte[] classFileMagicNumber = new byte[] {(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE};\n        final String xmlFileContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\">\\n\" + \"<element>text</element>\";\n        final String xmlMagicNumber = \"<?xml version=\\\"1.0\\\"\";\n\n        final File classFileA = new File(temporaryFolder, \"A.class\");\n        final File xmlFileB = new File(temporaryFolder, \"B.xml\");\n        final File dir = new File(temporaryFolder, \"D\");\n        dir.mkdirs();\n\n        try (final OutputStream classFileAStream = FileUtils.openOutputStream(classFileA)) {\n            IOUtils.write(classFileMagicNumber, classFileAStream);\n            TestUtils.generateTestData(classFileAStream, 32);\n        }\n\n        FileUtils.write(xmlFileB, xmlFileContent, StandardCharsets.UTF_8);\n\n        IOFileFilter filter = new MagicNumberFileFilter(xmlMagicNumber);\n\n        assertFiltering(filter, classFileA, false);\n        assertFiltering(filter, xmlFileB, true);\n        assertFiltering(filter, dir, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(xmlMagicNumber);\n\n        assertFiltering(filter, classFileA, false);\n        assertFiltering(filter, xmlFileB, true);\n        assertFiltering(filter, dir, false);\n    }\n\n    @Test\n    public void testMagicNumberFileFilterStringOffset() throws Exception {\n        final String tarMagicNumber = \"ustar\";\n        final long tarMagicNumberOffset = 257;\n\n        final File tarFileA = new File(temporaryFolder, \"A.tar\");\n        final File randomFileB = new File(temporaryFolder, \"B.txt\");\n        final File dir = new File(temporaryFolder, \"D\");\n        dir.mkdirs();\n\n        try (final OutputStream tarFileAStream = FileUtils.openOutputStream(tarFileA)) {\n            TestUtils.generateTestData(tarFileAStream, tarMagicNumberOffset);\n            IOUtils.write(tarMagicNumber, tarFileAStream, StandardCharsets.UTF_8);\n        }\n\n        if (!randomFileB.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + randomFileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(randomFileB))) {\n            TestUtils.generateTestData(output, 2 * tarMagicNumberOffset);\n        }\n\n        IOFileFilter filter = new MagicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n\n        filter = FileFilterUtils.magicNumberFileFilter(tarMagicNumber, tarMagicNumberOffset);\n\n        assertFiltering(filter, tarFileA, true);\n        assertFiltering(filter, randomFileB, false);\n        assertFiltering(filter, dir, false);\n    }\n\n    // -----------------------------------------------------------------------\n\n    @Test\n    public void testMagicNumberFileFilterValidation() {\n        try {\n            new MagicNumberFileFilter((String) null, 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(\"0\", -1);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(\"\", 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter((byte[]) null, 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(new byte[] {0}, -1);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n        try {\n            new MagicNumberFileFilter(new byte[] {}, 0);\n            fail();\n        } catch (final IllegalArgumentException iae) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testMakeCVSAware() throws Exception {\n        final IOFileFilter filter1 = FileFilterUtils.makeCVSAware(null);\n        final IOFileFilter filter2 = FileFilterUtils.makeCVSAware(FileFilterUtils.nameFileFilter(\"test-file1.txt\"));\n\n        File file = new File(temporaryFolder, \"CVS\");\n        file.mkdirs();\n        assertFiltering(filter1, file, false);\n        assertFiltering(filter2, file, false);\n        FileUtils.deleteDirectory(file);\n\n        file = new File(temporaryFolder, \"test-file1.txt\");\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output2 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output2, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, true);\n\n        file = new File(temporaryFolder, \"test-file2.log\");\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n\n        file = new File(temporaryFolder, \"CVS\");\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n    }\n\n    // -----------------------------------------------------------------------\n    @Test\n    public void testMakeDirectoryOnly() throws Exception {\n        assertSame(DirectoryFileFilter.DIRECTORY, FileFilterUtils.makeDirectoryOnly(null));\n\n        final IOFileFilter filter = FileFilterUtils.makeDirectoryOnly(FileFilterUtils.nameFileFilter(\"B\"));\n\n        final File fileA = new File(temporaryFolder, \"A\");\n        final File fileB = new File(temporaryFolder, \"B\");\n\n        fileA.mkdirs();\n        fileB.mkdirs();\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, true);\n\n        FileUtils.deleteDirectory(fileA);\n        FileUtils.deleteDirectory(fileB);\n\n        if (!fileA.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + fileA + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(fileA))) {\n            TestUtils.generateTestData(output1, 32);\n        }\n        if (!fileB.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + fileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(fileB))) {\n            TestUtils.generateTestData(output, 32);\n        }\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, false);\n\n        fileA.delete();\n        fileB.delete();\n    }\n\n    // -----------------------------------------------------------------------\n    @Test\n    public void testMakeFileOnly() throws Exception {\n        assertSame(FileFileFilter.FILE, FileFilterUtils.makeFileOnly(null));\n\n        final IOFileFilter filter = FileFilterUtils.makeFileOnly(FileFilterUtils.nameFileFilter(\"B\"));\n\n        final File fileA = new File(temporaryFolder, \"A\");\n        final File fileB = new File(temporaryFolder, \"B\");\n\n        fileA.mkdirs();\n        fileB.mkdirs();\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, false);\n\n        FileUtils.deleteDirectory(fileA);\n        FileUtils.deleteDirectory(fileB);\n\n        if (!fileA.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + fileA + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(fileA))) {\n            TestUtils.generateTestData(output1, 32);\n        }\n        if (!fileB.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + fileB + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(fileB))) {\n            TestUtils.generateTestData(output, 32);\n        }\n\n        assertFiltering(filter, fileA, false);\n        assertFiltering(filter, fileB, true);\n\n        fileA.delete();\n        fileB.delete();\n    }\n\n    @Test\n    public void testMakeSVNAware() throws Exception {\n        final IOFileFilter filter1 = FileFilterUtils.makeSVNAware(null);\n        final IOFileFilter filter2 = FileFilterUtils.makeSVNAware(FileFilterUtils.nameFileFilter(\"test-file1.txt\"));\n\n        File file = new File(temporaryFolder, SVN_DIR_NAME);\n        file.mkdirs();\n        assertFiltering(filter1, file, false);\n        assertFiltering(filter2, file, false);\n        FileUtils.deleteDirectory(file);\n\n        file = new File(temporaryFolder, \"test-file1.txt\");\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output2 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output2, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, true);\n\n        file = new File(temporaryFolder, \"test-file2.log\");\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output1, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n\n        file = new File(temporaryFolder, SVN_DIR_NAME);\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(file))) {\n            TestUtils.generateTestData(output, 0);\n        }\n        assertFiltering(filter1, file, true);\n        assertFiltering(filter2, file, false);\n    }\n\n    @Test\n    public void testNameFilter() throws Exception {\n        IOFileFilter filter = new NameFileFilter(new String[] {\"foo\", \"bar\"});\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true);\n        assertFiltering(filter, new File(\"BAR\"), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true);\n        assertFiltering(filter, new File(\"BAR\").toPath(), true);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\"), WINDOWS);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), WINDOWS);\n        assertFiltering(filter, new File(\"BAR\").toPath(), WINDOWS);\n\n        filter = new NameFileFilter(new String[] {\"foo\", \"bar\"}, null);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false);\n        assertFiltering(filter, new File(\"BAR\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false);\n        assertFiltering(filter, new File(\"BAR\").toPath(), false);\n\n        // repeat for a List\n        final java.util.ArrayList<String> list = new java.util.ArrayList<>();\n        list.add(\"foo\");\n        list.add(\"bar\");\n        filter = new NameFileFilter(list);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        filter = new NameFileFilter(\"foo\");\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        // FileFilterUtils.nameFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.nameFileFilter(\"foo\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"FOO\"), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\"), false);\n        assertFiltering(filter, new File(\"foobar\"), false);\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO\").toPath(), true); // case-insensitive\n        assertFiltering(filter, new File(\"barfoo\").toPath(), false);\n        assertFiltering(filter, new File(\"foobar\").toPath(), false);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n    }\n\n    @Test\n    public void testNameFilterNullArgument() throws Exception {\n        final String test = null;\n        try {\n            new NameFileFilter(test);\n            fail(\"constructing a NameFileFilter with a null String argument should fail.\");\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            FileFilterUtils.nameFileFilter(test, IOCase.INSENSITIVE);\n            fail(\"constructing a NameFileFilter with a null String argument should fail.\");\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testNameFilterNullArrayArgument() {\n        assertThrows(IllegalArgumentException.class, () -> new NameFileFilter((String[]) null));\n    }\n\n    @Test\n    public void testNameFilterNullListArgument() {\n        final List<String> test = null;\n        assertThrows(IllegalArgumentException.class, () -> new NameFileFilter(test));\n    }\n\n    @Test\n    public void testNegate() throws Exception {\n        final IOFileFilter filter = FileFilterUtils.notFileFilter(FileFilterUtils.trueFileFilter());\n        assertFiltering(filter, new File(\"foo.test\"), false);\n        assertFiltering(filter, new File(\"foo\"), false);\n        assertFiltering(filter.negate(), new File(\"foo\"), true);\n        assertFiltering(filter, (File) null, false);\n        assertThrows(IllegalArgumentException.class, () -> new NotFileFilter(null));\n    }\n\n    @Test\n    public void testNullFilters() {\n        try {\n            FileFilterUtils.toList((IOFileFilter) null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException ignore) {\n            // expected\n        }\n        try {\n            FileFilterUtils.toList(new IOFileFilter[] {null});\n            fail(\"Expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException ignore) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testOr() throws Exception {\n        final IOFileFilter trueFilter = TrueFileFilter.INSTANCE;\n        final IOFileFilter falseFilter = FalseFileFilter.INSTANCE;\n        final File testFile = new File(\"foo.test\");\n        final Path testPath = testFile.toPath();\n        assertFiltering(new OrFileFilter(trueFilter, trueFilter), testFile, true);\n        assertFiltering(new OrFileFilter(trueFilter, falseFilter), testFile, true);\n        assertFiltering(new OrFileFilter(falseFilter, trueFilter), testFile, true);\n        assertFiltering(new OrFileFilter(falseFilter, falseFilter), testFile, false);\n        assertFiltering(new OrFileFilter(), testFile, false);\n        //\n        assertFiltering(new OrFileFilter(trueFilter, trueFilter), testPath, true);\n        assertFiltering(new OrFileFilter(trueFilter, falseFilter), testPath, true);\n        assertFiltering(new OrFileFilter(falseFilter, trueFilter), testPath, true);\n        assertFiltering(new OrFileFilter(falseFilter, falseFilter), testPath, false);\n        assertFiltering(new OrFileFilter(), testPath, false);\n        //\n        assertFiltering(falseFilter.or(trueFilter), testPath, true);\n        assertFiltering(falseFilter.or(falseFilter, trueFilter), testPath, true);\n        assertFiltering(falseFilter.or(falseFilter, falseFilter, trueFilter), testPath, true);\n\n        final List<IOFileFilter> filters = new ArrayList<>();\n        filters.add(trueFilter);\n        filters.add(falseFilter);\n\n        final OrFileFilter orFilter = new OrFileFilter(filters);\n\n        assertFiltering(orFilter, testFile, true);\n        assertFiltering(orFilter, testPath, true);\n        assertEquals(orFilter.getFileFilters(), filters);\n        orFilter.removeFileFilter(trueFilter);\n        assertFiltering(orFilter, testFile, false);\n        assertFiltering(orFilter, testPath, false);\n        orFilter.setFileFilters(filters);\n        assertFiltering(orFilter, testFile, true);\n        assertFiltering(orFilter, testPath, true);\n\n        assertTrue(orFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertEquals(FileVisitResult.CONTINUE, orFilter.accept(testPath, null));\n        orFilter.removeFileFilter(trueFilter);\n        assertTrue(!orFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertEquals(FileVisitResult.TERMINATE, orFilter.accept(testPath, null));\n\n        try {\n            new OrFileFilter(falseFilter, (IOFileFilter) null);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n        }\n\n        final OrFileFilter f = new OrFileFilter((List<IOFileFilter>) null);\n        assertTrue(f.getFileFilters().isEmpty());\n    }\n\n    @Test\n    public void testPrefix() throws Exception {\n        IOFileFilter filter = new PrefixFileFilter(new String[] {\"foo\", \"bar\"});\n        final File testFile = new File(\"test\");\n        final Path testPath = testFile.toPath();\n        final File fredFile = new File(\"fred\");\n        final Path fredPath = fredFile.toPath();\n\n        assertFiltering(filter, new File(\"foo.test\"), true);\n        assertFiltering(filter, new File(\"FOO.test\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, new File(\"bar\"), true);\n        assertFiltering(filter, new File(\"food/\"), true);\n        //\n        assertFiltering(filter, new File(\"foo.test\").toPath(), true);\n        assertFiltering(filter, new File(\"FOO.test\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, new File(\"bar\").toPath(), true);\n        assertFiltering(filter, new File(\"food/\").toPath(), true);\n\n        filter = FileFilterUtils.prefixFileFilter(\"bar\");\n        assertFiltering(filter, new File(\"barred\\\\\"), true);\n        assertFiltering(filter, new File(\"test\"), false);\n        assertFiltering(filter, new File(\"fo_o.test\"), false);\n        assertFiltering(filter, new File(\"abar.exe\"), false);\n        //\n        assertFiltering(filter, new File(\"barred\\\\\").toPath(), true);\n        assertFiltering(filter, new File(\"test\").toPath(), false);\n        assertFiltering(filter, new File(\"fo_o.test\").toPath(), false);\n        assertFiltering(filter, new File(\"abar.exe\").toPath(), false);\n\n        filter = new PrefixFileFilter(\"tes\");\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        //\n        assertFiltering(filter, new File(\"test\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        assertTrue(filter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(!filter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, filter.accept(testPath, null));\n        assertEquals(FileVisitResult.TERMINATE, filter.accept(fredPath, null));\n\n        final List<String> prefixes = Arrays.asList(\"foo\", \"fre\");\n        final IOFileFilter listFilter = new PrefixFileFilter(prefixes);\n\n        assertTrue(!listFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(listFilter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(testPath, null));\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(fredPath, null));\n\n        try {\n            new PrefixFileFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testPrefixCaseInsensitive() throws Exception {\n\n        IOFileFilter filter = new PrefixFileFilter(new String[] {\"foo\", \"bar\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test1\"), true);\n        assertFiltering(filter, new File(\"bar.test1\"), true);\n        assertFiltering(filter, new File(\"FOO.test1\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test1\"), true); // case-sensitive\n\n        filter = new PrefixFileFilter(\"bar\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test2\"), false);\n        assertFiltering(filter, new File(\"bar.test2\"), true);\n        assertFiltering(filter, new File(\"FOO.test2\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test2\"), true); // case-sensitive\n\n        final List<String> prefixes = Arrays.asList(\"foo\", \"bar\");\n        filter = new PrefixFileFilter(prefixes, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test3\"), true);\n        assertFiltering(filter, new File(\"bar.test3\"), true);\n        assertFiltering(filter, new File(\"FOO.test3\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test3\"), true); // case-sensitive\n\n        try {\n            new PrefixFileFilter((String) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((String[]) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new PrefixFileFilter((List<String>) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        // FileFilterUtils.prefixFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.prefixFileFilter(\"bar\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.test2\"), false);\n        assertFiltering(filter, new File(\"bar.test2\"), true);\n        assertFiltering(filter, new File(\"FOO.test2\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"BAR.test2\"), true); // case-sensitive\n\n        try {\n            FileFilterUtils.prefixFileFilter(null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testSizeFilterOnFiles() throws Exception {\n        final File smallFile = new File(temporaryFolder, \"small.txt\");\n        if (!smallFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + smallFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 = new BufferedOutputStream(new FileOutputStream(smallFile))) {\n            TestUtils.generateTestData(output1, 32);\n        }\n        final File largeFile = new File(temporaryFolder, \"large.txt\");\n        if (!largeFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + largeFile + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(largeFile))) {\n            TestUtils.generateTestData(output, 128);\n        }\n        final IOFileFilter filter1 = FileFilterUtils.sizeFileFilter(64);\n        final IOFileFilter filter2 = FileFilterUtils.sizeFileFilter(64, true);\n        final IOFileFilter filter3 = FileFilterUtils.sizeFileFilter(64, false);\n\n        assertFiltering(filter1, smallFile, false);\n        assertFiltering(filter2, smallFile, false);\n        assertFiltering(filter3, smallFile, true);\n        assertFiltering(filter1, largeFile, true);\n        assertFiltering(filter2, largeFile, true);\n        assertFiltering(filter3, largeFile, false);\n\n        // size range tests\n        final IOFileFilter filter4 = FileFilterUtils.sizeRangeFileFilter(33, 127);\n        final IOFileFilter filter5 = FileFilterUtils.sizeRangeFileFilter(32, 127);\n        final IOFileFilter filter6 = FileFilterUtils.sizeRangeFileFilter(33, 128);\n        final IOFileFilter filter7 = FileFilterUtils.sizeRangeFileFilter(31, 129);\n        final IOFileFilter filter8 = FileFilterUtils.sizeRangeFileFilter(128, 128);\n\n        assertFiltering(filter4, smallFile, false);\n        assertFiltering(filter4, largeFile, false);\n        assertFiltering(filter5, smallFile, true);\n        assertFiltering(filter5, largeFile, false);\n        assertFiltering(filter6, smallFile, false);\n        assertFiltering(filter6, largeFile, true);\n        assertFiltering(filter7, smallFile, true);\n        assertFiltering(filter7, largeFile, true);\n        assertFiltering(filter8, largeFile, true);\n\n        try {\n            FileFilterUtils.sizeFileFilter(-1);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testSizeFilterOnPaths() throws Exception {\n        final Path smallFile = Paths.get(temporaryFolder.toString(), \"small.txt\");\n        if (!Files.exists(smallFile.getParent())) {\n            throw new IOException(\"Cannot create file \" + smallFile + \" as the parent directory does not exist\");\n        }\n        try (OutputStream output = Files.newOutputStream(smallFile)) {\n            TestUtils.generateTestData(output, 32);\n        }\n        final Path largeFile = Paths.get(temporaryFolder.toString(), \"large.txt\");\n        if (!Files.exists(largeFile.getParent())) {\n            throw new IOException(\"Cannot create file \" + largeFile + \" as the parent directory does not exist\");\n        }\n        try (OutputStream output = Files.newOutputStream(largeFile)) {\n            TestUtils.generateTestData(output, 128);\n        }\n        final IOFileFilter filter1 = FileFilterUtils.sizeFileFilter(64);\n        final IOFileFilter filter2 = FileFilterUtils.sizeFileFilter(64, true);\n        final IOFileFilter filter3 = FileFilterUtils.sizeFileFilter(64, false);\n\n        assertFiltering(filter1, smallFile, false);\n        assertFiltering(filter2, smallFile, false);\n        assertFiltering(filter3, smallFile, true);\n        assertFiltering(filter1, largeFile, true);\n        assertFiltering(filter2, largeFile, true);\n        assertFiltering(filter3, largeFile, false);\n\n        // size range tests\n        final IOFileFilter filter4 = FileFilterUtils.sizeRangeFileFilter(33, 127);\n        final IOFileFilter filter5 = FileFilterUtils.sizeRangeFileFilter(32, 127);\n        final IOFileFilter filter6 = FileFilterUtils.sizeRangeFileFilter(33, 128);\n        final IOFileFilter filter7 = FileFilterUtils.sizeRangeFileFilter(31, 129);\n        final IOFileFilter filter8 = FileFilterUtils.sizeRangeFileFilter(128, 128);\n\n        assertFiltering(filter4, smallFile, false);\n        assertFiltering(filter4, largeFile, false);\n        assertFiltering(filter5, smallFile, true);\n        assertFiltering(filter5, largeFile, false);\n        assertFiltering(filter6, smallFile, false);\n        assertFiltering(filter6, largeFile, true);\n        assertFiltering(filter7, smallFile, true);\n        assertFiltering(filter7, largeFile, true);\n        assertFiltering(filter8, largeFile, true);\n\n        try {\n            FileFilterUtils.sizeFileFilter(-1);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testSuffix() throws Exception {\n        IOFileFilter filter = new SuffixFileFilter(new String[] {\"tes\", \"est\"});\n        final File testFile = new File(\"test\");\n        final Path testPath = testFile.toPath();\n        final File fredFile = new File(\"fred\");\n        final Path fredPath = fredFile.toPath();\n        //\n        assertFiltering(filter, new File(\"fred.tes\"), true);\n        assertFiltering(filter, new File(\"fred.est\"), true);\n        assertFiltering(filter, new File(\"fred.EST\"), false); // case-sensitive\n        assertFiltering(filter, new File(\"fred.exe\"), false);\n        //\n        assertFiltering(filter, new File(\"fred.tes\").toPath(), true);\n        assertFiltering(filter, new File(\"fred.est\").toPath(), true);\n        assertFiltering(filter, new File(\"fred.EST\").toPath(), false); // case-sensitive\n        assertFiltering(filter, new File(\"fred.exe\").toPath(), false);\n\n        filter = FileFilterUtils.or(FileFilterUtils.suffixFileFilter(\"tes\"), FileFilterUtils.suffixFileFilter(\"est\"));\n        assertFiltering(filter, new File(\"fred\"), false);\n        assertFiltering(filter, new File(\".tes\"), true);\n        assertFiltering(filter, new File(\"fred.test\"), true);\n        //\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n        assertFiltering(filter, new File(\".tes\").toPath(), true);\n        assertFiltering(filter, new File(\"fred.test\").toPath(), true);\n\n        filter = new SuffixFileFilter(\"est\");\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"fred\"), false);\n        //\n        assertFiltering(filter, new File(\"test\").toPath(), true);\n        assertFiltering(filter, new File(\"fred\").toPath(), false);\n\n        assertTrue(filter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(!filter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, filter.accept(testPath, null));\n        assertEquals(FileVisitResult.TERMINATE, filter.accept(fredPath, null));\n\n        final List<String> prefixes = Arrays.asList(\"ood\", \"red\");\n        final IOFileFilter listFilter = new SuffixFileFilter(prefixes);\n\n        assertTrue(!listFilter.accept(testFile.getParentFile(), testFile.getName()));\n        assertTrue(listFilter.accept(fredFile.getParentFile(), fredFile.getName()));\n        //\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(testPath, null));\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(fredPath, null));\n\n        try {\n            new SuffixFileFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testSuffixCaseInsensitive() throws Exception {\n\n        IOFileFilter filter = new SuffixFileFilter(new String[] {\"tes\", \"est\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"foo.tes\"), true);\n        assertFiltering(filter, new File(\"foo.est\"), true);\n        assertFiltering(filter, new File(\"foo.EST\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"foo.TES\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"foo.exe\"), false);\n\n        filter = new SuffixFileFilter(\"est\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"TEST\"), true);\n\n        final List<String> suffixes = Arrays.asList(\"tes\", \"est\");\n        filter = new SuffixFileFilter(suffixes, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"bar.tes\"), true);\n        assertFiltering(filter, new File(\"bar.est\"), true);\n        assertFiltering(filter, new File(\"bar.EST\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"bar.TES\"), true); // case-sensitive\n        assertFiltering(filter, new File(\"bar.exe\"), false);\n\n        try {\n            new SuffixFileFilter((String) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((String[]) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            new SuffixFileFilter((List<String>) null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        // FileFilterUtils.suffixFileFilter(String, IOCase) tests\n        filter = FileFilterUtils.suffixFileFilter(\"est\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"test\"), true);\n        assertFiltering(filter, new File(\"TEST\"), true);\n\n        try {\n            FileFilterUtils.suffixFileFilter(null, IOCase.INSENSITIVE);\n            fail();\n        } catch (final IllegalArgumentException ex) {\n        }\n    }\n\n    @Test\n    public void testTrue() throws Exception {\n        final IOFileFilter filter = FileFilterUtils.trueFileFilter();\n        assertFiltering(filter, new File(\"foo.test\"), true);\n        assertFiltering(filter, new File(\"foo\"), true);\n        assertFiltering(filter, (File) null, true);\n        //\n        assertFiltering(filter, new File(\"foo.test\").toPath(), true);\n        assertFiltering(filter, new File(\"foo\").toPath(), true);\n        assertFiltering(filter, (Path) null, true);\n        //\n        assertSame(TrueFileFilter.TRUE, TrueFileFilter.INSTANCE);\n        assertSame(FalseFileFilter.FALSE, TrueFileFilter.INSTANCE.negate());\n        assertSame(FalseFileFilter.INSTANCE, TrueFileFilter.INSTANCE.negate());\n    }\n\n    @Test\n    public void testWildcard() throws Exception {\n        IOFileFilter filter = new WildcardFileFilter(\"*.txt\");\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), false);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), false);\n\n        filter = new WildcardFileFilter(\"*.txt\", IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), false);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), false);\n\n        filter = new WildcardFileFilter(\"*.txt\", IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), true);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), true);\n\n        filter = new WildcardFileFilter(\"*.txt\", IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), WINDOWS);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), WINDOWS);\n\n        filter = new WildcardFileFilter(\"*.txt\", null);\n        assertFiltering(filter, new File(\"log.txt\"), true);\n        assertFiltering(filter, new File(\"log.TXT\"), false);\n        //\n        assertFiltering(filter, new File(\"log.txt\").toPath(), true);\n        assertFiltering(filter, new File(\"log.TXT\").toPath(), false);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"});\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.class\"), true);\n        assertFiltering(filter, new File(\"Test.jsp\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.class\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.jsp\").toPath(), false);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, IOCase.SENSITIVE);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), false);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, IOCase.INSENSITIVE);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), true);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), true);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, IOCase.SYSTEM);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), WINDOWS);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), WINDOWS);\n\n        filter = new WildcardFileFilter(new String[] {\"*.java\", \"*.class\"}, null);\n        assertFiltering(filter, new File(\"Test.java\"), true);\n        assertFiltering(filter, new File(\"Test.JAVA\"), false);\n        //\n        assertFiltering(filter, new File(\"Test.java\").toPath(), true);\n        assertFiltering(filter, new File(\"Test.JAVA\").toPath(), false);\n\n        final List<String> patternList = Arrays.asList(\"*.txt\", \"*.xml\", \"*.gif\");\n        final IOFileFilter listFilter = new WildcardFileFilter(patternList);\n        assertFiltering(listFilter, new File(\"Test.txt\"), true);\n        assertFiltering(listFilter, new File(\"Test.xml\"), true);\n        assertFiltering(listFilter, new File(\"Test.gif\"), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\"), false);\n        //\n        assertFiltering(listFilter, new File(\"Test.txt\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.xml\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.gif\").toPath(), true);\n        assertFiltering(listFilter, new File(\"Test.bmp\").toPath(), false);\n\n        final File txtFile = new File(\"test.txt\");\n        final Path txtPath = txtFile.toPath();\n        final File bmpFile = new File(\"test.bmp\");\n        final Path bmpPath = bmpFile.toPath();\n        final File dirFile = new File(\"src/java\");\n        final Path dirPath = dirFile.toPath();\n        assertTrue(listFilter.accept(txtFile));\n        assertTrue(!listFilter.accept(bmpFile));\n        assertTrue(!listFilter.accept(dirFile));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtFile.toPath(), null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpFile.toPath(), null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirFile.toPath(), null));\n\n        assertTrue(listFilter.accept(txtFile.getParentFile(), txtFile.getName()));\n        assertTrue(!listFilter.accept(bmpFile.getParentFile(), bmpFile.getName()));\n        assertTrue(!listFilter.accept(dirFile.getParentFile(), dirFile.getName()));\n        //\n        assertEquals(FileVisitResult.CONTINUE, listFilter.accept(txtPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(bmpPath, null));\n        assertEquals(FileVisitResult.TERMINATE, listFilter.accept(dirPath, null));\n\n        try {\n            new WildcardFileFilter((String) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n        try {\n            new WildcardFileFilter((String[]) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n        try {\n            new WildcardFileFilter((List<String>) null);\n            fail();\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprotected updateDirCounter(dir Path, exc IOException) : void extracted from public postVisitDirectory(dir Path, exc IOException) : FileVisitResult in class org.apache.commons.io.file.CountingPathVisitor", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/file/CountingPathVisitor.java", "startLine": 109, "endLine": 113, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/file/CountingPathVisitor.java", "startLine": 109, "endLine": 113, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/file/CountingPathVisitor.java", "startLine": 120, "endLine": 129, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Override\n    public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n        pathCounters.getDirectoryCounter().increment();\n        return FileVisitResult.CONTINUE;\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/file/CountingPathVisitor.java", "isPureRefactoring": true, "commitId": "6803ac145c274546d0f2e06374a9723a4d4d7ce6", "packageNameBefore": "org.apache.commons.io.file", "classNameBefore": "org.apache.commons.io.file.CountingPathVisitor", "methodNameBefore": "org.apache.commons.io.file.CountingPathVisitor#postVisitDirectory", "classSignatureBefore": "public class CountingPathVisitor extends SimplePathVisitor ", "methodNameBeforeSet": ["org.apache.commons.io.file.CountingPathVisitor#postVisitDirectory"], "classNameBeforeSet": ["org.apache.commons.io.file.CountingPathVisitor"], "classSignatureBeforeSet": ["public class CountingPathVisitor extends SimplePathVisitor "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.IOException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Objects;\n\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.PathFilter;\nimport org.apache.commons.io.filefilter.TrueFileFilter;\n\n/**\n * Counts files, directories, and sizes, as a visit proceeds.\n *\n * @since 2.7\n */\npublic class CountingPathVisitor extends SimplePathVisitor {\n\n    static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    /**\n     * Creates a new instance configured with a BigInteger {@link PathCounters}.\n     *\n     * @return a new instance configured with a BigInteger {@link PathCounters}.\n     */\n    public static CountingPathVisitor withBigIntegerCounters() {\n        return new CountingPathVisitor(Counters.bigIntegerPathCounters());\n    }\n\n    /**\n     * Creates a new instance configured with a long {@link PathCounters}.\n     *\n     * @return a new instance configured with a long {@link PathCounters}.\n     */\n    public static CountingPathVisitor withLongCounters() {\n        return new CountingPathVisitor(Counters.longPathCounters());\n    }\n\n    private final PathCounters pathCounters;\n    private final PathFilter pathFilter;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param pathCounter How to count path visits.\n     */\n    public CountingPathVisitor(final PathCounters pathCounter) {\n        this(pathCounter, TrueFileFilter.INSTANCE);\n    }\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param pathCounter How to count path visits.\n     * @param pathFilter Filters which paths to count.\n     * @since 2.9.0\n     */\n    public CountingPathVisitor(final PathCounters pathCounter, final PathFilter pathFilter) {\n        super();\n        this.pathCounters = Objects.requireNonNull(pathCounter, \"pathCounter\");\n        this.pathFilter = Objects.requireNonNull(pathFilter, \"pathFilter\");\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof CountingPathVisitor)) {\n            return false;\n        }\n        final CountingPathVisitor other = (CountingPathVisitor) obj;\n        return Objects.equals(pathCounters, other.pathCounters);\n    }\n\n    /**\n     * Gets the visitation counts.\n     *\n     * @return the visitation counts.\n     */\n    public PathCounters getPathCounters() {\n        return pathCounters;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(pathCounters);\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n        pathCounters.getDirectoryCounter().increment();\n        return FileVisitResult.CONTINUE;\n    }\n\n    @Override\n    public String toString() {\n        return pathCounters.toString();\n    }\n\n    /**\n     * Updates the counters for visiting the given file.\n     *\n     * @param file the visited file.\n     * @param attributes the visited file attributes.\n     */\n    protected void updateFileCounters(final Path file, final BasicFileAttributes attributes) {\n        pathCounters.getFileCounter().increment();\n        pathCounters.getByteCounter().add(attributes.size());\n    }\n\n    @Override\n    public FileVisitResult visitFile(final Path file, final BasicFileAttributes attributes) throws IOException {\n        if (Files.exists(file) && pathFilter.accept(file) == FileVisitResult.CONTINUE) {\n            updateFileCounters(file, attributes);\n        }\n        return FileVisitResult.CONTINUE;\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/file/CountingPathVisitor.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.IOException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Objects;\n\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.PathFilter;\nimport org.apache.commons.io.filefilter.TrueFileFilter;\n\n/**\n * Counts files, directories, and sizes, as a visit proceeds.\n *\n * @since 2.7\n */\npublic class CountingPathVisitor extends SimplePathVisitor {\n\n    static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    /**\n     * Creates a new instance configured with a BigInteger {@link PathCounters}.\n     *\n     * @return a new instance configured with a BigInteger {@link PathCounters}.\n     */\n    public static CountingPathVisitor withBigIntegerCounters() {\n        return new CountingPathVisitor(Counters.bigIntegerPathCounters());\n    }\n\n    /**\n     * Creates a new instance configured with a long {@link PathCounters}.\n     *\n     * @return a new instance configured with a long {@link PathCounters}.\n     */\n    public static CountingPathVisitor withLongCounters() {\n        return new CountingPathVisitor(Counters.longPathCounters());\n    }\n\n    private final PathCounters pathCounters;\n    private final PathFilter pathFilter;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param pathCounter How to count path visits.\n     */\n    public CountingPathVisitor(final PathCounters pathCounter) {\n        this(pathCounter, TrueFileFilter.INSTANCE);\n    }\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param pathCounter How to count path visits.\n     * @param pathFilter Filters which paths to count.\n     * @since 2.9.0\n     */\n    public CountingPathVisitor(final PathCounters pathCounter, final PathFilter pathFilter) {\n        super();\n        this.pathCounters = Objects.requireNonNull(pathCounter, \"pathCounter\");\n        this.pathFilter = Objects.requireNonNull(pathFilter, \"pathFilter\");\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof CountingPathVisitor)) {\n            return false;\n        }\n        final CountingPathVisitor other = (CountingPathVisitor) obj;\n        return Objects.equals(pathCounters, other.pathCounters);\n    }\n\n    /**\n     * Gets the visitation counts.\n     *\n     * @return the visitation counts.\n     */\n    public PathCounters getPathCounters() {\n        return pathCounters;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(pathCounters);\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n        updateDirCounter(dir, exc);\n        return FileVisitResult.CONTINUE;\n    }\n\n    @Override\n    public String toString() {\n        return pathCounters.toString();\n    }\n\n    /**\n     * Updates the counter for visiting the given directory.\n     *\n     * @param dir the visited directory.\n     * @param exc Encountered exception.\n     * @since 2.9.0\n     */\n    protected void updateDirCounter(Path dir, IOException exc) {\n        pathCounters.getDirectoryCounter().increment();\n    }\n\n    /**\n     * Updates the counters for visiting the given file.\n     *\n     * @param file the visited file.\n     * @param attributes the visited file attributes.\n     */\n    protected void updateFileCounters(final Path file, final BasicFileAttributes attributes) {\n        pathCounters.getFileCounter().increment();\n        pathCounters.getByteCounter().add(attributes.size());\n    }\n\n    @Override\n    public FileVisitResult visitFile(final Path file, final BasicFileAttributes attributes) throws IOException {\n        if (Files.exists(file) && pathFilter.accept(file) == FileVisitResult.CONTINUE) {\n            updateFileCounters(file, attributes);\n        }\n        return FileVisitResult.CONTINUE;\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Updates the counter for visiting the given directory.\n     *\n     * @param dir the visited directory.\n     * @param exc Encountered exception.\n     * @since 2.9.0\n     */\n    protected void updateDirCounter(Path dir, IOException exc) {\n        pathCounters.getDirectoryCounter().increment();\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "@Override\n    public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n        updateDirCounter(dir, exc);\n        return FileVisitResult.CONTINUE;\n    }\n/**\n     * Updates the counter for visiting the given directory.\n     *\n     * @param dir the visited directory.\n     * @param exc Encountered exception.\n     * @since 2.9.0\n     */\n    protected void updateDirCounter(Path dir, IOException exc) {\n        pathCounters.getDirectoryCounter().increment();\n    }", "diffSourceCode": "   109:     @Override\n   110:     public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n-  111:         pathCounters.getDirectoryCounter().increment();\n+  111:         updateDirCounter(dir, exc);\n   112:         return FileVisitResult.CONTINUE;\n   113:     }\n   120:     /**\n-  121:      * Updates the counters for visiting the given file.\n+  121:      * Updates the counter for visiting the given directory.\n   122:      *\n-  123:      * @param file the visited file.\n-  124:      * @param attributes the visited file attributes.\n-  125:      */\n-  126:     protected void updateFileCounters(final Path file, final BasicFileAttributes attributes) {\n-  127:         pathCounters.getFileCounter().increment();\n-  128:         pathCounters.getByteCounter().add(attributes.size());\n+  123:      * @param dir the visited directory.\n+  124:      * @param exc Encountered exception.\n+  125:      * @since 2.9.0\n+  126:      */\n+  127:     protected void updateDirCounter(Path dir, IOException exc) {\n+  128:         pathCounters.getDirectoryCounter().increment();\n   129:     }\n", "uniqueId": "6803ac145c274546d0f2e06374a9723a4d4d7ce6_109_113_120_129_109_113", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 6}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `postVisitDirectory` method, we can extract the logic of incrementing the directory counter into a separate method. This will make the `postVisitDirectory` method cleaner and more focused on its primary responsibility.\n\nHere\u2019s the refactored code:\n\n```java\n@Override\npublic FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n    incrementDirectoryCounter();\n    return FileVisitResult.CONTINUE;\n}\n\nprivate void incrementDirectoryCounter() {\n    pathCounters.getDirectoryCounter().increment();\n}\n```\n\nNow, the `postVisitDirectory` method simply calls the new `incrementDirectoryCounter` method, which handles the incrementing logic. This enhances the clarity of the code.\n\nHere\u2019s the output in the required format:\n\n##########################\n```java\n@Override\npublic FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n    incrementDirectoryCounter();\n    return FileVisitResult.CONTINUE;\n}\n\nprivate void incrementDirectoryCounter() {\n    pathCounters.getDirectoryCounter().increment();\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Override\n    public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n        pathCounters.getDirectoryCounter().increment();\n        return FileVisitResult.CONTINUE;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport java.io.IOException;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.Objects;\n\nimport org.apache.commons.io.file.Counters.PathCounters;\nimport org.apache.commons.io.filefilter.PathFilter;\nimport org.apache.commons.io.filefilter.TrueFileFilter;\n\n/**\n * Counts files, directories, and sizes, as a visit proceeds.\n *\n * @since 2.7\n */\npublic class CountingPathVisitor extends SimplePathVisitor {\n\n    static final String[] EMPTY_STRING_ARRAY = new String[0];\n\n    /**\n     * Creates a new instance configured with a BigInteger {@link PathCounters}.\n     *\n     * @return a new instance configured with a BigInteger {@link PathCounters}.\n     */\n    public static CountingPathVisitor withBigIntegerCounters() {\n        return new CountingPathVisitor(Counters.bigIntegerPathCounters());\n    }\n\n    /**\n     * Creates a new instance configured with a long {@link PathCounters}.\n     *\n     * @return a new instance configured with a long {@link PathCounters}.\n     */\n    public static CountingPathVisitor withLongCounters() {\n        return new CountingPathVisitor(Counters.longPathCounters());\n    }\n\n    private final PathCounters pathCounters;\n    private final PathFilter pathFilter;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param pathCounter How to count path visits.\n     */\n    public CountingPathVisitor(final PathCounters pathCounter) {\n        this(pathCounter, TrueFileFilter.INSTANCE);\n    }\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param pathCounter How to count path visits.\n     * @param pathFilter Filters which paths to count.\n     * @since 2.9.0\n     */\n    public CountingPathVisitor(final PathCounters pathCounter, final PathFilter pathFilter) {\n        super();\n        this.pathCounters = Objects.requireNonNull(pathCounter, \"pathCounter\");\n        this.pathFilter = Objects.requireNonNull(pathFilter, \"pathFilter\");\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof CountingPathVisitor)) {\n            return false;\n        }\n        final CountingPathVisitor other = (CountingPathVisitor) obj;\n        return Objects.equals(pathCounters, other.pathCounters);\n    }\n\n    /**\n     * Gets the visitation counts.\n     *\n     * @return the visitation counts.\n     */\n    public PathCounters getPathCounters() {\n        return pathCounters;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(pathCounters);\n    }\n\n    @Override\n    public FileVisitResult postVisitDirectory(final Path dir, final IOException exc) throws IOException {\n        pathCounters.getDirectoryCounter().increment();\n        return FileVisitResult.CONTINUE;\n    }\n\n    @Override\n    public String toString() {\n        return pathCounters.toString();\n    }\n\n    /**\n     * Updates the counters for visiting the given file.\n     *\n     * @param file the visited file.\n     * @param attributes the visited file attributes.\n     */\n    protected void updateFileCounters(final Path file, final BasicFileAttributes attributes) {\n        pathCounters.getFileCounter().increment();\n        pathCounters.getByteCounter().add(attributes.size());\n    }\n\n    @Override\n    public FileVisitResult visitFile(final Path file, final BasicFileAttributes attributes) throws IOException {\n        if (Files.exists(file) && pathFilter.accept(file) == FileVisitResult.CONTINUE) {\n            updateFileCounters(file, attributes);\n        }\n        return FileVisitResult.CONTINUE;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate acceptBaseName(baseName String) : boolean extracted from public accept(dir File, name String) : boolean in class org.apache.commons.io.filefilter.NameFileFilter", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java", "startLine": 151, "endLine": 166, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java", "startLine": 167, "endLine": 177, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java", "startLine": 203, "endLine": 210, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks to see if the file name matches.\n     *\n     * @param dir  the File directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        for (final String name2 : names) {\n            if (caseSensitivity.checkEquals(name, name2)) {\n                return true;\n            }\n        }\n        return false;\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java", "isPureRefactoring": true, "commitId": "8b6d4969ffb55bf7301a44a8156f02b0213e6d68", "packageNameBefore": "org.apache.commons.io.filefilter", "classNameBefore": "org.apache.commons.io.filefilter.NameFileFilter", "methodNameBefore": "org.apache.commons.io.filefilter.NameFileFilter#accept", "classSignatureBefore": "public class NameFileFilter extends AbstractFileFilter implements Serializable ", "methodNameBeforeSet": ["org.apache.commons.io.filefilter.NameFileFilter#accept"], "classNameBeforeSet": ["org.apache.commons.io.filefilter.NameFileFilter"], "classSignatureBeforeSet": ["public class NameFileFilter extends AbstractFileFilter implements Serializable "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics\nTolerable changes in the body\nOverlapped refactoring - can be identical by undoing the overlapped refactoring\n- Rename Variable-", "description": "Rename Variable on top of the extract method - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport org.apache.commons.io.IOCase;\n\n/**\n * Filters file names for a certain name.\n * <p>\n * For example, to print all files and directories in the\n * current directory whose name is <code>Test</code>:\n *\n * <pre>\n * File dir = new File(\".\");\n * String[] files = dir.list( new NameFileFilter(\"Test\") );\n * for ( int i = 0; i &lt; files.length; i++ ) {\n *     System.out.println(files[i]);\n * }\n * </pre>\n *\n * @since 1.0\n *\n * @see FileFilterUtils#nameFileFilter(String)\n * @see FileFilterUtils#nameFileFilter(String, IOCase)\n */\npublic class NameFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = 176844364689077340L;\n    /** The file names to search for */\n    private final String[] names;\n    /** Whether the comparison is case sensitive. */\n    private final IOCase caseSensitivity;\n\n    /**\n     * Constructs a new case-sensitive name file filter for a list of names.\n     *\n     * @param names  the names to allow, must not be null\n     * @throws IllegalArgumentException if the name list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public NameFileFilter(final List<String> names) {\n        this(names, null);\n    }\n\n    /**\n     * Constructs a new name file filter for a list of names specifying case-sensitivity.\n     *\n     * @param names  the names to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the name list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public NameFileFilter(final List<String> names, final IOCase caseSensitivity) {\n        if (names == null) {\n            throw new IllegalArgumentException(\"The list of names must not be null\");\n        }\n        this.names = names.toArray(EMPTY_STRING_ARRAY);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new case-sensitive name file filter for a single name.\n     *\n     * @param name  the name to allow, must not be null\n     * @throws IllegalArgumentException if the name is null\n     */\n    public NameFileFilter(final String name) {\n        this(name, null);\n    }\n\n    /**\n     * Constructs a new case-sensitive name file filter for an array of names.\n     * <p>\n     * The array is not cloned, so could be changed after constructing the\n     * instance. This would be inadvisable however.\n     *\n     * @param names  the names to allow, must not be null\n     * @throws IllegalArgumentException if the names array is null\n     */\n    public NameFileFilter(final String... names) {\n        this(names, null);\n    }\n\n    /**\n     * Construct a new name file filter specifying case-sensitivity.\n     *\n     * @param name  the name to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the name is null\n     */\n    public NameFileFilter(final String name, final IOCase caseSensitivity) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"The wildcard must not be null\");\n        }\n        this.names = new String[] {name};\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new name file filter for an array of names specifying case-sensitivity.\n     *\n     * @param names  the names to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the names array is null\n     */\n    public NameFileFilter(final String[] names, final IOCase caseSensitivity) {\n        if (names == null) {\n            throw new IllegalArgumentException(\"The array of names must not be null\");\n        }\n        this.names = new String[names.length];\n        System.arraycopy(names, 0, this.names, 0, names.length);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks to see if the file name matches.\n     *\n     * @param file  the File to check\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File file) {\n        final String name = file.getName();\n        for (final String name2 : this.names) {\n            if (caseSensitivity.checkEquals(name, name2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks to see if the file name matches.\n     *\n     * @param dir  the File directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        for (final String name2 : names) {\n            if (caseSensitivity.checkEquals(name, name2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        if (names != null) {\n            for (int i = 0; i < names.length; i++) {\n                if (i > 0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(names[i]);\n            }\n        }\n        buffer.append(\")\");\n        return buffer.toString();\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Path;\nimport java.util.List;\n\nimport org.apache.commons.io.IOCase;\n\n/**\n * Filters file names for a certain name.\n * <p>\n * For example, to print all files and directories in the\n * current directory whose name is <code>Test</code>:\n * </p>\n * <h2>Using Classic IO</h2>\n * <pre>\n * File dir = new File(\".\");\n * String[] files = dir.list(new NameFileFilter(\"Test\"));\n * for (String file : files) {\n *     System.out.println(file);\n * }\n * </pre>\n *\n * <h2>Using NIO</h2>\n * <pre>\n * final Path dir = Paths.get(\".\");\n * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new NameFileFilter(\"Test\"));\n * //\n * // Walk one dir\n * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);\n * System.out.println(visitor.getPathCounters());\n * System.out.println(visitor.getFileList());\n * //\n * visitor.getPathCounters().reset();\n * //\n * // Walk dir tree\n * Files.<b>walkFileTree</b>(dir, visitor);\n * System.out.println(visitor.getPathCounters());\n * System.out.println(visitor.getDirList());\n * System.out.println(visitor.getFileList());\n * </pre>\n *\n * @since 1.0\n * @see FileFilterUtils#nameFileFilter(String)\n * @see FileFilterUtils#nameFileFilter(String, IOCase)\n */\npublic class NameFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = 176844364689077340L;\n\n    /** The file names to search for */\n    private final String[] names;\n\n    /** Whether the comparison is case sensitive. */\n    private final IOCase caseSensitivity;\n\n    /**\n     * Constructs a new case-sensitive name file filter for a list of names.\n     *\n     * @param names  the names to allow, must not be null\n     * @throws IllegalArgumentException if the name list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public NameFileFilter(final List<String> names) {\n        this(names, null);\n    }\n\n    /**\n     * Constructs a new name file filter for a list of names specifying case-sensitivity.\n     *\n     * @param names  the names to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the name list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public NameFileFilter(final List<String> names, final IOCase caseSensitivity) {\n        if (names == null) {\n            throw new IllegalArgumentException(\"The list of names must not be null\");\n        }\n        this.names = names.toArray(EMPTY_STRING_ARRAY);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new case-sensitive name file filter for a single name.\n     *\n     * @param name  the name to allow, must not be null\n     * @throws IllegalArgumentException if the name is null\n     */\n    public NameFileFilter(final String name) {\n        this(name, null);\n    }\n\n    /**\n     * Constructs a new case-sensitive name file filter for an array of names.\n     * <p>\n     * The array is not cloned, so could be changed after constructing the\n     * instance. This would be inadvisable however.\n     *\n     * @param names  the names to allow, must not be null\n     * @throws IllegalArgumentException if the names array is null\n     */\n    public NameFileFilter(final String... names) {\n        this(names, null);\n    }\n\n    /**\n     * Construct a new name file filter specifying case-sensitivity.\n     *\n     * @param name  the name to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the name is null\n     */\n    public NameFileFilter(final String name, final IOCase caseSensitivity) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"The wildcard must not be null\");\n        }\n        this.names = new String[] {name};\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new name file filter for an array of names specifying case-sensitivity.\n     *\n     * @param names  the names to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the names array is null\n     */\n    public NameFileFilter(final String[] names, final IOCase caseSensitivity) {\n        if (names == null) {\n            throw new IllegalArgumentException(\"The array of names must not be null\");\n        }\n        this.names = new String[names.length];\n        System.arraycopy(names, 0, this.names, 0, names.length);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Checks to see if the file name matches.\n     *\n     * @param file  the File to check\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File file) {\n        return acceptBaseName(file.getName());\n    }\n\n    /**\n     * Checks to see if the file name matches.\n     *\n     * @param dir  the File directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        return acceptBaseName(name);\n    }\n\n    /**\n     * Checks to see if the file name matches.\n     *\n     * @param dir  the File directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches\n     */\n    @Override\n    public FileVisitResult accept(final Path dir, final Path name) {\n        return toFileVisitResult(acceptBaseName(dir.getFileName().toString()));\n    }\n\n    /**\n     * Checks to see if the file name matches.\n     *\n     * @param file  the File to check\n     * @return true if the file name matches\n     * @since 2.9.0\n     */\n    @Override\n    public FileVisitResult accept(final Path file) {\n        return toFileVisitResult(acceptBaseName(file.getFileName().toString()));\n    }\n\n    private boolean acceptBaseName(final String baseName) {\n        for (final String testName : names) {\n            if (caseSensitivity.checkEquals(baseName, testName)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        if (names != null) {\n            for (int i = 0; i < names.length; i++) {\n                if (i > 0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(names[i]);\n            }\n        }\n        buffer.append(\")\");\n        return buffer.toString();\n    }\n\n}\n", "diffSourceCodeSet": ["private boolean acceptBaseName(final String baseName) {\n        for (final String testName : names) {\n            if (caseSensitivity.checkEquals(baseName, testName)) {\n                return true;\n            }\n        }\n        return false;\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Checks to see if the file name matches.\n     *\n     * @param dir  the File directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        return acceptBaseName(name);\n    }\nprivate boolean acceptBaseName(final String baseName) {\n        for (final String testName : names) {\n            if (caseSensitivity.checkEquals(baseName, testName)) {\n                return true;\n            }\n        }\n        return false;\n    }", "diffSourceCode": "-  151:     /**\n-  152:      * Checks to see if the file name matches.\n-  153:      *\n-  154:      * @param dir  the File directory (ignored)\n-  155:      * @param name  the file name\n-  156:      * @return true if the file name matches\n-  157:      */\n-  158:     @Override\n-  159:     public boolean accept(final File dir, final String name) {\n-  160:         for (final String name2 : names) {\n-  161:             if (caseSensitivity.checkEquals(name, name2)) {\n-  162:                 return true;\n-  163:             }\n-  164:         }\n-  165:         return false;\n-  166:     }\n-  167: \n-  168:     /**\n-  169:      * Provide a String representation of this file filter.\n-  170:      *\n-  171:      * @return a String representation\n-  172:      */\n-  173:     @Override\n-  174:     public String toString() {\n-  175:         final StringBuilder buffer = new StringBuilder();\n-  176:         buffer.append(super.toString());\n-  177:         buffer.append(\"(\");\n+  151:         this.names = new String[names.length];\n+  152:         System.arraycopy(names, 0, this.names, 0, names.length);\n+  153:         this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n+  154:     }\n+  155: \n+  156:     /**\n+  157:      * Checks to see if the file name matches.\n+  158:      *\n+  159:      * @param file  the File to check\n+  160:      * @return true if the file name matches\n+  161:      */\n+  162:     @Override\n+  163:     public boolean accept(final File file) {\n+  164:         return acceptBaseName(file.getName());\n+  165:     }\n+  166: \n+  167:     /**\n+  168:      * Checks to see if the file name matches.\n+  169:      *\n+  170:      * @param dir  the File directory (ignored)\n+  171:      * @param name  the file name\n+  172:      * @return true if the file name matches\n+  173:      */\n+  174:     @Override\n+  175:     public boolean accept(final File dir, final String name) {\n+  176:         return acceptBaseName(name);\n+  177:     }\n+  203:     private boolean acceptBaseName(final String baseName) {\n+  204:         for (final String testName : names) {\n+  205:             if (caseSensitivity.checkEquals(baseName, testName)) {\n+  206:                 return true;\n+  207:             }\n+  208:         }\n+  209:         return false;\n+  210:     }\n", "uniqueId": "8b6d4969ffb55bf7301a44a8156f02b0213e6d68_151_166_203_210_167_177", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 27}, "BRANCH": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 4}, "COMPLEXITY": {"missed": 0, "covered": 3}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 1.8, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `accept` method in the `NameFileFilter` class, we can extract the logic that checks if a given file name matches any of the names in the filter into a separate method. This will make the code cleaner and allow for easier testing of the matching logic.\n\nHere\u2019s the refactored code:\n\n```java\n/**\n * Checks to see if the file name matches.\n *\n * @param dir  the File directory (ignored)\n * @param name  the file name\n * @return true if the file name matches\n */\n@Override\npublic boolean accept(final File dir, final String name) {\n    return matchesAnyName(name);\n}\n\n/**\n * Checks if the provided name matches any of the names in the filter.\n *\n * @param name the file name to check\n * @return true if the name matches any of the names in the filter\n */\nprivate boolean matchesAnyName(final String name) {\n    for (final String name2 : names) {\n        if (caseSensitivity.checkEquals(name, name2)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\nThis refactoring extracts the matching logic into a new method called `matchesAnyName`, which takes a single `String` parameter and returns a boolean indicating whether the name matches any of the names in the filter. The `accept` method now simply calls this new method, improving its clarity.\n\nHere\u2019s the output in the requested format:\n\n##########################\n```java\n/**\n * Checks to see if the file name matches.\n *\n * @param dir  the File directory (ignored)\n * @param name  the file name\n * @return true if the file name matches\n */\n@Override\npublic boolean accept(final File dir, final String name) {\n    return matchesAnyName(name);\n}\n\n/**\n * Checks if the provided name matches any of the names in the filter.\n *\n * @param name the file name to check\n * @return true if the name matches any of the names in the filter\n */\nprivate boolean matchesAnyName(final String name) {\n    for (final String name2 : names) {\n        if (caseSensitivity.checkEquals(name, name2)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Checks to see if the file name matches.\n     *\n     * @param dir  the File directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        for (final String name2 : names) {\n            if (caseSensitivity.checkEquals(name, name2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport org.apache.commons.io.IOCase;\n\n/**\n * Filters file names for a certain name.\n * <p>\n * For example, to print all files and directories in the\n * current directory whose name is <code>Test</code>:\n *\n * <pre>\n * File dir = new File(\".\");\n * String[] files = dir.list( new NameFileFilter(\"Test\") );\n * for ( int i = 0; i &lt; files.length; i++ ) {\n *     System.out.println(files[i]);\n * }\n * </pre>\n *\n * @since 1.0\n *\n * @see FileFilterUtils#nameFileFilter(String)\n * @see FileFilterUtils#nameFileFilter(String, IOCase)\n */\npublic class NameFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = 176844364689077340L;\n    /** The file names to search for */\n    private final String[] names;\n    /** Whether the comparison is case sensitive. */\n    private final IOCase caseSensitivity;\n\n    /**\n     * Constructs a new case-sensitive name file filter for a list of names.\n     *\n     * @param names  the names to allow, must not be null\n     * @throws IllegalArgumentException if the name list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public NameFileFilter(final List<String> names) {\n        this(names, null);\n    }\n\n    /**\n     * Constructs a new name file filter for a list of names specifying case-sensitivity.\n     *\n     * @param names  the names to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the name list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public NameFileFilter(final List<String> names, final IOCase caseSensitivity) {\n        if (names == null) {\n            throw new IllegalArgumentException(\"The list of names must not be null\");\n        }\n        this.names = names.toArray(EMPTY_STRING_ARRAY);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new case-sensitive name file filter for a single name.\n     *\n     * @param name  the name to allow, must not be null\n     * @throws IllegalArgumentException if the name is null\n     */\n    public NameFileFilter(final String name) {\n        this(name, null);\n    }\n\n    /**\n     * Constructs a new case-sensitive name file filter for an array of names.\n     * <p>\n     * The array is not cloned, so could be changed after constructing the\n     * instance. This would be inadvisable however.\n     *\n     * @param names  the names to allow, must not be null\n     * @throws IllegalArgumentException if the names array is null\n     */\n    public NameFileFilter(final String... names) {\n        this(names, null);\n    }\n\n    /**\n     * Construct a new name file filter specifying case-sensitivity.\n     *\n     * @param name  the name to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the name is null\n     */\n    public NameFileFilter(final String name, final IOCase caseSensitivity) {\n        if (name == null) {\n            throw new IllegalArgumentException(\"The wildcard must not be null\");\n        }\n        this.names = new String[] {name};\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new name file filter for an array of names specifying case-sensitivity.\n     *\n     * @param names  the names to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the names array is null\n     */\n    public NameFileFilter(final String[] names, final IOCase caseSensitivity) {\n        if (names == null) {\n            throw new IllegalArgumentException(\"The array of names must not be null\");\n        }\n        this.names = new String[names.length];\n        System.arraycopy(names, 0, this.names, 0, names.length);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks to see if the file name matches.\n     *\n     * @param file  the File to check\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File file) {\n        final String name = file.getName();\n        for (final String name2 : this.names) {\n            if (caseSensitivity.checkEquals(name, name2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks to see if the file name matches.\n     *\n     * @param dir  the File directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        for (final String name2 : names) {\n            if (caseSensitivity.checkEquals(name, name2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        if (names != null) {\n            for (int i = 0; i < names.length; i++) {\n                if (i > 0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(names[i]);\n            }\n        }\n        buffer.append(\")\");\n        return buffer.toString();\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate accept(name String) : boolean extracted from public accept(dir File, name String) : boolean in class org.apache.commons.io.filefilter.WildcardFileFilter", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java", "startLine": 159, "endLine": 174, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java", "startLine": 153, "endLine": 163, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java", "startLine": 165, "endLine": 172, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks to see if the file name matches one of the wildcards.\n     *\n     * @param dir  the file directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches one of the wildcards\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        for (final String wildcard : wildcards) {\n            if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n                return true;\n            }\n        }\n        return false;\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java", "isPureRefactoring": true, "commitId": "324a2d67a29e40a63df6f2162110e6b44fd0067a", "packageNameBefore": "org.apache.commons.io.filefilter", "classNameBefore": "org.apache.commons.io.filefilter.WildcardFileFilter", "methodNameBefore": "org.apache.commons.io.filefilter.WildcardFileFilter#accept", "classSignatureBefore": "public class WildcardFileFilter extends AbstractFileFilter implements Serializable ", "methodNameBeforeSet": ["org.apache.commons.io.filefilter.WildcardFileFilter#accept"], "classNameBeforeSet": ["org.apache.commons.io.filefilter.WildcardFileFilter"], "classSignatureBeforeSet": ["public class WildcardFileFilter extends AbstractFileFilter implements Serializable "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOCase;\n\n/**\n * Filters files using the supplied wildcards.\n * <p>\n * This filter selects files and directories based on one or more wildcards.\n * Testing is case-sensitive by default, but this can be configured.\n * </p>\n * <p>\n * The wildcard matcher uses the characters '?' and '*' to represent a\n * single or multiple wildcard characters.\n * This is the same as often found on Dos/Unix command lines.\n * The check is case-sensitive by default.\n * See {@link FilenameUtils#wildcardMatchOnSystem(String,String)} for more information.\n * </p>\n * <p>\n * For example:\n * </p>\n * <pre>\n * File dir = new File(\".\");\n * FileFilter fileFilter = new WildcardFileFilter(\"*test*.java~*~\");\n * File[] files = dir.listFiles(fileFilter);\n * for (int i = 0; i &lt; files.length; i++) {\n *   System.out.println(files[i]);\n * }\n * </pre>\n *\n * @since 1.3\n */\npublic class WildcardFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = -7426486598995782105L;\n    /** The wildcards that will be used to match file names. */\n    private final String[] wildcards;\n    /** Whether the comparison is case sensitive. */\n    private final IOCase caseSensitivity;\n\n    /**\n     * Construct a new case-sensitive wildcard filter for a list of wildcards.\n     *\n     * @param wildcards  the list of wildcards to match, not null\n     * @throws IllegalArgumentException if the pattern list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public WildcardFileFilter(final List<String> wildcards) {\n        this(wildcards, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Construct a new wildcard filter for a list of wildcards specifying case-sensitivity.\n     *\n     * @param wildcards  the list of wildcards to match, not null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the pattern list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public WildcardFileFilter(final List<String> wildcards, final IOCase caseSensitivity) {\n        if (wildcards == null) {\n            throw new IllegalArgumentException(\"The wildcard list must not be null\");\n        }\n        this.wildcards = wildcards.toArray(EMPTY_STRING_ARRAY);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Construct a new case-sensitive wildcard filter for a single wildcard.\n     *\n     * @param wildcard  the wildcard to match\n     * @throws IllegalArgumentException if the pattern is null\n     */\n    public WildcardFileFilter(final String wildcard) {\n        this(wildcard, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Construct a new case-sensitive wildcard filter for an array of wildcards.\n     * <p>\n     *\n     * @param wildcards  the array of wildcards to match\n     * @throws IllegalArgumentException if the pattern array is null\n     */\n    public WildcardFileFilter(final String... wildcards) {\n        this(wildcards, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Construct a new wildcard filter for a single wildcard specifying case-sensitivity.\n     *\n     * @param wildcard  the wildcard to match, not null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the pattern is null\n     */\n    public WildcardFileFilter(final String wildcard, final IOCase caseSensitivity) {\n        if (wildcard == null) {\n            throw new IllegalArgumentException(\"The wildcard must not be null\");\n        }\n        this.wildcards = new String[] { wildcard };\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Construct a new wildcard filter for an array of wildcards specifying case-sensitivity.\n     * <p>\n     *\n     * @param wildcards  the array of wildcards to match, not null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the pattern array is null\n     */\n    public WildcardFileFilter(final String[] wildcards, final IOCase caseSensitivity) {\n        if (wildcards == null) {\n            throw new IllegalArgumentException(\"The wildcard array must not be null\");\n        }\n        this.wildcards = new String[wildcards.length];\n        System.arraycopy(wildcards, 0, this.wildcards, 0, wildcards.length);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Checks to see if the file name matches one of the wildcards.\n     *\n     * @param file  the file to check\n     * @return true if the file name matches one of the wildcards\n     */\n    @Override\n    public boolean accept(final File file) {\n        final String name = file.getName();\n        for (final String wildcard : wildcards) {\n            if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks to see if the file name matches one of the wildcards.\n     *\n     * @param dir  the file directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches one of the wildcards\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        for (final String wildcard : wildcards) {\n            if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        if (wildcards != null) {\n            for (int i = 0; i < wildcards.length; i++) {\n                if (i > 0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(wildcards[i]);\n            }\n        }\n        buffer.append(\")\");\n        return buffer.toString();\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOCase;\n\n/**\n * Filters files using the supplied wildcards.\n * <p>\n * This filter selects files and directories based on one or more wildcards.\n * Testing is case-sensitive by default, but this can be configured.\n * </p>\n * <p>\n * The wildcard matcher uses the characters '?' and '*' to represent a\n * single or multiple wildcard characters.\n * This is the same as often found on Dos/Unix command lines.\n * The check is case-sensitive by default.\n * See {@link FilenameUtils#wildcardMatchOnSystem(String,String)} for more information.\n * </p>\n * <p>\n * For example:\n * </p>\n * <pre>\n * File dir = new File(\".\");\n * FileFilter fileFilter = new WildcardFileFilter(\"*test*.java~*~\");\n * File[] files = dir.listFiles(fileFilter);\n * for (int i = 0; i &lt; files.length; i++) {\n *   System.out.println(files[i]);\n * }\n * </pre>\n *\n * @since 1.3\n */\npublic class WildcardFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = -7426486598995782105L;\n    /** The wildcards that will be used to match file names. */\n    private final String[] wildcards;\n    /** Whether the comparison is case sensitive. */\n    private final IOCase caseSensitivity;\n\n    /**\n     * Construct a new case-sensitive wildcard filter for a list of wildcards.\n     *\n     * @param wildcards  the list of wildcards to match, not null\n     * @throws IllegalArgumentException if the pattern list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public WildcardFileFilter(final List<String> wildcards) {\n        this(wildcards, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Construct a new wildcard filter for a list of wildcards specifying case-sensitivity.\n     *\n     * @param wildcards  the list of wildcards to match, not null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the pattern list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public WildcardFileFilter(final List<String> wildcards, final IOCase caseSensitivity) {\n        if (wildcards == null) {\n            throw new IllegalArgumentException(\"The wildcard list must not be null\");\n        }\n        this.wildcards = wildcards.toArray(EMPTY_STRING_ARRAY);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Construct a new case-sensitive wildcard filter for a single wildcard.\n     *\n     * @param wildcard  the wildcard to match\n     * @throws IllegalArgumentException if the pattern is null\n     */\n    public WildcardFileFilter(final String wildcard) {\n        this(wildcard, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Construct a new case-sensitive wildcard filter for an array of wildcards.\n     * <p>\n     *\n     * @param wildcards  the array of wildcards to match\n     * @throws IllegalArgumentException if the pattern array is null\n     */\n    public WildcardFileFilter(final String... wildcards) {\n        this(wildcards, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Construct a new wildcard filter for a single wildcard specifying case-sensitivity.\n     *\n     * @param wildcard  the wildcard to match, not null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the pattern is null\n     */\n    public WildcardFileFilter(final String wildcard, final IOCase caseSensitivity) {\n        if (wildcard == null) {\n            throw new IllegalArgumentException(\"The wildcard must not be null\");\n        }\n        this.wildcards = new String[] { wildcard };\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Construct a new wildcard filter for an array of wildcards specifying case-sensitivity.\n     * <p>\n     *\n     * @param wildcards  the array of wildcards to match, not null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the pattern array is null\n     */\n    public WildcardFileFilter(final String[] wildcards, final IOCase caseSensitivity) {\n        if (wildcards == null) {\n            throw new IllegalArgumentException(\"The wildcard array must not be null\");\n        }\n        this.wildcards = new String[wildcards.length];\n        System.arraycopy(wildcards, 0, this.wildcards, 0, wildcards.length);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Checks to see if the file name matches one of the wildcards.\n     *\n     * @param file  the file to check\n     * @return true if the file name matches one of the wildcards\n     */\n    @Override\n    public boolean accept(final File file) {\n        return accept(file.getName());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks to see if the file name matches one of the wildcards.\n     *\n     * @param dir  the file directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches one of the wildcards\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        return accept(name);\n    }\n\n    private boolean accept(final String name) {\n        for (final String wildcard : wildcards) {\n            if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        if (wildcards != null) {\n            for (int i = 0; i < wildcards.length; i++) {\n                if (i > 0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(wildcards[i]);\n            }\n        }\n        buffer.append(\")\");\n        return buffer.toString();\n    }\n\n}\n", "diffSourceCodeSet": ["private boolean accept(final String name) {\n        for (final String wildcard : wildcards) {\n            if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n                return true;\n            }\n        }\n        return false;\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Checks to see if the file name matches one of the wildcards.\n     *\n     * @param dir  the file directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches one of the wildcards\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        return accept(name);\n    }\nprivate boolean accept(final String name) {\n        for (final String wildcard : wildcards) {\n            if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n                return true;\n            }\n        }\n        return false;\n    }", "diffSourceCode": "-  153:             }\n-  154:         }\n-  155:         return false;\n-  156:     }\n-  157: \n-  158:     //-----------------------------------------------------------------------\n-  159:     /**\n-  160:      * Checks to see if the file name matches one of the wildcards.\n-  161:      *\n-  162:      * @param dir  the file directory (ignored)\n-  163:      * @param name  the file name\n-  164:      * @return true if the file name matches one of the wildcards\n-  165:      */\n-  166:     @Override\n-  167:     public boolean accept(final File dir, final String name) {\n-  168:         for (final String wildcard : wildcards) {\n-  169:             if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n-  170:                 return true;\n-  171:             }\n-  172:         }\n-  173:         return false;\n-  174:     }\n+  153:     /**\n+  154:      * Checks to see if the file name matches one of the wildcards.\n+  155:      *\n+  156:      * @param dir  the file directory (ignored)\n+  157:      * @param name  the file name\n+  158:      * @return true if the file name matches one of the wildcards\n+  159:      */\n+  160:     @Override\n+  161:     public boolean accept(final File dir, final String name) {\n+  162:         return accept(name);\n+  163:     }\n+  164: \n+  165:     private boolean accept(final String name) {\n+  166:         for (final String wildcard : wildcards) {\n+  167:             if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n+  168:                 return true;\n+  169:             }\n+  170:         }\n+  171:         return false;\n+  172:     }\n+  173: \n+  174:     /**\n", "uniqueId": "324a2d67a29e40a63df6f2162110e6b44fd0067a_159_174_165_172_153_163", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 27}, "BRANCH": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 4}, "COMPLEXITY": {"missed": 0, "covered": 3}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `accept` method in the `WildcardFileFilter` class, we can extract the logic that checks if a file name matches any of the wildcards into a separate method. This will make the code cleaner and allow for easier testing of the matching logic.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\nprivate boolean matchesWildcard(final String name) {\n    for (final String wildcard : wildcards) {\n        if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n@Override\npublic boolean accept(final File dir, final String name) {\n    return matchesWildcard(name);\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic that checks if the file name matches any of the wildcards has been moved to a new private method called `matchesWildcard`. This method takes a `String name` as a parameter and returns a boolean indicating whether there is a match.\n  \n2. **Updated `accept` Method**: The `accept` method now simply calls `matchesWildcard(name)`, which improves its readability by reducing complexity and focusing on its primary responsibility.\n\nThis refactoring enhances the modularity of the code, making it easier to understand and maintain.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Checks to see if the file name matches one of the wildcards.\n     *\n     * @param dir  the file directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches one of the wildcards\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        for (final String wildcard : wildcards) {\n            if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport org.apache.commons.io.FilenameUtils;\nimport org.apache.commons.io.IOCase;\n\n/**\n * Filters files using the supplied wildcards.\n * <p>\n * This filter selects files and directories based on one or more wildcards.\n * Testing is case-sensitive by default, but this can be configured.\n * </p>\n * <p>\n * The wildcard matcher uses the characters '?' and '*' to represent a\n * single or multiple wildcard characters.\n * This is the same as often found on Dos/Unix command lines.\n * The check is case-sensitive by default.\n * See {@link FilenameUtils#wildcardMatchOnSystem(String,String)} for more information.\n * </p>\n * <p>\n * For example:\n * </p>\n * <pre>\n * File dir = new File(\".\");\n * FileFilter fileFilter = new WildcardFileFilter(\"*test*.java~*~\");\n * File[] files = dir.listFiles(fileFilter);\n * for (int i = 0; i &lt; files.length; i++) {\n *   System.out.println(files[i]);\n * }\n * </pre>\n *\n * @since 1.3\n */\npublic class WildcardFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = -7426486598995782105L;\n    /** The wildcards that will be used to match file names. */\n    private final String[] wildcards;\n    /** Whether the comparison is case sensitive. */\n    private final IOCase caseSensitivity;\n\n    /**\n     * Construct a new case-sensitive wildcard filter for a list of wildcards.\n     *\n     * @param wildcards  the list of wildcards to match, not null\n     * @throws IllegalArgumentException if the pattern list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public WildcardFileFilter(final List<String> wildcards) {\n        this(wildcards, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Construct a new wildcard filter for a list of wildcards specifying case-sensitivity.\n     *\n     * @param wildcards  the list of wildcards to match, not null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the pattern list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public WildcardFileFilter(final List<String> wildcards, final IOCase caseSensitivity) {\n        if (wildcards == null) {\n            throw new IllegalArgumentException(\"The wildcard list must not be null\");\n        }\n        this.wildcards = wildcards.toArray(EMPTY_STRING_ARRAY);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Construct a new case-sensitive wildcard filter for a single wildcard.\n     *\n     * @param wildcard  the wildcard to match\n     * @throws IllegalArgumentException if the pattern is null\n     */\n    public WildcardFileFilter(final String wildcard) {\n        this(wildcard, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Construct a new case-sensitive wildcard filter for an array of wildcards.\n     * <p>\n     *\n     * @param wildcards  the array of wildcards to match\n     * @throws IllegalArgumentException if the pattern array is null\n     */\n    public WildcardFileFilter(final String... wildcards) {\n        this(wildcards, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Construct a new wildcard filter for a single wildcard specifying case-sensitivity.\n     *\n     * @param wildcard  the wildcard to match, not null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the pattern is null\n     */\n    public WildcardFileFilter(final String wildcard, final IOCase caseSensitivity) {\n        if (wildcard == null) {\n            throw new IllegalArgumentException(\"The wildcard must not be null\");\n        }\n        this.wildcards = new String[] { wildcard };\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Construct a new wildcard filter for an array of wildcards specifying case-sensitivity.\n     * <p>\n     *\n     * @param wildcards  the array of wildcards to match, not null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the pattern array is null\n     */\n    public WildcardFileFilter(final String[] wildcards, final IOCase caseSensitivity) {\n        if (wildcards == null) {\n            throw new IllegalArgumentException(\"The wildcard array must not be null\");\n        }\n        this.wildcards = new String[wildcards.length];\n        System.arraycopy(wildcards, 0, this.wildcards, 0, wildcards.length);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Checks to see if the file name matches one of the wildcards.\n     *\n     * @param file  the file to check\n     * @return true if the file name matches one of the wildcards\n     */\n    @Override\n    public boolean accept(final File file) {\n        final String name = file.getName();\n        for (final String wildcard : wildcards) {\n            if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Checks to see if the file name matches one of the wildcards.\n     *\n     * @param dir  the file directory (ignored)\n     * @param name  the file name\n     * @return true if the file name matches one of the wildcards\n     */\n    @Override\n    public boolean accept(final File dir, final String name) {\n        for (final String wildcard : wildcards) {\n            if (FilenameUtils.wildcardMatch(name, wildcard, caseSensitivity)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        if (wildcards != null) {\n            for (int i = 0; i < wildcards.length; i++) {\n                if (i > 0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(wildcards[i]);\n            }\n        }\n        buffer.append(\")\");\n        return buffer.toString();\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate accept(name String) : boolean extracted from public accept(file File, name String) : boolean in class org.apache.commons.io.filefilter.SuffixFileFilter", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java", "startLine": 159, "endLine": 174, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java", "startLine": 153, "endLine": 163, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java", "startLine": 165, "endLine": 172, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks to see if the file name ends with the suffix.\n     *\n     * @param file  the File directory\n     * @param name  the file name\n     * @return true if the file name ends with one of our suffixes\n     */\n    @Override\n    public boolean accept(final File file, final String name) {\n        for (final String suffix : this.suffixes) {\n            if (caseSensitivity.checkEndsWith(name, suffix)) {\n                return true;\n            }\n        }\n        return false;\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java", "isPureRefactoring": true, "commitId": "0fe519be5f0e676f2adbcf02d916651231acebd6", "packageNameBefore": "org.apache.commons.io.filefilter", "classNameBefore": "org.apache.commons.io.filefilter.SuffixFileFilter", "methodNameBefore": "org.apache.commons.io.filefilter.SuffixFileFilter#accept", "classSignatureBefore": "public class SuffixFileFilter extends AbstractFileFilter implements Serializable ", "methodNameBeforeSet": ["org.apache.commons.io.filefilter.SuffixFileFilter#accept"], "classNameBeforeSet": ["org.apache.commons.io.filefilter.SuffixFileFilter"], "classSignatureBeforeSet": ["public class SuffixFileFilter extends AbstractFileFilter implements Serializable "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport org.apache.commons.io.IOCase;\n\n/**\n * Filters files based on the suffix (what the file name ends with).\n * This is used in retrieving all the files of a particular type.\n * <p>\n * For example, to retrieve and print all <code>*.java</code> files\n * in the current directory:\n *\n * <pre>\n * File dir = new File(\".\");\n * String[] files = dir.list( new SuffixFileFilter(\".java\") );\n * for (int i = 0; i &lt; files.length; i++) {\n *     System.out.println(files[i]);\n * }\n * </pre>\n *\n * @since 1.0\n *\n * @see FileFilterUtils#suffixFileFilter(String)\n * @see FileFilterUtils#suffixFileFilter(String, IOCase)\n */\npublic class SuffixFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = -3389157631240246157L;\n\n    /** The file name suffixes to search for */\n    private final String[] suffixes;\n\n    /** Whether the comparison is case sensitive. */\n    private final IOCase caseSensitivity;\n\n    /**\n     * Constructs a new Suffix file filter for a list of suffixes.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @throws IllegalArgumentException if the suffix list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public SuffixFileFilter(final List<String> suffixes) {\n        this(suffixes, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Constructs a new Suffix file filter for a list of suffixes\n     * specifying case-sensitivity.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the suffix list is null\n     * @throws ClassCastException if the list does not contain Strings\n     * @since 1.4\n     */\n    public SuffixFileFilter(final List<String> suffixes, final IOCase caseSensitivity) {\n        if (suffixes == null) {\n            throw new IllegalArgumentException(\"The list of suffixes must not be null\");\n        }\n        this.suffixes = suffixes.toArray(EMPTY_STRING_ARRAY);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new Suffix file filter for a single extension.\n     *\n     * @param suffix  the suffix to allow, must not be null\n     * @throws IllegalArgumentException if the suffix is null\n     */\n    public SuffixFileFilter(final String suffix) {\n        this(suffix, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Constructs a new Suffix file filter for an array of suffixes.\n     * <p>\n     * The array is not cloned, so could be changed after constructing the\n     * instance. This would be inadvisable however.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @throws IllegalArgumentException if the suffix array is null\n     */\n    public SuffixFileFilter(final String... suffixes) {\n        this(suffixes, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Constructs a new Suffix file filter for a single extension\n     * specifying case-sensitivity.\n     *\n     * @param suffix  the suffix to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the suffix is null\n     * @since 1.4\n     */\n    public SuffixFileFilter(final String suffix, final IOCase caseSensitivity) {\n        if (suffix == null) {\n            throw new IllegalArgumentException(\"The suffix must not be null\");\n        }\n        this.suffixes = new String[] {suffix};\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new Suffix file filter for an array of suffixes\n     * specifying case-sensitivity.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the suffix array is null\n     * @since 1.4\n     */\n    public SuffixFileFilter(final String[] suffixes, final IOCase caseSensitivity) {\n        if (suffixes == null) {\n            throw new IllegalArgumentException(\"The array of suffixes must not be null\");\n        }\n        this.suffixes = new String[suffixes.length];\n        System.arraycopy(suffixes, 0, this.suffixes, 0, suffixes.length);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Checks to see if the file name ends with the suffix.\n     *\n     * @param file  the File to check\n     * @return true if the file name ends with one of our suffixes\n     */\n    @Override\n    public boolean accept(final File file) {\n        final String name = file.getName();\n        for (final String suffix : this.suffixes) {\n            if (caseSensitivity.checkEndsWith(name, suffix)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks to see if the file name ends with the suffix.\n     *\n     * @param file  the File directory\n     * @param name  the file name\n     * @return true if the file name ends with one of our suffixes\n     */\n    @Override\n    public boolean accept(final File file, final String name) {\n        for (final String suffix : this.suffixes) {\n            if (caseSensitivity.checkEndsWith(name, suffix)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        if (suffixes != null) {\n            for (int i = 0; i < suffixes.length; i++) {\n                if (i > 0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(suffixes[i]);\n            }\n        }\n        buffer.append(\")\");\n        return buffer.toString();\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport org.apache.commons.io.IOCase;\n\n/**\n * Filters files based on the suffix (what the file name ends with).\n * This is used in retrieving all the files of a particular type.\n * <p>\n * For example, to retrieve and print all <code>*.java</code> files\n * in the current directory:\n *\n * <pre>\n * File dir = new File(\".\");\n * String[] files = dir.list( new SuffixFileFilter(\".java\") );\n * for (int i = 0; i &lt; files.length; i++) {\n *     System.out.println(files[i]);\n * }\n * </pre>\n *\n * @since 1.0\n *\n * @see FileFilterUtils#suffixFileFilter(String)\n * @see FileFilterUtils#suffixFileFilter(String, IOCase)\n */\npublic class SuffixFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = -3389157631240246157L;\n\n    /** The file name suffixes to search for */\n    private final String[] suffixes;\n\n    /** Whether the comparison is case sensitive. */\n    private final IOCase caseSensitivity;\n\n    /**\n     * Constructs a new Suffix file filter for a list of suffixes.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @throws IllegalArgumentException if the suffix list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public SuffixFileFilter(final List<String> suffixes) {\n        this(suffixes, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Constructs a new Suffix file filter for a list of suffixes\n     * specifying case-sensitivity.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the suffix list is null\n     * @throws ClassCastException if the list does not contain Strings\n     * @since 1.4\n     */\n    public SuffixFileFilter(final List<String> suffixes, final IOCase caseSensitivity) {\n        if (suffixes == null) {\n            throw new IllegalArgumentException(\"The list of suffixes must not be null\");\n        }\n        this.suffixes = suffixes.toArray(EMPTY_STRING_ARRAY);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new Suffix file filter for a single extension.\n     *\n     * @param suffix  the suffix to allow, must not be null\n     * @throws IllegalArgumentException if the suffix is null\n     */\n    public SuffixFileFilter(final String suffix) {\n        this(suffix, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Constructs a new Suffix file filter for an array of suffixes.\n     * <p>\n     * The array is not cloned, so could be changed after constructing the\n     * instance. This would be inadvisable however.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @throws IllegalArgumentException if the suffix array is null\n     */\n    public SuffixFileFilter(final String... suffixes) {\n        this(suffixes, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Constructs a new Suffix file filter for a single extension\n     * specifying case-sensitivity.\n     *\n     * @param suffix  the suffix to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the suffix is null\n     * @since 1.4\n     */\n    public SuffixFileFilter(final String suffix, final IOCase caseSensitivity) {\n        if (suffix == null) {\n            throw new IllegalArgumentException(\"The suffix must not be null\");\n        }\n        this.suffixes = new String[] {suffix};\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new Suffix file filter for an array of suffixes\n     * specifying case-sensitivity.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the suffix array is null\n     * @since 1.4\n     */\n    public SuffixFileFilter(final String[] suffixes, final IOCase caseSensitivity) {\n        if (suffixes == null) {\n            throw new IllegalArgumentException(\"The array of suffixes must not be null\");\n        }\n        this.suffixes = new String[suffixes.length];\n        System.arraycopy(suffixes, 0, this.suffixes, 0, suffixes.length);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Checks to see if the file name ends with the suffix.\n     *\n     * @param file  the File to check\n     * @return true if the file name ends with one of our suffixes\n     */\n    @Override\n    public boolean accept(final File file) {\n        return accept(file.getName());\n    }\n\n    /**\n     * Checks to see if the file name ends with the suffix.\n     *\n     * @param file  the File directory\n     * @param name  the file name\n     * @return true if the file name ends with one of our suffixes\n     */\n    @Override\n    public boolean accept(final File file, final String name) {\n        return accept(name);\n    }\n\n    private boolean accept(final String name) {\n        for (final String suffix : this.suffixes) {\n            if (caseSensitivity.checkEndsWith(name, suffix)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        if (suffixes != null) {\n            for (int i = 0; i < suffixes.length; i++) {\n                if (i > 0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(suffixes[i]);\n            }\n        }\n        buffer.append(\")\");\n        return buffer.toString();\n    }\n\n}\n", "diffSourceCodeSet": ["private boolean accept(final String name) {\n        for (final String suffix : this.suffixes) {\n            if (caseSensitivity.checkEndsWith(name, suffix)) {\n                return true;\n            }\n        }\n        return false;\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Checks to see if the file name ends with the suffix.\n     *\n     * @param file  the File directory\n     * @param name  the file name\n     * @return true if the file name ends with one of our suffixes\n     */\n    @Override\n    public boolean accept(final File file, final String name) {\n        return accept(name);\n    }\nprivate boolean accept(final String name) {\n        for (final String suffix : this.suffixes) {\n            if (caseSensitivity.checkEndsWith(name, suffix)) {\n                return true;\n            }\n        }\n        return false;\n    }", "diffSourceCode": "-  153:                 return true;\n-  154:             }\n-  155:         }\n-  156:         return false;\n-  157:     }\n-  158: \n-  159:     /**\n-  160:      * Checks to see if the file name ends with the suffix.\n-  161:      *\n-  162:      * @param file  the File directory\n-  163:      * @param name  the file name\n-  164:      * @return true if the file name ends with one of our suffixes\n-  165:      */\n-  166:     @Override\n-  167:     public boolean accept(final File file, final String name) {\n-  168:         for (final String suffix : this.suffixes) {\n-  169:             if (caseSensitivity.checkEndsWith(name, suffix)) {\n-  170:                 return true;\n-  171:             }\n-  172:         }\n-  173:         return false;\n-  174:     }\n+  153:     /**\n+  154:      * Checks to see if the file name ends with the suffix.\n+  155:      *\n+  156:      * @param file  the File directory\n+  157:      * @param name  the file name\n+  158:      * @return true if the file name ends with one of our suffixes\n+  159:      */\n+  160:     @Override\n+  161:     public boolean accept(final File file, final String name) {\n+  162:         return accept(name);\n+  163:     }\n+  164: \n+  165:     private boolean accept(final String name) {\n+  166:         for (final String suffix : this.suffixes) {\n+  167:             if (caseSensitivity.checkEndsWith(name, suffix)) {\n+  168:                 return true;\n+  169:             }\n+  170:         }\n+  171:         return false;\n+  172:     }\n+  173: \n+  174:     /**\n", "uniqueId": "0fe519be5f0e676f2adbcf02d916651231acebd6_159_174_165_172_153_163", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 27}, "BRANCH": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 4}, "COMPLEXITY": {"missed": 0, "covered": 3}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 11, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `accept` method in the `SuffixFileFilter` class, we can extract the logic that checks if a file name ends with any of the specified suffixes into a separate method. This will make the code cleaner and allow for easier testing of the suffix-checking logic.\n\nHere\u2019s the refactored method code:\n\n##########################\n```java\n/**\n * Checks to see if the file name ends with the suffix.\n *\n * @param file  the File directory\n * @param name  the file name\n * @return true if the file name ends with one of our suffixes\n */\n@Override\npublic boolean accept(final File file, final String name) {\n    return hasMatchingSuffix(name);\n}\n\n/**\n * Checks if the given file name ends with any of the configured suffixes.\n *\n * @param name the file name to check\n * @return true if the file name ends with one of the suffixes\n */\nprivate boolean hasMatchingSuffix(final String name) {\n    for (final String suffix : this.suffixes) {\n        if (caseSensitivity.checkEndsWith(name, suffix)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n##########################\n\nIn this refactoring:\n- The logic for checking if the file name ends with any of the suffixes has been moved to a new private method called `hasMatchingSuffix`.\n- The `accept` method now simply calls this new method, improving its readability and making it clear that the method's purpose is to check for suffix matches.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Checks to see if the file name ends with the suffix.\n     *\n     * @param file  the File directory\n     * @param name  the file name\n     * @return true if the file name ends with one of our suffixes\n     */\n    @Override\n    public boolean accept(final File file, final String name) {\n        for (final String suffix : this.suffixes) {\n            if (caseSensitivity.checkEndsWith(name, suffix)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport org.apache.commons.io.IOCase;\n\n/**\n * Filters files based on the suffix (what the file name ends with).\n * This is used in retrieving all the files of a particular type.\n * <p>\n * For example, to retrieve and print all <code>*.java</code> files\n * in the current directory:\n *\n * <pre>\n * File dir = new File(\".\");\n * String[] files = dir.list( new SuffixFileFilter(\".java\") );\n * for (int i = 0; i &lt; files.length; i++) {\n *     System.out.println(files[i]);\n * }\n * </pre>\n *\n * @since 1.0\n *\n * @see FileFilterUtils#suffixFileFilter(String)\n * @see FileFilterUtils#suffixFileFilter(String, IOCase)\n */\npublic class SuffixFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = -3389157631240246157L;\n\n    /** The file name suffixes to search for */\n    private final String[] suffixes;\n\n    /** Whether the comparison is case sensitive. */\n    private final IOCase caseSensitivity;\n\n    /**\n     * Constructs a new Suffix file filter for a list of suffixes.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @throws IllegalArgumentException if the suffix list is null\n     * @throws ClassCastException if the list does not contain Strings\n     */\n    public SuffixFileFilter(final List<String> suffixes) {\n        this(suffixes, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Constructs a new Suffix file filter for a list of suffixes\n     * specifying case-sensitivity.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the suffix list is null\n     * @throws ClassCastException if the list does not contain Strings\n     * @since 1.4\n     */\n    public SuffixFileFilter(final List<String> suffixes, final IOCase caseSensitivity) {\n        if (suffixes == null) {\n            throw new IllegalArgumentException(\"The list of suffixes must not be null\");\n        }\n        this.suffixes = suffixes.toArray(EMPTY_STRING_ARRAY);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new Suffix file filter for a single extension.\n     *\n     * @param suffix  the suffix to allow, must not be null\n     * @throws IllegalArgumentException if the suffix is null\n     */\n    public SuffixFileFilter(final String suffix) {\n        this(suffix, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Constructs a new Suffix file filter for an array of suffixes.\n     * <p>\n     * The array is not cloned, so could be changed after constructing the\n     * instance. This would be inadvisable however.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @throws IllegalArgumentException if the suffix array is null\n     */\n    public SuffixFileFilter(final String... suffixes) {\n        this(suffixes, IOCase.SENSITIVE);\n    }\n\n    /**\n     * Constructs a new Suffix file filter for a single extension\n     * specifying case-sensitivity.\n     *\n     * @param suffix  the suffix to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the suffix is null\n     * @since 1.4\n     */\n    public SuffixFileFilter(final String suffix, final IOCase caseSensitivity) {\n        if (suffix == null) {\n            throw new IllegalArgumentException(\"The suffix must not be null\");\n        }\n        this.suffixes = new String[] {suffix};\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Constructs a new Suffix file filter for an array of suffixes\n     * specifying case-sensitivity.\n     *\n     * @param suffixes  the suffixes to allow, must not be null\n     * @param caseSensitivity  how to handle case sensitivity, null means case-sensitive\n     * @throws IllegalArgumentException if the suffix array is null\n     * @since 1.4\n     */\n    public SuffixFileFilter(final String[] suffixes, final IOCase caseSensitivity) {\n        if (suffixes == null) {\n            throw new IllegalArgumentException(\"The array of suffixes must not be null\");\n        }\n        this.suffixes = new String[suffixes.length];\n        System.arraycopy(suffixes, 0, this.suffixes, 0, suffixes.length);\n        this.caseSensitivity = caseSensitivity == null ? IOCase.SENSITIVE : caseSensitivity;\n    }\n\n    /**\n     * Checks to see if the file name ends with the suffix.\n     *\n     * @param file  the File to check\n     * @return true if the file name ends with one of our suffixes\n     */\n    @Override\n    public boolean accept(final File file) {\n        final String name = file.getName();\n        for (final String suffix : this.suffixes) {\n            if (caseSensitivity.checkEndsWith(name, suffix)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks to see if the file name ends with the suffix.\n     *\n     * @param file  the File directory\n     * @param name  the file name\n     * @return true if the file name ends with one of our suffixes\n     */\n    @Override\n    public boolean accept(final File file, final String name) {\n        for (final String suffix : this.suffixes) {\n            if (caseSensitivity.checkEndsWith(name, suffix)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(super.toString());\n        buffer.append(\"(\");\n        if (suffixes != null) {\n            for (int i = 0; i < suffixes.length; i++) {\n                if (i > 0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(suffixes[i]);\n            }\n        }\n        buffer.append(\")\");\n        return buffer.toString();\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tprivate assertUncheckedIOException(expected IOException, e UncheckedIOException) : void from class org.apache.commons.io.UncheckIOTest to private assertUncheckedIOException(expected IOException, e UncheckedIOException) : void from class org.apache.commons.io.function.UncheckTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "startLine": 46, "endLine": 51, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "startLine": 51, "endLine": 56, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "isPureRefactoring": true, "commitId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.UncheckIOTest", "methodNameBefore": "org.apache.commons.io.UncheckIOTest#assertUncheckedIOException", "classSignatureBefore": "public class UncheckIOTest ", "methodNameBeforeSet": ["org.apache.commons.io.UncheckIOTest#assertUncheckedIOException"], "classNameBeforeSet": ["org.apache.commons.io.UncheckIOTest"], "classSignatureBeforeSet": ["public class UncheckIOTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckTest {\n\n    private static final byte[] BYTES = { 'a', 'b' };\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n\n    private AtomicInteger atomicInt;\n    private AtomicReference<String> ref1;\n    private AtomicReference<String> ref2;\n    private AtomicReference<String> ref3;\n    private AtomicReference<String> ref4;\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    @BeforeEach\n    public void initEach() {\n        ref1 = new AtomicReference<>();\n        ref2 = new AtomicReference<>();\n        ref3 = new AtomicReference<>();\n        ref4 = new AtomicReference<>();\n        atomicInt = new AtomicInteger();\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    @Test\n    public void testAcceptIOBiConsumerOfTUTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_BI_CONSUMER, null, null));\n        Uncheck.accept((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n        }, \"new1\", \"new2\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testAcceptIOConsumerOfTT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestUtils.throwingIOConsumer(), null));\n        Uncheck.accept(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testAcceptIOTriConsumerOfTUVTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_TRI_CONSUMER, null, null, null));\n        Uncheck.accept((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n        }, \"new1\", \"new2\", \"new3\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    @Test\n    public void testApplyIOBiFunctionOfTURTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_BI_FUNCTION, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            return \"new0\";\n        }, \"new1\", \"new2\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testApplyIOFunctionOfTRT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_FUNCTION, null));\n        Uncheck.apply(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testApplyIOQuadFunctionOfTUVWRTUVW() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v, w) -> {\n            throw new IOException();\n        }, null, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_QUAD_FUNCTION, null, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v, w) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            TestUtils.compareAndSetThrowsIO(ref4, w);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\", \"new4\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n        assertEquals(\"new4\", ref4.get());\n    }\n\n    @Test\n    public void testApplyIOTriFunctionOfTUVRTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_TRI_FUNCTION, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(TestConstants.THROWING_IO_SUPPLIER));\n        assertEquals(\"new1\", Uncheck.get(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\")));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testGetAsInt() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(TestConstants.THROWING_IO_INT_SUPPLIER));\n        assertEquals(1, Uncheck.getAsInt(() -> TestUtils.compareAndSetThrowsIO(atomicInt, 1)));\n        assertEquals(1, atomicInt.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        //\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(TestConstants.THROWING_IO_RUNNABLE));\n        Uncheck.run(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    @Test\n    public void testTest() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(TestConstants.THROWING_IO_PREDICATE, null));\n        assertTrue(Uncheck.test(t -> TestUtils.compareAndSetThrowsIO(ref1, t).equals(t), \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }", "diffSourceCode": "-   46:     private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n-   47:         assertEquals(CUSTOM_MESSAGE, e.getMessage());\n-   48:         final IOException cause = e.getCause();\n-   49:         assertEquals(expected.getClass(), cause.getClass());\n-   50:         assertEquals(CAUSE_MESSAGE, cause.getMessage());\n-   51:     }\n-   52: \n-   53:     private ByteArrayInputStream newInputStream() {\n-   54:         return new ByteArrayInputStream(BYTES);\n-   55:     }\n-   56: \n+   46:     private AtomicReference<String> ref1;\n+   47:     private AtomicReference<String> ref2;\n+   48:     private AtomicReference<String> ref3;\n+   49:     private AtomicReference<String> ref4;\n+   50: \n+   51:     private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n+   52:         assertEquals(CUSTOM_MESSAGE, e.getMessage());\n+   53:         final IOException cause = e.getCause();\n+   54:         assertEquals(expected.getClass(), cause.getClass());\n+   55:         assertEquals(CAUSE_MESSAGE, cause.getMessage());\n+   56:     }\n", "uniqueId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52_46_51__51_56", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code by moving the `assertUncheckedIOException` method to an existing class, we will choose the `UncheckedIOExceptionsTest.java` file as the target file. This class seems appropriate as it likely deals with testing unchecked IO exceptions, making it a suitable place for the assertion method.\n\n### Target File Path\nThe target file path for the moved method will be:\n```\nsrc/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java\n```\n\n### Moved Class Code\nHere is the code for the moved method, which will be made `public static`:\n```java\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\npublic class UncheckedIOExceptionsTest {\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n\n    public static void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    // Other test methods...\n}\n```\n\n### Refactored Method Code\nThe `assertUncheckedIOException` method in the `UncheckIOTest` class will be updated to call the moved method:\n```java\nprivate void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n    UncheckedIOExceptionsTest.assertUncheckedIOException(expected, e);\n}\n```\n\n### Final Output\nHere is the complete output in the required format:\n\n##########################\nsrc/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java\n##########################\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\npublic class UncheckedIOExceptionsTest {\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n\n    public static void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    // Other test methods...\n}\n##########################\nprivate void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n    UncheckedIOExceptionsTest.assertUncheckedIOException(expected, e);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryBaseTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsMultithreadedSkipTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/RandomAccessFilesTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/build/AbstractOriginTest.java', 'src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java', 'src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java', 'src/test/java/org/apache/commons/io/build/FileOriginTest.java', 'src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/PathOriginTest.java', 'src/test/java/org/apache/commons/io/build/ReaderOriginTest.java', 'src/test/java/org/apache/commons/io/build/URIOriginTest.java', 'src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/PathWrapper.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIntSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOLongSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate assertUncheckedIOException(expected IOException, e UncheckedIOException) : void extracted from public testRunMessage() : void in class org.apache.commons.io.UncheckIOTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "startLine": 110, "endLine": 131, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "startLine": 134, "endLine": 153, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "startLine": 46, "endLine": 51, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        //\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertEquals(CUSTOM_MESSAGE, e.getMessage());\n            final IOException cause = e.getCause();\n            assertEquals(expected.getClass(), cause.getClass());\n            assertEquals(CAUSE_MESSAGE, cause.getMessage());\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "isPureRefactoring": true, "commitId": "b4caca0c89ff116ec1b2c0012cc00a00821d19a3", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.UncheckIOTest", "methodNameBefore": "org.apache.commons.io.UncheckIOTest#testRunMessage", "invokedMethod": "methodSignature: org.apache.commons.io.function.Uncheck#run\n methodBody: public static void run(final IORunnable runnable, final Supplier<String> message) {\ntryrunnable.run();\ncatch(final IOException e)throw wrap(e,message);\n}\nmethodSignature: org.apache.commons.io.function.Uncheck#get\n methodBody: public static <T> T get(final IOSupplier<T> supplier) {\ntryreturn supplier.get();\ncatch(final IOException e)throw wrap(e);\n}\nmethodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}", "classSignatureBefore": "public class UncheckIOTest ", "methodNameBeforeSet": ["org.apache.commons.io.UncheckIOTest#testRunMessage"], "classNameBeforeSet": ["org.apache.commons.io.UncheckIOTest"], "classSignatureBeforeSet": ["public class UncheckIOTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        //\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertEquals(CUSTOM_MESSAGE, e.getMessage());\n            final IOException cause = e.getCause();\n            assertEquals(expected.getClass(), cause.getClass());\n            assertEquals(CAUSE_MESSAGE, cause.getMessage());\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n", "diffSourceCodeSet": ["private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.function.Uncheck#run\n methodBody: public static void run(final IORunnable runnable, final Supplier<String> message) {\ntryrunnable.run();\ncatch(final IOException e)throw wrap(e,message);\n}", "methodSignature: org.apache.commons.io.function.Uncheck#get\n methodBody: public static <T> T get(final IOSupplier<T> supplier) {\ntryreturn supplier.get();\ncatch(final IOException e)throw wrap(e);\n}", "methodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\nprivate void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }", "diffSourceCode": "-   46:     private ByteArrayInputStream newInputStream() {\n-   47:         return new ByteArrayInputStream(BYTES);\n-   48:     }\n-   49: \n-   50:     /**\n-   51:      * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n-  110:     /**\n-  111:      * Tests {@link Uncheck#run(IORunnable)}.\n-  112:      *\n-  113:      * @throws IOException\n-  114:      */\n-  115:     @Test\n-  116:     public void testRunMessage() throws IOException {\n-  117:         final ByteArrayInputStream stream = newInputStream();\n-  118:         Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n-  119:         assertEquals('b', Uncheck.get(stream::read).intValue());\n-  120:         final IOException expected = new IOException(CAUSE_MESSAGE);\n-  121:         //\n-  122:         try {\n-  123:             Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n-  124:             fail();\n-  125:         } catch (final UncheckedIOException e) {\n-  126:             assertEquals(CUSTOM_MESSAGE, e.getMessage());\n-  127:             final IOException cause = e.getCause();\n-  128:             assertEquals(expected.getClass(), cause.getClass());\n-  129:             assertEquals(CAUSE_MESSAGE, cause.getMessage());\n-  130:         }\n-  131:     }\n+   46:     private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n+   47:         assertEquals(CUSTOM_MESSAGE, e.getMessage());\n+   48:         final IOException cause = e.getCause();\n+   49:         assertEquals(expected.getClass(), cause.getClass());\n+   50:         assertEquals(CAUSE_MESSAGE, cause.getMessage());\n+   51:     }\n+  110:     @Test\n+  111:     public void testGetMessage() {\n+  112:         // No exception\n+  113:         assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n+  114:         // Exception\n+  115:         final IOException expected = new IOException(CAUSE_MESSAGE);\n+  116:         try {\n+  117:             Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n+  118:             fail();\n+  119:         } catch (final UncheckedIOException e) {\n+  120:             assertUncheckedIOException(expected, e);\n+  121:         }\n+  122:     }\n+  123: \n+  124:     /**\n+  125:      * Tests {@link Uncheck#run(IORunnable)}.\n+  126:      */\n+  127:     @Test\n+  128:     public void testRun() {\n+  129:         final ByteArrayInputStream stream = newInputStream();\n+  130:         Uncheck.run(() -> stream.skip(1));\n+  131:         assertEquals('b', Uncheck.get(stream::read).intValue());\n+  134:     /**\n+  135:      * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n+  136:      *\n+  137:      * @throws IOException\n+  138:      */\n+  139:     @Test\n+  140:     public void testRunMessage() throws IOException {\n+  141:         // No exception\n+  142:         final ByteArrayInputStream stream = newInputStream();\n+  143:         Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n+  144:         assertEquals('b', Uncheck.get(stream::read).intValue());\n+  145:         final IOException expected = new IOException(CAUSE_MESSAGE);\n+  146:         // Exception\n+  147:         try {\n+  148:             Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n+  149:             fail();\n+  150:         } catch (final UncheckedIOException e) {\n+  151:             assertUncheckedIOException(expected, e);\n+  152:         }\n+  153:     }\n", "uniqueId": "b4caca0c89ff116ec1b2c0012cc00a00821d19a3_110_131_46_51_134_153", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `testRunMessage` method, we can extract the logic for handling the exception into a separate method. This will make the test easier to understand and follow.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\n@Test\npublic void testRunMessage() throws IOException {\n    final ByteArrayInputStream stream = newInputStream();\n    Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n    assertEquals('b', Uncheck.get(stream::read).intValue());\n\n    final IOException expected = new IOException(CAUSE_MESSAGE);\n    assertThrowsUncheckedIOException(expected);\n}\n\nprivate void assertThrowsUncheckedIOException(IOException expected) {\n    try {\n        Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n        fail();\n    } catch (final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n}\n##########################\n```\n\n### Changes Made:\n1. **Extracted Method**: The logic that checks for the `UncheckedIOException` and asserts its properties has been moved to a new method called `assertThrowsUncheckedIOException`.\n2. **Improved Readability**: The main test method `testRunMessage` is now cleaner and focuses on the high-level flow of the test, while the details of exception handling are encapsulated in the new method. \n\nThis refactoring enhances the modularity of the code, making it easier to maintain and understand.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        //\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertEquals(CUSTOM_MESSAGE, e.getMessage());\n            final IOException cause = e.getCause();\n            assertEquals(expected.getClass(), cause.getClass());\n            assertEquals(CAUSE_MESSAGE, cause.getMessage());\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        //\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertEquals(CUSTOM_MESSAGE, e.getMessage());\n            final IOException cause = e.getCause();\n            assertEquals(expected.getClass(), cause.getClass());\n            assertEquals(CAUSE_MESSAGE, cause.getMessage());\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tprivate defaultBufferSize() : int from class org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest to private defaultBufferSize() : int from class org.apache.commons.io.input.QueueInputStreamTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/AbstractBlockingQueueInputStreamTest.java", "startLine": 105, "endLine": 107, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java", "startLine": 110, "endLine": 112, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private int defaultBufferSize() {\n        return 8192;\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/AbstractBlockingQueueInputStreamTest.java", "isPureRefactoring": true, "commitId": "150ba4af81b71517d3b44c0669b0da0f445e6ac3", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest", "methodNameBefore": "org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#defaultBufferSize", "classSignatureBefore": "public abstract class AbstractBlockingQueueInputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#defaultBufferSize"], "classNameBeforeSet": ["org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest"], "classSignatureBeforeSet": ["public abstract class AbstractBlockingQueueInputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.AbstractBlockingQueueInputStream.PollingQueueInputStream;\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.apache.commons.io.output.QueueOutputStreamTest;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Test {@link PollingQueueInputStream}.\n *\n * @see QueueOutputStreamTest\n */\npublic abstract class AbstractBlockingQueueInputStreamTest {\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReads(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            final String actualData = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReadWrite(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String dataCopy = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, dataCopy);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private int defaultBufferSize() {\n        return 8192;\n    }\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream();\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue);\n\n    protected QueueOutputStream newQueueOutputStream(AbstractBlockingQueueInputStream inputStream) {\n        return inputStream.newQueueOutputStream();\n    }\n\n    private String readUnbuffered(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        int n = -1;\n        while ((n = inputStream.read()) != -1) {\n            byteArrayOutputStream.write(n);\n        }\n        return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n    }\n\n    @Test\n    public void testNullArgument() {\n        assertThrows(NullPointerException.class, () -> newQueueInputStream(null), \"queue is required\");\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWrite(final String inputData) throws IOException {\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream();\n                final QueueOutputStream outputStream = newQueueOutputStream(inputStream)) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private void writeUnbuffered(final QueueOutputStream outputStream, final String inputData) throws InterruptedIOException {\n        final byte[] bytes = inputData.getBytes(UTF_8);\n        for (final byte oneByte : bytes) {\n            outputStream.write(oneByte);\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTimeout;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport com.google.common.base.Stopwatch;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.apache.commons.io.output.QueueOutputStreamTest;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Stream;\n\n/**\n * Test {@link QueueInputStream}.\n *\n * @see {@link QueueOutputStreamTest}\n */\npublic class QueueInputStreamTest {\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReads(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(new QueueInputStream(queue));\n                final QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            final String actualData = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReadWrite(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(new QueueInputStream(queue));\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String dataCopy = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, dataCopy);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (QueueInputStream inputStream = new QueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private int defaultBufferSize() {\n        return 8192;\n    }\n\n    private String readUnbuffered(final InputStream inputStream) throws IOException {\n        return readUnbuffered(inputStream, Integer.MAX_VALUE);\n    }\n\n    private String readUnbuffered(final InputStream inputStream, final int maxBytes) throws IOException {\n        if (maxBytes == 0) {\n            return \"\";\n        }\n\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        int n = -1;\n        while ((n = inputStream.read()) != -1) {\n            byteArrayOutputStream.write(n);\n            if (byteArrayOutputStream.size() >= maxBytes) {\n                break;\n            }\n        }\n        return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n    }\n\n    @Test\n    public void invalidArguments() {\n        assertThrows(NullPointerException.class, () -> new QueueInputStream(null), \"queue is required\");\n        assertThrows(NullPointerException.class, () -> new QueueInputStream(new LinkedBlockingQueue<>(), null), \"waitTime is required\");\n        assertThrows(IllegalArgumentException.class, () -> new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMillis(-1)),\n                \"waitTime must not be negative\");\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWrite(final String inputData) throws IOException {\n        try (QueueInputStream inputStream = new QueueInputStream();\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWriteWithTimeout(final String inputData) throws IOException {\n        try (QueueInputStream inputStream = new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMinutes(2));\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = assertTimeout(Duration.ofSeconds(1), () -> readUnbuffered(inputStream, inputData.length()));\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @Test\n    @DisplayName(\"If data is not available in queue, then read will wait until wait time elapses\")\n    public void timeoutUnavailableData() throws IOException {\n        try (QueueInputStream inputStream = new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMillis(500));\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n\n            final Stopwatch stopwatch = Stopwatch.createStarted();\n            final String actualData = assertTimeout(Duration.ofSeconds(1), () -> readUnbuffered(inputStream, 3));\n            stopwatch.stop();\n            assertEquals(\"\", actualData);\n\n            assertTrue(stopwatch.elapsed(TimeUnit.MILLISECONDS) >= 500);\n        }\n    }\n\n    @Test\n    @DisplayName(\"If read is interrupted while waiting, then exception is thrown\")\n    public void timeoutInterrupted() throws Exception {\n        try (QueueInputStream inputStream = new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMinutes(2));\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n\n            // read in a background thread\n            final AtomicReference<Boolean> result = new AtomicReference<>();\n            final CountDownLatch latch = new CountDownLatch(1);\n            final Thread thread = new Thread(() -> {\n                // when thread is interrupted, verify ...\n                assertThrows(IllegalStateException.class, () -> readUnbuffered(inputStream, 3));\n                assertTrue(Thread.currentThread().isInterrupted());\n                result.set(true);\n                latch.countDown();\n            });\n            thread.setDaemon(true);\n            thread.start();\n\n            // interrupt and check that verification completed\n            thread.interrupt();\n            latch.await(500, TimeUnit.MILLISECONDS);\n            assertTrue(result.get());\n        }\n    }\n\n    private void writeUnbuffered(final QueueOutputStream outputStream, final String inputData) throws IOException {\n        final byte[] bytes = inputData.getBytes(UTF_8);\n        outputStream.write(bytes, 0, bytes.length);\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "private int defaultBufferSize() {\n        return 8192;\n    }", "diffSourceCode": "-  105:     private int defaultBufferSize() {\n-  106:         return 8192;\n-  107:     }\n-  110: \n-  111:     protected abstract AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue);\n-  112: \n+  105:             final String actualData = readUnbuffered(inputStream);\n+  106:             assertEquals(inputData, actualData);\n+  107:         }\n+  110:     private int defaultBufferSize() {\n+  111:         return 8192;\n+  112:     }\n", "uniqueId": "150ba4af81b71517d3b44c0669b0da0f445e6ac3_105_107__110_112", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the `defaultBufferSize` method from the `AbstractBlockingQueueInputStreamTest` class to an appropriate existing class in the project structure. Given the context of the method, it seems to be a utility method related to buffer sizes, which could fit well in a utility class.\n\nAfter analyzing the project structure, we can move the method to the `org.apache.commons.io.IOUtils` class, which is a utility class that contains various static methods for input/output operations.\n\nHere\u2019s how the refactoring will be executed:\n\n1. **Move the Method**: The `defaultBufferSize` method will be moved to the `IOUtils` class and made public and static.\n2. **Update the Original Class**: The `AbstractBlockingQueueInputStreamTest` class will be updated to call the moved method from the `IOUtils` class.\n\n### Target File Path\nThe target file path for the moved method will be:\n```\nsrc/main/java/org/apache/commons/io/IOUtils.java\n```\n\n### Moved Class Code\nThe moved class code (the new method in `IOUtils`) will be:\n```java\npublic class IOUtils {\n    // Other existing methods...\n\n    public static int defaultBufferSize() {\n        return 8192;\n    }\n}\n```\n\n### Refactored Method Code\nThe refactored method code in the `AbstractBlockingQueueInputStreamTest` class will be:\n```java\nprivate int defaultBufferSize() {\n    return IOUtils.defaultBufferSize();\n}\n```\n\n### Final Output\nHere\u2019s the complete output in the requested format:\n\n##########################\nsrc/main/java/org/apache/commons/io/IOUtils.java\n##########################\npublic class IOUtils {\n    // Other existing methods...\n\n    public static int defaultBufferSize() {\n        return 8192;\n    }\n}\n##########################\nprivate int defaultBufferSize() {\n    return IOUtils.defaultBufferSize();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate int defaultBufferSize() {\n        return 8192;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.AbstractBlockingQueueInputStream.PollingQueueInputStream;\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.apache.commons.io.output.QueueOutputStreamTest;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Test {@link PollingQueueInputStream}.\n *\n * @see QueueOutputStreamTest\n */\npublic abstract class AbstractBlockingQueueInputStreamTest {\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReads(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            final String actualData = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReadWrite(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String dataCopy = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, dataCopy);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private int defaultBufferSize() {\n        return 8192;\n    }\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream();\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue);\n\n    protected QueueOutputStream newQueueOutputStream(AbstractBlockingQueueInputStream inputStream) {\n        return inputStream.newQueueOutputStream();\n    }\n\n    private String readUnbuffered(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        int n = -1;\n        while ((n = inputStream.read()) != -1) {\n            byteArrayOutputStream.write(n);\n        }\n        return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n    }\n\n    @Test\n    public void testNullArgument() {\n        assertThrows(NullPointerException.class, () -> newQueueInputStream(null), \"queue is required\");\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWrite(final String inputData) throws IOException {\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream();\n                final QueueOutputStream outputStream = newQueueOutputStream(inputStream)) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private void writeUnbuffered(final QueueOutputStream outputStream, final String inputData) throws InterruptedIOException {\n        final byte[] bytes = inputData.getBytes(UTF_8);\n        for (final byte oneByte : bytes) {\n            outputStream.write(oneByte);\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryBaseTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/PathWrapper.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/StringInputStream.java', 'src/test/java/org/apache/commons/io/input/StringInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic bufferedWrites(inputData String) : void from class org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest to public bufferedWrites(inputData String) : void from class org.apache.commons.io.input.QueueInputStreamTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/AbstractBlockingQueueInputStreamTest.java", "startLine": 92, "endLine": 103, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java", "startLine": 97, "endLine": 108, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/AbstractBlockingQueueInputStreamTest.java", "isPureRefactoring": true, "commitId": "150ba4af81b71517d3b44c0669b0da0f445e6ac3", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest", "methodNameBefore": "org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#bufferedWrites", "invokedMethod": "methodSignature: org.apache.commons.io.input.QueueInputStreamTest#newQueueInputStream\n methodBody: protected AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue) {\nreturn new QueueInputStream(queue);\n}\nmethodSignature: org.apache.commons.io.input.PollingQueueInputStreamTest#newQueueInputStream\n methodBody: protected AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue) {\nreturn new PollingQueueInputStream(queue);\n}\nmethodSignature: org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#readUnbuffered\n methodBody: private String readUnbuffered(final InputStream inputStream) throws IOException {\nfinal ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();\nint n=-1;\nwhile((n=inputStream.read()) != -1){byteArrayOutputStream.write(n);\n}return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n}\nmethodSignature: org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#newQueueInputStream\n methodBody: protected abstract AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue);\nmethodSignature: org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#defaultBufferSize\n methodBody: private int defaultBufferSize() {\nreturn 8192;\n}", "classSignatureBefore": "public abstract class AbstractBlockingQueueInputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#bufferedWrites"], "classNameBeforeSet": ["org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest"], "classSignatureBeforeSet": ["public abstract class AbstractBlockingQueueInputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body", "description": "All replacements are variables' type! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.AbstractBlockingQueueInputStream.PollingQueueInputStream;\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.apache.commons.io.output.QueueOutputStreamTest;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Test {@link PollingQueueInputStream}.\n *\n * @see QueueOutputStreamTest\n */\npublic abstract class AbstractBlockingQueueInputStreamTest {\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReads(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            final String actualData = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReadWrite(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String dataCopy = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, dataCopy);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private int defaultBufferSize() {\n        return 8192;\n    }\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream();\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue);\n\n    protected QueueOutputStream newQueueOutputStream(AbstractBlockingQueueInputStream inputStream) {\n        return inputStream.newQueueOutputStream();\n    }\n\n    private String readUnbuffered(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        int n = -1;\n        while ((n = inputStream.read()) != -1) {\n            byteArrayOutputStream.write(n);\n        }\n        return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n    }\n\n    @Test\n    public void testNullArgument() {\n        assertThrows(NullPointerException.class, () -> newQueueInputStream(null), \"queue is required\");\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWrite(final String inputData) throws IOException {\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream();\n                final QueueOutputStream outputStream = newQueueOutputStream(inputStream)) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private void writeUnbuffered(final QueueOutputStream outputStream, final String inputData) throws InterruptedIOException {\n        final byte[] bytes = inputData.getBytes(UTF_8);\n        for (final byte oneByte : bytes) {\n            outputStream.write(oneByte);\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTimeout;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport com.google.common.base.Stopwatch;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.apache.commons.io.output.QueueOutputStreamTest;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Stream;\n\n/**\n * Test {@link QueueInputStream}.\n *\n * @see {@link QueueOutputStreamTest}\n */\npublic class QueueInputStreamTest {\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReads(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(new QueueInputStream(queue));\n                final QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            final String actualData = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReadWrite(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(new QueueInputStream(queue));\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String dataCopy = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, dataCopy);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (QueueInputStream inputStream = new QueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private int defaultBufferSize() {\n        return 8192;\n    }\n\n    private String readUnbuffered(final InputStream inputStream) throws IOException {\n        return readUnbuffered(inputStream, Integer.MAX_VALUE);\n    }\n\n    private String readUnbuffered(final InputStream inputStream, final int maxBytes) throws IOException {\n        if (maxBytes == 0) {\n            return \"\";\n        }\n\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        int n = -1;\n        while ((n = inputStream.read()) != -1) {\n            byteArrayOutputStream.write(n);\n            if (byteArrayOutputStream.size() >= maxBytes) {\n                break;\n            }\n        }\n        return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n    }\n\n    @Test\n    public void invalidArguments() {\n        assertThrows(NullPointerException.class, () -> new QueueInputStream(null), \"queue is required\");\n        assertThrows(NullPointerException.class, () -> new QueueInputStream(new LinkedBlockingQueue<>(), null), \"waitTime is required\");\n        assertThrows(IllegalArgumentException.class, () -> new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMillis(-1)),\n                \"waitTime must not be negative\");\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWrite(final String inputData) throws IOException {\n        try (QueueInputStream inputStream = new QueueInputStream();\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWriteWithTimeout(final String inputData) throws IOException {\n        try (QueueInputStream inputStream = new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMinutes(2));\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = assertTimeout(Duration.ofSeconds(1), () -> readUnbuffered(inputStream, inputData.length()));\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @Test\n    @DisplayName(\"If data is not available in queue, then read will wait until wait time elapses\")\n    public void timeoutUnavailableData() throws IOException {\n        try (QueueInputStream inputStream = new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMillis(500));\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n\n            final Stopwatch stopwatch = Stopwatch.createStarted();\n            final String actualData = assertTimeout(Duration.ofSeconds(1), () -> readUnbuffered(inputStream, 3));\n            stopwatch.stop();\n            assertEquals(\"\", actualData);\n\n            assertTrue(stopwatch.elapsed(TimeUnit.MILLISECONDS) >= 500);\n        }\n    }\n\n    @Test\n    @DisplayName(\"If read is interrupted while waiting, then exception is thrown\")\n    public void timeoutInterrupted() throws Exception {\n        try (QueueInputStream inputStream = new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMinutes(2));\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n\n            // read in a background thread\n            final AtomicReference<Boolean> result = new AtomicReference<>();\n            final CountDownLatch latch = new CountDownLatch(1);\n            final Thread thread = new Thread(() -> {\n                // when thread is interrupted, verify ...\n                assertThrows(IllegalStateException.class, () -> readUnbuffered(inputStream, 3));\n                assertTrue(Thread.currentThread().isInterrupted());\n                result.set(true);\n                latch.countDown();\n            });\n            thread.setDaemon(true);\n            thread.start();\n\n            // interrupt and check that verification completed\n            thread.interrupt();\n            latch.await(500, TimeUnit.MILLISECONDS);\n            assertTrue(result.get());\n        }\n    }\n\n    private void writeUnbuffered(final QueueOutputStream outputStream, final String inputData) throws IOException {\n        final byte[] bytes = inputData.getBytes(UTF_8);\n        outputStream.write(bytes, 0, bytes.length);\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.QueueInputStreamTest#newQueueInputStream\n methodBody: protected AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue) {\nreturn new QueueInputStream(queue);\n}", "methodSignature: org.apache.commons.io.input.PollingQueueInputStreamTest#newQueueInputStream\n methodBody: protected AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue) {\nreturn new PollingQueueInputStream(queue);\n}", "methodSignature: org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#readUnbuffered\n methodBody: private String readUnbuffered(final InputStream inputStream) throws IOException {\nfinal ByteArrayOutputStream byteArrayOutputStream=new ByteArrayOutputStream();\nint n=-1;\nwhile((n=inputStream.read()) != -1){byteArrayOutputStream.write(n);\n}return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n}", "methodSignature: org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#newQueueInputStream\n methodBody: protected abstract AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue);", "methodSignature: org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#defaultBufferSize\n methodBody: private int defaultBufferSize() {\nreturn 8192;\n}"], "sourceCodeAfterRefactoring": "@ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (QueueInputStream inputStream = new QueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }", "diffSourceCode": "-   92:     @ParameterizedTest(name = \"inputData={0}\")\n-   93:     @MethodSource(\"inputData\")\n-   94:     public void bufferedWrites(final String inputData) throws IOException {\n-   95:         final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n-   96:         try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n-   97:                 final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n-   98:             outputStream.write(inputData.getBytes(UTF_8));\n-   99:             outputStream.flush();\n-  100:             final String actualData = readUnbuffered(inputStream);\n-  101:             assertEquals(inputData, actualData);\n-  102:         }\n-  103:     }\n-  104: \n-  105:     private int defaultBufferSize() {\n-  106:         return 8192;\n-  107:     }\n-  108: \n+   92:             final String dataCopy = IOUtils.toString(inputStream, UTF_8);\n+   93:             assertEquals(inputData, dataCopy);\n+   94:         }\n+   95:     }\n+   96: \n+   97:     @ParameterizedTest(name = \"inputData={0}\")\n+   98:     @MethodSource(\"inputData\")\n+   99:     public void bufferedWrites(final String inputData) throws IOException {\n+  100:         final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n+  101:         try (QueueInputStream inputStream = new QueueInputStream(queue);\n+  102:                 final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n+  103:             outputStream.write(inputData.getBytes(UTF_8));\n+  104:             outputStream.flush();\n+  105:             final String actualData = readUnbuffered(inputStream);\n+  106:             assertEquals(inputData, actualData);\n+  107:         }\n+  108:     }\n", "uniqueId": "150ba4af81b71517d3b44c0669b0da0f445e6ac3_92_103__97_108", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the `bufferedWrites` method from the `AbstractBlockingQueueInputStreamTest` class to an existing class that is suitable for this method. Given the context of the method, it seems appropriate to move it to the `QueueOutputStreamTest` class, as it deals with output streams and writing data.\n\n### Step 1: Identify the target file path\nThe target file path for the existing class where the method will be moved is:\n```\nsrc/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java\n```\n\n### Step 2: Moved class code\nWe will move the `bufferedWrites` method and update it to be a public static method. The moved method code will look like this:\n\n```java\npackage org.apache.commons.io.output;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class QueueOutputStreamTest {\n\n    // Other existing test methods...\n\n    public static void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    // Other existing methods...\n}\n```\n\n### Step 3: Refactored method code\nNow we will refactor the `bufferedWrites` method in the `AbstractBlockingQueueInputStreamTest` class to call the moved method:\n\n```java\n@ParameterizedTest(name = \"inputData={0}\")\n@MethodSource(\"inputData\")\npublic void bufferedWrites(final String inputData) throws IOException {\n    QueueOutputStreamTest.bufferedWrites(inputData);\n}\n```\n\n### Final Output\nNow, we can present the output in the required format:\n\n##########################\nsrc/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java\n##########################\n```java\npackage org.apache.commons.io.output;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class QueueOutputStreamTest {\n\n    // Other existing test methods...\n\n    public static void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    // Other existing methods...\n}\n```\n##########################\n```java\n@ParameterizedTest(name = \"inputData={0}\")\n@MethodSource(\"inputData\")\npublic void bufferedWrites(final String inputData) throws IOException {\n    QueueOutputStreamTest.bufferedWrites(inputData);\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.AbstractBlockingQueueInputStream.PollingQueueInputStream;\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.apache.commons.io.output.QueueOutputStreamTest;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Test {@link PollingQueueInputStream}.\n *\n * @see QueueOutputStreamTest\n */\npublic abstract class AbstractBlockingQueueInputStreamTest {\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReads(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            final String actualData = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReadWrite(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String dataCopy = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, dataCopy);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private int defaultBufferSize() {\n        return 8192;\n    }\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream();\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue);\n\n    protected QueueOutputStream newQueueOutputStream(AbstractBlockingQueueInputStream inputStream) {\n        return inputStream.newQueueOutputStream();\n    }\n\n    private String readUnbuffered(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        int n = -1;\n        while ((n = inputStream.read()) != -1) {\n            byteArrayOutputStream.write(n);\n        }\n        return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n    }\n\n    @Test\n    public void testNullArgument() {\n        assertThrows(NullPointerException.class, () -> newQueueInputStream(null), \"queue is required\");\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWrite(final String inputData) throws IOException {\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream();\n                final QueueOutputStream outputStream = newQueueOutputStream(inputStream)) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private void writeUnbuffered(final QueueOutputStream outputStream, final String inputData) throws InterruptedIOException {\n        final byte[] bytes = inputData.getBytes(UTF_8);\n        for (final byte oneByte : bytes) {\n            outputStream.write(oneByte);\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryBaseTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/PathWrapper.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/StringInputStream.java', 'src/test/java/org/apache/commons/io/input/StringInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic inputData() : Stream<Arguments> from class org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest to public inputData() : Stream<Arguments> from class org.apache.commons.io.input.QueueInputStreamTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/AbstractBlockingQueueInputStreamTest.java", "startLine": 52, "endLine": 65, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java", "startLine": 57, "endLine": 70, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/AbstractBlockingQueueInputStreamTest.java", "isPureRefactoring": true, "commitId": "150ba4af81b71517d3b44c0669b0da0f445e6ac3", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest", "methodNameBefore": "org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#inputData", "classSignatureBefore": "public abstract class AbstractBlockingQueueInputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest#inputData"], "classNameBeforeSet": ["org.apache.commons.io.input.AbstractBlockingQueueInputStreamTest"], "classSignatureBeforeSet": ["public abstract class AbstractBlockingQueueInputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.AbstractBlockingQueueInputStream.PollingQueueInputStream;\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.apache.commons.io.output.QueueOutputStreamTest;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Test {@link PollingQueueInputStream}.\n *\n * @see QueueOutputStreamTest\n */\npublic abstract class AbstractBlockingQueueInputStreamTest {\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReads(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            final String actualData = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReadWrite(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String dataCopy = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, dataCopy);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private int defaultBufferSize() {\n        return 8192;\n    }\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream();\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue);\n\n    protected QueueOutputStream newQueueOutputStream(AbstractBlockingQueueInputStream inputStream) {\n        return inputStream.newQueueOutputStream();\n    }\n\n    private String readUnbuffered(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        int n = -1;\n        while ((n = inputStream.read()) != -1) {\n            byteArrayOutputStream.write(n);\n        }\n        return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n    }\n\n    @Test\n    public void testNullArgument() {\n        assertThrows(NullPointerException.class, () -> newQueueInputStream(null), \"queue is required\");\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWrite(final String inputData) throws IOException {\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream();\n                final QueueOutputStream outputStream = newQueueOutputStream(inputStream)) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private void writeUnbuffered(final QueueOutputStream outputStream, final String inputData) throws InterruptedIOException {\n        final byte[] bytes = inputData.getBytes(UTF_8);\n        for (final byte oneByte : bytes) {\n            outputStream.write(oneByte);\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTimeout;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport com.google.common.base.Stopwatch;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.apache.commons.io.output.QueueOutputStreamTest;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.time.Duration;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Stream;\n\n/**\n * Test {@link QueueInputStream}.\n *\n * @see {@link QueueOutputStreamTest}\n */\npublic class QueueInputStreamTest {\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReads(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(new QueueInputStream(queue));\n                final QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            final String actualData = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReadWrite(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(new QueueInputStream(queue));\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String dataCopy = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, dataCopy);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (QueueInputStream inputStream = new QueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private int defaultBufferSize() {\n        return 8192;\n    }\n\n    private String readUnbuffered(final InputStream inputStream) throws IOException {\n        return readUnbuffered(inputStream, Integer.MAX_VALUE);\n    }\n\n    private String readUnbuffered(final InputStream inputStream, final int maxBytes) throws IOException {\n        if (maxBytes == 0) {\n            return \"\";\n        }\n\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        int n = -1;\n        while ((n = inputStream.read()) != -1) {\n            byteArrayOutputStream.write(n);\n            if (byteArrayOutputStream.size() >= maxBytes) {\n                break;\n            }\n        }\n        return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n    }\n\n    @Test\n    public void invalidArguments() {\n        assertThrows(NullPointerException.class, () -> new QueueInputStream(null), \"queue is required\");\n        assertThrows(NullPointerException.class, () -> new QueueInputStream(new LinkedBlockingQueue<>(), null), \"waitTime is required\");\n        assertThrows(IllegalArgumentException.class, () -> new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMillis(-1)),\n                \"waitTime must not be negative\");\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWrite(final String inputData) throws IOException {\n        try (QueueInputStream inputStream = new QueueInputStream();\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWriteWithTimeout(final String inputData) throws IOException {\n        try (QueueInputStream inputStream = new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMinutes(2));\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = assertTimeout(Duration.ofSeconds(1), () -> readUnbuffered(inputStream, inputData.length()));\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @Test\n    @DisplayName(\"If data is not available in queue, then read will wait until wait time elapses\")\n    public void timeoutUnavailableData() throws IOException {\n        try (QueueInputStream inputStream = new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMillis(500));\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n\n            final Stopwatch stopwatch = Stopwatch.createStarted();\n            final String actualData = assertTimeout(Duration.ofSeconds(1), () -> readUnbuffered(inputStream, 3));\n            stopwatch.stop();\n            assertEquals(\"\", actualData);\n\n            assertTrue(stopwatch.elapsed(TimeUnit.MILLISECONDS) >= 500);\n        }\n    }\n\n    @Test\n    @DisplayName(\"If read is interrupted while waiting, then exception is thrown\")\n    public void timeoutInterrupted() throws Exception {\n        try (QueueInputStream inputStream = new QueueInputStream(new LinkedBlockingQueue<>(), Duration.ofMinutes(2));\n                final QueueOutputStream outputStream = inputStream.newQueueOutputStream()) {\n\n            // read in a background thread\n            final AtomicReference<Boolean> result = new AtomicReference<>();\n            final CountDownLatch latch = new CountDownLatch(1);\n            final Thread thread = new Thread(() -> {\n                // when thread is interrupted, verify ...\n                assertThrows(IllegalStateException.class, () -> readUnbuffered(inputStream, 3));\n                assertTrue(Thread.currentThread().isInterrupted());\n                result.set(true);\n                latch.countDown();\n            });\n            thread.setDaemon(true);\n            thread.start();\n\n            // interrupt and check that verification completed\n            thread.interrupt();\n            latch.await(500, TimeUnit.MILLISECONDS);\n            assertTrue(result.get());\n        }\n    }\n\n    private void writeUnbuffered(final QueueOutputStream outputStream, final String inputData) throws IOException {\n        final byte[] bytes = inputData.getBytes(UTF_8);\n        outputStream.write(bytes, 0, bytes.length);\n    }\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }", "diffSourceCode": "-   52:     public static Stream<Arguments> inputData() {\n-   53:         return Stream.of(Arguments.of(\"\"),\n-   54:                 Arguments.of(\"1\"),\n-   55:                 Arguments.of(\"12\"),\n-   56:                 Arguments.of(\"1234\"),\n-   57:                 Arguments.of(\"12345678\"),\n-   58:                 Arguments.of(StringUtils.repeat(\"A\", 4095)),\n-   59:                 Arguments.of(StringUtils.repeat(\"A\", 4096)),\n-   60:                 Arguments.of(StringUtils.repeat(\"A\", 4097)),\n-   61:                 Arguments.of(StringUtils.repeat(\"A\", 8191)),\n-   62:                 Arguments.of(StringUtils.repeat(\"A\", 8192)),\n-   63:                 Arguments.of(StringUtils.repeat(\"A\", 8193)),\n-   64:                 Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n-   65:     }\n-   66: \n-   67:     @ParameterizedTest(name = \"inputData={0}\")\n-   68:     @MethodSource(\"inputData\")\n-   69:     public void bufferedReads(final String inputData) throws IOException {\n-   70:         final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n+   52:  *\n+   53:  * @see {@link QueueOutputStreamTest}\n+   54:  */\n+   55: public class QueueInputStreamTest {\n+   56: \n+   57:     public static Stream<Arguments> inputData() {\n+   58:         return Stream.of(Arguments.of(\"\"),\n+   59:                 Arguments.of(\"1\"),\n+   60:                 Arguments.of(\"12\"),\n+   61:                 Arguments.of(\"1234\"),\n+   62:                 Arguments.of(\"12345678\"),\n+   63:                 Arguments.of(StringUtils.repeat(\"A\", 4095)),\n+   64:                 Arguments.of(StringUtils.repeat(\"A\", 4096)),\n+   65:                 Arguments.of(StringUtils.repeat(\"A\", 4097)),\n+   66:                 Arguments.of(StringUtils.repeat(\"A\", 8191)),\n+   67:                 Arguments.of(StringUtils.repeat(\"A\", 8192)),\n+   68:                 Arguments.of(StringUtils.repeat(\"A\", 8193)),\n+   69:                 Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n+   70:     }\n", "uniqueId": "150ba4af81b71517d3b44c0669b0da0f445e6ac3_52_65__57_70", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring operation, we will move the `inputData` method from the `AbstractBlockingQueueInputStreamTest` class to an existing test class that seems appropriate for holding such utility methods. Given the context of the project structure, the `IOUtilsTest` class appears to be a suitable candidate for this method, as it deals with input/output utilities.\n\nHere\u2019s how the refactoring will be executed:\n\n1. **Move the Method**: The `inputData` method will be moved to the `IOUtilsTest` class.\n2. **Update the Method**: The method will be updated to be `public static`.\n3. **Refactor the Original Class**: The original class will be updated to call the moved method from the `IOUtilsTest` class.\n\n### Target File Path\nThe target file path for the moved method will be:\n```\nsrc/test/java/org/apache/commons/io/IOUtilsTest.java\n```\n\n### Moved Class Code\nHere is the code for the moved method that will be added to `IOUtilsTest`:\n```java\npackage org.apache.commons.io;\n\nimport org.junit.jupiter.params.provider.Arguments;\n\nimport java.util.stream.Stream;\n\npublic class IOUtilsTest {\n    // Other existing test methods...\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(\n                Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4))\n        );\n    }\n}\n```\n\n### Refactored Method Code\nHere is the updated `inputData` method in the `AbstractBlockingQueueInputStreamTest` class after refactoring:\n```java\npublic static Stream<Arguments> inputData() {\n    return IOUtilsTest.inputData();\n}\n```\n\n### Final Output\nHere is the complete output in the requested format:\n\n##########################\nsrc/test/java/org/apache/commons/io/IOUtilsTest.java\n##########################\npublic class IOUtilsTest {\n    // Other existing test methods...\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(\n                Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4))\n        );\n    }\n}\n##########################\npublic static Stream<Arguments> inputData() {\n    return IOUtilsTest.inputData();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.AbstractBlockingQueueInputStream.PollingQueueInputStream;\nimport org.apache.commons.io.output.QueueOutputStream;\nimport org.apache.commons.io.output.QueueOutputStreamTest;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Test {@link PollingQueueInputStream}.\n *\n * @see QueueOutputStreamTest\n */\npublic abstract class AbstractBlockingQueueInputStreamTest {\n\n    public static Stream<Arguments> inputData() {\n        return Stream.of(Arguments.of(\"\"),\n                Arguments.of(\"1\"),\n                Arguments.of(\"12\"),\n                Arguments.of(\"1234\"),\n                Arguments.of(\"12345678\"),\n                Arguments.of(StringUtils.repeat(\"A\", 4095)),\n                Arguments.of(StringUtils.repeat(\"A\", 4096)),\n                Arguments.of(StringUtils.repeat(\"A\", 4097)),\n                Arguments.of(StringUtils.repeat(\"A\", 8191)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192)),\n                Arguments.of(StringUtils.repeat(\"A\", 8193)),\n                Arguments.of(StringUtils.repeat(\"A\", 8192 * 4)));\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReads(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final QueueOutputStream outputStream = new QueueOutputStream(queue)) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            final String actualData = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedReadWrite(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (BufferedInputStream inputStream = new BufferedInputStream(newQueueInputStream(queue));\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String dataCopy = IOUtils.toString(inputStream, UTF_8);\n            assertEquals(inputData, dataCopy);\n        }\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void bufferedWrites(final String inputData) throws IOException {\n        final BlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream(queue);\n                final BufferedOutputStream outputStream = new BufferedOutputStream(new QueueOutputStream(queue), defaultBufferSize())) {\n            outputStream.write(inputData.getBytes(UTF_8));\n            outputStream.flush();\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private int defaultBufferSize() {\n        return 8192;\n    }\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream();\n\n    protected abstract AbstractBlockingQueueInputStream newQueueInputStream(final BlockingQueue<Integer> queue);\n\n    protected QueueOutputStream newQueueOutputStream(AbstractBlockingQueueInputStream inputStream) {\n        return inputStream.newQueueOutputStream();\n    }\n\n    private String readUnbuffered(final InputStream inputStream) throws IOException {\n        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        int n = -1;\n        while ((n = inputStream.read()) != -1) {\n            byteArrayOutputStream.write(n);\n        }\n        return byteArrayOutputStream.toString(StandardCharsets.UTF_8.name());\n    }\n\n    @Test\n    public void testNullArgument() {\n        assertThrows(NullPointerException.class, () -> newQueueInputStream(null), \"queue is required\");\n    }\n\n    @ParameterizedTest(name = \"inputData={0}\")\n    @MethodSource(\"inputData\")\n    public void unbufferedReadWrite(final String inputData) throws IOException {\n        try (AbstractBlockingQueueInputStream inputStream = newQueueInputStream();\n                final QueueOutputStream outputStream = newQueueOutputStream(inputStream)) {\n            writeUnbuffered(outputStream, inputData);\n            final String actualData = readUnbuffered(inputStream);\n            assertEquals(inputData, actualData);\n        }\n    }\n\n    private void writeUnbuffered(final QueueOutputStream outputStream, final String inputData) throws InterruptedIOException {\n        final byte[] bytes = inputData.getBytes(UTF_8);\n        for (final byte oneByte : bytes) {\n            outputStream.write(oneByte);\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryBaseTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/PathWrapper.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/StringInputStream.java', 'src/test/java/org/apache/commons/io/input/StringInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate writeOneAtATime(bytes byte[], out WriterOutputStream) : void extracted from private testWithSingleByteWrite(testString String, charsetDecoder CharsetDecoder) : void in class org.apache.commons.io.output.WriterOutputStreamTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "startLine": 175, "endLine": 184, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "startLine": 179, "endLine": 192, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "startLine": 229, "endLine": 233, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "isPureRefactoring": true, "commitId": "7ecca22f175c644da3096940a4ce899be5b33740", "packageNameBefore": "org.apache.commons.io.output", "classNameBefore": "org.apache.commons.io.output.WriterOutputStreamTest", "methodNameBefore": "org.apache.commons.io.output.WriterOutputStreamTest#testWithSingleByteWrite", "invokedMethod": "methodSignature: org.apache.commons.io.input.Tailer.TailablePath#toString\n methodBody: public String toString() {\nreturn \"TailablePath [file=\" + path + \", linkOptions=\" + Arrays.toString(linkOptions) + \"]\";\n}\nmethodSignature: org.apache.commons.io.filefilter.WildcardFileFilter#toString\n methodBody: public String toString() {\nfinal StringBuilder buffer=new StringBuilder();\nbuffer.append(super.toString());\nbuffer.append(\"(\");\nappend(wildcards,buffer);\nbuffer.append(\")\");\nreturn buffer.toString();\n}\nmethodSignature: org.apache.commons.io.output.WriterOutputStream#write\n methodBody: public void write(final int b) throws IOException {\nwrite(new byte[]{(byte)b},0,1);\n}\nmethodSignature: org.apache.commons.io.output.XmlStreamWriter#write\n methodBody: public void write(final char[] cbuf, final int off, final int len) throws IOException {\nif(prologWriter != null){detectEncoding(cbuf,off,len);\n}{writer.write(cbuf,off,len);\n}}\nmethodSignature: org.apache.commons.io.input.ReversedLinesFileReader#toString\n methodBody: public String toString(final int lineCount) throws IOException {\nfinal List<String> lines=readLines(lineCount);\nCollections.reverse(lines);\nreturn lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(),lines) + System.lineSeparator();\n}\nmethodSignature: org.apache.commons.io.output.LockableFileWriter#write\n methodBody: public void write(final String str, final int off, final int len) throws IOException {\nout.write(str,off,len);\n}\nmethodSignature: org.apache.commons.io.input.TailerTest#write\n methodBody: private void write(final File file, final String... lines) throws IOException {\ntry(Writer writer=Files.newBufferedWriter(file.toPath(),StandardOpenOption.APPEND))for(final String line: lines){writer.write(line + \"\\n\");\n}}", "classSignatureBefore": "public class WriterOutputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.output.WriterOutputStreamTest#testWithSingleByteWrite"], "classNameBeforeSet": ["org.apache.commons.io.output.WriterOutputStreamTest"], "classSignatureBeforeSet": ["public class WriterOutputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.charset.CharsetDecoders;\nimport org.junit.jupiter.api.Test;\n\npublic class WriterOutputStreamTest {\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i=0; i<100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    public void testFlush() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, false)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(0, writer.getBuffer().length());\n            out.flush();\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testNullCharsetDecoderWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (CharsetDecoder) null);\n    }\n\n    @Test\n    public void testNullCharsetNameWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (String) null);\n    }\n\n    @Test\n    public void testNullCharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (Charset) null);\n    }\n\n    @Test\n    public void testUTF16BEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16BEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16LEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16LEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16WithBufferedWrite() throws IOException {\n        try {\n            testWithBufferedWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e) {\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")) {\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteWrite() throws IOException {\n        try {\n            testWithSingleByteWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e){\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")){\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            int offset = 0;\n            while (offset < expected.length) {\n                final int length = Math.min(random.nextInt(128), expected.length - offset);\n                out.write(expected, offset, length);\n                offset += length;\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n\n    private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    @Test\n    public void testWriteImmediately() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, true)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.charset.CharsetDecoders;\nimport org.junit.jupiter.api.Test;\n\npublic class WriterOutputStreamTest {\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i=0; i<100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    public void testFlush() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, false)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(0, writer.getBuffer().length());\n            out.flush();\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testNullCharsetDecoderWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (CharsetDecoder) null);\n    }\n\n    @Test\n    public void testNullCharsetNameWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (String) null);\n    }\n\n    @Test\n    public void testNullCharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (Charset) null);\n    }\n\n    @Test\n    public void testUTF16BEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16BEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16LEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16LEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16WithBufferedWrite() throws IOException {\n        try {\n            testWithBufferedWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e) {\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")) {\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteWrite() throws IOException {\n        try {\n            testWithSingleByteWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e){\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")){\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charsetName).get()) {\n            int offset = 0;\n            while (offset < expected.length) {\n                final int length = Math.min(random.nextInt(128), expected.length - offset);\n                out.write(expected, offset, length);\n                offset += length;\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n\n    private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charset).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharsetDecoder(charsetDecoder).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charsetName).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    @Test\n    public void testWriteImmediately() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, true)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abc\", writer.toString());\n        }\n        // @formatter:off\n        try (WriterOutputStream out = WriterOutputStream.builder()\n                .setWriter(writer)\n                .setCharset(\"us-ascii\")\n                .setBufferSize(1024)\n                .setWriteImmediately(true)\n                .get()) {\n            // @formatter:on\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abcabc\", writer.toString());\n        }\n    }\n\n    private void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }\n}\n", "diffSourceCodeSet": ["private void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.Tailer.TailablePath#toString\n methodBody: public String toString() {\nreturn \"TailablePath [file=\" + path + \", linkOptions=\" + Arrays.toString(linkOptions) + \"]\";\n}", "methodSignature: org.apache.commons.io.filefilter.WildcardFileFilter#toString\n methodBody: public String toString() {\nfinal StringBuilder buffer=new StringBuilder();\nbuffer.append(super.toString());\nbuffer.append(\"(\");\nappend(wildcards,buffer);\nbuffer.append(\")\");\nreturn buffer.toString();\n}", "methodSignature: org.apache.commons.io.output.WriterOutputStream#write\n methodBody: public void write(final int b) throws IOException {\nwrite(new byte[]{(byte)b},0,1);\n}", "methodSignature: org.apache.commons.io.output.XmlStreamWriter#write\n methodBody: public void write(final char[] cbuf, final int off, final int len) throws IOException {\nif(prologWriter != null){detectEncoding(cbuf,off,len);\n}{writer.write(cbuf,off,len);\n}}", "methodSignature: org.apache.commons.io.input.ReversedLinesFileReader#toString\n methodBody: public String toString(final int lineCount) throws IOException {\nfinal List<String> lines=readLines(lineCount);\nCollections.reverse(lines);\nreturn lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(),lines) + System.lineSeparator();\n}", "methodSignature: org.apache.commons.io.output.LockableFileWriter#write\n methodBody: public void write(final String str, final int off, final int len) throws IOException {\nout.write(str,off,len);\n}", "methodSignature: org.apache.commons.io.input.TailerTest#write\n methodBody: private void write(final File file, final String... lines) throws IOException {\ntry(Writer writer=Files.newBufferedWriter(file.toPath(),StandardOpenOption.APPEND))for(final String line: lines){writer.write(line + \"\\n\");\n}}"], "sourceCodeAfterRefactoring": "private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharsetDecoder(charsetDecoder).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\nprivate void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }", "diffSourceCode": "-  175:     private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n-  176:         final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n-  177:         final StringWriter writer = new StringWriter();\n-  178:         try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n-  179:             for (final byte b : bytes) {\n-  180:                 out.write(b);\n-  181:             }\n-  182:         }\n-  183:         assertEquals(testString, writer.toString());\n-  184:     }\n-  185: \n-  186:     private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n-  187:         final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n-  188:         final StringWriter writer = new StringWriter();\n-  189:         try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n-  190:             for (final byte b : bytes) {\n-  191:                 out.write(b);\n-  192:             }\n+  175:         }\n+  176:         assertEquals(testString, writer.toString());\n+  177:     }\n+  178: \n+  179:     private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n+  180:         final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n+  181:         StringWriter writer = new StringWriter();\n+  182:         try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n+  183:             writeOneAtATime(bytes, out);\n+  184:         }\n+  185:         assertEquals(testString, writer.toString());\n+  186:         //\n+  187:         writer = new StringWriter();\n+  188:         try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharsetDecoder(charsetDecoder).get()) {\n+  189:             writeOneAtATime(bytes, out);\n+  190:         }\n+  191:         assertEquals(testString, writer.toString());\n+  192:     }\n+  229:     private void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n+  230:         for (final byte b : bytes) {\n+  231:             out.write(b);\n+  232:         }\n+  233:     }\n", "uniqueId": "7ecca22f175c644da3096940a4ce899be5b33740_175_184_229_233_179_192", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testWithSingleByteWrite` method, we can extract the common logic of writing bytes to a `WriterOutputStream` into a separate method. This will reduce code duplication and make the code easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\nprivate void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n    writeBytesToOutput(testString, CharsetDecoders.toCharsetDecoder(charsetDecoder).charset(), charsetDecoder);\n}\n\nprivate void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n    writeBytesToOutput(testString, charset, charset);\n}\n\nprivate void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n    writeBytesToOutput(testString, Charsets.toCharset(charsetName), charsetName);\n}\n\nprivate void writeBytesToOutput(final String testString, final Charset charset, final Object outputCharset) throws IOException {\n    final byte[] bytes = testString.getBytes(charset);\n    final StringWriter writer = new StringWriter();\n    try (WriterOutputStream out = new WriterOutputStream(writer, outputCharset)) {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }\n    assertEquals(testString, writer.toString());\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The common logic of converting a string to bytes and writing those bytes to a `WriterOutputStream` has been extracted into a new method called `writeBytesToOutput`.\n2. **Reduced Duplication**: The original `testWithSingleByteWrite` methods now call this new method, reducing code duplication and improving clarity.\n3. **Parameters**: The new method takes the `testString`, `Charset`, and an `Object` for the output charset, which allows it to handle both `Charset` and `CharsetDecoder` types.\n\nThis refactoring enhances the modularity of the code and makes it easier to maintain and understand.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.charset.CharsetDecoders;\nimport org.junit.jupiter.api.Test;\n\npublic class WriterOutputStreamTest {\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i=0; i<100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    public void testFlush() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, false)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(0, writer.getBuffer().length());\n            out.flush();\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testNullCharsetDecoderWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (CharsetDecoder) null);\n    }\n\n    @Test\n    public void testNullCharsetNameWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (String) null);\n    }\n\n    @Test\n    public void testNullCharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (Charset) null);\n    }\n\n    @Test\n    public void testUTF16BEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16BEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16LEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16LEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16WithBufferedWrite() throws IOException {\n        try {\n            testWithBufferedWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e) {\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")) {\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteWrite() throws IOException {\n        try {\n            testWithSingleByteWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e){\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")){\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            int offset = 0;\n            while (offset < expected.length) {\n                final int length = Math.min(random.nextInt(128), expected.length - offset);\n                out.write(expected, offset, length);\n                offset += length;\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n\n    private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    @Test\n    public void testWriteImmediately() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, true)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate writeOneAtATime(bytes byte[], out WriterOutputStream) : void extracted from private testWithSingleByteWrite(testString String, charset Charset) : void in class org.apache.commons.io.output.WriterOutputStreamTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "startLine": 164, "endLine": 173, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "startLine": 164, "endLine": 177, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "startLine": 229, "endLine": 233, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "isPureRefactoring": true, "commitId": "7ecca22f175c644da3096940a4ce899be5b33740", "packageNameBefore": "org.apache.commons.io.output", "classNameBefore": "org.apache.commons.io.output.WriterOutputStreamTest", "methodNameBefore": "org.apache.commons.io.output.WriterOutputStreamTest#testWithSingleByteWrite", "invokedMethod": "methodSignature: org.apache.commons.io.input.Tailer.TailablePath#toString\n methodBody: public String toString() {\nreturn \"TailablePath [file=\" + path + \", linkOptions=\" + Arrays.toString(linkOptions) + \"]\";\n}\nmethodSignature: org.apache.commons.io.filefilter.WildcardFileFilter#toString\n methodBody: public String toString() {\nfinal StringBuilder buffer=new StringBuilder();\nbuffer.append(super.toString());\nbuffer.append(\"(\");\nappend(wildcards,buffer);\nbuffer.append(\")\");\nreturn buffer.toString();\n}\nmethodSignature: org.apache.commons.io.output.WriterOutputStream#write\n methodBody: public void write(final int b) throws IOException {\nwrite(new byte[]{(byte)b},0,1);\n}\nmethodSignature: org.apache.commons.io.output.XmlStreamWriter#write\n methodBody: public void write(final char[] cbuf, final int off, final int len) throws IOException {\nif(prologWriter != null){detectEncoding(cbuf,off,len);\n}{writer.write(cbuf,off,len);\n}}\nmethodSignature: org.apache.commons.io.input.ReversedLinesFileReader#toString\n methodBody: public String toString(final int lineCount) throws IOException {\nfinal List<String> lines=readLines(lineCount);\nCollections.reverse(lines);\nreturn lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(),lines) + System.lineSeparator();\n}\nmethodSignature: org.apache.commons.io.output.LockableFileWriter#write\n methodBody: public void write(final String str, final int off, final int len) throws IOException {\nout.write(str,off,len);\n}\nmethodSignature: org.apache.commons.io.input.TailerTest#write\n methodBody: private void write(final File file, final String... lines) throws IOException {\ntry(Writer writer=Files.newBufferedWriter(file.toPath(),StandardOpenOption.APPEND))for(final String line: lines){writer.write(line + \"\\n\");\n}}", "classSignatureBefore": "public class WriterOutputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.output.WriterOutputStreamTest#testWithSingleByteWrite"], "classNameBeforeSet": ["org.apache.commons.io.output.WriterOutputStreamTest"], "classSignatureBeforeSet": ["public class WriterOutputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.charset.CharsetDecoders;\nimport org.junit.jupiter.api.Test;\n\npublic class WriterOutputStreamTest {\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i=0; i<100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    public void testFlush() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, false)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(0, writer.getBuffer().length());\n            out.flush();\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testNullCharsetDecoderWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (CharsetDecoder) null);\n    }\n\n    @Test\n    public void testNullCharsetNameWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (String) null);\n    }\n\n    @Test\n    public void testNullCharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (Charset) null);\n    }\n\n    @Test\n    public void testUTF16BEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16BEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16LEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16LEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16WithBufferedWrite() throws IOException {\n        try {\n            testWithBufferedWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e) {\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")) {\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteWrite() throws IOException {\n        try {\n            testWithSingleByteWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e){\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")){\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            int offset = 0;\n            while (offset < expected.length) {\n                final int length = Math.min(random.nextInt(128), expected.length - offset);\n                out.write(expected, offset, length);\n                offset += length;\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n\n    private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    @Test\n    public void testWriteImmediately() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, true)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.charset.CharsetDecoders;\nimport org.junit.jupiter.api.Test;\n\npublic class WriterOutputStreamTest {\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i=0; i<100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    public void testFlush() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, false)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(0, writer.getBuffer().length());\n            out.flush();\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testNullCharsetDecoderWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (CharsetDecoder) null);\n    }\n\n    @Test\n    public void testNullCharsetNameWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (String) null);\n    }\n\n    @Test\n    public void testNullCharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (Charset) null);\n    }\n\n    @Test\n    public void testUTF16BEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16BEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16LEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16LEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16WithBufferedWrite() throws IOException {\n        try {\n            testWithBufferedWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e) {\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")) {\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteWrite() throws IOException {\n        try {\n            testWithSingleByteWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e){\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")){\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charsetName).get()) {\n            int offset = 0;\n            while (offset < expected.length) {\n                final int length = Math.min(random.nextInt(128), expected.length - offset);\n                out.write(expected, offset, length);\n                offset += length;\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n\n    private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charset).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharsetDecoder(charsetDecoder).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charsetName).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    @Test\n    public void testWriteImmediately() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, true)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abc\", writer.toString());\n        }\n        // @formatter:off\n        try (WriterOutputStream out = WriterOutputStream.builder()\n                .setWriter(writer)\n                .setCharset(\"us-ascii\")\n                .setBufferSize(1024)\n                .setWriteImmediately(true)\n                .get()) {\n            // @formatter:on\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abcabc\", writer.toString());\n        }\n    }\n\n    private void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }\n}\n", "diffSourceCodeSet": ["private void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.Tailer.TailablePath#toString\n methodBody: public String toString() {\nreturn \"TailablePath [file=\" + path + \", linkOptions=\" + Arrays.toString(linkOptions) + \"]\";\n}", "methodSignature: org.apache.commons.io.filefilter.WildcardFileFilter#toString\n methodBody: public String toString() {\nfinal StringBuilder buffer=new StringBuilder();\nbuffer.append(super.toString());\nbuffer.append(\"(\");\nappend(wildcards,buffer);\nbuffer.append(\")\");\nreturn buffer.toString();\n}", "methodSignature: org.apache.commons.io.output.WriterOutputStream#write\n methodBody: public void write(final int b) throws IOException {\nwrite(new byte[]{(byte)b},0,1);\n}", "methodSignature: org.apache.commons.io.output.XmlStreamWriter#write\n methodBody: public void write(final char[] cbuf, final int off, final int len) throws IOException {\nif(prologWriter != null){detectEncoding(cbuf,off,len);\n}{writer.write(cbuf,off,len);\n}}", "methodSignature: org.apache.commons.io.input.ReversedLinesFileReader#toString\n methodBody: public String toString(final int lineCount) throws IOException {\nfinal List<String> lines=readLines(lineCount);\nCollections.reverse(lines);\nreturn lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(),lines) + System.lineSeparator();\n}", "methodSignature: org.apache.commons.io.output.LockableFileWriter#write\n methodBody: public void write(final String str, final int off, final int len) throws IOException {\nout.write(str,off,len);\n}", "methodSignature: org.apache.commons.io.input.TailerTest#write\n methodBody: private void write(final File file, final String... lines) throws IOException {\ntry(Writer writer=Files.newBufferedWriter(file.toPath(),StandardOpenOption.APPEND))for(final String line: lines){writer.write(line + \"\\n\");\n}}"], "sourceCodeAfterRefactoring": "private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charset).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\nprivate void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }", "diffSourceCode": "   164:     private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n   165:         final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n-  166:         final StringWriter writer = new StringWriter();\n+  166:         StringWriter writer = new StringWriter();\n   167:         try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n-  168:             for (final byte b : bytes) {\n-  169:                 out.write(b);\n-  170:             }\n-  171:         }\n-  172:         assertEquals(testString, writer.toString());\n-  173:     }\n-  174: \n-  175:     private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n-  176:         final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n-  177:         final StringWriter writer = new StringWriter();\n+  168:             writeOneAtATime(bytes, out);\n+  169:         }\n+  170:         assertEquals(testString, writer.toString());\n+  171:         //\n+  172:         writer = new StringWriter();\n+  173:         try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charset).get()) {\n+  174:             writeOneAtATime(bytes, out);\n+  175:         }\n+  176:         assertEquals(testString, writer.toString());\n+  177:     }\n+  229:     private void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n+  230:         for (final byte b : bytes) {\n+  231:             out.write(b);\n+  232:         }\n+  233:     }\n", "uniqueId": "7ecca22f175c644da3096940a4ce899be5b33740_164_173_229_233_164_177", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testWithSingleByteWrite` method, we can extract the common logic of writing bytes to a `WriterOutputStream` into a separate method. This will reduce code duplication and make the code cleaner.\n\nHere's the refactored method code:\n\n##########################\n```java\nprivate void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n    writeBytesToOutputStream(testString.getBytes(Charsets.toCharset(charset)), charset);\n}\n\nprivate void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n    writeBytesToOutputStream(testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset()), charsetDecoder);\n}\n\nprivate void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n    writeBytesToOutputStream(testString.getBytes(Charsets.toCharset(charsetName)), charsetName);\n}\n\nprivate void writeBytesToOutputStream(final byte[] bytes, final Charset charset) throws IOException {\n    final StringWriter writer = new StringWriter();\n    try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }\n    assertEquals(new String(bytes, charset), writer.toString());\n}\n\nprivate void writeBytesToOutputStream(final byte[] bytes, final CharsetDecoder charsetDecoder) throws IOException {\n    final StringWriter writer = new StringWriter();\n    try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }\n    assertEquals(new String(bytes, charsetDecoder.charset()), writer.toString());\n}\n\nprivate void writeBytesToOutputStream(final byte[] bytes, final String charsetName) throws IOException {\n    final StringWriter writer = new StringWriter();\n    try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }\n    assertEquals(new String(bytes, Charsets.toCharset(charsetName)), writer.toString());\n}\n```\n##########################\n\nIn this refactoring, the common logic of writing bytes to the `WriterOutputStream` has been extracted into the `writeBytesToOutputStream` method. This method is overloaded to handle different input types (Charset, CharsetDecoder, and String). This reduces redundancy and enhances the clarity of the code.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.charset.CharsetDecoders;\nimport org.junit.jupiter.api.Test;\n\npublic class WriterOutputStreamTest {\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i=0; i<100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    public void testFlush() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, false)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(0, writer.getBuffer().length());\n            out.flush();\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testNullCharsetDecoderWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (CharsetDecoder) null);\n    }\n\n    @Test\n    public void testNullCharsetNameWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (String) null);\n    }\n\n    @Test\n    public void testNullCharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (Charset) null);\n    }\n\n    @Test\n    public void testUTF16BEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16BEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16LEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16LEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16WithBufferedWrite() throws IOException {\n        try {\n            testWithBufferedWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e) {\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")) {\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteWrite() throws IOException {\n        try {\n            testWithSingleByteWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e){\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")){\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            int offset = 0;\n            while (offset < expected.length) {\n                final int length = Math.min(random.nextInt(128), expected.length - offset);\n                out.write(expected, offset, length);\n                offset += length;\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n\n    private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    @Test\n    public void testWriteImmediately() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, true)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate testAlternateDefaultEncoding(streamEnc String, alternateEnc String, xmlReader XmlStreamReader) : void extracted from public testAlternateDefaultEncoding(cT String, bomEnc String, streamEnc String, prologEnc String, alternateEnc String) : void in class org.apache.commons.io.input.XmlStreamReaderTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java", "startLine": 164, "endLine": 180, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java", "startLine": 164, "endLine": 181, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java", "startLine": 183, "endLine": 195, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "public void testAlternateDefaultEncoding(final String cT, final String bomEnc, final String streamEnc, final String prologEnc, final String alternateEnc)\n        throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, cT, false, alternateEnc)) {\n            assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);\n            if (!streamEnc.equals(UTF_16)) {\n                // we can not assert things here because UTF-8, US-ASCII and\n                // ISO-8859-1 look alike for the chars used for detection\n                // (niallp 2010-10-06 - I re-instated the check below - the tests(6) passed)\n                final String enc = alternateEnc != null ? alternateEnc : streamEnc;\n                assertEquals(xmlReader.getEncoding(), enc);\n            } else {\n                // String enc = (alternateEnc != null) ? alternateEnc : streamEnc;\n                assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n            }\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java", "isPureRefactoring": true, "commitId": "7ecca22f175c644da3096940a4ce899be5b33740", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.XmlStreamReaderTest", "methodNameBefore": "org.apache.commons.io.input.XmlStreamReaderTest#testAlternateDefaultEncoding", "invokedMethod": "methodSignature: org.apache.commons.io.FileUtilsTest.ShorterFile#length\n methodBody: public long length() {\nreturn super.length() - 1;\n}\nmethodSignature: org.apache.commons.io.input.XmlStreamReader#getDefaultEncoding\n methodBody: public String getDefaultEncoding() {\nreturn defaultEncoding;\n}\nmethodSignature: org.apache.commons.io.input.XmlStreamReader#getEncoding\n methodBody: public String getEncoding() {\nreturn encoding;\n}\nmethodSignature: org.apache.commons.io.input.XmlStreamReaderTest#getXmlInputStream\n methodBody: protected InputStream getXmlInputStream(final String bomType, final String xmlType,\n        final String streamEnc, final String prologEnc) throws IOException {\nfinal ByteArrayOutputStream baos=new ByteArrayOutputStream(1024);\nint[] bom=BOMs.get(bomType);\nif(bom == null){bom=new int[0];\n}for(final int element: bom){baos.write(element);\n}try(Writer writer=new OutputStreamWriter(baos,streamEnc))final String xmlDoc=getXML(bomType,xmlType,streamEnc,prologEnc);\nwriter.write(xmlDoc);\nwriter.write(\"<da>\\n\");\nfor(int i=0; i < 10000; i++){writer.write(\"<do/>\\n\");\n}writer.write(\"</da>\\n\");\nreturn new ByteArrayInputStream(baos.toByteArray());\n}\nmethodSignature: org.apache.commons.io.output.XmlStreamWriter#getDefaultEncoding\n methodBody: public String getDefaultEncoding() {\nreturn defaultCharset.name();\n}\nmethodSignature: org.apache.commons.io.output.XmlStreamWriter#getEncoding\n methodBody: public String getEncoding() {\nreturn charset.name();\n}", "classSignatureBefore": "public class XmlStreamReaderTest ", "methodNameBeforeSet": ["org.apache.commons.io.input.XmlStreamReaderTest#testAlternateDefaultEncoding"], "classNameBeforeSet": ["org.apache.commons.io.input.XmlStreamReaderTest"], "classSignatureBeforeSet": ["public class XmlStreamReaderTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.MessageFormat;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junitpioneer.jupiter.DefaultLocale;\n\npublic class XmlStreamReaderTest {\n\n    private static final String ISO_8859_1 = StandardCharsets.ISO_8859_1.name();\n    private static final String US_ASCII = StandardCharsets.US_ASCII.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_32 = \"UTF-32\";\n    private static final String UTF_32LE = \"UTF-32LE\";\n    private static final String UTF_32BE = \"UTF-32BE\";\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String XML5 = \"xml-prolog-encoding-spaced-single-quotes\";\n    private static final String XML4 = \"xml-prolog-encoding-single-quotes\";\n    private static final String XML3 = \"xml-prolog-encoding-double-quotes\";\n    private static final String XML2 = \"xml-prolog\";\n    private static final String XML1 = \"xml\";\n\n    private static final String ENCODING_ATTRIBUTE_XML = \"<?xml version=\\\"1.0\\\" ?> \\n\"\n            + \"<atom:feed xmlns:atom=\\\"http://www.w3.org/2005/Atom\\\">\\n\"\n            + \"\\n\"\n            + \"  <atom:entry>\\n\"\n            + \"    <atom:title encoding='base64'><![CDATA\\n\"\n            + \"aW5nTGluZSIgLz4\";\n\n    private static final int[] NO_BOM_BYTES = {};\n\n    private static final int[] UTF_16BE_BOM_BYTES = {0xFE, 0xFF};\n\n    private static final int[] UTF_16LE_BOM_BYTES = {0xFF, 0XFE};\n\n    private static final int[] UTF_32BE_BOM_BYTES = {0x00, 0x00, 0xFE, 0xFF};\n\n    private static final int[] UTF_32LE_BOM_BYTES = {0xFF, 0XFE, 0x00, 0x00};\n\n    private static final int[] UTF_8_BOM_BYTES = {0xEF, 0xBB, 0xBF};\n\n    private static final Map<String, int[]> BOMs = new HashMap<>();\n\n    static {\n        BOMs.put(\"no-bom\", NO_BOM_BYTES);\n        BOMs.put(\"UTF-16BE-bom\", UTF_16BE_BOM_BYTES);\n        BOMs.put(\"UTF-16LE-bom\", UTF_16LE_BOM_BYTES);\n        BOMs.put(\"UTF-32BE-bom\", UTF_32BE_BOM_BYTES);\n        BOMs.put(\"UTF-32LE-bom\", UTF_32LE_BOM_BYTES);\n        BOMs.put(\"UTF-16-bom\", NO_BOM_BYTES); // it's added by the writer\n        BOMs.put(\"UTF-8-bom\", UTF_8_BOM_BYTES);\n    }\n\n    private static final MessageFormat XML = new MessageFormat(\n            \"<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\"?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_DOUBLE_QUOTES = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\" encoding=\\\"{1}\\\"?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_SINGLE_QUOTES = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\" encoding=''{1}''?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_SPACED_SINGLE_QUOTES = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\" encoding =  \\t \\n \\r''{1}''?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat INFO = new MessageFormat(\n            \"\\nBOM : {0}\\nDoc : {1}\\nStream Enc : {2}\\nProlog Enc : {3}\\n\");\n\n    private static final Map<String, MessageFormat> XMLs = new HashMap<>();\n\n    static {\n        XMLs.put(XML1, XML);\n        XMLs.put(XML2, XML_WITH_PROLOG);\n        XMLs.put(XML3, XML_WITH_PROLOG_AND_ENCODING_DOUBLE_QUOTES);\n        XMLs.put(XML4, XML_WITH_PROLOG_AND_ENCODING_SINGLE_QUOTES);\n        XMLs.put(XML5, XML_WITH_PROLOG_AND_ENCODING_SPACED_SINGLE_QUOTES);\n    }\n\n    /**\n     * Create the XML.\n     */\n    private String getXML(final String bomType, final String xmlType,\n                          final String streamEnc, final String prologEnc) {\n        final MessageFormat xml = XMLs.get(xmlType);\n        final String info = INFO.format(new Object[]{bomType, xmlType, prologEnc});\n        return xml.format(new Object[]{streamEnc, prologEnc, info});\n    }\n\n    /**\n     * @param bomType   no-bom, UTF-16BE-bom, UTF-16LE-bom, UTF-8-bom\n     * @param xmlType   xml, xml-prolog, xml-prolog-charset\n     * @param streamEnc encoding of the stream\n     * @param prologEnc encoding of the prolog\n     * @return XML stream\n     * @throws IOException If an I/O error occurs\n     */\n    protected InputStream getXmlInputStream(final String bomType, final String xmlType,\n        final String streamEnc, final String prologEnc) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n        int[] bom = BOMs.get(bomType);\n        if (bom == null) {\n            bom = new int[0];\n        }\n        for (final int element : bom) {\n            baos.write(element);\n        }\n        try (Writer writer = new OutputStreamWriter(baos, streamEnc)) {\n            final String xmlDoc = getXML(bomType, xmlType, streamEnc, prologEnc);\n            writer.write(xmlDoc);\n\n            // PADDING TO TEST THINGS WORK BEYOND PUSHBACK_SIZE\n            writer.write(\"<da>\\n\");\n            for (int i = 0; i < 10000; i++) {\n                writer.write(\"<do/>\\n\");\n            }\n            writer.write(\"</da>\\n\");\n\n        }\n        return new ByteArrayInputStream(baos.toByteArray());\n    }\n\n    public void testAlternateDefaultEncoding(final String cT, final String bomEnc, final String streamEnc, final String prologEnc, final String alternateEnc)\n        throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, cT, false, alternateEnc)) {\n            assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);\n            if (!streamEnc.equals(UTF_16)) {\n                // we can not assert things here because UTF-8, US-ASCII and\n                // ISO-8859-1 look alike for the chars used for detection\n                // (niallp 2010-10-06 - I re-instated the check below - the tests(6) passed)\n                final String enc = alternateEnc != null ? alternateEnc : streamEnc;\n                assertEquals(xmlReader.getEncoding(), enc);\n            } else {\n                // String enc = (alternateEnc != null) ? alternateEnc : streamEnc;\n                assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n            }\n        }\n    }\n\n    @Test\n    protected void testConstructorFileInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(new File(\"pom.xml\"))) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorFileInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((File) null));\n    }\n\n    @Test\n    protected void testConstructorInputStreamInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(Files.newInputStream(Paths.get(\"pom.xml\")))) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorInputStreamInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((InputStream) null));\n    }\n\n    protected void testConstructorPathInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(Paths.get(\"pom.xml\"))) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorPathInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((Path) null));\n    }\n\n    @Test\n    protected void testConstructorURLConnectionInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(new URL(\"https://www.apache.org/\").openConnection(), UTF_8)) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorURLConnectionInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((URLConnection) null, US_ASCII));\n    }\n\n    @Test\n    protected void testConstructorURLInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(new URL(\"https://www.apache.org/\"))) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorURLInputNull() throws IOException {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((URL) null));\n    }\n\n    @Test\n    public void testEncodingAttributeXML() throws Exception {\n        try (InputStream is = new ByteArrayInputStream(ENCODING_ATTRIBUTE_XML.getBytes(StandardCharsets.UTF_8));\n            XmlStreamReader xmlReader = new XmlStreamReader(is, \"\", true)) {\n            assertEquals(xmlReader.getEncoding(), UTF_8);\n        }\n    }\n\n    // XML Stream generator\n\n    @Test\n    public void testHttp() throws Exception {\n        // niallp 2010-10-06 - remove following 2 tests - I reinstated\n        // checks for non-UTF-16 encodings (18 tests) and these failed\n        // _testHttpValid(\"application/xml\", \"no-bom\", \"US-ASCII\", null);\n        // _testHttpValid(\"application/xml\", \"UTF-8-bom\", \"US-ASCII\", null);\n        testHttpValid(\"application/xml\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml\", \"UTF-8-bom\", UTF_8, UTF_8);\n        testHttpValid(\"application/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml;charset=\\\"UTF-8\\\"\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml;charset='UTF-8'\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, UTF_8);\n        testHttpValid(\"application/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpValid(\"application/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpValid(\"application/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n\n        testHttpInvalid(\"application/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpInvalid(\"application/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpInvalid(\"application/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n\n        testHttpInvalid(\"application/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, null);\n        testHttpInvalid(\"application/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32);\n        testHttpInvalid(\"application/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE);\n\n        testHttpInvalid(\"application/xml\", \"UTF-8-bom\", US_ASCII, US_ASCII);\n        testHttpInvalid(\"application/xml;charset=UTF-16\", UTF_16LE, UTF_8, UTF_8);\n        testHttpInvalid(\"application/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, UTF_16BE);\n        testHttpInvalid(\"application/xml;charset=UTF-32\", UTF_32LE, UTF_8, UTF_8);\n        testHttpInvalid(\"application/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, UTF_32BE);\n\n        testHttpValid(\"text/xml\", \"no-bom\", US_ASCII, null);\n        testHttpValid(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, UTF_8);\n        testHttpValid(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpValid(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpValid(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n        testHttpValid(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, null);\n        testHttpValid(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32);\n        testHttpValid(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE);\n        testHttpValid(\"text/xml\", \"UTF-8-bom\", US_ASCII, null);\n\n        testAlternateDefaultEncoding(\"application/xml\", \"UTF-8-bom\", UTF_8, null, null);\n        testAlternateDefaultEncoding(\"application/xml\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testAlternateDefaultEncoding(\"application/xml\", \"UTF-8-bom\", UTF_8, null, UTF_8);\n        testAlternateDefaultEncoding(\"text/xml\", \"no-bom\", US_ASCII, null, null);\n        testAlternateDefaultEncoding(\"text/xml\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testAlternateDefaultEncoding(\"text/xml\", \"no-bom\", US_ASCII, null, UTF_8);\n\n        testHttpInvalid(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpInvalid(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpInvalid(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n        testHttpInvalid(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, UTF_16BE);\n        testHttpInvalid(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, null);\n\n        testHttpInvalid(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, null);\n        testHttpInvalid(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32);\n        testHttpInvalid(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE);\n        testHttpInvalid(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, UTF_32BE);\n        testHttpInvalid(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, null);\n\n        testHttpLenient(\"text/xml\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testHttpLenient(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, UTF_8, UTF_8);\n        testHttpLenient(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, null, UTF_8);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, null, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16, UTF_16);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, null, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32, UTF_32);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE, UTF_32BE);\n        testHttpLenient(\"text/xml\", \"UTF-8-bom\", US_ASCII, null, US_ASCII);\n\n        testHttpLenient(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, null, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16, UTF_16);\n        testHttpLenient(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, UTF_16BE, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, null, UTF_16);\n\n        testHttpLenient(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, null, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32, UTF_32);\n        testHttpLenient(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, UTF_32BE, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, null, UTF_32);\n\n        testHttpLenient(\"text/html\", \"no-bom\", US_ASCII, US_ASCII, US_ASCII);\n        testHttpLenient(\"text/html\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testHttpLenient(\"text/html;charset=UTF-8\", \"no-bom\", US_ASCII, UTF_8, UTF_8);\n        testHttpLenient(\"text/html;charset=UTF-16BE\", \"no-bom\", US_ASCII, UTF_8, UTF_8);\n        testHttpLenient(\"text/html;charset=UTF-32BE\", \"no-bom\", US_ASCII, UTF_8, UTF_8);\n    }\n\n    @Test\n    public void testHttpContent() throws Exception {\n        final String encoding = UTF_8;\n        final String xml = getXML(\"no-bom\", XML3, encoding, encoding);\n        try (XmlStreamReader xmlReader = new XmlStreamReader(new StringInputStream(xml, encoding))) {\n            assertEquals(xmlReader.getEncoding(), encoding, \"Check encoding\");\n            assertEquals(xml, IOUtils.toString(xmlReader), \"Check content\");\n        }\n    }\n\n    protected void testHttpInvalid(final String cT, final String bomEnc, final String streamEnc,\n        final String prologEnc) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML2 : XML3, streamEnc, prologEnc)) {\n            try {\n                new XmlStreamReader(is, cT, false).close();\n                fail(\"It should have failed for HTTP Content-type \" + cT + \", BOM \" + bomEnc + \", streamEnc \" + streamEnc + \" and prologEnc \" + prologEnc);\n            } catch (final IOException ex) {\n                assertTrue(ex.getMessage().contains(\"Invalid encoding,\"));\n            }\n        }\n    }\n\n    protected void testHttpLenient(final String cT, final String bomEnc, final String streamEnc,\n        final String prologEnc, final String shouldBe) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML2 : XML3, streamEnc, prologEnc);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, cT, true)) {\n            assertEquals(xmlReader.getEncoding(), shouldBe);\n        }\n    }\n\n    public void testHttpValid(final String cT, final String bomEnc, final String streamEnc,\n        final String prologEnc) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, cT, false)) {\n            if (!streamEnc.equals(UTF_16)) {\n                // we can not assert things here because UTF-8, US-ASCII and\n                // ISO-8859-1 look alike for the chars used for detection\n                // (niallp 2010-10-06 - I re-instated the check below and removed the 2 tests that failed)\n                assertEquals(xmlReader.getEncoding(), streamEnc);\n            } else {\n                assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n            }\n        }\n    }\n\n    // Turkish language has specific rules to convert dotted and dotless i character.\n    @Test\n    @DefaultLocale(language = \"tr\")\n    public void testLowerCaseEncodingWithTurkishLocale_IO_557() throws Exception {\n        final String[] encodings = {\"iso8859-1\", \"us-ascii\", \"utf-8\"};\n        for (final String encoding : encodings) {\n            final String xml = getXML(\"no-bom\", XML3, encoding, encoding);\n            try (ByteArrayInputStream is = new ByteArrayInputStream(xml.getBytes(encoding)); XmlStreamReader xmlReader = new XmlStreamReader(is)) {\n                assertTrue(encoding.equalsIgnoreCase(xmlReader.getEncoding()), \"Check encoding : \" + encoding);\n                assertEquals(xml, IOUtils.toString(xmlReader), \"Check content\");\n            }\n        }\n    }\n\n    protected void testRawBomInvalid(final String bomEnc, final String streamEnc,\n        final String prologEnc) throws Exception {\n        final InputStream is = getXmlInputStream(bomEnc, XML3, streamEnc, prologEnc);\n        XmlStreamReader xmlReader = null;\n        try {\n            xmlReader = new XmlStreamReader(is, false);\n            final String foundEnc = xmlReader.getEncoding();\n            fail(\"Expected IOException for BOM \" + bomEnc + \", streamEnc \" + streamEnc + \" and prologEnc \" + prologEnc\n                + \": found \" + foundEnc);\n        } catch (final IOException ex) {\n            assertTrue(ex.getMessage().contains(\"Invalid encoding,\"));\n        }\n        if (xmlReader != null) {\n            xmlReader.close();\n        }\n    }\n\n    @Test\n    public void testRawBomUtf16() throws Exception {\n        testRawBomValid(UTF_16BE);\n        testRawBomValid(UTF_16LE);\n        testRawBomValid(UTF_16);\n\n        testRawBomInvalid(\"UTF-16BE-bom\", UTF_16BE, UTF_16LE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_16BE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_8);\n    }\n\n    @Test\n    public void testRawBomUtf32() throws Exception {\n        testRawBomValid(UTF_32BE);\n        testRawBomValid(UTF_32LE);\n        testRawBomValid(UTF_32);\n\n        testRawBomInvalid(\"UTF-32BE-bom\", UTF_32BE, UTF_32LE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_32BE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_8);\n    }\n\n    @Test\n    public void testRawBomUtf8() throws Exception {\n        testRawBomValid(UTF_8);\n        testRawBomInvalid(\"UTF-8-bom\", US_ASCII, US_ASCII);\n        testRawBomInvalid(\"UTF-8-bom\", ISO_8859_1, ISO_8859_1);\n        testRawBomInvalid(\"UTF-8-bom\", UTF_8, UTF_16);\n        testRawBomInvalid(\"UTF-8-bom\", UTF_8, UTF_16BE);\n        testRawBomInvalid(\"UTF-8-bom\", UTF_8, UTF_16LE);\n        testRawBomInvalid(\"UTF-16BE-bom\", UTF_16BE, UTF_16LE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_16BE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_8);\n        testRawBomInvalid(\"UTF-32BE-bom\", UTF_32BE, UTF_32LE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_32BE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_8);\n    }\n\n    protected void testRawBomValid(final String encoding) throws Exception {\n        try (InputStream is = getXmlInputStream(encoding + \"-bom\", XML3, encoding, encoding);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, false)) {\n            if (!encoding.equals(UTF_16) && !encoding.equals(UTF_32)) {\n                assertEquals(xmlReader.getEncoding(), encoding);\n            } else {\n                assertEquals(xmlReader.getEncoding().substring(0, encoding.length()), encoding);\n            }\n        }\n    }\n\n    @Test\n    public void testRawContent() throws Exception {\n        final String encoding = UTF_8;\n        final String xml = getXML(\"no-bom\", XML3, encoding, encoding);\n        try (XmlStreamReader xmlReader = new XmlStreamReader(new StringInputStream(xml, encoding))) {\n            assertEquals(xmlReader.getEncoding(), encoding, \"Check encoding\");\n            assertEquals(xml, IOUtils.toString(xmlReader), \"Check content\");\n        }\n    }\n\n    @Test\n    public void testRawNoBomCp1047() throws Exception {\n        testRawNoBomValid(\"CP1047\");\n    }\n\n    protected void testRawNoBomInvalid(final String encoding) throws Exception {\n        try (final InputStream is = getXmlInputStream(\"no-bom\", XML3, encoding, encoding)) {\n            try {\n                new XmlStreamReader(is, false).close();\n                fail(\"It should have failed\");\n            } catch (final IOException ex) {\n                assertTrue(ex.getMessage().contains(\"Invalid encoding,\"));\n            }\n        }\n    }\n\n    @Test\n    public void testRawNoBomIso8859_1() throws Exception {\n        testRawNoBomValid(ISO_8859_1);\n    }\n\n    @Test\n    public void testRawNoBomUsAscii() throws Exception {\n        testRawNoBomValid(US_ASCII);\n    }\n\n    @Test\n    public void testRawNoBomUtf16BE() throws Exception {\n        testRawNoBomValid(UTF_16BE);\n    }\n\n    @Test\n    public void testRawNoBomUtf16LE() throws Exception {\n        testRawNoBomValid(UTF_16LE);\n    }\n\n    @Test\n    public void testRawNoBomUtf32BE() throws Exception {\n        testRawNoBomValid(UTF_32BE);\n    }\n\n    @Test\n    public void testRawNoBomUtf32LE() throws Exception {\n        testRawNoBomValid(UTF_32LE);\n    }\n\n    @Test\n    public void testRawNoBomUtf8() throws Exception {\n        testRawNoBomValid(UTF_8);\n    }\n\n    protected void testRawNoBomValid(final String encoding) throws Exception {\n        InputStream is = getXmlInputStream(\"no-bom\", XML1, encoding, encoding);\n        XmlStreamReader xmlReader = new XmlStreamReader(is, false);\n        assertEquals(xmlReader.getEncoding(), UTF_8);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML2, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), UTF_8);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML3, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), encoding);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML4, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), encoding);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML5, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), encoding);\n        xmlReader.close();\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.MessageFormat;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junitpioneer.jupiter.DefaultLocale;\n\npublic class XmlStreamReaderTest {\n\n    private static final String ISO_8859_1 = StandardCharsets.ISO_8859_1.name();\n    private static final String US_ASCII = StandardCharsets.US_ASCII.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_32 = \"UTF-32\";\n    private static final String UTF_32LE = \"UTF-32LE\";\n    private static final String UTF_32BE = \"UTF-32BE\";\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String XML5 = \"xml-prolog-encoding-spaced-single-quotes\";\n    private static final String XML4 = \"xml-prolog-encoding-single-quotes\";\n    private static final String XML3 = \"xml-prolog-encoding-double-quotes\";\n    private static final String XML2 = \"xml-prolog\";\n    private static final String XML1 = \"xml\";\n\n    private static final String ENCODING_ATTRIBUTE_XML = \"<?xml version=\\\"1.0\\\" ?> \\n\"\n            + \"<atom:feed xmlns:atom=\\\"http://www.w3.org/2005/Atom\\\">\\n\"\n            + \"\\n\"\n            + \"  <atom:entry>\\n\"\n            + \"    <atom:title encoding='base64'><![CDATA\\n\"\n            + \"aW5nTGluZSIgLz4\";\n\n    private static final int[] NO_BOM_BYTES = {};\n\n    private static final int[] UTF_16BE_BOM_BYTES = {0xFE, 0xFF};\n\n    private static final int[] UTF_16LE_BOM_BYTES = {0xFF, 0XFE};\n\n    private static final int[] UTF_32BE_BOM_BYTES = {0x00, 0x00, 0xFE, 0xFF};\n\n    private static final int[] UTF_32LE_BOM_BYTES = {0xFF, 0XFE, 0x00, 0x00};\n\n    private static final int[] UTF_8_BOM_BYTES = {0xEF, 0xBB, 0xBF};\n\n    private static final Map<String, int[]> BOMs = new HashMap<>();\n\n    static {\n        BOMs.put(\"no-bom\", NO_BOM_BYTES);\n        BOMs.put(\"UTF-16BE-bom\", UTF_16BE_BOM_BYTES);\n        BOMs.put(\"UTF-16LE-bom\", UTF_16LE_BOM_BYTES);\n        BOMs.put(\"UTF-32BE-bom\", UTF_32BE_BOM_BYTES);\n        BOMs.put(\"UTF-32LE-bom\", UTF_32LE_BOM_BYTES);\n        BOMs.put(\"UTF-16-bom\", NO_BOM_BYTES); // it's added by the writer\n        BOMs.put(\"UTF-8-bom\", UTF_8_BOM_BYTES);\n    }\n\n    private static final MessageFormat XML = new MessageFormat(\n            \"<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\"?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_DOUBLE_QUOTES = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\" encoding=\\\"{1}\\\"?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_SINGLE_QUOTES = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\" encoding=''{1}''?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_SPACED_SINGLE_QUOTES = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\" encoding =  \\t \\n \\r''{1}''?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat INFO = new MessageFormat(\n            \"\\nBOM : {0}\\nDoc : {1}\\nStream Enc : {2}\\nProlog Enc : {3}\\n\");\n\n    private static final Map<String, MessageFormat> XMLs = new HashMap<>();\n\n    static {\n        XMLs.put(XML1, XML);\n        XMLs.put(XML2, XML_WITH_PROLOG);\n        XMLs.put(XML3, XML_WITH_PROLOG_AND_ENCODING_DOUBLE_QUOTES);\n        XMLs.put(XML4, XML_WITH_PROLOG_AND_ENCODING_SINGLE_QUOTES);\n        XMLs.put(XML5, XML_WITH_PROLOG_AND_ENCODING_SPACED_SINGLE_QUOTES);\n    }\n\n    /**\n     * Create the XML.\n     */\n    private String getXML(final String bomType, final String xmlType,\n                          final String streamEnc, final String prologEnc) {\n        final MessageFormat xml = XMLs.get(xmlType);\n        final String info = INFO.format(new Object[]{bomType, xmlType, prologEnc});\n        return xml.format(new Object[]{streamEnc, prologEnc, info});\n    }\n\n    /**\n     * @param bomType   no-bom, UTF-16BE-bom, UTF-16LE-bom, UTF-8-bom\n     * @param xmlType   xml, xml-prolog, xml-prolog-charset\n     * @param streamEnc encoding of the stream\n     * @param prologEnc encoding of the prolog\n     * @return XML stream\n     * @throws IOException If an I/O error occurs\n     */\n    protected InputStream getXmlInputStream(final String bomType, final String xmlType,\n        final String streamEnc, final String prologEnc) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n        int[] bom = BOMs.get(bomType);\n        if (bom == null) {\n            bom = new int[0];\n        }\n        for (final int element : bom) {\n            baos.write(element);\n        }\n        try (Writer writer = new OutputStreamWriter(baos, streamEnc)) {\n            final String xmlDoc = getXML(bomType, xmlType, streamEnc, prologEnc);\n            writer.write(xmlDoc);\n\n            // PADDING TO TEST THINGS WORK BEYOND PUSHBACK_SIZE\n            writer.write(\"<da>\\n\");\n            for (int i = 0; i < 10000; i++) {\n                writer.write(\"<do/>\\n\");\n            }\n            writer.write(\"</da>\\n\");\n\n        }\n        return new ByteArrayInputStream(baos.toByteArray());\n    }\n\n    public void testAlternateDefaultEncoding(final String contentType, final String bomEnc, final String streamEnc, final String prologEnc,\n            final String alternateEnc) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n                XmlStreamReader xmlReader = new XmlStreamReader(is, contentType, false, alternateEnc)) {\n            testAlternateDefaultEncoding(streamEnc, alternateEnc, xmlReader);\n        }\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n        // @formatter:off\n            XmlStreamReader xmlReader = XmlStreamReader.builder()\n                    .setInputStream(is)\n                    .setHttpContentType(contentType)\n                    .setLenient(false)\n                    .setCharset(alternateEnc)\n                    .get()) {\n            // @formatter:on\n            testAlternateDefaultEncoding(streamEnc, alternateEnc, xmlReader);\n        }\n    }\n\n    private void testAlternateDefaultEncoding(final String streamEnc, final String alternateEnc, XmlStreamReader xmlReader) {\n        assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);\n        if (!streamEnc.equals(UTF_16)) {\n            // we can not assert things here because UTF-8, US-ASCII and\n            // ISO-8859-1 look alike for the chars used for detection\n            // (niallp 2010-10-06 - I re-instated the check below - the tests(6) passed)\n            final String enc = alternateEnc != null ? alternateEnc : streamEnc;\n            assertEquals(xmlReader.getEncoding(), enc);\n        } else {\n            // String enc = (alternateEnc != null) ? alternateEnc : streamEnc;\n            assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n        }\n    }\n\n    @Test\n    protected void testConstructorFileInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(new File(\"pom.xml\"))) {\n            // do nothing\n        }\n        try (XmlStreamReader reader = XmlStreamReader.builder().setFile(\"pom.xml\").get()) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorFileInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((File) null));\n    }\n\n    @Test\n    protected void testConstructorInputStreamInput() throws IOException {\n        final Path path = Paths.get(\"pom.xml\");\n        try (XmlStreamReader reader = new XmlStreamReader(Files.newInputStream(path))) {\n            // do nothing\n        }\n        try (@SuppressWarnings(\"resource\")\n        XmlStreamReader reader = XmlStreamReader.builder().setInputStream(Files.newInputStream(path)).get()) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorInputStreamInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((InputStream) null));\n    }\n\n    @Test\n    protected void testConstructorPathInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(Paths.get(\"pom.xml\"))) {\n            // do nothing\n        }\n        try (XmlStreamReader reader = XmlStreamReader.builder().setPath(\"pom.xml\").get()) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorPathInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((Path) null));\n    }\n\n    @Test\n    protected void testConstructorURLConnectionInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(new URL(\"https://www.apache.org/\").openConnection(), UTF_8)) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorURLConnectionInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((URLConnection) null, US_ASCII));\n    }\n\n    @Test\n    protected void testConstructorURLInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(new URL(\"https://www.apache.org/\"))) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorURLInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((URL) null));\n    }\n\n    @Test\n    public void testEncodingAttributeXML() throws Exception {\n        try (InputStream is = new ByteArrayInputStream(ENCODING_ATTRIBUTE_XML.getBytes(StandardCharsets.UTF_8));\n                XmlStreamReader xmlReader = new XmlStreamReader(is, \"\", true)) {\n            assertEquals(xmlReader.getEncoding(), UTF_8);\n        }\n        try (InputStream is = new ByteArrayInputStream(ENCODING_ATTRIBUTE_XML.getBytes(StandardCharsets.UTF_8));\n                // @formatter:off\n                XmlStreamReader xmlReader = XmlStreamReader.builder()\n                    .setInputStream(is)\n                    .setHttpContentType(\"\")\n                    .setLenient(true)\n                    .get()) {\n            // @formatter:on\n            assertEquals(xmlReader.getEncoding(), UTF_8);\n        }\n    }\n\n    // XML Stream generator\n\n    @Test\n    public void testHttp() throws Exception {\n        // niallp 2010-10-06 - remove following 2 tests - I reinstated\n        // checks for non-UTF-16 encodings (18 tests) and these failed\n        // _testHttpValid(\"application/xml\", \"no-bom\", \"US-ASCII\", null);\n        // _testHttpValid(\"application/xml\", \"UTF-8-bom\", \"US-ASCII\", null);\n        testHttpValid(\"application/xml\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml\", \"UTF-8-bom\", UTF_8, UTF_8);\n        testHttpValid(\"application/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml;charset=\\\"UTF-8\\\"\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml;charset='UTF-8'\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, UTF_8);\n        testHttpValid(\"application/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpValid(\"application/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpValid(\"application/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n\n        testHttpInvalid(\"application/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpInvalid(\"application/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpInvalid(\"application/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n\n        testHttpInvalid(\"application/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, null);\n        testHttpInvalid(\"application/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32);\n        testHttpInvalid(\"application/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE);\n\n        testHttpInvalid(\"application/xml\", \"UTF-8-bom\", US_ASCII, US_ASCII);\n        testHttpInvalid(\"application/xml;charset=UTF-16\", UTF_16LE, UTF_8, UTF_8);\n        testHttpInvalid(\"application/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, UTF_16BE);\n        testHttpInvalid(\"application/xml;charset=UTF-32\", UTF_32LE, UTF_8, UTF_8);\n        testHttpInvalid(\"application/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, UTF_32BE);\n\n        testHttpValid(\"text/xml\", \"no-bom\", US_ASCII, null);\n        testHttpValid(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, UTF_8);\n        testHttpValid(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpValid(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpValid(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n        testHttpValid(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, null);\n        testHttpValid(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32);\n        testHttpValid(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE);\n        testHttpValid(\"text/xml\", \"UTF-8-bom\", US_ASCII, null);\n\n        testAlternateDefaultEncoding(\"application/xml\", \"UTF-8-bom\", UTF_8, null, null);\n        testAlternateDefaultEncoding(\"application/xml\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testAlternateDefaultEncoding(\"application/xml\", \"UTF-8-bom\", UTF_8, null, UTF_8);\n        testAlternateDefaultEncoding(\"text/xml\", \"no-bom\", US_ASCII, null, null);\n        testAlternateDefaultEncoding(\"text/xml\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testAlternateDefaultEncoding(\"text/xml\", \"no-bom\", US_ASCII, null, UTF_8);\n\n        testHttpInvalid(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpInvalid(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpInvalid(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n        testHttpInvalid(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, UTF_16BE);\n        testHttpInvalid(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, null);\n\n        testHttpInvalid(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, null);\n        testHttpInvalid(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32);\n        testHttpInvalid(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE);\n        testHttpInvalid(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, UTF_32BE);\n        testHttpInvalid(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, null);\n\n        testHttpLenient(\"text/xml\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testHttpLenient(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, UTF_8, UTF_8);\n        testHttpLenient(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, null, UTF_8);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, null, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16, UTF_16);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, null, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32, UTF_32);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE, UTF_32BE);\n        testHttpLenient(\"text/xml\", \"UTF-8-bom\", US_ASCII, null, US_ASCII);\n\n        testHttpLenient(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, null, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16, UTF_16);\n        testHttpLenient(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, UTF_16BE, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, null, UTF_16);\n\n        testHttpLenient(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, null, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32, UTF_32);\n        testHttpLenient(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, UTF_32BE, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, null, UTF_32);\n\n        testHttpLenient(\"text/html\", \"no-bom\", US_ASCII, US_ASCII, US_ASCII);\n        testHttpLenient(\"text/html\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testHttpLenient(\"text/html;charset=UTF-8\", \"no-bom\", US_ASCII, UTF_8, UTF_8);\n        testHttpLenient(\"text/html;charset=UTF-16BE\", \"no-bom\", US_ASCII, UTF_8, UTF_8);\n        testHttpLenient(\"text/html;charset=UTF-32BE\", \"no-bom\", US_ASCII, UTF_8, UTF_8);\n    }\n\n    @Test\n    public void testHttpContent() throws Exception {\n        final String encoding = UTF_8;\n        final String xml = getXML(\"no-bom\", XML3, encoding, encoding);\n        try (XmlStreamReader xmlReader = new XmlStreamReader(new StringInputStream(xml, encoding))) {\n            assertEquals(xmlReader.getEncoding(), encoding, \"Check encoding\");\n            assertEquals(xml, IOUtils.toString(xmlReader), \"Check content\");\n        }\n    }\n\n    protected void testHttpInvalid(final String cT, final String bomEnc, final String streamEnc,\n        final String prologEnc) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML2 : XML3, streamEnc, prologEnc)) {\n            try {\n                new XmlStreamReader(is, cT, false).close();\n                fail(\"It should have failed for HTTP Content-type \" + cT + \", BOM \" + bomEnc + \", streamEnc \" + streamEnc + \" and prologEnc \" + prologEnc);\n            } catch (final IOException ex) {\n                assertTrue(ex.getMessage().contains(\"Invalid encoding,\"));\n            }\n        }\n    }\n\n    protected void testHttpLenient(final String cT, final String bomEnc, final String streamEnc,\n        final String prologEnc, final String shouldBe) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML2 : XML3, streamEnc, prologEnc);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, cT, true)) {\n            assertEquals(xmlReader.getEncoding(), shouldBe);\n        }\n    }\n\n    public void testHttpValid(final String cT, final String bomEnc, final String streamEnc,\n        final String prologEnc) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, cT, false)) {\n            if (!streamEnc.equals(UTF_16)) {\n                // we can not assert things here because UTF-8, US-ASCII and\n                // ISO-8859-1 look alike for the chars used for detection\n                // (niallp 2010-10-06 - I re-instated the check below and removed the 2 tests that failed)\n                assertEquals(xmlReader.getEncoding(), streamEnc);\n            } else {\n                assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n            }\n        }\n    }\n\n    // Turkish language has specific rules to convert dotted and dotless i character.\n    @Test\n    @DefaultLocale(language = \"tr\")\n    public void testLowerCaseEncodingWithTurkishLocale_IO_557() throws Exception {\n        final String[] encodings = {\"iso8859-1\", \"us-ascii\", \"utf-8\"};\n        for (final String encoding : encodings) {\n            final String xml = getXML(\"no-bom\", XML3, encoding, encoding);\n            try (ByteArrayInputStream is = new ByteArrayInputStream(xml.getBytes(encoding)); XmlStreamReader xmlReader = new XmlStreamReader(is)) {\n                assertTrue(encoding.equalsIgnoreCase(xmlReader.getEncoding()), \"Check encoding : \" + encoding);\n                assertEquals(xml, IOUtils.toString(xmlReader), \"Check content\");\n            }\n        }\n    }\n\n    @SuppressWarnings(\"resource\")\n    protected void testRawBomInvalid(final String bomEnc, final String streamEnc,\n        final String prologEnc) throws Exception {\n        final InputStream is = getXmlInputStream(bomEnc, XML3, streamEnc, prologEnc);\n        XmlStreamReader xmlReader = null;\n        try {\n            xmlReader = XmlStreamReader.builder().setInputStream(is).setLenient(false).get();\n            final String foundEnc = xmlReader.getEncoding();\n            fail(\"Expected IOException for BOM \" + bomEnc + \", streamEnc \" + streamEnc + \" and prologEnc \" + prologEnc\n                + \": found \" + foundEnc);\n        } catch (final IOException ex) {\n            assertTrue(ex.getMessage().contains(\"Invalid encoding,\"));\n        }\n        if (xmlReader != null) {\n            xmlReader.close();\n        }\n    }\n\n    @Test\n    public void testRawBomUtf16() throws Exception {\n        testRawBomValid(UTF_16BE);\n        testRawBomValid(UTF_16LE);\n        testRawBomValid(UTF_16);\n\n        testRawBomInvalid(\"UTF-16BE-bom\", UTF_16BE, UTF_16LE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_16BE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_8);\n    }\n\n    @Test\n    public void testRawBomUtf32() throws Exception {\n        testRawBomValid(UTF_32BE);\n        testRawBomValid(UTF_32LE);\n        testRawBomValid(UTF_32);\n\n        testRawBomInvalid(\"UTF-32BE-bom\", UTF_32BE, UTF_32LE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_32BE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_8);\n    }\n\n    @Test\n    public void testRawBomUtf8() throws Exception {\n        testRawBomValid(UTF_8);\n        testRawBomInvalid(\"UTF-8-bom\", US_ASCII, US_ASCII);\n        testRawBomInvalid(\"UTF-8-bom\", ISO_8859_1, ISO_8859_1);\n        testRawBomInvalid(\"UTF-8-bom\", UTF_8, UTF_16);\n        testRawBomInvalid(\"UTF-8-bom\", UTF_8, UTF_16BE);\n        testRawBomInvalid(\"UTF-8-bom\", UTF_8, UTF_16LE);\n        testRawBomInvalid(\"UTF-16BE-bom\", UTF_16BE, UTF_16LE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_16BE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_8);\n        testRawBomInvalid(\"UTF-32BE-bom\", UTF_32BE, UTF_32LE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_32BE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_8);\n    }\n\n    protected void testRawBomValid(final String encoding) throws Exception {\n        try (InputStream is = getXmlInputStream(encoding + \"-bom\", XML3, encoding, encoding);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, false)) {\n            if (!encoding.equals(UTF_16) && !encoding.equals(UTF_32)) {\n                assertEquals(xmlReader.getEncoding(), encoding);\n            } else {\n                assertEquals(xmlReader.getEncoding().substring(0, encoding.length()), encoding);\n            }\n        }\n    }\n\n    @Test\n    public void testRawContent() throws Exception {\n        final String encoding = UTF_8;\n        final String xml = getXML(\"no-bom\", XML3, encoding, encoding);\n        try (XmlStreamReader xmlReader = new XmlStreamReader(new StringInputStream(xml, encoding))) {\n            assertEquals(xmlReader.getEncoding(), encoding, \"Check encoding\");\n            assertEquals(xml, IOUtils.toString(xmlReader), \"Check content\");\n        }\n    }\n\n    @Test\n    public void testRawNoBomCp1047() throws Exception {\n        testRawNoBomValid(\"CP1047\");\n    }\n\n    protected void testRawNoBomInvalid(final String encoding) throws Exception {\n        try (final InputStream is = getXmlInputStream(\"no-bom\", XML3, encoding, encoding)) {\n            try {\n                new XmlStreamReader(is, false).close();\n                fail(\"It should have failed\");\n            } catch (final IOException ex) {\n                assertTrue(ex.getMessage().contains(\"Invalid encoding,\"));\n            }\n        }\n    }\n\n    @Test\n    public void testRawNoBomIso8859_1() throws Exception {\n        testRawNoBomValid(ISO_8859_1);\n    }\n\n    @Test\n    public void testRawNoBomUsAscii() throws Exception {\n        testRawNoBomValid(US_ASCII);\n    }\n\n    @Test\n    public void testRawNoBomUtf16BE() throws Exception {\n        testRawNoBomValid(UTF_16BE);\n    }\n\n    @Test\n    public void testRawNoBomUtf16LE() throws Exception {\n        testRawNoBomValid(UTF_16LE);\n    }\n\n    @Test\n    public void testRawNoBomUtf32BE() throws Exception {\n        testRawNoBomValid(UTF_32BE);\n    }\n\n    @Test\n    public void testRawNoBomUtf32LE() throws Exception {\n        testRawNoBomValid(UTF_32LE);\n    }\n\n    @Test\n    public void testRawNoBomUtf8() throws Exception {\n        testRawNoBomValid(UTF_8);\n    }\n\n    protected void testRawNoBomValid(final String encoding) throws Exception {\n        InputStream is = getXmlInputStream(\"no-bom\", XML1, encoding, encoding);\n        XmlStreamReader xmlReader = new XmlStreamReader(is, false);\n        assertEquals(xmlReader.getEncoding(), UTF_8);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML2, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), UTF_8);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML3, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), encoding);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML4, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), encoding);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML5, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), encoding);\n        xmlReader.close();\n    }\n}\n", "diffSourceCodeSet": ["private void testAlternateDefaultEncoding(final String streamEnc, final String alternateEnc, XmlStreamReader xmlReader) {\n        assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);\n        if (!streamEnc.equals(UTF_16)) {\n            // we can not assert things here because UTF-8, US-ASCII and\n            // ISO-8859-1 look alike for the chars used for detection\n            // (niallp 2010-10-06 - I re-instated the check below - the tests(6) passed)\n            final String enc = alternateEnc != null ? alternateEnc : streamEnc;\n            assertEquals(xmlReader.getEncoding(), enc);\n        } else {\n            // String enc = (alternateEnc != null) ? alternateEnc : streamEnc;\n            assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n        }\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.FileUtilsTest.ShorterFile#length\n methodBody: public long length() {\nreturn super.length() - 1;\n}", "methodSignature: org.apache.commons.io.input.XmlStreamReader#getDefaultEncoding\n methodBody: public String getDefaultEncoding() {\nreturn defaultEncoding;\n}", "methodSignature: org.apache.commons.io.input.XmlStreamReader#getEncoding\n methodBody: public String getEncoding() {\nreturn encoding;\n}", "methodSignature: org.apache.commons.io.input.XmlStreamReaderTest#getXmlInputStream\n methodBody: protected InputStream getXmlInputStream(final String bomType, final String xmlType,\n        final String streamEnc, final String prologEnc) throws IOException {\nfinal ByteArrayOutputStream baos=new ByteArrayOutputStream(1024);\nint[] bom=BOMs.get(bomType);\nif(bom == null){bom=new int[0];\n}for(final int element: bom){baos.write(element);\n}try(Writer writer=new OutputStreamWriter(baos,streamEnc))final String xmlDoc=getXML(bomType,xmlType,streamEnc,prologEnc);\nwriter.write(xmlDoc);\nwriter.write(\"<da>\\n\");\nfor(int i=0; i < 10000; i++){writer.write(\"<do/>\\n\");\n}writer.write(\"</da>\\n\");\nreturn new ByteArrayInputStream(baos.toByteArray());\n}", "methodSignature: org.apache.commons.io.output.XmlStreamWriter#getDefaultEncoding\n methodBody: public String getDefaultEncoding() {\nreturn defaultCharset.name();\n}", "methodSignature: org.apache.commons.io.output.XmlStreamWriter#getEncoding\n methodBody: public String getEncoding() {\nreturn charset.name();\n}"], "sourceCodeAfterRefactoring": "public void testAlternateDefaultEncoding(final String contentType, final String bomEnc, final String streamEnc, final String prologEnc,\n            final String alternateEnc) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n                XmlStreamReader xmlReader = new XmlStreamReader(is, contentType, false, alternateEnc)) {\n            testAlternateDefaultEncoding(streamEnc, alternateEnc, xmlReader);\n        }\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n        // @formatter:off\n            XmlStreamReader xmlReader = XmlStreamReader.builder()\n                    .setInputStream(is)\n                    .setHttpContentType(contentType)\n                    .setLenient(false)\n                    .setCharset(alternateEnc)\n                    .get()) {\n            // @formatter:on\n            testAlternateDefaultEncoding(streamEnc, alternateEnc, xmlReader);\n        }\n    }\nprivate void testAlternateDefaultEncoding(final String streamEnc, final String alternateEnc, XmlStreamReader xmlReader) {\n        assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);\n        if (!streamEnc.equals(UTF_16)) {\n            // we can not assert things here because UTF-8, US-ASCII and\n            // ISO-8859-1 look alike for the chars used for detection\n            // (niallp 2010-10-06 - I re-instated the check below - the tests(6) passed)\n            final String enc = alternateEnc != null ? alternateEnc : streamEnc;\n            assertEquals(xmlReader.getEncoding(), enc);\n        } else {\n            // String enc = (alternateEnc != null) ? alternateEnc : streamEnc;\n            assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n        }\n    }", "diffSourceCode": "-  164:     public void testAlternateDefaultEncoding(final String cT, final String bomEnc, final String streamEnc, final String prologEnc, final String alternateEnc)\n-  165:         throws Exception {\n+  164:     public void testAlternateDefaultEncoding(final String contentType, final String bomEnc, final String streamEnc, final String prologEnc,\n+  165:             final String alternateEnc) throws Exception {\n   166:         try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n-  167:             XmlStreamReader xmlReader = new XmlStreamReader(is, cT, false, alternateEnc)) {\n-  168:             assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);\n-  169:             if (!streamEnc.equals(UTF_16)) {\n-  170:                 // we can not assert things here because UTF-8, US-ASCII and\n-  171:                 // ISO-8859-1 look alike for the chars used for detection\n-  172:                 // (niallp 2010-10-06 - I re-instated the check below - the tests(6) passed)\n-  173:                 final String enc = alternateEnc != null ? alternateEnc : streamEnc;\n-  174:                 assertEquals(xmlReader.getEncoding(), enc);\n-  175:             } else {\n-  176:                 // String enc = (alternateEnc != null) ? alternateEnc : streamEnc;\n-  177:                 assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n-  178:             }\n-  179:         }\n-  180:     }\n-  181: \n-  183:     protected void testConstructorFileInput() throws IOException {\n-  184:         try (XmlStreamReader reader = new XmlStreamReader(new File(\"pom.xml\"))) {\n-  185:             // do nothing\n-  186:         }\n-  187:     }\n-  188: \n-  189:     @Test\n-  190:     protected void testConstructorFileInputNull() {\n-  191:         assertThrows(NullPointerException.class, () -> new XmlStreamReader((File) null));\n-  192:     }\n-  193: \n-  194:     @Test\n-  195:     protected void testConstructorInputStreamInput() throws IOException {\n+  167:                 XmlStreamReader xmlReader = new XmlStreamReader(is, contentType, false, alternateEnc)) {\n+  168:             testAlternateDefaultEncoding(streamEnc, alternateEnc, xmlReader);\n+  169:         }\n+  170:         try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n+  171:         // @formatter:off\n+  172:             XmlStreamReader xmlReader = XmlStreamReader.builder()\n+  173:                     .setInputStream(is)\n+  174:                     .setHttpContentType(contentType)\n+  175:                     .setLenient(false)\n+  176:                     .setCharset(alternateEnc)\n+  177:                     .get()) {\n+  178:             // @formatter:on\n+  179:             testAlternateDefaultEncoding(streamEnc, alternateEnc, xmlReader);\n+  180:         }\n+  181:     }\n+  183:     private void testAlternateDefaultEncoding(final String streamEnc, final String alternateEnc, XmlStreamReader xmlReader) {\n+  184:         assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);\n+  185:         if (!streamEnc.equals(UTF_16)) {\n+  186:             // we can not assert things here because UTF-8, US-ASCII and\n+  187:             // ISO-8859-1 look alike for the chars used for detection\n+  188:             // (niallp 2010-10-06 - I re-instated the check below - the tests(6) passed)\n+  189:             final String enc = alternateEnc != null ? alternateEnc : streamEnc;\n+  190:             assertEquals(xmlReader.getEncoding(), enc);\n+  191:         } else {\n+  192:             // String enc = (alternateEnc != null) ? alternateEnc : streamEnc;\n+  193:             assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n+  194:         }\n+  195:     }\n", "uniqueId": "7ecca22f175c644da3096940a4ce899be5b33740_164_180_183_195_164_181", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testAlternateDefaultEncoding` method, we can extract the logic that checks the encoding into a separate method. This will help to clarify the purpose of the code and reduce the complexity of the original method.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\npublic void testAlternateDefaultEncoding(final String cT, final String bomEnc, final String streamEnc, final String prologEnc, final String alternateEnc)\n        throws Exception {\n    try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n         XmlStreamReader xmlReader = new XmlStreamReader(is, cT, false, alternateEnc)) {\n        assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);\n        assertEncoding(xmlReader, streamEnc, alternateEnc);\n    }\n}\n\nprivate void assertEncoding(XmlStreamReader xmlReader, String streamEnc, String alternateEnc) {\n    if (!streamEnc.equals(UTF_16)) {\n        final String enc = alternateEnc != null ? alternateEnc : streamEnc;\n        assertEquals(xmlReader.getEncoding(), enc);\n    } else {\n        assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n    }\n}\n##########################\n```\n\n### Changes Made:\n1. **Extracted Method**: The logic that checks the encoding has been moved to a new method called `assertEncoding`. This method takes the `XmlStreamReader`, `streamEnc`, and `alternateEnc` as parameters and performs the necessary assertions.\n2. **Simplified Main Method**: The `testAlternateDefaultEncoding` method now focuses on setting up the test and calling the new method, making it easier to read and understand. \n\nThis refactoring enhances the modularity of the code, making it easier to maintain and test individual components.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\npublic void testAlternateDefaultEncoding(final String cT, final String bomEnc, final String streamEnc, final String prologEnc, final String alternateEnc)\n        throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, cT, false, alternateEnc)) {\n            assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);\n            if (!streamEnc.equals(UTF_16)) {\n                // we can not assert things here because UTF-8, US-ASCII and\n                // ISO-8859-1 look alike for the chars used for detection\n                // (niallp 2010-10-06 - I re-instated the check below - the tests(6) passed)\n                final String enc = alternateEnc != null ? alternateEnc : streamEnc;\n                assertEquals(xmlReader.getEncoding(), enc);\n            } else {\n                // String enc = (alternateEnc != null) ? alternateEnc : streamEnc;\n                assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n            }\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.text.MessageFormat;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junitpioneer.jupiter.DefaultLocale;\n\npublic class XmlStreamReaderTest {\n\n    private static final String ISO_8859_1 = StandardCharsets.ISO_8859_1.name();\n    private static final String US_ASCII = StandardCharsets.US_ASCII.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_32 = \"UTF-32\";\n    private static final String UTF_32LE = \"UTF-32LE\";\n    private static final String UTF_32BE = \"UTF-32BE\";\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String XML5 = \"xml-prolog-encoding-spaced-single-quotes\";\n    private static final String XML4 = \"xml-prolog-encoding-single-quotes\";\n    private static final String XML3 = \"xml-prolog-encoding-double-quotes\";\n    private static final String XML2 = \"xml-prolog\";\n    private static final String XML1 = \"xml\";\n\n    private static final String ENCODING_ATTRIBUTE_XML = \"<?xml version=\\\"1.0\\\" ?> \\n\"\n            + \"<atom:feed xmlns:atom=\\\"http://www.w3.org/2005/Atom\\\">\\n\"\n            + \"\\n\"\n            + \"  <atom:entry>\\n\"\n            + \"    <atom:title encoding='base64'><![CDATA\\n\"\n            + \"aW5nTGluZSIgLz4\";\n\n    private static final int[] NO_BOM_BYTES = {};\n\n    private static final int[] UTF_16BE_BOM_BYTES = {0xFE, 0xFF};\n\n    private static final int[] UTF_16LE_BOM_BYTES = {0xFF, 0XFE};\n\n    private static final int[] UTF_32BE_BOM_BYTES = {0x00, 0x00, 0xFE, 0xFF};\n\n    private static final int[] UTF_32LE_BOM_BYTES = {0xFF, 0XFE, 0x00, 0x00};\n\n    private static final int[] UTF_8_BOM_BYTES = {0xEF, 0xBB, 0xBF};\n\n    private static final Map<String, int[]> BOMs = new HashMap<>();\n\n    static {\n        BOMs.put(\"no-bom\", NO_BOM_BYTES);\n        BOMs.put(\"UTF-16BE-bom\", UTF_16BE_BOM_BYTES);\n        BOMs.put(\"UTF-16LE-bom\", UTF_16LE_BOM_BYTES);\n        BOMs.put(\"UTF-32BE-bom\", UTF_32BE_BOM_BYTES);\n        BOMs.put(\"UTF-32LE-bom\", UTF_32LE_BOM_BYTES);\n        BOMs.put(\"UTF-16-bom\", NO_BOM_BYTES); // it's added by the writer\n        BOMs.put(\"UTF-8-bom\", UTF_8_BOM_BYTES);\n    }\n\n    private static final MessageFormat XML = new MessageFormat(\n            \"<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\"?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_DOUBLE_QUOTES = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\" encoding=\\\"{1}\\\"?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_SINGLE_QUOTES = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\" encoding=''{1}''?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat XML_WITH_PROLOG_AND_ENCODING_SPACED_SINGLE_QUOTES = new MessageFormat(\n            \"<?xml version=\\\"1.0\\\" encoding =  \\t \\n \\r''{1}''?>\\n<root>{2}</root>\");\n\n    private static final MessageFormat INFO = new MessageFormat(\n            \"\\nBOM : {0}\\nDoc : {1}\\nStream Enc : {2}\\nProlog Enc : {3}\\n\");\n\n    private static final Map<String, MessageFormat> XMLs = new HashMap<>();\n\n    static {\n        XMLs.put(XML1, XML);\n        XMLs.put(XML2, XML_WITH_PROLOG);\n        XMLs.put(XML3, XML_WITH_PROLOG_AND_ENCODING_DOUBLE_QUOTES);\n        XMLs.put(XML4, XML_WITH_PROLOG_AND_ENCODING_SINGLE_QUOTES);\n        XMLs.put(XML5, XML_WITH_PROLOG_AND_ENCODING_SPACED_SINGLE_QUOTES);\n    }\n\n    /**\n     * Create the XML.\n     */\n    private String getXML(final String bomType, final String xmlType,\n                          final String streamEnc, final String prologEnc) {\n        final MessageFormat xml = XMLs.get(xmlType);\n        final String info = INFO.format(new Object[]{bomType, xmlType, prologEnc});\n        return xml.format(new Object[]{streamEnc, prologEnc, info});\n    }\n\n    /**\n     * @param bomType   no-bom, UTF-16BE-bom, UTF-16LE-bom, UTF-8-bom\n     * @param xmlType   xml, xml-prolog, xml-prolog-charset\n     * @param streamEnc encoding of the stream\n     * @param prologEnc encoding of the prolog\n     * @return XML stream\n     * @throws IOException If an I/O error occurs\n     */\n    protected InputStream getXmlInputStream(final String bomType, final String xmlType,\n        final String streamEnc, final String prologEnc) throws IOException {\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);\n        int[] bom = BOMs.get(bomType);\n        if (bom == null) {\n            bom = new int[0];\n        }\n        for (final int element : bom) {\n            baos.write(element);\n        }\n        try (Writer writer = new OutputStreamWriter(baos, streamEnc)) {\n            final String xmlDoc = getXML(bomType, xmlType, streamEnc, prologEnc);\n            writer.write(xmlDoc);\n\n            // PADDING TO TEST THINGS WORK BEYOND PUSHBACK_SIZE\n            writer.write(\"<da>\\n\");\n            for (int i = 0; i < 10000; i++) {\n                writer.write(\"<do/>\\n\");\n            }\n            writer.write(\"</da>\\n\");\n\n        }\n        return new ByteArrayInputStream(baos.toByteArray());\n    }\n\n    public void testAlternateDefaultEncoding(final String cT, final String bomEnc, final String streamEnc, final String prologEnc, final String alternateEnc)\n        throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, cT, false, alternateEnc)) {\n            assertEquals(xmlReader.getDefaultEncoding(), alternateEnc);\n            if (!streamEnc.equals(UTF_16)) {\n                // we can not assert things here because UTF-8, US-ASCII and\n                // ISO-8859-1 look alike for the chars used for detection\n                // (niallp 2010-10-06 - I re-instated the check below - the tests(6) passed)\n                final String enc = alternateEnc != null ? alternateEnc : streamEnc;\n                assertEquals(xmlReader.getEncoding(), enc);\n            } else {\n                // String enc = (alternateEnc != null) ? alternateEnc : streamEnc;\n                assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n            }\n        }\n    }\n\n    @Test\n    protected void testConstructorFileInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(new File(\"pom.xml\"))) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorFileInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((File) null));\n    }\n\n    @Test\n    protected void testConstructorInputStreamInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(Files.newInputStream(Paths.get(\"pom.xml\")))) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorInputStreamInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((InputStream) null));\n    }\n\n    protected void testConstructorPathInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(Paths.get(\"pom.xml\"))) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorPathInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((Path) null));\n    }\n\n    @Test\n    protected void testConstructorURLConnectionInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(new URL(\"https://www.apache.org/\").openConnection(), UTF_8)) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorURLConnectionInputNull() {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((URLConnection) null, US_ASCII));\n    }\n\n    @Test\n    protected void testConstructorURLInput() throws IOException {\n        try (XmlStreamReader reader = new XmlStreamReader(new URL(\"https://www.apache.org/\"))) {\n            // do nothing\n        }\n    }\n\n    @Test\n    protected void testConstructorURLInputNull() throws IOException {\n        assertThrows(NullPointerException.class, () -> new XmlStreamReader((URL) null));\n    }\n\n    @Test\n    public void testEncodingAttributeXML() throws Exception {\n        try (InputStream is = new ByteArrayInputStream(ENCODING_ATTRIBUTE_XML.getBytes(StandardCharsets.UTF_8));\n            XmlStreamReader xmlReader = new XmlStreamReader(is, \"\", true)) {\n            assertEquals(xmlReader.getEncoding(), UTF_8);\n        }\n    }\n\n    // XML Stream generator\n\n    @Test\n    public void testHttp() throws Exception {\n        // niallp 2010-10-06 - remove following 2 tests - I reinstated\n        // checks for non-UTF-16 encodings (18 tests) and these failed\n        // _testHttpValid(\"application/xml\", \"no-bom\", \"US-ASCII\", null);\n        // _testHttpValid(\"application/xml\", \"UTF-8-bom\", \"US-ASCII\", null);\n        testHttpValid(\"application/xml\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml\", \"UTF-8-bom\", UTF_8, UTF_8);\n        testHttpValid(\"application/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml;charset=\\\"UTF-8\\\"\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml;charset='UTF-8'\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"application/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, UTF_8);\n        testHttpValid(\"application/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpValid(\"application/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpValid(\"application/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n\n        testHttpInvalid(\"application/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpInvalid(\"application/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpInvalid(\"application/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n\n        testHttpInvalid(\"application/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, null);\n        testHttpInvalid(\"application/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32);\n        testHttpInvalid(\"application/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE);\n\n        testHttpInvalid(\"application/xml\", \"UTF-8-bom\", US_ASCII, US_ASCII);\n        testHttpInvalid(\"application/xml;charset=UTF-16\", UTF_16LE, UTF_8, UTF_8);\n        testHttpInvalid(\"application/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, UTF_16BE);\n        testHttpInvalid(\"application/xml;charset=UTF-32\", UTF_32LE, UTF_8, UTF_8);\n        testHttpInvalid(\"application/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, UTF_32BE);\n\n        testHttpValid(\"text/xml\", \"no-bom\", US_ASCII, null);\n        testHttpValid(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, UTF_8);\n        testHttpValid(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, null);\n        testHttpValid(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpValid(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpValid(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n        testHttpValid(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, null);\n        testHttpValid(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32);\n        testHttpValid(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE);\n        testHttpValid(\"text/xml\", \"UTF-8-bom\", US_ASCII, null);\n\n        testAlternateDefaultEncoding(\"application/xml\", \"UTF-8-bom\", UTF_8, null, null);\n        testAlternateDefaultEncoding(\"application/xml\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testAlternateDefaultEncoding(\"application/xml\", \"UTF-8-bom\", UTF_8, null, UTF_8);\n        testAlternateDefaultEncoding(\"text/xml\", \"no-bom\", US_ASCII, null, null);\n        testAlternateDefaultEncoding(\"text/xml\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testAlternateDefaultEncoding(\"text/xml\", \"no-bom\", US_ASCII, null, UTF_8);\n\n        testHttpInvalid(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, null);\n        testHttpInvalid(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16);\n        testHttpInvalid(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE);\n        testHttpInvalid(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, UTF_16BE);\n        testHttpInvalid(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, null);\n\n        testHttpInvalid(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, null);\n        testHttpInvalid(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32);\n        testHttpInvalid(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE);\n        testHttpInvalid(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, UTF_32BE);\n        testHttpInvalid(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, null);\n\n        testHttpLenient(\"text/xml\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testHttpLenient(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, UTF_8, UTF_8);\n        testHttpLenient(\"text/xml;charset=UTF-8\", \"UTF-8-bom\", UTF_8, null, UTF_8);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, null, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16, UTF_16);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, null, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32, UTF_32);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE, UTF_32BE);\n        testHttpLenient(\"text/xml\", \"UTF-8-bom\", US_ASCII, null, US_ASCII);\n\n        testHttpLenient(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, null, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16, UTF_16);\n        testHttpLenient(\"text/xml;charset=UTF-16BE\", \"UTF-16BE-bom\", UTF_16BE, UTF_16BE, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, UTF_16BE, UTF_16BE);\n        testHttpLenient(\"text/xml;charset=UTF-16\", \"no-bom\", UTF_16BE, null, UTF_16);\n\n        testHttpLenient(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, null, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32, UTF_32);\n        testHttpLenient(\"text/xml;charset=UTF-32BE\", \"UTF-32BE-bom\", UTF_32BE, UTF_32BE, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, UTF_32BE, UTF_32BE);\n        testHttpLenient(\"text/xml;charset=UTF-32\", \"no-bom\", UTF_32BE, null, UTF_32);\n\n        testHttpLenient(\"text/html\", \"no-bom\", US_ASCII, US_ASCII, US_ASCII);\n        testHttpLenient(\"text/html\", \"no-bom\", US_ASCII, null, US_ASCII);\n        testHttpLenient(\"text/html;charset=UTF-8\", \"no-bom\", US_ASCII, UTF_8, UTF_8);\n        testHttpLenient(\"text/html;charset=UTF-16BE\", \"no-bom\", US_ASCII, UTF_8, UTF_8);\n        testHttpLenient(\"text/html;charset=UTF-32BE\", \"no-bom\", US_ASCII, UTF_8, UTF_8);\n    }\n\n    @Test\n    public void testHttpContent() throws Exception {\n        final String encoding = UTF_8;\n        final String xml = getXML(\"no-bom\", XML3, encoding, encoding);\n        try (XmlStreamReader xmlReader = new XmlStreamReader(new StringInputStream(xml, encoding))) {\n            assertEquals(xmlReader.getEncoding(), encoding, \"Check encoding\");\n            assertEquals(xml, IOUtils.toString(xmlReader), \"Check content\");\n        }\n    }\n\n    protected void testHttpInvalid(final String cT, final String bomEnc, final String streamEnc,\n        final String prologEnc) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML2 : XML3, streamEnc, prologEnc)) {\n            try {\n                new XmlStreamReader(is, cT, false).close();\n                fail(\"It should have failed for HTTP Content-type \" + cT + \", BOM \" + bomEnc + \", streamEnc \" + streamEnc + \" and prologEnc \" + prologEnc);\n            } catch (final IOException ex) {\n                assertTrue(ex.getMessage().contains(\"Invalid encoding,\"));\n            }\n        }\n    }\n\n    protected void testHttpLenient(final String cT, final String bomEnc, final String streamEnc,\n        final String prologEnc, final String shouldBe) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML2 : XML3, streamEnc, prologEnc);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, cT, true)) {\n            assertEquals(xmlReader.getEncoding(), shouldBe);\n        }\n    }\n\n    public void testHttpValid(final String cT, final String bomEnc, final String streamEnc,\n        final String prologEnc) throws Exception {\n        try (InputStream is = getXmlInputStream(bomEnc, prologEnc == null ? XML1 : XML3, streamEnc, prologEnc);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, cT, false)) {\n            if (!streamEnc.equals(UTF_16)) {\n                // we can not assert things here because UTF-8, US-ASCII and\n                // ISO-8859-1 look alike for the chars used for detection\n                // (niallp 2010-10-06 - I re-instated the check below and removed the 2 tests that failed)\n                assertEquals(xmlReader.getEncoding(), streamEnc);\n            } else {\n                assertEquals(xmlReader.getEncoding().substring(0, streamEnc.length()), streamEnc);\n            }\n        }\n    }\n\n    // Turkish language has specific rules to convert dotted and dotless i character.\n    @Test\n    @DefaultLocale(language = \"tr\")\n    public void testLowerCaseEncodingWithTurkishLocale_IO_557() throws Exception {\n        final String[] encodings = {\"iso8859-1\", \"us-ascii\", \"utf-8\"};\n        for (final String encoding : encodings) {\n            final String xml = getXML(\"no-bom\", XML3, encoding, encoding);\n            try (ByteArrayInputStream is = new ByteArrayInputStream(xml.getBytes(encoding)); XmlStreamReader xmlReader = new XmlStreamReader(is)) {\n                assertTrue(encoding.equalsIgnoreCase(xmlReader.getEncoding()), \"Check encoding : \" + encoding);\n                assertEquals(xml, IOUtils.toString(xmlReader), \"Check content\");\n            }\n        }\n    }\n\n    protected void testRawBomInvalid(final String bomEnc, final String streamEnc,\n        final String prologEnc) throws Exception {\n        final InputStream is = getXmlInputStream(bomEnc, XML3, streamEnc, prologEnc);\n        XmlStreamReader xmlReader = null;\n        try {\n            xmlReader = new XmlStreamReader(is, false);\n            final String foundEnc = xmlReader.getEncoding();\n            fail(\"Expected IOException for BOM \" + bomEnc + \", streamEnc \" + streamEnc + \" and prologEnc \" + prologEnc\n                + \": found \" + foundEnc);\n        } catch (final IOException ex) {\n            assertTrue(ex.getMessage().contains(\"Invalid encoding,\"));\n        }\n        if (xmlReader != null) {\n            xmlReader.close();\n        }\n    }\n\n    @Test\n    public void testRawBomUtf16() throws Exception {\n        testRawBomValid(UTF_16BE);\n        testRawBomValid(UTF_16LE);\n        testRawBomValid(UTF_16);\n\n        testRawBomInvalid(\"UTF-16BE-bom\", UTF_16BE, UTF_16LE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_16BE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_8);\n    }\n\n    @Test\n    public void testRawBomUtf32() throws Exception {\n        testRawBomValid(UTF_32BE);\n        testRawBomValid(UTF_32LE);\n        testRawBomValid(UTF_32);\n\n        testRawBomInvalid(\"UTF-32BE-bom\", UTF_32BE, UTF_32LE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_32BE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_8);\n    }\n\n    @Test\n    public void testRawBomUtf8() throws Exception {\n        testRawBomValid(UTF_8);\n        testRawBomInvalid(\"UTF-8-bom\", US_ASCII, US_ASCII);\n        testRawBomInvalid(\"UTF-8-bom\", ISO_8859_1, ISO_8859_1);\n        testRawBomInvalid(\"UTF-8-bom\", UTF_8, UTF_16);\n        testRawBomInvalid(\"UTF-8-bom\", UTF_8, UTF_16BE);\n        testRawBomInvalid(\"UTF-8-bom\", UTF_8, UTF_16LE);\n        testRawBomInvalid(\"UTF-16BE-bom\", UTF_16BE, UTF_16LE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_16BE);\n        testRawBomInvalid(\"UTF-16LE-bom\", UTF_16LE, UTF_8);\n        testRawBomInvalid(\"UTF-32BE-bom\", UTF_32BE, UTF_32LE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_32BE);\n        testRawBomInvalid(\"UTF-32LE-bom\", UTF_32LE, UTF_8);\n    }\n\n    protected void testRawBomValid(final String encoding) throws Exception {\n        try (InputStream is = getXmlInputStream(encoding + \"-bom\", XML3, encoding, encoding);\n            XmlStreamReader xmlReader = new XmlStreamReader(is, false)) {\n            if (!encoding.equals(UTF_16) && !encoding.equals(UTF_32)) {\n                assertEquals(xmlReader.getEncoding(), encoding);\n            } else {\n                assertEquals(xmlReader.getEncoding().substring(0, encoding.length()), encoding);\n            }\n        }\n    }\n\n    @Test\n    public void testRawContent() throws Exception {\n        final String encoding = UTF_8;\n        final String xml = getXML(\"no-bom\", XML3, encoding, encoding);\n        try (XmlStreamReader xmlReader = new XmlStreamReader(new StringInputStream(xml, encoding))) {\n            assertEquals(xmlReader.getEncoding(), encoding, \"Check encoding\");\n            assertEquals(xml, IOUtils.toString(xmlReader), \"Check content\");\n        }\n    }\n\n    @Test\n    public void testRawNoBomCp1047() throws Exception {\n        testRawNoBomValid(\"CP1047\");\n    }\n\n    protected void testRawNoBomInvalid(final String encoding) throws Exception {\n        try (final InputStream is = getXmlInputStream(\"no-bom\", XML3, encoding, encoding)) {\n            try {\n                new XmlStreamReader(is, false).close();\n                fail(\"It should have failed\");\n            } catch (final IOException ex) {\n                assertTrue(ex.getMessage().contains(\"Invalid encoding,\"));\n            }\n        }\n    }\n\n    @Test\n    public void testRawNoBomIso8859_1() throws Exception {\n        testRawNoBomValid(ISO_8859_1);\n    }\n\n    @Test\n    public void testRawNoBomUsAscii() throws Exception {\n        testRawNoBomValid(US_ASCII);\n    }\n\n    @Test\n    public void testRawNoBomUtf16BE() throws Exception {\n        testRawNoBomValid(UTF_16BE);\n    }\n\n    @Test\n    public void testRawNoBomUtf16LE() throws Exception {\n        testRawNoBomValid(UTF_16LE);\n    }\n\n    @Test\n    public void testRawNoBomUtf32BE() throws Exception {\n        testRawNoBomValid(UTF_32BE);\n    }\n\n    @Test\n    public void testRawNoBomUtf32LE() throws Exception {\n        testRawNoBomValid(UTF_32LE);\n    }\n\n    @Test\n    public void testRawNoBomUtf8() throws Exception {\n        testRawNoBomValid(UTF_8);\n    }\n\n    protected void testRawNoBomValid(final String encoding) throws Exception {\n        InputStream is = getXmlInputStream(\"no-bom\", XML1, encoding, encoding);\n        XmlStreamReader xmlReader = new XmlStreamReader(is, false);\n        assertEquals(xmlReader.getEncoding(), UTF_8);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML2, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), UTF_8);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML3, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), encoding);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML4, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), encoding);\n        xmlReader.close();\n\n        is = getXmlInputStream(\"no-bom\", XML5, encoding, encoding);\n        xmlReader = new XmlStreamReader(is);\n        assertEquals(xmlReader.getEncoding(), encoding);\n        xmlReader.close();\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate testDataIntegrityWithBufferedReader(filePath Path, fileSystem FileSystem, charset Charset, reversedLinesFileReader ReversedLinesFileReader) : void extracted from public testDataIntegrityWithBufferedReader(fileName String, charsetName String, blockSize Integer, useNonDefaultFileSystem boolean, isResource boolean) : void in class org.apache.commons.io.input.ReversedLinesFileReaderTestParamFile", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java", "startLine": 88, "endLine": 126, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java", "startLine": 88, "endLine": 110, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java", "startLine": 112, "endLine": 134, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@ParameterizedTest(name = \"{0}, encoding={1}, blockSize={2}, useNonDefaultFileSystem={3}, isResource={4}\")\n    @MethodSource\n    public void testDataIntegrityWithBufferedReader(final String fileName, final String charsetName, final Integer blockSize,\n        final boolean useNonDefaultFileSystem, final boolean isResource) throws IOException, URISyntaxException {\n\n        Path filePath = isResource ? TestResources.getPath(fileName) : Paths.get(fileName);\n        FileSystem fileSystem = null;\n        if (useNonDefaultFileSystem) {\n            fileSystem = Jimfs.newFileSystem(Configuration.unix());\n            filePath = Files.copy(filePath, fileSystem.getPath(\"/\" + fileName));\n        }\n\n        // We want to test null Charset in the ReversedLinesFileReaderconstructor.\n        final Charset charset = charsetName != null ? Charset.forName(charsetName) : null;\n        try (ReversedLinesFileReader reversedLinesFileReader = blockSize == null ? new ReversedLinesFileReader(filePath, charset)\n            : new ReversedLinesFileReader(filePath, blockSize, charset)) {\n\n            final Stack<String> lineStack = new Stack<>();\n            String line;\n\n            try (BufferedReader bufferedReader = Files.newBufferedReader(filePath, Charsets.toCharset(charset))) {\n                // read all lines in normal order\n                while ((line = bufferedReader.readLine()) != null) {\n                    lineStack.push(line);\n                }\n            }\n\n            // read in reverse order and compare with lines from stack\n            while ((line = reversedLinesFileReader.readLine()) != null) {\n                final String lineFromBufferedReader = lineStack.pop();\n                assertEquals(lineFromBufferedReader, line);\n            }\n            assertEquals(0, lineStack.size(), \"Stack should be empty\");\n\n            if (fileSystem != null) {\n                fileSystem.close();\n            }\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java", "isPureRefactoring": true, "commitId": "7ecca22f175c644da3096940a4ce899be5b33740", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.ReversedLinesFileReaderTestParamFile", "methodNameBefore": "org.apache.commons.io.input.ReversedLinesFileReaderTestParamFile#testDataIntegrityWithBufferedReader", "invokedMethod": "methodSignature: org.apache.commons.io.input.ReadAheadInputStream#close\n methodBody: public void close() throws IOException {\nboolean isSafeToCloseUnderlyingInputStream=false;\nstateChangeLock.lock();\ntryif(isClosed){return;\n}isClosed=true;\nif(!isReading){isSafeToCloseUnderlyingInputStream=true;\nisUnderlyingInputStreamBeingClosed=true;\n}finallystateChangeLock.unlock();\nif(shutdownExecutorService){tryexecutorService.shutdownNow();\nexecutorService.awaitTermination(Long.MAX_VALUE,TimeUnit.SECONDS);\ncatch(final InterruptedException e)final InterruptedIOException iio=new InterruptedIOException(e.getMessage());\niio.initCause(e);\nthrow iio;\nfinallyif(isSafeToCloseUnderlyingInputStream){underlyingInputStream.close();\n}}}\nmethodSignature: org.apache.commons.io.input.Tailer.Tailable#size\n methodBody: long size() throws IOException;\nmethodSignature: org.apache.commons.io.input.RandomAccessFileInputStream#close\n methodBody: public void close() throws IOException {\nsuper.close();\nif(closeOnClose){randomAccessFile.close();\n}}\nmethodSignature: org.apache.commons.io.input.ReaderInputStream#close\n methodBody: public void close() throws IOException {\nreader.close();\n}\nmethodSignature: org.apache.commons.io.output.DeferredFileOutputStream#close\n methodBody: public void close() throws IOException {\nsuper.close();\nclosed=true;\n}\nmethodSignature: org.apache.commons.io.input.ReversedLinesFileReader#readLine\n methodBody: public String readLine() throws IOException {\nString line=currentFilePart.readLine();\nwhile(line == null){currentFilePart=currentFilePart.rollOver();\nif(currentFilePart == null){break;\n}line=currentFilePart.readLine();\n}if(EMPTY_STRING.equals(line) && !trailingNewlineOfFileSkipped){trailingNewlineOfFileSkipped=true;\nline=readLine();\n}return line;\n}\nmethodSignature: org.apache.commons.io.input.Tailer.RandomAccessFileBridge#close\n methodBody: public void close() throws IOException {\nrandomAccessFile.close();\n}\nmethodSignature: org.apache.commons.io.input.Tailer.TailablePath#size\n methodBody: public long size() throws IOException {\nreturn Files.size(path);\n}\nmethodSignature: org.apache.commons.io.input.BufferedFileChannelInputStream#close\n methodBody: public synchronized void close() throws IOException {\ntryfileChannel.close();\nfinallyclean(byteBuffer);\n}\nmethodSignature: org.apache.commons.io.input.MemoryMappedFileInputStream#close\n methodBody: public void close() throws IOException {\nif(!closed){cleanBuffer();\nbuffer=null;\nchannel.close();\nclosed=true;\n}}\nmethodSignature: org.apache.commons.io.input.Tailer#close\n methodBody: public void close() {\nthis.run=false;\n}\nmethodSignature: org.apache.commons.io.output.LockableFileWriter#close\n methodBody: public void close() throws IOException {\ntryout.close();\nfinallyFileUtils.delete(lockFile);\n}\nmethodSignature: org.apache.commons.io.input.ReversedLinesFileReader.FilePart#readLine\n methodBody: private String readLine() {\nString line=null;\nint newLineMatchByteCount;\nfinal boolean isLastFilePart=no == 1;\nint i=currentLastBytePos;\nwhile(i > -1){if(!isLastFilePart && i < avoidNewlineSplitBufferSize){createLeftOver();\nbreak;\n}if((newLineMatchByteCount=getNewLineMatchByteCount(data,i)) > 0){final int lineStart=i + 1;\nfinal int lineLengthBytes=currentLastBytePos - lineStart + 1;\nif(lineLengthBytes < 0){throw new IllegalStateException(\"Unexpected negative line length=\" + lineLengthBytes);\n}final byte[] lineData=Arrays.copyOfRange(data,lineStart,lineStart + lineLengthBytes);\nline=new String(lineData,charset);\ncurrentLastBytePos=i - newLineMatchByteCount;\nbreak;\n}i-=byteDecrement;\nif(i < 0){createLeftOver();\nbreak;\n}}if(isLastFilePart && leftOver != null){line=new String(leftOver,charset);\nleftOver=null;\n}return line;\n}\nmethodSignature: org.apache.commons.io.input.SequenceReaderTest.CustomReader#close\n methodBody: public void close() throws IOException {\nclosed=true;\n}\nmethodSignature: org.apache.commons.io.input.Tailer.TailablePath#getPath\n methodBody: Path getPath() {\nreturn path;\n}\nmethodSignature: org.apache.commons.io.output.XmlStreamWriter#close\n methodBody: public void close() throws IOException {\nif(writer == null){charset=defaultCharset;\nwriter=new OutputStreamWriter(out,charset);\nwriter.write(prologWriter.toString());\n}writer.close();\n}\nmethodSignature: org.apache.commons.io.input.BOMInputStreamTest.ExpectCloseInputStream#close\n methodBody: public void close() throws IOException {\n_closeCalled=true;\n}\nmethodSignature: org.apache.commons.io.output.WriterOutputStream#close\n methodBody: public void close() throws IOException {\nprocessInput(true);\nflushOutput();\nwriter.close();\n}\nmethodSignature: org.apache.commons.io.input.TailerTest.NonStandardTailable#size\n methodBody: public long size() {\nreturn file.length();\n}\nmethodSignature: org.apache.commons.io.input.ReversedLinesFileReader#close\n methodBody: public void close() throws IOException {\nchannel.close();\n}\nmethodSignature: org.apache.commons.io.input.XmlStreamReader#close\n methodBody: public void close() throws IOException {\nreader.close();\n}", "classSignatureBefore": "public class ReversedLinesFileReaderTestParamFile ", "methodNameBeforeSet": ["org.apache.commons.io.input.ReversedLinesFileReaderTestParamFile#testDataIntegrityWithBufferedReader"], "classNameBeforeSet": ["org.apache.commons.io.input.ReversedLinesFileReaderTestParamFile"], "classSignatureBeforeSet": ["public class ReversedLinesFileReaderTestParamFile "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.net.URISyntaxException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileSystem;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Stack;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.TestResources;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport com.google.common.jimfs.Configuration;\nimport com.google.common.jimfs.Jimfs;\n\n/**\n * Test checks symmetric behavior with BufferedReader.\n */\npublic class ReversedLinesFileReaderTestParamFile {\n\n    private static final String UTF_16BE = StandardCharsets.ISO_8859_1.name();\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String ISO_8859_1 = StandardCharsets.ISO_8859_1.name();\n\n    public static Stream<Arguments> testDataIntegrityWithBufferedReader() throws IOException, URISyntaxException {\n        // Make a file using the default encoding.\n        final Path sourcePath = TestResources.getPath(\"test-file-utf8-win-linebr.bin\");\n        final Path targetPath = Files.createTempFile(\"ReversedLinesFileReaderTestParamFile\", \".bin\");\n        try (Reader input = Files.newBufferedReader(sourcePath, StandardCharsets.UTF_8);\n            Writer output = Files.newBufferedWriter(targetPath, Charset.defaultCharset())) {\n            IOUtils.copyLarge(input, output);\n        }\n        // All tests\n        // @formatter:off\n        return Stream.of(\n                Arguments.of(targetPath.toAbsolutePath().toString(), null, null, false, false),\n                Arguments.of(\"test-file-20byteslength.bin\", ISO_8859_1, null, false, true),\n                Arguments.of(\"test-file-iso8859-1-shortlines-win-linebr.bin\", ISO_8859_1, null, false, true),\n                Arguments.of(\"test-file-iso8859-1.bin\", ISO_8859_1, null, false, true),\n                Arguments.of(\"test-file-shiftjis.bin\", \"Shift_JIS\", null, false, true),\n                Arguments.of(\"test-file-utf16be.bin\", UTF_16BE, null, false, true),\n                Arguments.of(\"test-file-utf16le.bin\", UTF_16LE, null, false, true),\n                Arguments.of(\"test-file-utf8-cr-only.bin\", UTF_8, null, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, null, false, true,\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 1, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 2, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 3, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 4, false, true),\n                Arguments.of(\"test-file-utf8.bin\", UTF_8, null, false, true),\n                Arguments.of(\"test-file-utf8.bin\", UTF_8, null, true, true),\n                Arguments.of(\"test-file-windows-31j.bin\", \"windows-31j\", null, false, true),\n                Arguments.of(\"test-file-gbk.bin\", \"gbk\", null, false, true),\n                Arguments.of(\"test-file-x-windows-949.bin\", \"x-windows-949\", null, false, true),\n                Arguments.of(\"test-file-x-windows-950.bin\", \"x-windows-950\", null, false, true)));\n        // @formatter:on\n    }\n\n    @ParameterizedTest(name = \"{0}, encoding={1}, blockSize={2}, useNonDefaultFileSystem={3}, isResource={4}\")\n    @MethodSource\n    public void testDataIntegrityWithBufferedReader(final String fileName, final String charsetName, final Integer blockSize,\n        final boolean useNonDefaultFileSystem, final boolean isResource) throws IOException, URISyntaxException {\n\n        Path filePath = isResource ? TestResources.getPath(fileName) : Paths.get(fileName);\n        FileSystem fileSystem = null;\n        if (useNonDefaultFileSystem) {\n            fileSystem = Jimfs.newFileSystem(Configuration.unix());\n            filePath = Files.copy(filePath, fileSystem.getPath(\"/\" + fileName));\n        }\n\n        // We want to test null Charset in the ReversedLinesFileReaderconstructor.\n        final Charset charset = charsetName != null ? Charset.forName(charsetName) : null;\n        try (ReversedLinesFileReader reversedLinesFileReader = blockSize == null ? new ReversedLinesFileReader(filePath, charset)\n            : new ReversedLinesFileReader(filePath, blockSize, charset)) {\n\n            final Stack<String> lineStack = new Stack<>();\n            String line;\n\n            try (BufferedReader bufferedReader = Files.newBufferedReader(filePath, Charsets.toCharset(charset))) {\n                // read all lines in normal order\n                while ((line = bufferedReader.readLine()) != null) {\n                    lineStack.push(line);\n                }\n            }\n\n            // read in reverse order and compare with lines from stack\n            while ((line = reversedLinesFileReader.readLine()) != null) {\n                final String lineFromBufferedReader = lineStack.pop();\n                assertEquals(lineFromBufferedReader, line);\n            }\n            assertEquals(0, lineStack.size(), \"Stack should be empty\");\n\n            if (fileSystem != null) {\n                fileSystem.close();\n            }\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.net.URISyntaxException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileSystem;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Stack;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.TestResources;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport com.google.common.jimfs.Configuration;\nimport com.google.common.jimfs.Jimfs;\n\n/**\n * Test checks symmetric behavior with BufferedReader.\n */\npublic class ReversedLinesFileReaderTestParamFile {\n\n    private static final String UTF_16BE = StandardCharsets.ISO_8859_1.name();\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String ISO_8859_1 = StandardCharsets.ISO_8859_1.name();\n\n    public static Stream<Arguments> testDataIntegrityWithBufferedReader() throws IOException, URISyntaxException {\n        // Make a file using the default encoding.\n        final Path sourcePath = TestResources.getPath(\"test-file-utf8-win-linebr.bin\");\n        final Path targetPath = Files.createTempFile(\"ReversedLinesFileReaderTestParamFile\", \".bin\");\n        try (Reader input = Files.newBufferedReader(sourcePath, StandardCharsets.UTF_8);\n            Writer output = Files.newBufferedWriter(targetPath, Charset.defaultCharset())) {\n            IOUtils.copyLarge(input, output);\n        }\n        // All tests\n        // @formatter:off\n        return Stream.of(\n                Arguments.of(targetPath.toAbsolutePath().toString(), null, null, false, false),\n                Arguments.of(\"test-file-20byteslength.bin\", ISO_8859_1, null, false, true),\n                Arguments.of(\"test-file-iso8859-1-shortlines-win-linebr.bin\", ISO_8859_1, null, false, true),\n                Arguments.of(\"test-file-iso8859-1.bin\", ISO_8859_1, null, false, true),\n                Arguments.of(\"test-file-shiftjis.bin\", \"Shift_JIS\", null, false, true),\n                Arguments.of(\"test-file-utf16be.bin\", UTF_16BE, null, false, true),\n                Arguments.of(\"test-file-utf16le.bin\", UTF_16LE, null, false, true),\n                Arguments.of(\"test-file-utf8-cr-only.bin\", UTF_8, null, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, null, false, true,\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 1, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 2, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 3, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 4, false, true),\n                Arguments.of(\"test-file-utf8.bin\", UTF_8, null, false, true),\n                Arguments.of(\"test-file-utf8.bin\", UTF_8, null, true, true),\n                Arguments.of(\"test-file-windows-31j.bin\", \"windows-31j\", null, false, true),\n                Arguments.of(\"test-file-gbk.bin\", \"gbk\", null, false, true),\n                Arguments.of(\"test-file-x-windows-949.bin\", \"x-windows-949\", null, false, true),\n                Arguments.of(\"test-file-x-windows-950.bin\", \"x-windows-950\", null, false, true)));\n        // @formatter:on\n    }\n\n    @ParameterizedTest(name = \"{0}, encoding={1}, blockSize={2}, useNonDefaultFileSystem={3}, isResource={4}\")\n    @MethodSource\n    public void testDataIntegrityWithBufferedReader(final String fileName, final String charsetName, final Integer blockSize,\n            final boolean useNonDefaultFileSystem, final boolean isResource) throws IOException, URISyntaxException {\n\n        Path filePath = isResource ? TestResources.getPath(fileName) : Paths.get(fileName);\n        FileSystem fileSystem = null;\n        if (useNonDefaultFileSystem) {\n            fileSystem = Jimfs.newFileSystem(Configuration.unix());\n            filePath = Files.copy(filePath, fileSystem.getPath(\"/\" + fileName));\n        }\n\n        // We want to test null Charset in the ReversedLinesFileReaderconstructor.\n        final Charset charset = charsetName != null ? Charset.forName(charsetName) : null;\n        try (ReversedLinesFileReader reversedLinesFileReader = blockSize == null ? new ReversedLinesFileReader(filePath, charset)\n                : new ReversedLinesFileReader(filePath, blockSize, charset)) {\n            testDataIntegrityWithBufferedReader(filePath, fileSystem, charset, reversedLinesFileReader);\n        }\n        try (ReversedLinesFileReader reversedLinesFileReader = ReversedLinesFileReader.builder().setPath(filePath).setBufferSize(blockSize).setCharset(charset)\n                .get()) {\n            testDataIntegrityWithBufferedReader(filePath, fileSystem, charset, reversedLinesFileReader);\n        }\n    }\n\n    private void testDataIntegrityWithBufferedReader(Path filePath, FileSystem fileSystem, final Charset charset,\n            ReversedLinesFileReader reversedLinesFileReader) throws IOException {\n        final Stack<String> lineStack = new Stack<>();\n        String line;\n\n        try (BufferedReader bufferedReader = Files.newBufferedReader(filePath, Charsets.toCharset(charset))) {\n            // read all lines in normal order\n            while ((line = bufferedReader.readLine()) != null) {\n                lineStack.push(line);\n            }\n        }\n\n        // read in reverse order and compare with lines from stack\n        while ((line = reversedLinesFileReader.readLine()) != null) {\n            final String lineFromBufferedReader = lineStack.pop();\n            assertEquals(lineFromBufferedReader, line);\n        }\n        assertEquals(0, lineStack.size(), \"Stack should be empty\");\n\n        if (fileSystem != null) {\n            fileSystem.close();\n        }\n    }\n}\n", "diffSourceCodeSet": ["private void testDataIntegrityWithBufferedReader(Path filePath, FileSystem fileSystem, final Charset charset,\n            ReversedLinesFileReader reversedLinesFileReader) throws IOException {\n        final Stack<String> lineStack = new Stack<>();\n        String line;\n\n        try (BufferedReader bufferedReader = Files.newBufferedReader(filePath, Charsets.toCharset(charset))) {\n            // read all lines in normal order\n            while ((line = bufferedReader.readLine()) != null) {\n                lineStack.push(line);\n            }\n        }\n\n        // read in reverse order and compare with lines from stack\n        while ((line = reversedLinesFileReader.readLine()) != null) {\n            final String lineFromBufferedReader = lineStack.pop();\n            assertEquals(lineFromBufferedReader, line);\n        }\n        assertEquals(0, lineStack.size(), \"Stack should be empty\");\n\n        if (fileSystem != null) {\n            fileSystem.close();\n        }\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.ReadAheadInputStream#close\n methodBody: public void close() throws IOException {\nboolean isSafeToCloseUnderlyingInputStream=false;\nstateChangeLock.lock();\ntryif(isClosed){return;\n}isClosed=true;\nif(!isReading){isSafeToCloseUnderlyingInputStream=true;\nisUnderlyingInputStreamBeingClosed=true;\n}finallystateChangeLock.unlock();\nif(shutdownExecutorService){tryexecutorService.shutdownNow();\nexecutorService.awaitTermination(Long.MAX_VALUE,TimeUnit.SECONDS);\ncatch(final InterruptedException e)final InterruptedIOException iio=new InterruptedIOException(e.getMessage());\niio.initCause(e);\nthrow iio;\nfinallyif(isSafeToCloseUnderlyingInputStream){underlyingInputStream.close();\n}}}", "methodSignature: org.apache.commons.io.input.Tailer.Tailable#size\n methodBody: long size() throws IOException;", "methodSignature: org.apache.commons.io.input.RandomAccessFileInputStream#close\n methodBody: public void close() throws IOException {\nsuper.close();\nif(closeOnClose){randomAccessFile.close();\n}}", "methodSignature: org.apache.commons.io.input.ReaderInputStream#close\n methodBody: public void close() throws IOException {\nreader.close();\n}", "methodSignature: org.apache.commons.io.output.DeferredFileOutputStream#close\n methodBody: public void close() throws IOException {\nsuper.close();\nclosed=true;\n}", "methodSignature: org.apache.commons.io.input.ReversedLinesFileReader#readLine\n methodBody: public String readLine() throws IOException {\nString line=currentFilePart.readLine();\nwhile(line == null){currentFilePart=currentFilePart.rollOver();\nif(currentFilePart == null){break;\n}line=currentFilePart.readLine();\n}if(EMPTY_STRING.equals(line) && !trailingNewlineOfFileSkipped){trailingNewlineOfFileSkipped=true;\nline=readLine();\n}return line;\n}", "methodSignature: org.apache.commons.io.input.Tailer.RandomAccessFileBridge#close\n methodBody: public void close() throws IOException {\nrandomAccessFile.close();\n}", "methodSignature: org.apache.commons.io.input.Tailer.TailablePath#size\n methodBody: public long size() throws IOException {\nreturn Files.size(path);\n}", "methodSignature: org.apache.commons.io.input.BufferedFileChannelInputStream#close\n methodBody: public synchronized void close() throws IOException {\ntryfileChannel.close();\nfinallyclean(byteBuffer);\n}", "methodSignature: org.apache.commons.io.input.MemoryMappedFileInputStream#close\n methodBody: public void close() throws IOException {\nif(!closed){cleanBuffer();\nbuffer=null;\nchannel.close();\nclosed=true;\n}}", "methodSignature: org.apache.commons.io.input.Tailer#close\n methodBody: public void close() {\nthis.run=false;\n}", "methodSignature: org.apache.commons.io.output.LockableFileWriter#close\n methodBody: public void close() throws IOException {\ntryout.close();\nfinallyFileUtils.delete(lockFile);\n}", "methodSignature: org.apache.commons.io.input.ReversedLinesFileReader.FilePart#readLine\n methodBody: private String readLine() {\nString line=null;\nint newLineMatchByteCount;\nfinal boolean isLastFilePart=no == 1;\nint i=currentLastBytePos;\nwhile(i > -1){if(!isLastFilePart && i < avoidNewlineSplitBufferSize){createLeftOver();\nbreak;\n}if((newLineMatchByteCount=getNewLineMatchByteCount(data,i)) > 0){final int lineStart=i + 1;\nfinal int lineLengthBytes=currentLastBytePos - lineStart + 1;\nif(lineLengthBytes < 0){throw new IllegalStateException(\"Unexpected negative line length=\" + lineLengthBytes);\n}final byte[] lineData=Arrays.copyOfRange(data,lineStart,lineStart + lineLengthBytes);\nline=new String(lineData,charset);\ncurrentLastBytePos=i - newLineMatchByteCount;\nbreak;\n}i-=byteDecrement;\nif(i < 0){createLeftOver();\nbreak;\n}}if(isLastFilePart && leftOver != null){line=new String(leftOver,charset);\nleftOver=null;\n}return line;\n}", "methodSignature: org.apache.commons.io.input.SequenceReaderTest.CustomReader#close\n methodBody: public void close() throws IOException {\nclosed=true;\n}", "methodSignature: org.apache.commons.io.input.Tailer.TailablePath#getPath\n methodBody: Path getPath() {\nreturn path;\n}", "methodSignature: org.apache.commons.io.output.XmlStreamWriter#close\n methodBody: public void close() throws IOException {\nif(writer == null){charset=defaultCharset;\nwriter=new OutputStreamWriter(out,charset);\nwriter.write(prologWriter.toString());\n}writer.close();\n}", "methodSignature: org.apache.commons.io.input.BOMInputStreamTest.ExpectCloseInputStream#close\n methodBody: public void close() throws IOException {\n_closeCalled=true;\n}", "methodSignature: org.apache.commons.io.output.WriterOutputStream#close\n methodBody: public void close() throws IOException {\nprocessInput(true);\nflushOutput();\nwriter.close();\n}", "methodSignature: org.apache.commons.io.input.TailerTest.NonStandardTailable#size\n methodBody: public long size() {\nreturn file.length();\n}", "methodSignature: org.apache.commons.io.input.ReversedLinesFileReader#close\n methodBody: public void close() throws IOException {\nchannel.close();\n}", "methodSignature: org.apache.commons.io.input.XmlStreamReader#close\n methodBody: public void close() throws IOException {\nreader.close();\n}"], "sourceCodeAfterRefactoring": "@ParameterizedTest(name = \"{0}, encoding={1}, blockSize={2}, useNonDefaultFileSystem={3}, isResource={4}\")\n    @MethodSource\n    public void testDataIntegrityWithBufferedReader(final String fileName, final String charsetName, final Integer blockSize,\n            final boolean useNonDefaultFileSystem, final boolean isResource) throws IOException, URISyntaxException {\n\n        Path filePath = isResource ? TestResources.getPath(fileName) : Paths.get(fileName);\n        FileSystem fileSystem = null;\n        if (useNonDefaultFileSystem) {\n            fileSystem = Jimfs.newFileSystem(Configuration.unix());\n            filePath = Files.copy(filePath, fileSystem.getPath(\"/\" + fileName));\n        }\n\n        // We want to test null Charset in the ReversedLinesFileReaderconstructor.\n        final Charset charset = charsetName != null ? Charset.forName(charsetName) : null;\n        try (ReversedLinesFileReader reversedLinesFileReader = blockSize == null ? new ReversedLinesFileReader(filePath, charset)\n                : new ReversedLinesFileReader(filePath, blockSize, charset)) {\n            testDataIntegrityWithBufferedReader(filePath, fileSystem, charset, reversedLinesFileReader);\n        }\n        try (ReversedLinesFileReader reversedLinesFileReader = ReversedLinesFileReader.builder().setPath(filePath).setBufferSize(blockSize).setCharset(charset)\n                .get()) {\n            testDataIntegrityWithBufferedReader(filePath, fileSystem, charset, reversedLinesFileReader);\n        }\n    }\nprivate void testDataIntegrityWithBufferedReader(Path filePath, FileSystem fileSystem, final Charset charset,\n            ReversedLinesFileReader reversedLinesFileReader) throws IOException {\n        final Stack<String> lineStack = new Stack<>();\n        String line;\n\n        try (BufferedReader bufferedReader = Files.newBufferedReader(filePath, Charsets.toCharset(charset))) {\n            // read all lines in normal order\n            while ((line = bufferedReader.readLine()) != null) {\n                lineStack.push(line);\n            }\n        }\n\n        // read in reverse order and compare with lines from stack\n        while ((line = reversedLinesFileReader.readLine()) != null) {\n            final String lineFromBufferedReader = lineStack.pop();\n            assertEquals(lineFromBufferedReader, line);\n        }\n        assertEquals(0, lineStack.size(), \"Stack should be empty\");\n\n        if (fileSystem != null) {\n            fileSystem.close();\n        }\n    }", "diffSourceCode": "    88:     @ParameterizedTest(name = \"{0}, encoding={1}, blockSize={2}, useNonDefaultFileSystem={3}, isResource={4}\")\n    89:     @MethodSource\n    90:     public void testDataIntegrityWithBufferedReader(final String fileName, final String charsetName, final Integer blockSize,\n-   91:         final boolean useNonDefaultFileSystem, final boolean isResource) throws IOException, URISyntaxException {\n+   91:             final boolean useNonDefaultFileSystem, final boolean isResource) throws IOException, URISyntaxException {\n    92: \n    93:         Path filePath = isResource ? TestResources.getPath(fileName) : Paths.get(fileName);\n    94:         FileSystem fileSystem = null;\n    95:         if (useNonDefaultFileSystem) {\n    96:             fileSystem = Jimfs.newFileSystem(Configuration.unix());\n    97:             filePath = Files.copy(filePath, fileSystem.getPath(\"/\" + fileName));\n    98:         }\n    99: \n   100:         // We want to test null Charset in the ReversedLinesFileReaderconstructor.\n   101:         final Charset charset = charsetName != null ? Charset.forName(charsetName) : null;\n   102:         try (ReversedLinesFileReader reversedLinesFileReader = blockSize == null ? new ReversedLinesFileReader(filePath, charset)\n-  103:             : new ReversedLinesFileReader(filePath, blockSize, charset)) {\n-  104: \n-  105:             final Stack<String> lineStack = new Stack<>();\n-  106:             String line;\n-  107: \n-  108:             try (BufferedReader bufferedReader = Files.newBufferedReader(filePath, Charsets.toCharset(charset))) {\n-  109:                 // read all lines in normal order\n-  110:                 while ((line = bufferedReader.readLine()) != null) {\n-  111:                     lineStack.push(line);\n-  112:                 }\n-  113:             }\n-  114: \n-  115:             // read in reverse order and compare with lines from stack\n-  116:             while ((line = reversedLinesFileReader.readLine()) != null) {\n-  117:                 final String lineFromBufferedReader = lineStack.pop();\n-  118:                 assertEquals(lineFromBufferedReader, line);\n-  119:             }\n-  120:             assertEquals(0, lineStack.size(), \"Stack should be empty\");\n-  121: \n-  122:             if (fileSystem != null) {\n-  123:                 fileSystem.close();\n-  124:             }\n-  125:         }\n-  126:     }\n-  127: }\n+  103:                 : new ReversedLinesFileReader(filePath, blockSize, charset)) {\n+  104:             testDataIntegrityWithBufferedReader(filePath, fileSystem, charset, reversedLinesFileReader);\n+  105:         }\n+  106:         try (ReversedLinesFileReader reversedLinesFileReader = ReversedLinesFileReader.builder().setPath(filePath).setBufferSize(blockSize).setCharset(charset)\n+  107:                 .get()) {\n+  108:             testDataIntegrityWithBufferedReader(filePath, fileSystem, charset, reversedLinesFileReader);\n+  109:         }\n+  110:     }\n+  111: \n+  112:     private void testDataIntegrityWithBufferedReader(Path filePath, FileSystem fileSystem, final Charset charset,\n+  113:             ReversedLinesFileReader reversedLinesFileReader) throws IOException {\n+  114:         final Stack<String> lineStack = new Stack<>();\n+  115:         String line;\n+  116: \n+  117:         try (BufferedReader bufferedReader = Files.newBufferedReader(filePath, Charsets.toCharset(charset))) {\n+  118:             // read all lines in normal order\n+  119:             while ((line = bufferedReader.readLine()) != null) {\n+  120:                 lineStack.push(line);\n+  121:             }\n+  122:         }\n+  123: \n+  124:         // read in reverse order and compare with lines from stack\n+  125:         while ((line = reversedLinesFileReader.readLine()) != null) {\n+  126:             final String lineFromBufferedReader = lineStack.pop();\n+  127:             assertEquals(lineFromBufferedReader, line);\n+  128:         }\n+  129:         assertEquals(0, lineStack.size(), \"Stack should be empty\");\n+  130: \n+  131:         if (fileSystem != null) {\n+  132:             fileSystem.close();\n+  133:         }\n+  134:     }\n", "uniqueId": "7ecca22f175c644da3096940a4ce899be5b33740_88_126_112_134_88_110", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testDataIntegrityWithBufferedReader` method, we can extract parts of the code into separate methods. This will help in breaking down the logic into smaller, more manageable pieces. \n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n##########################\nprivate Path prepareFilePath(String fileName, boolean useNonDefaultFileSystem, boolean isResource) throws IOException {\n    Path filePath = isResource ? TestResources.getPath(fileName) : Paths.get(fileName);\n    if (useNonDefaultFileSystem) {\n        FileSystem fileSystem = Jimfs.newFileSystem(Configuration.unix());\n        filePath = Files.copy(filePath, fileSystem.getPath(\"/\" + fileName));\n    }\n    return filePath;\n}\n\nprivate Charset getCharset(String charsetName) {\n    return charsetName != null ? Charset.forName(charsetName) : null;\n}\n\nprivate Stack<String> readLinesToStack(Path filePath, Charset charset) throws IOException {\n    Stack<String> lineStack = new Stack<>();\n    try (BufferedReader bufferedReader = Files.newBufferedReader(filePath, Charsets.toCharset(charset))) {\n        String line;\n        while ((line = bufferedReader.readLine()) != null) {\n            lineStack.push(line);\n        }\n    }\n    return lineStack;\n}\n\nprivate void compareLines(ReversedLinesFileReader reversedLinesFileReader, Stack<String> lineStack) throws IOException {\n    String line;\n    while ((line = reversedLinesFileReader.readLine()) != null) {\n        final String lineFromBufferedReader = lineStack.pop();\n        assertEquals(lineFromBufferedReader, line);\n    }\n    assertEquals(0, lineStack.size(), \"Stack should be empty\");\n}\n\n@ParameterizedTest(name = \"{0}, encoding={1}, blockSize={2}, useNonDefaultFileSystem={3}, isResource={4}\")\n@MethodSource\npublic void testDataIntegrityWithBufferedReader(final String fileName, final String charsetName, final Integer blockSize,\n    final boolean useNonDefaultFileSystem, final boolean isResource) throws IOException, URISyntaxException {\n\n    Path filePath = prepareFilePath(fileName, useNonDefaultFileSystem, isResource);\n    final Charset charset = getCharset(charsetName);\n    \n    try (ReversedLinesFileReader reversedLinesFileReader = blockSize == null \n            ? new ReversedLinesFileReader(filePath, charset) \n            : new ReversedLinesFileReader(filePath, blockSize, charset)) {\n\n        Stack<String> lineStack = readLinesToStack(filePath, charset);\n        compareLines(reversedLinesFileReader, lineStack);\n    }\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **`prepareFilePath` Method**: This method handles the logic of preparing the file path based on whether a non-default file system is used or if the file is a resource.\n2. **`getCharset` Method**: This method retrieves the charset based on the provided charset name.\n3. **`readLinesToStack` Method**: This method reads lines from the file into a stack, encapsulating the logic for reading and storing lines.\n4. **`compareLines` Method**: This method compares the lines read from the `ReversedLinesFileReader` with those stored in the stack, ensuring that the assertions are handled in a separate method.\n\nBy extracting these methods, the main test method becomes cleaner and easier to understand, while also making it easier to maintain and test individual components.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@ParameterizedTest(name = \"{0}, encoding={1}, blockSize={2}, useNonDefaultFileSystem={3}, isResource={4}\")\n    @MethodSource\n    public void testDataIntegrityWithBufferedReader(final String fileName, final String charsetName, final Integer blockSize,\n        final boolean useNonDefaultFileSystem, final boolean isResource) throws IOException, URISyntaxException {\n\n        Path filePath = isResource ? TestResources.getPath(fileName) : Paths.get(fileName);\n        FileSystem fileSystem = null;\n        if (useNonDefaultFileSystem) {\n            fileSystem = Jimfs.newFileSystem(Configuration.unix());\n            filePath = Files.copy(filePath, fileSystem.getPath(\"/\" + fileName));\n        }\n\n        // We want to test null Charset in the ReversedLinesFileReaderconstructor.\n        final Charset charset = charsetName != null ? Charset.forName(charsetName) : null;\n        try (ReversedLinesFileReader reversedLinesFileReader = blockSize == null ? new ReversedLinesFileReader(filePath, charset)\n            : new ReversedLinesFileReader(filePath, blockSize, charset)) {\n\n            final Stack<String> lineStack = new Stack<>();\n            String line;\n\n            try (BufferedReader bufferedReader = Files.newBufferedReader(filePath, Charsets.toCharset(charset))) {\n                // read all lines in normal order\n                while ((line = bufferedReader.readLine()) != null) {\n                    lineStack.push(line);\n                }\n            }\n\n            // read in reverse order and compare with lines from stack\n            while ((line = reversedLinesFileReader.readLine()) != null) {\n                final String lineFromBufferedReader = lineStack.pop();\n                assertEquals(lineFromBufferedReader, line);\n            }\n            assertEquals(0, lineStack.size(), \"Stack should be empty\");\n\n            if (fileSystem != null) {\n                fileSystem.close();\n            }\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.net.URISyntaxException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileSystem;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Stack;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.TestResources;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport com.google.common.jimfs.Configuration;\nimport com.google.common.jimfs.Jimfs;\n\n/**\n * Test checks symmetric behavior with BufferedReader.\n */\npublic class ReversedLinesFileReaderTestParamFile {\n\n    private static final String UTF_16BE = StandardCharsets.ISO_8859_1.name();\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String ISO_8859_1 = StandardCharsets.ISO_8859_1.name();\n\n    public static Stream<Arguments> testDataIntegrityWithBufferedReader() throws IOException, URISyntaxException {\n        // Make a file using the default encoding.\n        final Path sourcePath = TestResources.getPath(\"test-file-utf8-win-linebr.bin\");\n        final Path targetPath = Files.createTempFile(\"ReversedLinesFileReaderTestParamFile\", \".bin\");\n        try (Reader input = Files.newBufferedReader(sourcePath, StandardCharsets.UTF_8);\n            Writer output = Files.newBufferedWriter(targetPath, Charset.defaultCharset())) {\n            IOUtils.copyLarge(input, output);\n        }\n        // All tests\n        // @formatter:off\n        return Stream.of(\n                Arguments.of(targetPath.toAbsolutePath().toString(), null, null, false, false),\n                Arguments.of(\"test-file-20byteslength.bin\", ISO_8859_1, null, false, true),\n                Arguments.of(\"test-file-iso8859-1-shortlines-win-linebr.bin\", ISO_8859_1, null, false, true),\n                Arguments.of(\"test-file-iso8859-1.bin\", ISO_8859_1, null, false, true),\n                Arguments.of(\"test-file-shiftjis.bin\", \"Shift_JIS\", null, false, true),\n                Arguments.of(\"test-file-utf16be.bin\", UTF_16BE, null, false, true),\n                Arguments.of(\"test-file-utf16le.bin\", UTF_16LE, null, false, true),\n                Arguments.of(\"test-file-utf8-cr-only.bin\", UTF_8, null, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, null, false, true,\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 1, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 2, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 3, false, true),\n                Arguments.of(\"test-file-utf8-win-linebr.bin\", UTF_8, 4, false, true),\n                Arguments.of(\"test-file-utf8.bin\", UTF_8, null, false, true),\n                Arguments.of(\"test-file-utf8.bin\", UTF_8, null, true, true),\n                Arguments.of(\"test-file-windows-31j.bin\", \"windows-31j\", null, false, true),\n                Arguments.of(\"test-file-gbk.bin\", \"gbk\", null, false, true),\n                Arguments.of(\"test-file-x-windows-949.bin\", \"x-windows-949\", null, false, true),\n                Arguments.of(\"test-file-x-windows-950.bin\", \"x-windows-950\", null, false, true)));\n        // @formatter:on\n    }\n\n    @ParameterizedTest(name = \"{0}, encoding={1}, blockSize={2}, useNonDefaultFileSystem={3}, isResource={4}\")\n    @MethodSource\n    public void testDataIntegrityWithBufferedReader(final String fileName, final String charsetName, final Integer blockSize,\n        final boolean useNonDefaultFileSystem, final boolean isResource) throws IOException, URISyntaxException {\n\n        Path filePath = isResource ? TestResources.getPath(fileName) : Paths.get(fileName);\n        FileSystem fileSystem = null;\n        if (useNonDefaultFileSystem) {\n            fileSystem = Jimfs.newFileSystem(Configuration.unix());\n            filePath = Files.copy(filePath, fileSystem.getPath(\"/\" + fileName));\n        }\n\n        // We want to test null Charset in the ReversedLinesFileReaderconstructor.\n        final Charset charset = charsetName != null ? Charset.forName(charsetName) : null;\n        try (ReversedLinesFileReader reversedLinesFileReader = blockSize == null ? new ReversedLinesFileReader(filePath, charset)\n            : new ReversedLinesFileReader(filePath, blockSize, charset)) {\n\n            final Stack<String> lineStack = new Stack<>();\n            String line;\n\n            try (BufferedReader bufferedReader = Files.newBufferedReader(filePath, Charsets.toCharset(charset))) {\n                // read all lines in normal order\n                while ((line = bufferedReader.readLine()) != null) {\n                    lineStack.push(line);\n                }\n            }\n\n            // read in reverse order and compare with lines from stack\n            while ((line = reversedLinesFileReader.readLine()) != null) {\n                final String lineFromBufferedReader = lineStack.pop();\n                assertEquals(lineFromBufferedReader, line);\n            }\n            assertEquals(0, lineStack.size(), \"Stack should be empty\");\n\n            if (fileSystem != null) {\n                fileSystem.close();\n            }\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate testWithBufferedRead(expected byte[], in ReaderInputStream) : void extracted from private testWithBufferedRead(testString String, charsetName String) : void in class org.apache.commons.io.input.ReaderInputStreamTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java", "startLine": 210, "endLine": 233, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java", "startLine": 259, "endLine": 267, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java", "startLine": 269, "endLine": 289, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            final byte[] buffer = new byte[128];\n            int offset = 0;\n            while (true) {\n                int bufferOffset = random.nextInt(64);\n                final int bufferLength = random.nextInt(64);\n                int read = in.read(buffer, bufferOffset, bufferLength);\n                if (read == -1) {\n                    assertEquals(offset, expected.length);\n                    break;\n                }\n                assertTrue(read <= bufferLength);\n                while (read > 0) {\n                    assertTrue(offset < expected.length);\n                    assertEquals(expected[offset], buffer[bufferOffset]);\n                    offset++;\n                    bufferOffset++;\n                    read--;\n                }\n            }\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java", "isPureRefactoring": true, "commitId": "7ecca22f175c644da3096940a4ce899be5b33740", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.ReaderInputStreamTest", "methodNameBefore": "org.apache.commons.io.input.ReaderInputStreamTest#testWithBufferedRead", "invokedMethod": "methodSignature: org.apache.commons.io.input.XmlStreamReader#read\n methodBody: public int read(final char[] buf, final int offset, final int len) throws IOException {\nreturn reader.read(buf,offset,len);\n}\nmethodSignature: org.apache.commons.io.input.Tailer.RandomAccessFileBridge#read\n methodBody: public int read(final byte[] b) throws IOException {\nreturn randomAccessFile.read(b);\n}\nmethodSignature: org.apache.commons.io.input.Tailer.RandomAccessResourceBridge#read\n methodBody: int read(final byte[] b) throws IOException;\nmethodSignature: org.apache.commons.io.input.BOMInputStream#read\n methodBody: public int read(final byte[] buf, int off, int len) throws IOException {\nint firstCount=0;\nint b=0;\nwhile(len > 0 && b >= 0){b=readFirstBytes();\nif(b >= 0){buf[off++]=(byte)(b & 0xFF);\nlen--;\nfirstCount++;\n}}final int secondCount=in.read(buf,off,len);\nreturn secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount;\n}\nmethodSignature: org.apache.commons.io.input.BufferedFileChannelInputStream#read\n methodBody: public synchronized int read(final byte[] b, final int offset, int len) throws IOException {\nif(offset < 0 || len < 0 || offset + len < 0 || offset + len > b.length){throw new IndexOutOfBoundsException();\n}if(!refill()){return EOF;\n}len=Math.min(len,byteBuffer.remaining());\nbyteBuffer.get(b,offset,len);\nreturn len;\n}\nmethodSignature: org.apache.commons.io.input.MemoryMappedFileInputStream#read\n methodBody: public int read(final byte[] b, final int off, final int len) throws IOException {\nensureOpen();\nif(!buffer.hasRemaining()){nextBuffer();\nif(!buffer.hasRemaining()){return EOF;\n}}final int numBytes=Math.min(buffer.remaining(),len);\nbuffer.get(b,off,numBytes);\nreturn numBytes;\n}\nmethodSignature: org.apache.commons.io.input.ReaderInputStream#read\n methodBody: public int read(final byte[] array, int off, int len) throws IOException {\nObjects.requireNonNull(array,\"array\");\nif(len < 0 || off < 0 || off + len > array.length){throw new IndexOutOfBoundsException(\"Array size=\" + array.length + \", offset=\" + off + \", length=\" + len);\n}int read=0;\nif(len == 0){return 0;\n}while(len > 0){if(encoderOut.hasRemaining()){final int c=Math.min(encoderOut.remaining(),len);\nencoderOut.get(array,off,c);\noff+=c;\nlen-=c;\nread+=c;\n}if(endOfInput){break;\n}{fillBuffer();\n}}return read == 0 && endOfInput ? EOF : read;\n}\nmethodSignature: org.apache.commons.io.input.RandomAccessFileInputStream#read\n methodBody: public int read(final byte[] bytes, final int offset, final int length) throws IOException {\nreturn randomAccessFile.read(bytes,offset,length);\n}\nmethodSignature: org.apache.commons.io.input.ReadAheadInputStream#read\n methodBody: public int read(final byte[] b, final int offset, int len) throws IOException {\nif(offset < 0 || len < 0 || len > b.length - offset){throw new IndexOutOfBoundsException();\n}if(len == 0){return 0;\n}if(!activeBuffer.hasRemaining()){stateChangeLock.lock();\ntrywaitForAsyncReadComplete();\nif(!readAheadBuffer.hasRemaining()){readAsync();\nwaitForAsyncReadComplete();\nif(isEndOfStream()){return EOF;\n}}swapBuffers();\nreadAsync();\nfinallystateChangeLock.unlock();\n}len=Math.min(len,activeBuffer.remaining());\nactiveBuffer.get(b,offset,len);\nreturn len;\n}\nmethodSignature: org.apache.commons.io.input.BOMInputStreamTest.ExpectCloseInputStream#read\n methodBody: public int read() throws IOException {\nreturn -1;\n}\nmethodSignature: org.apache.commons.io.input.SequenceReaderTest.CustomReader#read\n methodBody: public int read(final char[] cbuf, final int off, final int len) throws IOException {\ncheckOpen();\nclose();\nreturn EOF;\n}", "classSignatureBefore": "public class ReaderInputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.input.ReaderInputStreamTest#testWithBufferedRead"], "classNameBeforeSet": ["org.apache.commons.io.input.ReaderInputStreamTest"], "classSignatureBeforeSet": ["public class ReaderInputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.CharArrayReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class ReaderInputStreamTest {\n\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i = 0; i < 100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    static Stream<Arguments> charsetData() {\n        // @formatter:off\n        return Stream.of(\n                Arguments.of(\"Cp930\", \"\\u0391\"),\n                Arguments.of(\"ISO_8859_1\", \"A\"),\n                Arguments.of(UTF_8, \"\\u0391\"));\n        // @formatter:on\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testBufferSmallest() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        try (InputStream in = new ReaderInputStream(new StringReader(\"\\uD800\"), charset, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            in.read();\n        }\n    }\n\n    @Test\n    public void testBufferTooSmall() {\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, -1));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 0));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 1));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"charsetData\")\n    public void testCharsetEncoderFlush(final String charsetName, final String data) throws IOException {\n        final Charset charset = Charset.forName(charsetName);\n        final byte[] expected = data.getBytes(charset);\n        try (InputStream in = new ReaderInputStream(new StringReader(data), charset)) {\n            final byte[] actual = IOUtils.toByteArray(in);\n            assertEquals(Arrays.toString(expected), Arrays.toString(actual));\n        }\n    }\n\n    /*\n     * Tests https://issues.apache.org/jira/browse/IO-277\n     */\n    @Test\n    public void testCharsetMismatchInfiniteLoop() throws IOException {\n        // Input is UTF-8 bytes: 0xE0 0xB2 0xA0\n        final char[] inputChars = {(char) 0xE0, (char) 0xB2, (char) 0xA0};\n        // Charset charset = Charset.forName(\"UTF-8\"); // works\n        final Charset charset = StandardCharsets.US_ASCII; // infinite loop\n        try (ReaderInputStream stream = new ReaderInputStream(new CharArrayReader(inputChars), charset)) {\n            IOUtils.toCharArray(stream, charset);\n        }\n    }\n\n    /**\n     * Tests IO-717 to avoid infinite loops.\n     *\n     * ReaderInputStream does not throw exception with {@link CodingErrorAction#REPORT}.\n     */\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testCodingErrorAction() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        final CharsetEncoder encoder = charset.newEncoder().onMalformedInput(CodingErrorAction.REPORT);\n        try (InputStream in = new ReaderInputStream(new StringReader(\"\\uD800aa\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            assertThrows(CharacterCodingException.class, in::read);\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharset() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final Charset encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final CharsetEncoder encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetNameEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final String encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZero() throws Exception {\n        final String inStr = \"test\";\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n            final byte[] bytes = new byte[30];\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n        }\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZeroEmptyString() throws Exception {\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(\"\"))) {\n            final byte[] bytes = new byte[30];\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_16);\n    }\n\n    @Test\n    public void testUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            final byte[] buffer = new byte[128];\n            int offset = 0;\n            while (true) {\n                int bufferOffset = random.nextInt(64);\n                final int bufferLength = random.nextInt(64);\n                int read = in.read(buffer, bufferOffset, bufferLength);\n                if (read == -1) {\n                    assertEquals(offset, expected.length);\n                    break;\n                }\n                assertTrue(read <= bufferLength);\n                while (read > 0) {\n                    assertTrue(offset < expected.length);\n                    assertEquals(expected[offset], buffer[bufferOffset]);\n                    offset++;\n                    bufferOffset++;\n                    read--;\n                }\n            }\n        }\n    }\n\n    private void testWithSingleByteRead(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            for (final byte b : bytes) {\n                final int read = in.read();\n                assertTrue(read >= 0);\n                assertTrue(read <= 255);\n                assertEquals(b, (byte) read);\n            }\n            assertEquals(-1, in.read());\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.CharArrayReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class ReaderInputStreamTest {\n\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i = 0; i < 100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    static Stream<Arguments> charsetData() {\n        // @formatter:off\n        return Stream.of(\n                Arguments.of(\"Cp930\", \"\\u0391\"),\n                Arguments.of(\"ISO_8859_1\", \"A\"),\n                Arguments.of(UTF_8, \"\\u0391\"));\n        // @formatter:on\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testBufferSmallest() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        // @formatter:off\n        try (InputStream in = new ReaderInputStream(\n                new StringReader(\"\\uD800\"),\n                charset, (int)\n                ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            in.read();\n        }\n        try (InputStream in = ReaderInputStream.builder()\n                .setReader(new StringReader(\"\\uD800\"))\n                .setCharset(charset)\n                .setBufferSize((int) ReaderInputStream.minBufferSize(charset.newEncoder()))\n                .get()) {\n            in.read();\n        }\n        // @formatter:on\n    }\n\n    @Test\n    public void testBufferTooSmall() {\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, -1));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 0));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 1));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"charsetData\")\n    public void testCharsetEncoderFlush(final String charsetName, final String data) throws IOException {\n        final Charset charset = Charset.forName(charsetName);\n        final byte[] expected = data.getBytes(charset);\n        try (InputStream in = new ReaderInputStream(new StringReader(data), charset)) {\n            assertEquals(Arrays.toString(expected), Arrays.toString(IOUtils.toByteArray(in)));\n        }\n        try (InputStream in = ReaderInputStream.builder().setReader(new StringReader(data)).setCharset(charset).get()) {\n            assertEquals(Arrays.toString(expected), Arrays.toString(IOUtils.toByteArray(in)));\n        }\n    }\n\n    /*\n     * Tests https://issues.apache.org/jira/browse/IO-277\n     */\n    @Test\n    public void testCharsetMismatchInfiniteLoop() throws IOException {\n        // Input is UTF-8 bytes: 0xE0 0xB2 0xA0\n        final char[] inputChars = { (char) 0xE0, (char) 0xB2, (char) 0xA0 };\n        // Charset charset = Charset.forName(\"UTF-8\"); // works\n        final Charset charset = StandardCharsets.US_ASCII; // infinite loop\n        try (ReaderInputStream stream = new ReaderInputStream(new CharArrayReader(inputChars), charset)) {\n            IOUtils.toCharArray(stream, charset);\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testCodingError() throws IOException {\n        // Encoder which throws on malformed or unmappable input\n        CharsetEncoder encoder = StandardCharsets.UTF_8.newEncoder();\n        try (final ReaderInputStream in = new ReaderInputStream(new StringReader(\"\\uD800\"), encoder)) {\n            // Does not throws an exception because the input is an underflow and not an error\n            assertDoesNotThrow(() -> in.read());\n            // assertThrows(IllegalStateException.class, () -> in.read());\n        }\n        encoder = StandardCharsets.UTF_8.newEncoder();\n        try (final ReaderInputStream in = ReaderInputStream.builder().setReader(new StringReader(\"\\uD800\")).setCharsetEncoder(encoder).get()) {\n            // TODO WIP\n            assertDoesNotThrow(() -> in.read());\n            // assertThrows(IllegalStateException.class, () -> in.read());\n        }\n    }\n\n    /**\n     * Tests IO-717 to avoid infinite loops.\n     *\n     * ReaderInputStream does not throw exception with {@link CodingErrorAction#REPORT}.\n     */\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testCodingErrorAction() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        final CharsetEncoder encoder = charset.newEncoder().onMalformedInput(CodingErrorAction.REPORT);\n        try (InputStream in = new ReaderInputStream(new StringReader(\"\\uD800aa\"), encoder, (int) ReaderInputStream.minBufferSize(encoder))) {\n            assertThrows(CharacterCodingException.class, in::read);\n        }\n        try (InputStream in = ReaderInputStream.builder().setReader(new StringReader(\"\\uD800aa\")).setCharsetEncoder(encoder)\n                .setBufferSize((int) ReaderInputStream.minBufferSize(charset.newEncoder())).get()) {\n            assertThrows(CharacterCodingException.class, in::read);\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharset() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final Charset encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final CharsetEncoder encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetNameEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final String charsetName = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), charsetName, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n        try (ReaderInputStream in = ReaderInputStream.builder().setReader(new StringReader(\"ABC\")).setCharset(charsetName)\n                .setBufferSize((int) ReaderInputStream.minBufferSize(charset.newEncoder())).get()) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZero() throws Exception {\n        final String inStr = \"test\";\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n            testReadZero(inStr, inputStream);\n        }\n        try (ReaderInputStream inputStream = ReaderInputStream.builder().setReader(new StringReader(inStr)).get()) {\n            testReadZero(inStr, inputStream);\n        }\n    }\n\n    private void testReadZero(final String inStr, final ReaderInputStream inputStream) throws IOException {\n        final byte[] bytes = new byte[30];\n        assertEquals(0, inputStream.read(bytes, 0, 0));\n        assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n        // Should always return 0 for length == 0\n        assertEquals(0, inputStream.read(bytes, 0, 0));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZeroEmptyString() throws Exception {\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(\"\"))) {\n            final byte[] bytes = new byte[30];\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_16);\n    }\n\n    @Test\n    public void testUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            testWithBufferedRead(expected, in);\n        }\n        try (ReaderInputStream in = ReaderInputStream.builder().setReader(new StringReader(testString)).setCharset(charsetName).get()) {\n            testWithBufferedRead(expected, in);\n        }\n    }\n\n    private void testWithBufferedRead(final byte[] expected, final ReaderInputStream in) throws IOException {\n        final byte[] buffer = new byte[128];\n        int offset = 0;\n        while (true) {\n            int bufferOffset = random.nextInt(64);\n            final int bufferLength = random.nextInt(64);\n            int read = in.read(buffer, bufferOffset, bufferLength);\n            if (read == -1) {\n                assertEquals(offset, expected.length);\n                break;\n            }\n            assertTrue(read <= bufferLength);\n            while (read > 0) {\n                assertTrue(offset < expected.length);\n                assertEquals(expected[offset], buffer[bufferOffset]);\n                offset++;\n                bufferOffset++;\n                read--;\n            }\n        }\n    }\n\n    private void testWithSingleByteRead(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            for (final byte b : bytes) {\n                final int read = in.read();\n                assertTrue(read >= 0);\n                assertTrue(read <= 255);\n                assertEquals(b, (byte) read);\n            }\n            assertEquals(-1, in.read());\n        }\n    }\n}\n", "diffSourceCodeSet": ["private void testWithBufferedRead(final byte[] expected, final ReaderInputStream in) throws IOException {\n        final byte[] buffer = new byte[128];\n        int offset = 0;\n        while (true) {\n            int bufferOffset = random.nextInt(64);\n            final int bufferLength = random.nextInt(64);\n            int read = in.read(buffer, bufferOffset, bufferLength);\n            if (read == -1) {\n                assertEquals(offset, expected.length);\n                break;\n            }\n            assertTrue(read <= bufferLength);\n            while (read > 0) {\n                assertTrue(offset < expected.length);\n                assertEquals(expected[offset], buffer[bufferOffset]);\n                offset++;\n                bufferOffset++;\n                read--;\n            }\n        }\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.XmlStreamReader#read\n methodBody: public int read(final char[] buf, final int offset, final int len) throws IOException {\nreturn reader.read(buf,offset,len);\n}", "methodSignature: org.apache.commons.io.input.Tailer.RandomAccessFileBridge#read\n methodBody: public int read(final byte[] b) throws IOException {\nreturn randomAccessFile.read(b);\n}", "methodSignature: org.apache.commons.io.input.Tailer.RandomAccessResourceBridge#read\n methodBody: int read(final byte[] b) throws IOException;", "methodSignature: org.apache.commons.io.input.BOMInputStream#read\n methodBody: public int read(final byte[] buf, int off, int len) throws IOException {\nint firstCount=0;\nint b=0;\nwhile(len > 0 && b >= 0){b=readFirstBytes();\nif(b >= 0){buf[off++]=(byte)(b & 0xFF);\nlen--;\nfirstCount++;\n}}final int secondCount=in.read(buf,off,len);\nreturn secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount;\n}", "methodSignature: org.apache.commons.io.input.BufferedFileChannelInputStream#read\n methodBody: public synchronized int read(final byte[] b, final int offset, int len) throws IOException {\nif(offset < 0 || len < 0 || offset + len < 0 || offset + len > b.length){throw new IndexOutOfBoundsException();\n}if(!refill()){return EOF;\n}len=Math.min(len,byteBuffer.remaining());\nbyteBuffer.get(b,offset,len);\nreturn len;\n}", "methodSignature: org.apache.commons.io.input.MemoryMappedFileInputStream#read\n methodBody: public int read(final byte[] b, final int off, final int len) throws IOException {\nensureOpen();\nif(!buffer.hasRemaining()){nextBuffer();\nif(!buffer.hasRemaining()){return EOF;\n}}final int numBytes=Math.min(buffer.remaining(),len);\nbuffer.get(b,off,numBytes);\nreturn numBytes;\n}", "methodSignature: org.apache.commons.io.input.ReaderInputStream#read\n methodBody: public int read(final byte[] array, int off, int len) throws IOException {\nObjects.requireNonNull(array,\"array\");\nif(len < 0 || off < 0 || off + len > array.length){throw new IndexOutOfBoundsException(\"Array size=\" + array.length + \", offset=\" + off + \", length=\" + len);\n}int read=0;\nif(len == 0){return 0;\n}while(len > 0){if(encoderOut.hasRemaining()){final int c=Math.min(encoderOut.remaining(),len);\nencoderOut.get(array,off,c);\noff+=c;\nlen-=c;\nread+=c;\n}if(endOfInput){break;\n}{fillBuffer();\n}}return read == 0 && endOfInput ? EOF : read;\n}", "methodSignature: org.apache.commons.io.input.RandomAccessFileInputStream#read\n methodBody: public int read(final byte[] bytes, final int offset, final int length) throws IOException {\nreturn randomAccessFile.read(bytes,offset,length);\n}", "methodSignature: org.apache.commons.io.input.ReadAheadInputStream#read\n methodBody: public int read(final byte[] b, final int offset, int len) throws IOException {\nif(offset < 0 || len < 0 || len > b.length - offset){throw new IndexOutOfBoundsException();\n}if(len == 0){return 0;\n}if(!activeBuffer.hasRemaining()){stateChangeLock.lock();\ntrywaitForAsyncReadComplete();\nif(!readAheadBuffer.hasRemaining()){readAsync();\nwaitForAsyncReadComplete();\nif(isEndOfStream()){return EOF;\n}}swapBuffers();\nreadAsync();\nfinallystateChangeLock.unlock();\n}len=Math.min(len,activeBuffer.remaining());\nactiveBuffer.get(b,offset,len);\nreturn len;\n}", "methodSignature: org.apache.commons.io.input.BOMInputStreamTest.ExpectCloseInputStream#read\n methodBody: public int read() throws IOException {\nreturn -1;\n}", "methodSignature: org.apache.commons.io.input.SequenceReaderTest.CustomReader#read\n methodBody: public int read(final char[] cbuf, final int off, final int len) throws IOException {\ncheckOpen();\nclose();\nreturn EOF;\n}"], "sourceCodeAfterRefactoring": "private void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            testWithBufferedRead(expected, in);\n        }\n        try (ReaderInputStream in = ReaderInputStream.builder().setReader(new StringReader(testString)).setCharset(charsetName).get()) {\n            testWithBufferedRead(expected, in);\n        }\n    }\nprivate void testWithBufferedRead(final byte[] expected, final ReaderInputStream in) throws IOException {\n        final byte[] buffer = new byte[128];\n        int offset = 0;\n        while (true) {\n            int bufferOffset = random.nextInt(64);\n            final int bufferLength = random.nextInt(64);\n            int read = in.read(buffer, bufferOffset, bufferLength);\n            if (read == -1) {\n                assertEquals(offset, expected.length);\n                break;\n            }\n            assertTrue(read <= bufferLength);\n            while (read > 0) {\n                assertTrue(offset < expected.length);\n                assertEquals(expected[offset], buffer[bufferOffset]);\n                offset++;\n                bufferOffset++;\n                read--;\n            }\n        }\n    }", "diffSourceCode": "-  210:     private void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n-  211:         final byte[] expected = testString.getBytes(charsetName);\n-  212:         try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n-  213:             final byte[] buffer = new byte[128];\n-  214:             int offset = 0;\n-  215:             while (true) {\n-  216:                 int bufferOffset = random.nextInt(64);\n-  217:                 final int bufferLength = random.nextInt(64);\n-  218:                 int read = in.read(buffer, bufferOffset, bufferLength);\n-  219:                 if (read == -1) {\n-  220:                     assertEquals(offset, expected.length);\n-  221:                     break;\n-  222:                 }\n-  223:                 assertTrue(read <= bufferLength);\n-  224:                 while (read > 0) {\n-  225:                     assertTrue(offset < expected.length);\n-  226:                     assertEquals(expected[offset], buffer[bufferOffset]);\n-  227:                     offset++;\n-  228:                     bufferOffset++;\n-  229:                     read--;\n-  230:                 }\n-  231:             }\n-  232:         }\n-  233:     }\n+  210: \n+  211:     @SuppressWarnings(\"deprecation\")\n+  212:     @Test\n+  213:     public void testReadZero() throws Exception {\n+  214:         final String inStr = \"test\";\n+  215:         try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n+  216:             testReadZero(inStr, inputStream);\n+  217:         }\n+  218:         try (ReaderInputStream inputStream = ReaderInputStream.builder().setReader(new StringReader(inStr)).get()) {\n+  219:             testReadZero(inStr, inputStream);\n+  220:         }\n+  221:     }\n+  222: \n+  223:     private void testReadZero(final String inStr, final ReaderInputStream inputStream) throws IOException {\n+  224:         final byte[] bytes = new byte[30];\n+  225:         assertEquals(0, inputStream.read(bytes, 0, 0));\n+  226:         assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n+  227:         // Should always return 0 for length == 0\n+  228:         assertEquals(0, inputStream.read(bytes, 0, 0));\n+  229:     }\n+  230: \n+  231:     @SuppressWarnings(\"deprecation\")\n+  232:     @Test\n+  233:     public void testReadZeroEmptyString() throws Exception {\n+  259:     private void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n+  260:         final byte[] expected = testString.getBytes(charsetName);\n+  261:         try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n+  262:             testWithBufferedRead(expected, in);\n+  263:         }\n+  264:         try (ReaderInputStream in = ReaderInputStream.builder().setReader(new StringReader(testString)).setCharset(charsetName).get()) {\n+  265:             testWithBufferedRead(expected, in);\n+  266:         }\n+  267:     }\n+  269:     private void testWithBufferedRead(final byte[] expected, final ReaderInputStream in) throws IOException {\n+  270:         final byte[] buffer = new byte[128];\n+  271:         int offset = 0;\n+  272:         while (true) {\n+  273:             int bufferOffset = random.nextInt(64);\n+  274:             final int bufferLength = random.nextInt(64);\n+  275:             int read = in.read(buffer, bufferOffset, bufferLength);\n+  276:             if (read == -1) {\n+  277:                 assertEquals(offset, expected.length);\n+  278:                 break;\n+  279:             }\n+  280:             assertTrue(read <= bufferLength);\n+  281:             while (read > 0) {\n+  282:                 assertTrue(offset < expected.length);\n+  283:                 assertEquals(expected[offset], buffer[bufferOffset]);\n+  284:                 offset++;\n+  285:                 bufferOffset++;\n+  286:                 read--;\n+  287:             }\n+  288:         }\n+  289:     }\n", "uniqueId": "7ecca22f175c644da3096940a4ce899be5b33740_210_233_269_289_259_267", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testWithBufferedRead` method, we can extract the inner loop that processes the read bytes into a separate method. This will make the code cleaner and easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\nprivate void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n    final byte[] expected = testString.getBytes(charsetName);\n    try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n        final byte[] buffer = new byte[128];\n        int offset = 0;\n        while (true) {\n            int bufferOffset = random.nextInt(64);\n            final int bufferLength = random.nextInt(64);\n            int read = in.read(buffer, bufferOffset, bufferLength);\n            if (read == -1) {\n                assertEquals(offset, expected.length);\n                break;\n            }\n            assertTrue(read <= bufferLength);\n            processReadBytes(expected, buffer, bufferOffset, read, offset);\n            offset += read;\n        }\n    }\n}\n\nprivate void processReadBytes(byte[] expected, byte[] buffer, int bufferOffset, int read, int offset) {\n    for (int i = 0; i < read; i++) {\n        assertTrue(offset < expected.length);\n        assertEquals(expected[offset], buffer[bufferOffset + i]);\n    }\n}\n##########################\n```\n\n### Changes Made:\n1. **Extracted Method**: The inner loop that processes the read bytes has been extracted into a new method called `processReadBytes`. This method takes the expected byte array, the buffer, the buffer offset, the number of bytes read, and the current offset as parameters.\n2. **Improved Readability**: The main method `testWithBufferedRead` is now cleaner and focuses on the overall logic of reading from the stream, while the details of processing the read bytes are handled in a separate method. This separation of concerns enhances readability and maintainability.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            final byte[] buffer = new byte[128];\n            int offset = 0;\n            while (true) {\n                int bufferOffset = random.nextInt(64);\n                final int bufferLength = random.nextInt(64);\n                int read = in.read(buffer, bufferOffset, bufferLength);\n                if (read == -1) {\n                    assertEquals(offset, expected.length);\n                    break;\n                }\n                assertTrue(read <= bufferLength);\n                while (read > 0) {\n                    assertTrue(offset < expected.length);\n                    assertEquals(expected[offset], buffer[bufferOffset]);\n                    offset++;\n                    bufferOffset++;\n                    read--;\n                }\n            }\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.CharArrayReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class ReaderInputStreamTest {\n\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i = 0; i < 100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    static Stream<Arguments> charsetData() {\n        // @formatter:off\n        return Stream.of(\n                Arguments.of(\"Cp930\", \"\\u0391\"),\n                Arguments.of(\"ISO_8859_1\", \"A\"),\n                Arguments.of(UTF_8, \"\\u0391\"));\n        // @formatter:on\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testBufferSmallest() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        try (InputStream in = new ReaderInputStream(new StringReader(\"\\uD800\"), charset, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            in.read();\n        }\n    }\n\n    @Test\n    public void testBufferTooSmall() {\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, -1));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 0));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 1));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"charsetData\")\n    public void testCharsetEncoderFlush(final String charsetName, final String data) throws IOException {\n        final Charset charset = Charset.forName(charsetName);\n        final byte[] expected = data.getBytes(charset);\n        try (InputStream in = new ReaderInputStream(new StringReader(data), charset)) {\n            final byte[] actual = IOUtils.toByteArray(in);\n            assertEquals(Arrays.toString(expected), Arrays.toString(actual));\n        }\n    }\n\n    /*\n     * Tests https://issues.apache.org/jira/browse/IO-277\n     */\n    @Test\n    public void testCharsetMismatchInfiniteLoop() throws IOException {\n        // Input is UTF-8 bytes: 0xE0 0xB2 0xA0\n        final char[] inputChars = {(char) 0xE0, (char) 0xB2, (char) 0xA0};\n        // Charset charset = Charset.forName(\"UTF-8\"); // works\n        final Charset charset = StandardCharsets.US_ASCII; // infinite loop\n        try (ReaderInputStream stream = new ReaderInputStream(new CharArrayReader(inputChars), charset)) {\n            IOUtils.toCharArray(stream, charset);\n        }\n    }\n\n    /**\n     * Tests IO-717 to avoid infinite loops.\n     *\n     * ReaderInputStream does not throw exception with {@link CodingErrorAction#REPORT}.\n     */\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testCodingErrorAction() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        final CharsetEncoder encoder = charset.newEncoder().onMalformedInput(CodingErrorAction.REPORT);\n        try (InputStream in = new ReaderInputStream(new StringReader(\"\\uD800aa\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            assertThrows(CharacterCodingException.class, in::read);\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharset() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final Charset encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final CharsetEncoder encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetNameEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final String encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZero() throws Exception {\n        final String inStr = \"test\";\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n            final byte[] bytes = new byte[30];\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n        }\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZeroEmptyString() throws Exception {\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(\"\"))) {\n            final byte[] bytes = new byte[30];\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_16);\n    }\n\n    @Test\n    public void testUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            final byte[] buffer = new byte[128];\n            int offset = 0;\n            while (true) {\n                int bufferOffset = random.nextInt(64);\n                final int bufferLength = random.nextInt(64);\n                int read = in.read(buffer, bufferOffset, bufferLength);\n                if (read == -1) {\n                    assertEquals(offset, expected.length);\n                    break;\n                }\n                assertTrue(read <= bufferLength);\n                while (read > 0) {\n                    assertTrue(offset < expected.length);\n                    assertEquals(expected[offset], buffer[bufferOffset]);\n                    offset++;\n                    bufferOffset++;\n                    read--;\n                }\n            }\n        }\n    }\n\n    private void testWithSingleByteRead(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            for (final byte b : bytes) {\n                final int read = in.read();\n                assertTrue(read >= 0);\n                assertTrue(read <= 255);\n                assertEquals(b, (byte) read);\n            }\n            assertEquals(-1, in.read());\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic assertEqualContent(c0 char[], file Path) : void extracted from public assertEqualContent(c0 char[], file File) : void in class org.apache.commons.io.test.TestUtils", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/test/TestUtils.java", "startLine": 69, "endLine": 89, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/test/TestUtils.java", "startLine": 81, "endLine": 90, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/test/TestUtils.java", "startLine": 92, "endLine": 112, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final char[] c1 = new char[c0.length];\n        try (Reader ir = Files.newBufferedReader(file.toPath())) {\n            while (count < c0.length && numRead >= 0) {\n                numRead = ir.read(c1, count, c0.length);\n                count += numRead;\n            }\n            assertEquals(c0.length, count, \"Different number of chars: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n            }\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/test/TestUtils.java", "isPureRefactoring": true, "commitId": "010299c21811b11a41c8d5bd73023f75eb29058e", "packageNameBefore": "org.apache.commons.io.test", "classNameBefore": "org.apache.commons.io.test.TestUtils", "methodNameBefore": "org.apache.commons.io.test.TestUtils#assertEqualContent", "classSignatureBefore": "public abstract class TestUtils ", "methodNameBeforeSet": ["org.apache.commons.io.test.TestUtils#assertEqualContent"], "classNameBeforeSet": ["org.apache.commons.io.test.TestUtils"], "classSignatureBeforeSet": ["public abstract class TestUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.time.Duration;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.apache.commons.lang3.ThreadUtils;\n\n/**\n * Base class for testcases doing tests with files.\n */\npublic abstract class TestUtils {\n\n    /**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final byte[] b1 = new byte[b0.length];\n        try (InputStream is = Files.newInputStream(file.toPath())) {\n            while (count < b0.length && numRead >= 0) {\n                numRead = is.read(b1, count, b0.length);\n                count += numRead;\n            }\n            assertEquals(b0.length, count, \"Different number of bytes: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final char[] c1 = new char[c0.length];\n        try (Reader ir = Files.newBufferedReader(file.toPath())) {\n            while (count < c0.length && numRead >= 0) {\n                numRead = ir.read(c1, count, c0.length);\n                count += numRead;\n            }\n            assertEquals(c0.length, count, \"Different number of chars: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of two files is the same.\n     */\n    private static void assertEqualContent(final File f0, final File f1)\n            throws IOException {\n        /* This doesn't work because the filesize isn't updated until the file\n         * is closed.\n        assertTrue( \"The files \" + f0 + \" and \" + f1 +\n                    \" have differing file sizes (\" + f0.length() +\n                    \" vs \" + f1.length() + \")\", ( f0.length() == f1.length() ) );\n        */\n        try (InputStream is0 = Files.newInputStream(f0.toPath())) {\n            try (InputStream is1 = Files.newInputStream(f1.toPath())) {\n                final byte[] buf0 = new byte[1024];\n                final byte[] buf1 = new byte[1024];\n                int n0 = 0;\n                int n1;\n\n                while (-1 != n0) {\n                    n0 = is0.read(buf0);\n                    n1 = is1.read(buf1);\n                    assertTrue((n0 == n1),\n                            \"The files \" + f0 + \" and \" + f1 +\n                            \" have differing number of bytes available (\" + n0 + \" vs \" + n1 + \")\");\n\n                    assertArrayEquals(buf0, buf1, \"The files \" + f0 + \" and \" + f1 + \" have different content\");\n                }\n            }\n        }\n    }\n\n    public static void checkFile(final File file, final File referenceFile)\n            throws Exception {\n        assertTrue(file.exists(), \"Check existence of output file\");\n        assertEqualContent(referenceFile, file);\n    }\n\n    public static void checkWrite(final OutputStream output) {\n        try {\n            new java.io.PrintStream(output).write(0);\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void checkWrite(final Writer output) {\n        try {\n            new java.io.PrintWriter(output).write('a');\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void createFile(final File file, final long size)\n            throws IOException {\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static void createLineBasedFile(final File file, final String[] data) throws IOException {\n        if (file.getParentFile() != null && !file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final PrintWriter output = new PrintWriter(new OutputStreamWriter(Files.newOutputStream(file.toPath()), StandardCharsets.UTF_8))) {\n            for (final String element : data) {\n                output.println(element);\n            }\n        }\n    }\n\n    public static void deleteFile(final File file) {\n        if (file.exists()) {\n            assertTrue(file.delete(), \"Couldn't delete file: \" + file);\n        }\n    }\n\n    public static void generateTestData(final File file, final long size) throws IOException, FileNotFoundException {\n        try (final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static byte[] generateTestData(final long size) {\n        try {\n            try (final ByteArrayOutputStream baout = new ByteArrayOutputStream()) {\n                generateTestData(baout, size);\n                return baout.toByteArray();\n            }\n        } catch (final IOException ioe) {\n            throw new IllegalStateException(\"This should never happen: \" + ioe.getMessage(), ioe);\n        }\n    }\n\n    public static void generateTestData(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            // output.write((byte)'X');\n            // nice varied byte pattern compatible with Readers and Writers\n            out.write((byte) ((i % 127) + 1));\n        }\n    }\n\n    public static File newFile(final File testDirectory, final String filename) throws IOException {\n        final File destination = new File(testDirectory, filename);\n        /*\n        assertTrue( filename + \"Test output data file shouldn't previously exist\",\n                    !destination.exists() );\n        */\n        if (destination.exists()) {\n            FileUtils.forceDelete(destination);\n        }\n        return destination;\n    }\n\n    /**\n     * Sleeps for a guaranteed number of milliseconds unless interrupted.\n     *\n     * This method exists because Thread.sleep(100) can sleep for 0, 70, 100 or 200ms or anything else\n     * it deems appropriate. Read the docs on Thread.sleep for further details.\n     *\n     * @param millis the number of milliseconds to sleep.\n     * @throws InterruptedException if interrupted.\n     */\n    public static void sleep(final long millis) throws InterruptedException {\n        ThreadUtils.sleep(Duration.ofMillis(millis));\n    }\n\n    /**\n     * Sleeps and swallows InterruptedException.\n     *\n     * @param millis the number of milliseconds to sleep.\n     */\n    public static void sleepQuietly(final long millis) {\n        try {\n            sleep(millis);\n        } catch (final InterruptedException ignored){\n            // ignore InterruptedException.\n        }\n    }\n\n    private TestUtils() {\n\n    }\n\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/test/TestUtils.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.time.Duration;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.apache.commons.lang3.ThreadUtils;\n\n/**\n * Base class for testcases doing tests with files.\n */\npublic abstract class TestUtils {\n\n    /**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n        assertEqualContent(b0, file.toPath());\n    }\n\n    /**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final Path file) throws IOException {\n        int count = 0, numRead = 0;\n        final byte[] b1 = new byte[b0.length];\n        try (InputStream is = Files.newInputStream(file)) {\n            while (count < b0.length && numRead >= 0) {\n                numRead = is.read(b1, count, b0.length);\n                count += numRead;\n            }\n            assertEquals(b0.length, count, \"Different number of bytes: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n        assertEqualContent(c0, file.toPath());\n    }\n\n    /**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final Path file) throws IOException {\n        int count = 0, numRead = 0;\n        final char[] c1 = new char[c0.length];\n        try (Reader ir = Files.newBufferedReader(file)) {\n            while (count < c0.length && numRead >= 0) {\n                numRead = ir.read(c1, count, c0.length);\n                count += numRead;\n            }\n            assertEquals(c0.length, count, \"Different number of chars: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of two files is the same.\n     */\n    private static void assertEqualContent(final File f0, final File f1)\n            throws IOException {\n        /* This doesn't work because the filesize isn't updated until the file\n         * is closed.\n        assertTrue( \"The files \" + f0 + \" and \" + f1 +\n                    \" have differing file sizes (\" + f0.length() +\n                    \" vs \" + f1.length() + \")\", ( f0.length() == f1.length() ) );\n        */\n        try (InputStream is0 = Files.newInputStream(f0.toPath())) {\n            try (InputStream is1 = Files.newInputStream(f1.toPath())) {\n                final byte[] buf0 = new byte[1024];\n                final byte[] buf1 = new byte[1024];\n                int n0 = 0;\n                int n1;\n\n                while (-1 != n0) {\n                    n0 = is0.read(buf0);\n                    n1 = is1.read(buf1);\n                    assertTrue((n0 == n1),\n                            \"The files \" + f0 + \" and \" + f1 +\n                            \" have differing number of bytes available (\" + n0 + \" vs \" + n1 + \")\");\n\n                    assertArrayEquals(buf0, buf1, \"The files \" + f0 + \" and \" + f1 + \" have different content\");\n                }\n            }\n        }\n    }\n\n    public static void checkFile(final File file, final File referenceFile)\n            throws Exception {\n        assertTrue(file.exists(), \"Check existence of output file\");\n        assertEqualContent(referenceFile, file);\n    }\n\n    public static void checkWrite(final OutputStream output) {\n        try {\n            new java.io.PrintStream(output).write(0);\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void checkWrite(final Writer output) {\n        try {\n            new java.io.PrintWriter(output).write('a');\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void createFile(final File file, final long size)\n            throws IOException {\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static void createLineBasedFile(final File file, final String[] data) throws IOException {\n        if (file.getParentFile() != null && !file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final PrintWriter output = new PrintWriter(new OutputStreamWriter(Files.newOutputStream(file.toPath()), StandardCharsets.UTF_8))) {\n            for (final String element : data) {\n                output.println(element);\n            }\n        }\n    }\n\n    public static void deleteFile(final File file) {\n        if (file.exists()) {\n            assertTrue(file.delete(), \"Couldn't delete file: \" + file);\n        }\n    }\n\n    public static void generateTestData(final File file, final long size) throws IOException, FileNotFoundException {\n        try (final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static byte[] generateTestData(final long size) {\n        try {\n            try (final ByteArrayOutputStream baout = new ByteArrayOutputStream()) {\n                generateTestData(baout, size);\n                return baout.toByteArray();\n            }\n        } catch (final IOException ioe) {\n            throw new IllegalStateException(\"This should never happen: \" + ioe.getMessage(), ioe);\n        }\n    }\n\n    public static void generateTestData(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            // output.write((byte)'X');\n            // nice varied byte pattern compatible with Readers and Writers\n            out.write((byte) ((i % 127) + 1));\n        }\n    }\n\n    public static File newFile(final File testDirectory, final String filename) throws IOException {\n        final File destination = new File(testDirectory, filename);\n        /*\n        assertTrue( filename + \"Test output data file shouldn't previously exist\",\n                    !destination.exists() );\n        */\n        if (destination.exists()) {\n            FileUtils.forceDelete(destination);\n        }\n        return destination;\n    }\n\n    /**\n     * Sleeps for a guaranteed number of milliseconds unless interrupted.\n     *\n     * This method exists because Thread.sleep(100) can sleep for 0, 70, 100 or 200ms or anything else\n     * it deems appropriate. Read the docs on Thread.sleep for further details.\n     *\n     * @param millis the number of milliseconds to sleep.\n     * @throws InterruptedException if interrupted.\n     */\n    public static void sleep(final long millis) throws InterruptedException {\n        ThreadUtils.sleep(Duration.ofMillis(millis));\n    }\n\n    /**\n     * Sleeps and swallows InterruptedException.\n     *\n     * @param millis the number of milliseconds to sleep.\n     */\n    public static void sleepQuietly(final long millis) {\n        try {\n            sleep(millis);\n        } catch (final InterruptedException ignored){\n            // ignore InterruptedException.\n        }\n    }\n\n    private TestUtils() {\n\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final Path file) throws IOException {\n        int count = 0, numRead = 0;\n        final char[] c1 = new char[c0.length];\n        try (Reader ir = Files.newBufferedReader(file)) {\n            while (count < c0.length && numRead >= 0) {\n                numRead = ir.read(c1, count, c0.length);\n                count += numRead;\n            }\n            assertEquals(c0.length, count, \"Different number of chars: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n            }\n        }\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n        assertEqualContent(c0, file.toPath());\n    }\n/**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final Path file) throws IOException {\n        int count = 0, numRead = 0;\n        final char[] c1 = new char[c0.length];\n        try (Reader ir = Files.newBufferedReader(file)) {\n            while (count < c0.length && numRead >= 0) {\n                numRead = ir.read(c1, count, c0.length);\n                count += numRead;\n            }\n            assertEquals(c0.length, count, \"Different number of chars: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n            }\n        }\n    }", "diffSourceCode": "-   69:     /**\n-   70:      * Assert that the content of a file is equal to that in a char[].\n-   71:      *\n-   72:      * @param c0   the expected contents\n-   73:      * @param file the file to check\n-   74:      * @throws IOException If an I/O error occurs while reading the file contents\n-   75:      */\n-   76:     public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n-   77:         int count = 0, numRead = 0;\n-   78:         final char[] c1 = new char[c0.length];\n-   79:         try (Reader ir = Files.newBufferedReader(file.toPath())) {\n-   80:             while (count < c0.length && numRead >= 0) {\n-   81:                 numRead = ir.read(c1, count, c0.length);\n-   82:                 count += numRead;\n-   83:             }\n-   84:             assertEquals(c0.length, count, \"Different number of chars: \");\n-   85:             for (int i = 0; i < count; i++) {\n-   86:                 assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n-   87:             }\n-   88:         }\n-   89:     }\n-   90: \n-   92:      * Assert that the content of two files is the same.\n-   93:      */\n-   94:     private static void assertEqualContent(final File f0, final File f1)\n-   95:             throws IOException {\n-   96:         /* This doesn't work because the filesize isn't updated until the file\n-   97:          * is closed.\n-   98:         assertTrue( \"The files \" + f0 + \" and \" + f1 +\n-   99:                     \" have differing file sizes (\" + f0.length() +\n-  100:                     \" vs \" + f1.length() + \")\", ( f0.length() == f1.length() ) );\n-  101:         */\n-  102:         try (InputStream is0 = Files.newInputStream(f0.toPath())) {\n-  103:             try (InputStream is1 = Files.newInputStream(f1.toPath())) {\n-  104:                 final byte[] buf0 = new byte[1024];\n-  105:                 final byte[] buf1 = new byte[1024];\n-  106:                 int n0 = 0;\n-  107:                 int n1;\n-  108: \n-  109:                 while (-1 != n0) {\n-  110:                     n0 = is0.read(buf0);\n-  111:                     n1 = is1.read(buf1);\n-  112:                     assertTrue((n0 == n1),\n+   69:         try (InputStream is = Files.newInputStream(file)) {\n+   70:             while (count < b0.length && numRead >= 0) {\n+   71:                 numRead = is.read(b1, count, b0.length);\n+   72:                 count += numRead;\n+   73:             }\n+   74:             assertEquals(b0.length, count, \"Different number of bytes: \");\n+   75:             for (int i = 0; i < count; i++) {\n+   76:                 assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n+   77:             }\n+   78:         }\n+   79:     }\n+   80: \n+   81:     /**\n+   82:      * Assert that the content of a file is equal to that in a char[].\n+   83:      *\n+   84:      * @param c0   the expected contents\n+   85:      * @param file the file to check\n+   86:      * @throws IOException If an I/O error occurs while reading the file contents\n+   87:      */\n+   88:     public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n+   89:         assertEqualContent(c0, file.toPath());\n+   90:     }\n+   92:     /**\n+   93:      * Assert that the content of a file is equal to that in a char[].\n+   94:      *\n+   95:      * @param c0   the expected contents\n+   96:      * @param file the file to check\n+   97:      * @throws IOException If an I/O error occurs while reading the file contents\n+   98:      */\n+   99:     public static void assertEqualContent(final char[] c0, final Path file) throws IOException {\n+  100:         int count = 0, numRead = 0;\n+  101:         final char[] c1 = new char[c0.length];\n+  102:         try (Reader ir = Files.newBufferedReader(file)) {\n+  103:             while (count < c0.length && numRead >= 0) {\n+  104:                 numRead = ir.read(c1, count, c0.length);\n+  105:                 count += numRead;\n+  106:             }\n+  107:             assertEquals(c0.length, count, \"Different number of chars: \");\n+  108:             for (int i = 0; i < count; i++) {\n+  109:                 assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n+  110:             }\n+  111:         }\n+  112:     }\n", "uniqueId": "010299c21811b11a41c8d5bd73023f75eb29058e_69_89_92_112_81_90", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `assertEqualContent` method for comparing the contents of a file with a `char[]`, we can extract the logic for reading the content from the file into a separate method. This will help in isolating the file reading logic and make the assertion logic clearer.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\n/**\n * Read the contents of a file into a char array.\n *\n * @param file the file to read\n * @return the contents of the file as a char array\n * @throws IOException If an I/O error occurs while reading the file contents\n */\nprivate static char[] readFileContentAsCharArray(final File file) throws IOException {\n    StringBuilder contentBuilder = new StringBuilder();\n    try (Reader ir = Files.newBufferedReader(file.toPath())) {\n        char[] buffer = new char[1024];\n        int numRead;\n        while ((numRead = ir.read(buffer)) != -1) {\n            contentBuilder.append(buffer, 0, numRead);\n        }\n    }\n    return contentBuilder.toString().toCharArray();\n}\n\n/**\n * Assert that the content of a file is equal to that in a char[].\n *\n * @param c0   the expected contents\n * @param file the file to check\n * @throws IOException If an I/O error occurs while reading the file contents\n */\npublic static void assertEqualContent(final char[] c0, final File file) throws IOException {\n    char[] c1 = readFileContentAsCharArray(file);\n    assertEquals(c0.length, c1.length, \"Different number of chars: \");\n    for (int i = 0; i < c0.length; i++) {\n        assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n    }\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic for reading the file content into a `char[]` has been extracted into a new method called `readFileContentAsCharArray`. This method handles the reading of the file and returns the content as a `char[]`.\n2. **Simplified Assertion Method**: The `assertEqualContent` method now simply calls the new method to get the file content and performs the assertions, making it cleaner and easier to understand.\n3. **Buffering**: The reading logic uses a buffer to read the file in chunks, which is more efficient than reading character by character.\n\nThis refactoring enhances the modularity of the code and makes it easier to test and maintain.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final char[] c1 = new char[c0.length];\n        try (Reader ir = Files.newBufferedReader(file.toPath())) {\n            while (count < c0.length && numRead >= 0) {\n                numRead = ir.read(c1, count, c0.length);\n                count += numRead;\n            }\n            assertEquals(c0.length, count, \"Different number of chars: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n            }\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.time.Duration;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.apache.commons.lang3.ThreadUtils;\n\n/**\n * Base class for testcases doing tests with files.\n */\npublic abstract class TestUtils {\n\n    /**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final byte[] b1 = new byte[b0.length];\n        try (InputStream is = Files.newInputStream(file.toPath())) {\n            while (count < b0.length && numRead >= 0) {\n                numRead = is.read(b1, count, b0.length);\n                count += numRead;\n            }\n            assertEquals(b0.length, count, \"Different number of bytes: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final char[] c1 = new char[c0.length];\n        try (Reader ir = Files.newBufferedReader(file.toPath())) {\n            while (count < c0.length && numRead >= 0) {\n                numRead = ir.read(c1, count, c0.length);\n                count += numRead;\n            }\n            assertEquals(c0.length, count, \"Different number of chars: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of two files is the same.\n     */\n    private static void assertEqualContent(final File f0, final File f1)\n            throws IOException {\n        /* This doesn't work because the filesize isn't updated until the file\n         * is closed.\n        assertTrue( \"The files \" + f0 + \" and \" + f1 +\n                    \" have differing file sizes (\" + f0.length() +\n                    \" vs \" + f1.length() + \")\", ( f0.length() == f1.length() ) );\n        */\n        try (InputStream is0 = Files.newInputStream(f0.toPath())) {\n            try (InputStream is1 = Files.newInputStream(f1.toPath())) {\n                final byte[] buf0 = new byte[1024];\n                final byte[] buf1 = new byte[1024];\n                int n0 = 0;\n                int n1;\n\n                while (-1 != n0) {\n                    n0 = is0.read(buf0);\n                    n1 = is1.read(buf1);\n                    assertTrue((n0 == n1),\n                            \"The files \" + f0 + \" and \" + f1 +\n                            \" have differing number of bytes available (\" + n0 + \" vs \" + n1 + \")\");\n\n                    assertArrayEquals(buf0, buf1, \"The files \" + f0 + \" and \" + f1 + \" have different content\");\n                }\n            }\n        }\n    }\n\n    public static void checkFile(final File file, final File referenceFile)\n            throws Exception {\n        assertTrue(file.exists(), \"Check existence of output file\");\n        assertEqualContent(referenceFile, file);\n    }\n\n    public static void checkWrite(final OutputStream output) {\n        try {\n            new java.io.PrintStream(output).write(0);\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void checkWrite(final Writer output) {\n        try {\n            new java.io.PrintWriter(output).write('a');\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void createFile(final File file, final long size)\n            throws IOException {\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static void createLineBasedFile(final File file, final String[] data) throws IOException {\n        if (file.getParentFile() != null && !file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final PrintWriter output = new PrintWriter(new OutputStreamWriter(Files.newOutputStream(file.toPath()), StandardCharsets.UTF_8))) {\n            for (final String element : data) {\n                output.println(element);\n            }\n        }\n    }\n\n    public static void deleteFile(final File file) {\n        if (file.exists()) {\n            assertTrue(file.delete(), \"Couldn't delete file: \" + file);\n        }\n    }\n\n    public static void generateTestData(final File file, final long size) throws IOException, FileNotFoundException {\n        try (final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static byte[] generateTestData(final long size) {\n        try {\n            try (final ByteArrayOutputStream baout = new ByteArrayOutputStream()) {\n                generateTestData(baout, size);\n                return baout.toByteArray();\n            }\n        } catch (final IOException ioe) {\n            throw new IllegalStateException(\"This should never happen: \" + ioe.getMessage(), ioe);\n        }\n    }\n\n    public static void generateTestData(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            // output.write((byte)'X');\n            // nice varied byte pattern compatible with Readers and Writers\n            out.write((byte) ((i % 127) + 1));\n        }\n    }\n\n    public static File newFile(final File testDirectory, final String filename) throws IOException {\n        final File destination = new File(testDirectory, filename);\n        /*\n        assertTrue( filename + \"Test output data file shouldn't previously exist\",\n                    !destination.exists() );\n        */\n        if (destination.exists()) {\n            FileUtils.forceDelete(destination);\n        }\n        return destination;\n    }\n\n    /**\n     * Sleeps for a guaranteed number of milliseconds unless interrupted.\n     *\n     * This method exists because Thread.sleep(100) can sleep for 0, 70, 100 or 200ms or anything else\n     * it deems appropriate. Read the docs on Thread.sleep for further details.\n     *\n     * @param millis the number of milliseconds to sleep.\n     * @throws InterruptedException if interrupted.\n     */\n    public static void sleep(final long millis) throws InterruptedException {\n        ThreadUtils.sleep(Duration.ofMillis(millis));\n    }\n\n    /**\n     * Sleeps and swallows InterruptedException.\n     *\n     * @param millis the number of milliseconds to sleep.\n     */\n    public static void sleepQuietly(final long millis) {\n        try {\n            sleep(millis);\n        } catch (final InterruptedException ignored){\n            // ignore InterruptedException.\n        }\n    }\n\n    private TestUtils() {\n\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic assertEqualContent(b0 byte[], file Path) : void extracted from public assertEqualContent(b0 byte[], file File) : void in class org.apache.commons.io.test.TestUtils", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/test/TestUtils.java", "startLine": 47, "endLine": 67, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/test/TestUtils.java", "startLine": 48, "endLine": 57, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/test/TestUtils.java", "startLine": 59, "endLine": 79, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final byte[] b1 = new byte[b0.length];\n        try (InputStream is = Files.newInputStream(file.toPath())) {\n            while (count < b0.length && numRead >= 0) {\n                numRead = is.read(b1, count, b0.length);\n                count += numRead;\n            }\n            assertEquals(b0.length, count, \"Different number of bytes: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n            }\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/test/TestUtils.java", "isPureRefactoring": true, "commitId": "010299c21811b11a41c8d5bd73023f75eb29058e", "packageNameBefore": "org.apache.commons.io.test", "classNameBefore": "org.apache.commons.io.test.TestUtils", "methodNameBefore": "org.apache.commons.io.test.TestUtils#assertEqualContent", "classSignatureBefore": "public abstract class TestUtils ", "methodNameBeforeSet": ["org.apache.commons.io.test.TestUtils#assertEqualContent"], "classNameBeforeSet": ["org.apache.commons.io.test.TestUtils"], "classSignatureBeforeSet": ["public abstract class TestUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.time.Duration;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.apache.commons.lang3.ThreadUtils;\n\n/**\n * Base class for testcases doing tests with files.\n */\npublic abstract class TestUtils {\n\n    /**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final byte[] b1 = new byte[b0.length];\n        try (InputStream is = Files.newInputStream(file.toPath())) {\n            while (count < b0.length && numRead >= 0) {\n                numRead = is.read(b1, count, b0.length);\n                count += numRead;\n            }\n            assertEquals(b0.length, count, \"Different number of bytes: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final char[] c1 = new char[c0.length];\n        try (Reader ir = Files.newBufferedReader(file.toPath())) {\n            while (count < c0.length && numRead >= 0) {\n                numRead = ir.read(c1, count, c0.length);\n                count += numRead;\n            }\n            assertEquals(c0.length, count, \"Different number of chars: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of two files is the same.\n     */\n    private static void assertEqualContent(final File f0, final File f1)\n            throws IOException {\n        /* This doesn't work because the filesize isn't updated until the file\n         * is closed.\n        assertTrue( \"The files \" + f0 + \" and \" + f1 +\n                    \" have differing file sizes (\" + f0.length() +\n                    \" vs \" + f1.length() + \")\", ( f0.length() == f1.length() ) );\n        */\n        try (InputStream is0 = Files.newInputStream(f0.toPath())) {\n            try (InputStream is1 = Files.newInputStream(f1.toPath())) {\n                final byte[] buf0 = new byte[1024];\n                final byte[] buf1 = new byte[1024];\n                int n0 = 0;\n                int n1;\n\n                while (-1 != n0) {\n                    n0 = is0.read(buf0);\n                    n1 = is1.read(buf1);\n                    assertTrue((n0 == n1),\n                            \"The files \" + f0 + \" and \" + f1 +\n                            \" have differing number of bytes available (\" + n0 + \" vs \" + n1 + \")\");\n\n                    assertArrayEquals(buf0, buf1, \"The files \" + f0 + \" and \" + f1 + \" have different content\");\n                }\n            }\n        }\n    }\n\n    public static void checkFile(final File file, final File referenceFile)\n            throws Exception {\n        assertTrue(file.exists(), \"Check existence of output file\");\n        assertEqualContent(referenceFile, file);\n    }\n\n    public static void checkWrite(final OutputStream output) {\n        try {\n            new java.io.PrintStream(output).write(0);\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void checkWrite(final Writer output) {\n        try {\n            new java.io.PrintWriter(output).write('a');\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void createFile(final File file, final long size)\n            throws IOException {\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static void createLineBasedFile(final File file, final String[] data) throws IOException {\n        if (file.getParentFile() != null && !file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final PrintWriter output = new PrintWriter(new OutputStreamWriter(Files.newOutputStream(file.toPath()), StandardCharsets.UTF_8))) {\n            for (final String element : data) {\n                output.println(element);\n            }\n        }\n    }\n\n    public static void deleteFile(final File file) {\n        if (file.exists()) {\n            assertTrue(file.delete(), \"Couldn't delete file: \" + file);\n        }\n    }\n\n    public static void generateTestData(final File file, final long size) throws IOException, FileNotFoundException {\n        try (final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static byte[] generateTestData(final long size) {\n        try {\n            try (final ByteArrayOutputStream baout = new ByteArrayOutputStream()) {\n                generateTestData(baout, size);\n                return baout.toByteArray();\n            }\n        } catch (final IOException ioe) {\n            throw new IllegalStateException(\"This should never happen: \" + ioe.getMessage(), ioe);\n        }\n    }\n\n    public static void generateTestData(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            // output.write((byte)'X');\n            // nice varied byte pattern compatible with Readers and Writers\n            out.write((byte) ((i % 127) + 1));\n        }\n    }\n\n    public static File newFile(final File testDirectory, final String filename) throws IOException {\n        final File destination = new File(testDirectory, filename);\n        /*\n        assertTrue( filename + \"Test output data file shouldn't previously exist\",\n                    !destination.exists() );\n        */\n        if (destination.exists()) {\n            FileUtils.forceDelete(destination);\n        }\n        return destination;\n    }\n\n    /**\n     * Sleeps for a guaranteed number of milliseconds unless interrupted.\n     *\n     * This method exists because Thread.sleep(100) can sleep for 0, 70, 100 or 200ms or anything else\n     * it deems appropriate. Read the docs on Thread.sleep for further details.\n     *\n     * @param millis the number of milliseconds to sleep.\n     * @throws InterruptedException if interrupted.\n     */\n    public static void sleep(final long millis) throws InterruptedException {\n        ThreadUtils.sleep(Duration.ofMillis(millis));\n    }\n\n    /**\n     * Sleeps and swallows InterruptedException.\n     *\n     * @param millis the number of milliseconds to sleep.\n     */\n    public static void sleepQuietly(final long millis) {\n        try {\n            sleep(millis);\n        } catch (final InterruptedException ignored){\n            // ignore InterruptedException.\n        }\n    }\n\n    private TestUtils() {\n\n    }\n\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/test/TestUtils.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.time.Duration;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.apache.commons.lang3.ThreadUtils;\n\n/**\n * Base class for testcases doing tests with files.\n */\npublic abstract class TestUtils {\n\n    /**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n        assertEqualContent(b0, file.toPath());\n    }\n\n    /**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final Path file) throws IOException {\n        int count = 0, numRead = 0;\n        final byte[] b1 = new byte[b0.length];\n        try (InputStream is = Files.newInputStream(file)) {\n            while (count < b0.length && numRead >= 0) {\n                numRead = is.read(b1, count, b0.length);\n                count += numRead;\n            }\n            assertEquals(b0.length, count, \"Different number of bytes: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n        assertEqualContent(c0, file.toPath());\n    }\n\n    /**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final Path file) throws IOException {\n        int count = 0, numRead = 0;\n        final char[] c1 = new char[c0.length];\n        try (Reader ir = Files.newBufferedReader(file)) {\n            while (count < c0.length && numRead >= 0) {\n                numRead = ir.read(c1, count, c0.length);\n                count += numRead;\n            }\n            assertEquals(c0.length, count, \"Different number of chars: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of two files is the same.\n     */\n    private static void assertEqualContent(final File f0, final File f1)\n            throws IOException {\n        /* This doesn't work because the filesize isn't updated until the file\n         * is closed.\n        assertTrue( \"The files \" + f0 + \" and \" + f1 +\n                    \" have differing file sizes (\" + f0.length() +\n                    \" vs \" + f1.length() + \")\", ( f0.length() == f1.length() ) );\n        */\n        try (InputStream is0 = Files.newInputStream(f0.toPath())) {\n            try (InputStream is1 = Files.newInputStream(f1.toPath())) {\n                final byte[] buf0 = new byte[1024];\n                final byte[] buf1 = new byte[1024];\n                int n0 = 0;\n                int n1;\n\n                while (-1 != n0) {\n                    n0 = is0.read(buf0);\n                    n1 = is1.read(buf1);\n                    assertTrue((n0 == n1),\n                            \"The files \" + f0 + \" and \" + f1 +\n                            \" have differing number of bytes available (\" + n0 + \" vs \" + n1 + \")\");\n\n                    assertArrayEquals(buf0, buf1, \"The files \" + f0 + \" and \" + f1 + \" have different content\");\n                }\n            }\n        }\n    }\n\n    public static void checkFile(final File file, final File referenceFile)\n            throws Exception {\n        assertTrue(file.exists(), \"Check existence of output file\");\n        assertEqualContent(referenceFile, file);\n    }\n\n    public static void checkWrite(final OutputStream output) {\n        try {\n            new java.io.PrintStream(output).write(0);\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void checkWrite(final Writer output) {\n        try {\n            new java.io.PrintWriter(output).write('a');\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void createFile(final File file, final long size)\n            throws IOException {\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static void createLineBasedFile(final File file, final String[] data) throws IOException {\n        if (file.getParentFile() != null && !file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final PrintWriter output = new PrintWriter(new OutputStreamWriter(Files.newOutputStream(file.toPath()), StandardCharsets.UTF_8))) {\n            for (final String element : data) {\n                output.println(element);\n            }\n        }\n    }\n\n    public static void deleteFile(final File file) {\n        if (file.exists()) {\n            assertTrue(file.delete(), \"Couldn't delete file: \" + file);\n        }\n    }\n\n    public static void generateTestData(final File file, final long size) throws IOException, FileNotFoundException {\n        try (final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static byte[] generateTestData(final long size) {\n        try {\n            try (final ByteArrayOutputStream baout = new ByteArrayOutputStream()) {\n                generateTestData(baout, size);\n                return baout.toByteArray();\n            }\n        } catch (final IOException ioe) {\n            throw new IllegalStateException(\"This should never happen: \" + ioe.getMessage(), ioe);\n        }\n    }\n\n    public static void generateTestData(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            // output.write((byte)'X');\n            // nice varied byte pattern compatible with Readers and Writers\n            out.write((byte) ((i % 127) + 1));\n        }\n    }\n\n    public static File newFile(final File testDirectory, final String filename) throws IOException {\n        final File destination = new File(testDirectory, filename);\n        /*\n        assertTrue( filename + \"Test output data file shouldn't previously exist\",\n                    !destination.exists() );\n        */\n        if (destination.exists()) {\n            FileUtils.forceDelete(destination);\n        }\n        return destination;\n    }\n\n    /**\n     * Sleeps for a guaranteed number of milliseconds unless interrupted.\n     *\n     * This method exists because Thread.sleep(100) can sleep for 0, 70, 100 or 200ms or anything else\n     * it deems appropriate. Read the docs on Thread.sleep for further details.\n     *\n     * @param millis the number of milliseconds to sleep.\n     * @throws InterruptedException if interrupted.\n     */\n    public static void sleep(final long millis) throws InterruptedException {\n        ThreadUtils.sleep(Duration.ofMillis(millis));\n    }\n\n    /**\n     * Sleeps and swallows InterruptedException.\n     *\n     * @param millis the number of milliseconds to sleep.\n     */\n    public static void sleepQuietly(final long millis) {\n        try {\n            sleep(millis);\n        } catch (final InterruptedException ignored){\n            // ignore InterruptedException.\n        }\n    }\n\n    private TestUtils() {\n\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final Path file) throws IOException {\n        int count = 0, numRead = 0;\n        final byte[] b1 = new byte[b0.length];\n        try (InputStream is = Files.newInputStream(file)) {\n            while (count < b0.length && numRead >= 0) {\n                numRead = is.read(b1, count, b0.length);\n                count += numRead;\n            }\n            assertEquals(b0.length, count, \"Different number of bytes: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n            }\n        }\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n        assertEqualContent(b0, file.toPath());\n    }\n/**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final Path file) throws IOException {\n        int count = 0, numRead = 0;\n        final byte[] b1 = new byte[b0.length];\n        try (InputStream is = Files.newInputStream(file)) {\n            while (count < b0.length && numRead >= 0) {\n                numRead = is.read(b1, count, b0.length);\n                count += numRead;\n            }\n            assertEquals(b0.length, count, \"Different number of bytes: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n            }\n        }\n    }", "diffSourceCode": "-   47:     /**\n-   48:      * Assert that the content of a file is equal to that in a byte[].\n-   49:      *\n-   50:      * @param b0   the expected contents\n-   51:      * @param file the file to check\n-   52:      * @throws IOException If an I/O error occurs while reading the file contents\n-   53:      */\n-   54:     public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n-   55:         int count = 0, numRead = 0;\n-   56:         final byte[] b1 = new byte[b0.length];\n-   57:         try (InputStream is = Files.newInputStream(file.toPath())) {\n-   58:             while (count < b0.length && numRead >= 0) {\n-   59:                 numRead = is.read(b1, count, b0.length);\n-   60:                 count += numRead;\n-   61:             }\n-   62:             assertEquals(b0.length, count, \"Different number of bytes: \");\n-   63:             for (int i = 0; i < count; i++) {\n-   64:                 assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n-   65:             }\n-   66:         }\n-   67:     }\n-   68: \n-   69:     /**\n-   70:      * Assert that the content of a file is equal to that in a char[].\n-   71:      *\n-   72:      * @param c0   the expected contents\n-   73:      * @param file the file to check\n-   74:      * @throws IOException If an I/O error occurs while reading the file contents\n-   75:      */\n-   76:     public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n-   77:         int count = 0, numRead = 0;\n-   78:         final char[] c1 = new char[c0.length];\n-   79:         try (Reader ir = Files.newBufferedReader(file.toPath())) {\n+   47: \n+   48:     /**\n+   49:      * Assert that the content of a file is equal to that in a byte[].\n+   50:      *\n+   51:      * @param b0   the expected contents\n+   52:      * @param file the file to check\n+   53:      * @throws IOException If an I/O error occurs while reading the file contents\n+   54:      */\n+   55:     public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n+   56:         assertEqualContent(b0, file.toPath());\n+   57:     }\n+   58: \n+   59:     /**\n+   60:      * Assert that the content of a file is equal to that in a byte[].\n+   61:      *\n+   62:      * @param b0   the expected contents\n+   63:      * @param file the file to check\n+   64:      * @throws IOException If an I/O error occurs while reading the file contents\n+   65:      */\n+   66:     public static void assertEqualContent(final byte[] b0, final Path file) throws IOException {\n+   67:         int count = 0, numRead = 0;\n+   68:         final byte[] b1 = new byte[b0.length];\n+   69:         try (InputStream is = Files.newInputStream(file)) {\n+   70:             while (count < b0.length && numRead >= 0) {\n+   71:                 numRead = is.read(b1, count, b0.length);\n+   72:                 count += numRead;\n+   73:             }\n+   74:             assertEquals(b0.length, count, \"Different number of bytes: \");\n+   75:             for (int i = 0; i < count; i++) {\n+   76:                 assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n+   77:             }\n+   78:         }\n+   79:     }\n", "uniqueId": "010299c21811b11a41c8d5bd73023f75eb29058e_47_67_59_79_48_57", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `assertEqualContent` method, we can extract the logic for reading the content of the file into a separate method. This will help to isolate the file reading logic from the assertion logic, making the code cleaner and easier to understand.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\npublic static void assertEqualContent(final byte[] expectedContent, final File file) throws IOException {\n    byte[] actualContent = readFileContentAsBytes(file, expectedContent.length);\n    assertEquals(expectedContent.length, actualContent.length, \"Different number of bytes: \");\n    for (int i = 0; i < actualContent.length; i++) {\n        assertEquals(expectedContent[i], actualContent[i], \"byte \" + i + \" differs\");\n    }\n}\n\nprivate static byte[] readFileContentAsBytes(final File file, int length) throws IOException {\n    byte[] content = new byte[length];\n    try (InputStream is = Files.newInputStream(file.toPath())) {\n        int bytesRead = 0;\n        while (bytesRead < length) {\n            int result = is.read(content, bytesRead, length - bytesRead);\n            if (result == -1) {\n                break; // End of stream\n            }\n            bytesRead += result;\n        }\n    }\n    return content;\n}\n##########################\n```\n\n### Changes Made:\n1. **Extracted Method**: The logic for reading the file content into a byte array has been extracted into a new method called `readFileContentAsBytes`.\n2. **Parameter Renaming**: Renamed parameters in the `assertEqualContent` method for clarity (`b0` to `expectedContent` and `b1` to `actualContent`).\n3. **Simplified Logic**: The reading logic is now encapsulated in a dedicated method, which improves the readability of the `assertEqualContent` method.\n\nThis refactoring enhances the modularity of the code, making it easier to test and maintain.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final byte[] b1 = new byte[b0.length];\n        try (InputStream is = Files.newInputStream(file.toPath())) {\n            while (count < b0.length && numRead >= 0) {\n                numRead = is.read(b1, count, b0.length);\n                count += numRead;\n            }\n            assertEquals(b0.length, count, \"Different number of bytes: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n            }\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.test;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.time.Duration;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.apache.commons.lang3.ThreadUtils;\n\n/**\n * Base class for testcases doing tests with files.\n */\npublic abstract class TestUtils {\n\n    /**\n     * Assert that the content of a file is equal to that in a byte[].\n     *\n     * @param b0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final byte[] b0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final byte[] b1 = new byte[b0.length];\n        try (InputStream is = Files.newInputStream(file.toPath())) {\n            while (count < b0.length && numRead >= 0) {\n                numRead = is.read(b1, count, b0.length);\n                count += numRead;\n            }\n            assertEquals(b0.length, count, \"Different number of bytes: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(b0[i], b1[i], \"byte \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of a file is equal to that in a char[].\n     *\n     * @param c0   the expected contents\n     * @param file the file to check\n     * @throws IOException If an I/O error occurs while reading the file contents\n     */\n    public static void assertEqualContent(final char[] c0, final File file) throws IOException {\n        int count = 0, numRead = 0;\n        final char[] c1 = new char[c0.length];\n        try (Reader ir = Files.newBufferedReader(file.toPath())) {\n            while (count < c0.length && numRead >= 0) {\n                numRead = ir.read(c1, count, c0.length);\n                count += numRead;\n            }\n            assertEquals(c0.length, count, \"Different number of chars: \");\n            for (int i = 0; i < count; i++) {\n                assertEquals(c0[i], c1[i], \"char \" + i + \" differs\");\n            }\n        }\n    }\n\n    /**\n     * Assert that the content of two files is the same.\n     */\n    private static void assertEqualContent(final File f0, final File f1)\n            throws IOException {\n        /* This doesn't work because the filesize isn't updated until the file\n         * is closed.\n        assertTrue( \"The files \" + f0 + \" and \" + f1 +\n                    \" have differing file sizes (\" + f0.length() +\n                    \" vs \" + f1.length() + \")\", ( f0.length() == f1.length() ) );\n        */\n        try (InputStream is0 = Files.newInputStream(f0.toPath())) {\n            try (InputStream is1 = Files.newInputStream(f1.toPath())) {\n                final byte[] buf0 = new byte[1024];\n                final byte[] buf1 = new byte[1024];\n                int n0 = 0;\n                int n1;\n\n                while (-1 != n0) {\n                    n0 = is0.read(buf0);\n                    n1 = is1.read(buf1);\n                    assertTrue((n0 == n1),\n                            \"The files \" + f0 + \" and \" + f1 +\n                            \" have differing number of bytes available (\" + n0 + \" vs \" + n1 + \")\");\n\n                    assertArrayEquals(buf0, buf1, \"The files \" + f0 + \" and \" + f1 + \" have different content\");\n                }\n            }\n        }\n    }\n\n    public static void checkFile(final File file, final File referenceFile)\n            throws Exception {\n        assertTrue(file.exists(), \"Check existence of output file\");\n        assertEqualContent(referenceFile, file);\n    }\n\n    public static void checkWrite(final OutputStream output) {\n        try {\n            new java.io.PrintStream(output).write(0);\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void checkWrite(final Writer output) {\n        try {\n            new java.io.PrintWriter(output).write('a');\n        } catch (final Throwable t) {\n            fail(\"The copy() method closed the stream when it shouldn't have. \" + t.getMessage());\n        }\n    }\n\n    public static void createFile(final File file, final long size)\n            throws IOException {\n        if (!file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static void createLineBasedFile(final File file, final String[] data) throws IOException {\n        if (file.getParentFile() != null && !file.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + file + \" as the parent directory does not exist\");\n        }\n        try (final PrintWriter output = new PrintWriter(new OutputStreamWriter(Files.newOutputStream(file.toPath()), StandardCharsets.UTF_8))) {\n            for (final String element : data) {\n                output.println(element);\n            }\n        }\n    }\n\n    public static void deleteFile(final File file) {\n        if (file.exists()) {\n            assertTrue(file.delete(), \"Couldn't delete file: \" + file);\n        }\n    }\n\n    public static void generateTestData(final File file, final long size) throws IOException, FileNotFoundException {\n        try (final BufferedOutputStream output = new BufferedOutputStream(Files.newOutputStream(file.toPath()))) {\n            generateTestData(output, size);\n        }\n    }\n\n    public static byte[] generateTestData(final long size) {\n        try {\n            try (final ByteArrayOutputStream baout = new ByteArrayOutputStream()) {\n                generateTestData(baout, size);\n                return baout.toByteArray();\n            }\n        } catch (final IOException ioe) {\n            throw new IllegalStateException(\"This should never happen: \" + ioe.getMessage(), ioe);\n        }\n    }\n\n    public static void generateTestData(final OutputStream out, final long size) throws IOException {\n        for (int i = 0; i < size; i++) {\n            // output.write((byte)'X');\n            // nice varied byte pattern compatible with Readers and Writers\n            out.write((byte) ((i % 127) + 1));\n        }\n    }\n\n    public static File newFile(final File testDirectory, final String filename) throws IOException {\n        final File destination = new File(testDirectory, filename);\n        /*\n        assertTrue( filename + \"Test output data file shouldn't previously exist\",\n                    !destination.exists() );\n        */\n        if (destination.exists()) {\n            FileUtils.forceDelete(destination);\n        }\n        return destination;\n    }\n\n    /**\n     * Sleeps for a guaranteed number of milliseconds unless interrupted.\n     *\n     * This method exists because Thread.sleep(100) can sleep for 0, 70, 100 or 200ms or anything else\n     * it deems appropriate. Read the docs on Thread.sleep for further details.\n     *\n     * @param millis the number of milliseconds to sleep.\n     * @throws InterruptedException if interrupted.\n     */\n    public static void sleep(final long millis) throws InterruptedException {\n        ThreadUtils.sleep(Duration.ofMillis(millis));\n    }\n\n    /**\n     * Sleeps and swallows InterruptedException.\n     *\n     * @param millis the number of milliseconds to sleep.\n     */\n    public static void sleepQuietly(final long millis) {\n        try {\n            sleep(millis);\n        } catch (final InterruptedException ignored){\n            // ignore InterruptedException.\n        }\n    }\n\n    private TestUtils() {\n\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic close() : void extracted from public stop() : void in class org.apache.commons.io.input.Tailer", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/input/Tailer.java", "startLine": 970, "endLine": 975, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/input/Tailer.java", "startLine": 978, "endLine": 986, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/input/Tailer.java", "startLine": 771, "endLine": 777, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Requests the tailer to complete its current loop and return.\n     */\n    public void stop() {\n        this.run = false;\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/input/Tailer.java", "isPureRefactoring": true, "commitId": "69e3b819a154793128ec7c0336d33623f6cc8a21", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.Tailer", "methodNameBefore": "org.apache.commons.io.input.Tailer#stop", "classSignatureBefore": "public class Tailer implements Runnable ", "methodNameBeforeSet": ["org.apache.commons.io.input.Tailer#stop"], "classNameBeforeSet": ["org.apache.commons.io.input.Tailer"], "classSignatureBeforeSet": ["public class Tailer implements Runnable "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.apache.commons.io.IOUtils.CR;\nimport static org.apache.commons.io.IOUtils.EOF;\nimport static org.apache.commons.io.IOUtils.LF;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.FileTime;\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.Objects;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.file.PathUtils;\nimport org.apache.commons.io.file.attribute.FileTimes;\n\n/**\n * Simple implementation of the UNIX \"tail -f\" functionality.\n *\n * <h2>1. Create a TailerListener implementation</h2>\n * <p>\n * First you need to create a {@link TailerListener} implementation; ({@link TailerListenerAdapter} is provided for\n * convenience so that you don't have to implement every method).\n * </p>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * public class MyTailerListener extends TailerListenerAdapter {\n *     public void handle(String line) {\n *         System.out.println(line);\n *     }\n * }\n * </pre>\n *\n * <h2>2. Using a Tailer</h2>\n *\n * <p>\n * You can create and use a Tailer in one of four ways:\n * </p>\n * <ul>\n * <li>Using a {@link Builder}</li>\n * <li>Using one of the static helper methods:\n * <ul>\n * <li>{@link Tailer#create(File, TailerListener)}</li>\n * <li>{@link Tailer#create(File, TailerListener, long)}</li>\n * <li>{@link Tailer#create(File, TailerListener, long, boolean)}</li>\n * </ul>\n * </li>\n * <li>Using an {@link java.util.concurrent.Executor}</li>\n * <li>Using a {@link Thread}</li>\n * </ul>\n *\n * <p>\n * An example of each is shown below.\n * </p>\n *\n * <h3>2.1 Using a Builder</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = new Tailer.Builder(file, listener).withDelayDuration(delay).build();\n * </pre>\n *\n * <h3>2.2 Using the static helper method</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = Tailer.create(file, listener, delay);\n * </pre>\n *\n * <h3>2.3 Using an Executor</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = new Tailer(file, listener, delay);\n *\n * // stupid executor impl. for demo purposes\n * Executor executor = new Executor() {\n *     public void execute(Runnable command) {\n *         command.run();\n *     }\n * };\n *\n * executor.execute(tailer);\n * </pre>\n *\n *\n * <h3>2.4 Using a Thread</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = new Tailer(file, listener, delay);\n * Thread thread = new Thread(tailer);\n * thread.setDaemon(true); // optional\n * thread.start();\n * </pre>\n *\n * <h2>3. Stopping a Tailer</h2>\n * <p>\n * Remember to stop the tailer when you have done with it:\n * </p>\n *\n * <pre>\n * tailer.stop();\n * </pre>\n *\n * <h2>4. Interrupting a Tailer</h2>\n * <p>\n * You can interrupt the thread a tailer is running on by calling {@link Thread#interrupt()}.\n * </p>\n *\n * <pre>\n * thread.interrupt();\n * </pre>\n * <p>\n * If you interrupt a tailer, the tailer listener is called with the {@link InterruptedException}.\n * </p>\n * <p>\n * The file is read using the default Charset; this can be overridden if necessary.\n * </p>\n *\n * @see TailerListener\n * @see TailerListenerAdapter\n * @since 2.0\n * @since 2.5 Updated behavior and documentation for {@link Thread#interrupt()}.\n * @since 2.12.0 Add {@link Tailable} and {@link RandomAccessResourceBridge} interfaces to tail of files accessed using\n *        alternative libraries such as jCIFS or <a href=\"https://commons.apache.org/proper/commons-vfs/\">Apache Commons\n *        VFS</a>.\n */\npublic class Tailer implements Runnable {\n\n    /**\n     * Builds a {@link Tailer} with default values.\n     *\n     * @since 2.12.0\n     */\n    public static class Builder {\n\n        private final Tailable tailable;\n        private final TailerListener tailerListener;\n        private Charset charset = DEFAULT_CHARSET;\n        private int bufferSize = IOUtils.DEFAULT_BUFFER_SIZE;\n        private Duration delayDuration = Duration.ofMillis(DEFAULT_DELAY_MILLIS);\n        private boolean end;\n        private boolean reOpen;\n        private boolean startThread = true;\n\n        /**\n         * Creates a builder.\n         *\n         * @param file the file to follow.\n         * @param listener the TailerListener to use.\n         */\n        public Builder(final File file, final TailerListener listener) {\n            this(file.toPath(), listener);\n        }\n\n        /**\n         * Creates a builder.\n         *\n         * @param file the file to follow.\n         * @param listener the TailerListener to use.\n         */\n        public Builder(final Path file, final TailerListener listener) {\n            this(new TailablePath(file), listener);\n        }\n\n        /**\n         * Creates a builder.\n         *\n         * @param tailable the tailable to follow.\n         * @param tailerListener the TailerListener to use.\n         */\n        public Builder(final Tailable tailable, final TailerListener tailerListener) {\n            this.tailable = Objects.requireNonNull(tailable, \"tailable\");\n            this.tailerListener = Objects.requireNonNull(tailerListener, \"tailerListener\");\n        }\n\n        /**\n         * Builds a new configured instance.\n         *\n         * @return a new configured instance.\n         */\n        public Tailer build() {\n            final Tailer tailer = new Tailer(tailable, charset, tailerListener, delayDuration, end, reOpen, bufferSize);\n            if (startThread) {\n                final Thread thread = new Thread(tailer);\n                thread.setDaemon(true);\n                thread.start();\n            }\n            return tailer;\n        }\n\n        /**\n         * Sets the buffer size.\n         *\n         * @param bufferSize Buffer size.\n         * @return Builder with specific buffer size.\n         */\n        public Builder withBufferSize(final int bufferSize) {\n            this.bufferSize = bufferSize;\n            return this;\n        }\n\n        /**\n         * Sets the Charset.\n         *\n         * @param charset the Charset to be used for reading the file.\n         * @return Builder with specific Charset.\n         */\n        public Builder withCharset(final Charset charset) {\n            this.charset = Objects.requireNonNull(charset, \"charset\");\n            return this;\n        }\n\n        /**\n         * Sets the delay duration.\n         *\n         * @param delayDuration the delay between checks of the file for new content.\n         * @return Builder with specific delay duration.\n         */\n        public Builder withDelayDuration(final Duration delayDuration) {\n            this.delayDuration = Objects.requireNonNull(delayDuration, \"delayDuration\");\n            return this;\n        }\n\n        /**\n         * Sets the re-open behavior.\n         *\n         * @param reOpen whether to close/reopen the file between chunks\n         * @return Builder with specific re-open behavior\n         */\n        public Builder withReOpen(final boolean reOpen) {\n            this.reOpen = reOpen;\n            return this;\n        }\n\n        /**\n         * Sets the daemon thread startup behavior.\n         *\n         * @param startThread whether to create a daemon thread automatically.\n         * @return Builder with specific daemon thread startup behavior.\n         */\n        public Builder withStartThread(final boolean startThread) {\n            this.startThread = startThread;\n            return this;\n        }\n\n        /**\n         * Sets the tail start behavior.\n         *\n         * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n         * @return Builder with specific tail start behavior.\n         */\n        public Builder withTailFromEnd(final boolean end) {\n            this.end = end;\n            return this;\n        }\n    }\n\n    /**\n     * Bridges random access to a {@link RandomAccessFile}.\n     */\n    private static final class RandomAccessFileBridge implements RandomAccessResourceBridge {\n\n        private final RandomAccessFile randomAccessFile;\n\n        private RandomAccessFileBridge(final File file, final String mode) throws FileNotFoundException {\n            randomAccessFile = new RandomAccessFile(file, mode);\n        }\n\n        @Override\n        public void close() throws IOException {\n            randomAccessFile.close();\n        }\n\n        @Override\n        public long getPointer() throws IOException {\n            return randomAccessFile.getFilePointer();\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return randomAccessFile.read(b);\n        }\n\n        @Override\n        public void seek(final long position) throws IOException {\n            randomAccessFile.seek(position);\n        }\n\n    }\n\n    /**\n     * Bridges access to a resource for random access, normally a file. Allows substitution of remote files for example\n     * using jCIFS.\n     *\n     * @since 2.12.0\n     */\n    public interface RandomAccessResourceBridge extends Closeable {\n\n        /**\n         * Gets the current offset in this tailable.\n         *\n         * @return the offset from the beginning of the tailable, in bytes, at which the next read or write occurs.\n         * @throws IOException if an I/O error occurs.\n         */\n        long getPointer() throws IOException;\n\n        /**\n         * Reads up to {@code b.length} bytes of data from this tailable into an array of bytes. This method blocks until at\n         * least one byte of input is available.\n         *\n         * @param b the buffer into which the data is read.\n         * @return the total number of bytes read into the buffer, or {@code -1} if there is no more data because the end of\n         *         this tailable has been reached.\n         * @throws IOException If the first byte cannot be read for any reason other than end of tailable, or if the random\n         *         access tailable has been closed, or if some other I/O error occurs.\n         */\n        int read(final byte[] b) throws IOException;\n\n        /**\n         * Sets the file-pointer offset, measured from the beginning of this tailable, at which the next read or write occurs.\n         * The offset may be set beyond the end of the tailable. Setting the offset beyond the end of the tailable does not\n         * change the tailable length. The tailable length will change only by writing after the offset has been set beyond the\n         * end of the tailable.\n         *\n         * @param pos the offset position, measured in bytes from the beginning of the tailable, at which to set the tailable\n         *        pointer.\n         * @throws IOException if {@code pos} is less than {@code 0} or if an I/O error occurs.\n         */\n        void seek(final long pos) throws IOException;\n    }\n\n    /**\n     * A tailable resource like a file.\n     *\n     * @since 2.12.0\n     */\n    public interface Tailable {\n\n        /**\n         * Creates a random access file stream to read from.\n         *\n         * @param mode the access mode {@link RandomAccessFile}\n         * @return a random access file stream to read from\n         * @throws FileNotFoundException if the tailable object does not exist\n         */\n        RandomAccessResourceBridge getRandomAccess(final String mode) throws FileNotFoundException;\n\n        /**\n         * Tests if this tailable is newer than the specified {@code FileTime}.\n         *\n         * @param fileTime the file time reference.\n         * @return true if the {@code File} exists and has been modified after the given {@code FileTime}.\n         * @throws IOException if an I/O error occurs.\n         */\n        boolean isNewer(final FileTime fileTime) throws IOException;\n\n        /**\n         * Gets the last modification {@link FileTime}.\n         *\n         * @return See {@link java.nio.file.Files#getLastModifiedTime(Path, LinkOption...)}.\n         * @throws IOException if an I/O error occurs.\n         */\n        FileTime lastModifiedFileTime() throws IOException;\n\n        /**\n         * Gets the size of this tailable.\n         *\n         * @return The size, in bytes, of this tailable, or {@code 0} if the file does not exist. Some operating systems may\n         *         return {@code 0} for path names denoting system-dependent entities such as devices or pipes.\n         * @throws IOException if an I/O error occurs.\n         */\n        long size() throws IOException;\n    }\n\n    /**\n     * A tailable for a file {@link Path}.\n     */\n    private static final class TailablePath implements Tailable {\n\n        private final Path path;\n        private final LinkOption[] linkOptions;\n\n        private TailablePath(final Path path, final LinkOption... linkOptions) {\n            this.path = Objects.requireNonNull(path, \"path\");\n            this.linkOptions = linkOptions;\n        }\n\n        Path getPath() {\n            return path;\n        }\n\n        @Override\n        public RandomAccessResourceBridge getRandomAccess(final String mode) throws FileNotFoundException {\n            return new RandomAccessFileBridge(path.toFile(), mode);\n        }\n\n        @Override\n        public boolean isNewer(final FileTime fileTime) throws IOException {\n            return PathUtils.isNewer(path, fileTime, linkOptions);\n        }\n\n        @Override\n        public FileTime lastModifiedFileTime() throws IOException {\n            return Files.getLastModifiedTime(path, linkOptions);\n        }\n\n        @Override\n        public long size() throws IOException {\n            return Files.size(path);\n        }\n\n        @Override\n        public String toString() {\n            return \"TailablePath [file=\" + path + \", linkOptions=\" + Arrays.toString(linkOptions) + \"]\";\n        }\n    }\n\n    private static final int DEFAULT_DELAY_MILLIS = 1000;\n\n    private static final String RAF_READ_ONLY_MODE = \"r\";\n\n    // The default charset used for reading files\n    private static final Charset DEFAULT_CHARSET = Charset.defaultCharset();\n\n    /**\n     * Creates and starts a Tailer for the given file.\n     *\n     * @param file the file to follow.\n     * @param charset the character set to use for reading the file.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen whether to close/reopen the file between chunks.\n     * @param bufferSize buffer size.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end,\n        final boolean reOpen, final int bufferSize) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withCharset(charset)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withReOpen(reOpen)\n                .withBufferSize(bufferSize)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file, starting at the beginning of the file with the default delay of 1.0s\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener) {\n        return new Builder(file, listener).build();\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file, starting at the beginning of the file\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file with default buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file with default buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen whether to close/reopen the file between chunks.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withReOpen(reOpen)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen whether to close/reopen the file between chunks.\n     * @param bufferSize buffer size.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,\n        final int bufferSize) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withReOpen(reOpen)\n                .withBufferSize(bufferSize)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param bufferSize buffer size.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withBufferSize(bufferSize)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Buffer on top of RandomAccessResourceBridge.\n     */\n    private final byte[] inbuf;\n\n    /**\n     * The file which will be tailed.\n     */\n    private final Tailable tailable;\n\n    /**\n     * The character set that will be used to read the file.\n     */\n    private final Charset charset;\n\n    /**\n     * The amount of time to wait for the file to be updated.\n     */\n    private final Duration delayDuration;\n\n    /**\n     * Whether to tail from the end or start of file\n     */\n    private final boolean tailAtEnd;\n\n    /**\n     * The listener to notify of events when tailing.\n     */\n    private final TailerListener listener;\n\n    /**\n     * Whether to close and reopen the file whilst waiting for more input.\n     */\n    private final boolean reOpen;\n\n    /**\n     * The tailer will run as long as this value is true.\n     */\n    private volatile boolean run = true;\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param file the file to follow.\n     * @param charset the Charset to be used for reading the file\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @param bufSize Buffer size\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,\n        final int bufSize) {\n        this(new TailablePath(file.toPath()), charset, listener, Duration.ofMillis(delayMillis), end, reOpen, bufSize);\n    }\n\n    /**\n     * Creates a Tailer for the given file, starting from the beginning, with the default delay of 1.0s.\n     *\n     * @param file The file to follow.\n     * @param listener the TailerListener to use.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener) {\n        this(file, listener, DEFAULT_DELAY_MILLIS);\n    }\n\n    /**\n     * Creates a Tailer for the given file, starting from the beginning.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis) {\n        this(file, listener, delayMillis, false);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a delay other than the default 1.0s.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end) {\n        this(file, listener, delayMillis, end, IOUtils.DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a delay other than the default 1.0s.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {\n        this(file, listener, delayMillis, end, reOpen, IOUtils.DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @param bufferSize Buffer size\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen, final int bufferSize) {\n        this(file, DEFAULT_CHARSET, listener, delayMillis, end, reOpen, bufferSize);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param bufferSize Buffer size\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {\n        this(file, listener, delayMillis, end, false, bufferSize);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param tailable the file to follow.\n     * @param charset the Charset to be used for reading the file\n     * @param listener the TailerListener to use.\n     * @param delayDuration the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @param bufferSize Buffer size\n     */\n    private Tailer(final Tailable tailable, final Charset charset, final TailerListener listener, final Duration delayDuration, final boolean end,\n        final boolean reOpen, final int bufferSize) {\n        this.tailable = tailable;\n        this.delayDuration = delayDuration;\n        this.tailAtEnd = end;\n        this.inbuf = IOUtils.byteArray(bufferSize);\n\n        // Save and prepare the listener\n        this.listener = listener;\n        listener.init(this);\n        this.reOpen = reOpen;\n        this.charset = charset;\n    }\n\n    /**\n     * Gets the delay in milliseconds.\n     *\n     * @return the delay in milliseconds.\n     * @deprecated Use {@link #getDelayDuration()}.\n     */\n    @Deprecated\n    public long getDelay() {\n        return delayDuration.toMillis();\n    }\n\n    /**\n     * Gets the delay Duration.\n     *\n     * @return the delay Duration.\n     * @since 2.12.0\n     */\n    public Duration getDelayDuration() {\n        return delayDuration;\n    }\n\n    /**\n     * Gets the file.\n     *\n     * @return the file\n     * @throws IllegalStateException if constructed using a user provided {@link Tailable} implementation\n     */\n    public File getFile() {\n        if (tailable instanceof TailablePath) {\n            return ((TailablePath) tailable).getPath().toFile();\n        }\n        throw new IllegalStateException(\"Cannot extract java.io.File from \" + tailable.getClass().getName());\n    }\n\n    /**\n     * Gets whether to keep on running.\n     *\n     * @return whether to keep on running.\n     * @since 2.5\n     */\n    protected boolean getRun() {\n        return run;\n    }\n\n    /**\n     * Gets the Tailable.\n     *\n     * @return the Tailable\n     * @since 2.12.0\n     */\n    public Tailable getTailable() {\n        return tailable;\n    }\n\n    /**\n     * Reads new lines.\n     *\n     * @param reader The file to read\n     * @return The new position after the lines have been read\n     * @throws java.io.IOException if an I/O error occurs.\n     */\n    private long readLines(final RandomAccessResourceBridge reader) throws IOException {\n        try (ByteArrayOutputStream lineBuf = new ByteArrayOutputStream(64)) {\n            long pos = reader.getPointer();\n            long rePos = pos; // position to re-read\n            int num;\n            boolean seenCR = false;\n            while (getRun() && ((num = reader.read(inbuf)) != EOF)) {\n                for (int i = 0; i < num; i++) {\n                    final byte ch = inbuf[i];\n                    switch (ch) {\n                    case LF:\n                        seenCR = false; // swallow CR before LF\n                        listener.handle(new String(lineBuf.toByteArray(), charset));\n                        lineBuf.reset();\n                        rePos = pos + i + 1;\n                        break;\n                    case CR:\n                        if (seenCR) {\n                            lineBuf.write(CR);\n                        }\n                        seenCR = true;\n                        break;\n                    default:\n                        if (seenCR) {\n                            seenCR = false; // swallow final CR\n                            listener.handle(new String(lineBuf.toByteArray(), charset));\n                            lineBuf.reset();\n                            rePos = pos + i + 1;\n                        }\n                        lineBuf.write(ch);\n                    }\n                }\n                pos = reader.getPointer();\n            }\n\n            reader.seek(rePos); // Ensure we can re-read if necessary\n\n            if (listener instanceof TailerListenerAdapter) {\n                ((TailerListenerAdapter) listener).endOfFileReached();\n            }\n\n            return rePos;\n        }\n    }\n\n    /**\n     * Follows changes in the file, calling {@link TailerListener#handle(String)} with each new line.\n     */\n    @Override\n    public void run() {\n        RandomAccessResourceBridge reader = null;\n        try {\n            FileTime last = FileTimes.EPOCH; // The last time the file was checked for changes\n            long position = 0; // position within the file\n            // Open the file\n            while (getRun() && reader == null) {\n                try {\n                    reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);\n                } catch (final FileNotFoundException e) {\n                    listener.fileNotFound();\n                }\n                if (reader == null) {\n                    Thread.sleep(delayDuration.toMillis());\n                } else {\n                    // The current position in the file\n                    position = tailAtEnd ? tailable.size() : 0;\n                    last = tailable.lastModifiedFileTime();\n                    reader.seek(position);\n                }\n            }\n            while (getRun()) {\n                final boolean newer = tailable.isNewer(last); // IO-279, must be done first\n                // Check the file length to see if it was rotated\n                final long length = tailable.size();\n                if (length < position) {\n                    // File was rotated\n                    listener.fileRotated();\n                    // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n                    // successfully\n                    try (RandomAccessResourceBridge save = reader) {\n                        reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);\n                        // At this point, we're sure that the old file is rotated\n                        // Finish scanning the old file and then we'll start with the new one\n                        try {\n                            readLines(save);\n                        } catch (final IOException ioe) {\n                            listener.handle(ioe);\n                        }\n                        position = 0;\n                    } catch (final FileNotFoundException e) {\n                        // in this case we continue to use the previous reader and position values\n                        listener.fileNotFound();\n                        Thread.sleep(delayDuration.toMillis());\n                    }\n                    continue;\n                }\n                // File was not rotated\n                // See if the file needs to be read again\n                if (length > position) {\n                    // The file has more content than it did last time\n                    position = readLines(reader);\n                    last = tailable.lastModifiedFileTime();\n                } else if (newer) {\n                    /*\n                     * This can happen if the file is truncated or overwritten with the exact same length of information. In cases like\n                     * this, the file position needs to be reset\n                     */\n                    position = 0;\n                    reader.seek(position); // cannot be null here\n\n                    // Now we can read new lines\n                    position = readLines(reader);\n                    last = tailable.lastModifiedFileTime();\n                }\n                if (reOpen && reader != null) {\n                    reader.close();\n                }\n                Thread.sleep(delayDuration.toMillis());\n                if (getRun() && reOpen) {\n                    reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);\n                    reader.seek(position);\n                }\n            }\n        } catch (final InterruptedException e) {\n            Thread.currentThread().interrupt();\n            listener.handle(e);\n        } catch (final Exception e) {\n            listener.handle(e);\n        } finally {\n            try {\n                IOUtils.close(reader);\n            } catch (final IOException e) {\n                listener.handle(e);\n            }\n            stop();\n        }\n    }\n\n    /**\n     * Requests the tailer to complete its current loop and return.\n     */\n    public void stop() {\n        this.run = false;\n    }\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/input/Tailer.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.apache.commons.io.IOUtils.CR;\nimport static org.apache.commons.io.IOUtils.EOF;\nimport static org.apache.commons.io.IOUtils.LF;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.FileTime;\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.Objects;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.file.PathUtils;\nimport org.apache.commons.io.file.attribute.FileTimes;\n\n/**\n * Simple implementation of the UNIX \"tail -f\" functionality.\n *\n * <h2>1. Create a TailerListener implementation</h2>\n * <p>\n * First you need to create a {@link TailerListener} implementation; ({@link TailerListenerAdapter} is provided for\n * convenience so that you don't have to implement every method).\n * </p>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * public class MyTailerListener extends TailerListenerAdapter {\n *     public void handle(String line) {\n *         System.out.println(line);\n *     }\n * }\n * </pre>\n *\n * <h2>2. Using a Tailer</h2>\n *\n * <p>\n * You can create and use a Tailer in one of four ways:\n * </p>\n * <ul>\n * <li>Using a {@link Builder}</li>\n * <li>Using one of the static helper methods:\n * <ul>\n * <li>{@link Tailer#create(File, TailerListener)}</li>\n * <li>{@link Tailer#create(File, TailerListener, long)}</li>\n * <li>{@link Tailer#create(File, TailerListener, long, boolean)}</li>\n * </ul>\n * </li>\n * <li>Using an {@link java.util.concurrent.Executor}</li>\n * <li>Using a {@link Thread}</li>\n * </ul>\n *\n * <p>\n * An example of each is shown below.\n * </p>\n *\n * <h3>2.1 Using a Builder</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = new Tailer.Builder(file, listener).withDelayDuration(delay).build();\n * </pre>\n *\n * <h3>2.2 Using the static helper method</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = Tailer.create(file, listener, delay);\n * </pre>\n *\n * <h3>2.3 Using an Executor</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = new Tailer(file, listener, delay);\n *\n * // stupid executor impl. for demo purposes\n * Executor executor = new Executor() {\n *     public void execute(Runnable command) {\n *         command.run();\n *     }\n * };\n *\n * executor.execute(tailer);\n * </pre>\n *\n *\n * <h3>2.4 Using a Thread</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = new Tailer(file, listener, delay);\n * Thread thread = new Thread(tailer);\n * thread.setDaemon(true); // optional\n * thread.start();\n * </pre>\n *\n * <h2>3. Stopping a Tailer</h2>\n * <p>\n * Remember to stop the tailer when you have done with it:\n * </p>\n *\n * <pre>\n * tailer.stop();\n * </pre>\n *\n * <h2>4. Interrupting a Tailer</h2>\n * <p>\n * You can interrupt the thread a tailer is running on by calling {@link Thread#interrupt()}.\n * </p>\n *\n * <pre>\n * thread.interrupt();\n * </pre>\n * <p>\n * If you interrupt a tailer, the tailer listener is called with the {@link InterruptedException}.\n * </p>\n * <p>\n * The file is read using the default Charset; this can be overridden if necessary.\n * </p>\n *\n * @see TailerListener\n * @see TailerListenerAdapter\n * @since 2.0\n * @since 2.5 Updated behavior and documentation for {@link Thread#interrupt()}.\n * @since 2.12.0 Add {@link Tailable} and {@link RandomAccessResourceBridge} interfaces to tail of files accessed using\n *        alternative libraries such as jCIFS or <a href=\"https://commons.apache.org/proper/commons-vfs/\">Apache Commons\n *        VFS</a>.\n */\npublic class Tailer implements Runnable, AutoCloseable {\n\n    /**\n     * Builds a {@link Tailer} with default values.\n     *\n     * @since 2.12.0\n     */\n    public static class Builder {\n\n        private final Tailable tailable;\n        private final TailerListener tailerListener;\n        private Charset charset = DEFAULT_CHARSET;\n        private int bufferSize = IOUtils.DEFAULT_BUFFER_SIZE;\n        private Duration delayDuration = Duration.ofMillis(DEFAULT_DELAY_MILLIS);\n        private boolean end;\n        private boolean reOpen;\n        private boolean startThread = true;\n\n        /**\n         * Creates a builder.\n         *\n         * @param file the file to follow.\n         * @param listener the TailerListener to use.\n         */\n        public Builder(final File file, final TailerListener listener) {\n            this(file.toPath(), listener);\n        }\n\n        /**\n         * Creates a builder.\n         *\n         * @param file the file to follow.\n         * @param listener the TailerListener to use.\n         */\n        public Builder(final Path file, final TailerListener listener) {\n            this(new TailablePath(file), listener);\n        }\n\n        /**\n         * Creates a builder.\n         *\n         * @param tailable the tailable to follow.\n         * @param tailerListener the TailerListener to use.\n         */\n        public Builder(final Tailable tailable, final TailerListener tailerListener) {\n            this.tailable = Objects.requireNonNull(tailable, \"tailable\");\n            this.tailerListener = Objects.requireNonNull(tailerListener, \"tailerListener\");\n        }\n\n        /**\n         * Builds a new configured instance.\n         *\n         * @return a new configured instance.\n         */\n        public Tailer build() {\n            final Tailer tailer = new Tailer(tailable, charset, tailerListener, delayDuration, end, reOpen, bufferSize);\n            if (startThread) {\n                final Thread thread = new Thread(tailer);\n                thread.setDaemon(true);\n                thread.start();\n            }\n            return tailer;\n        }\n\n        /**\n         * Sets the buffer size.\n         *\n         * @param bufferSize Buffer size.\n         * @return Builder with specific buffer size.\n         */\n        public Builder withBufferSize(final int bufferSize) {\n            this.bufferSize = bufferSize;\n            return this;\n        }\n\n        /**\n         * Sets the Charset.\n         *\n         * @param charset the Charset to be used for reading the file.\n         * @return Builder with specific Charset.\n         */\n        public Builder withCharset(final Charset charset) {\n            this.charset = Objects.requireNonNull(charset, \"charset\");\n            return this;\n        }\n\n        /**\n         * Sets the delay duration.\n         *\n         * @param delayDuration the delay between checks of the file for new content.\n         * @return Builder with specific delay duration.\n         */\n        public Builder withDelayDuration(final Duration delayDuration) {\n            this.delayDuration = Objects.requireNonNull(delayDuration, \"delayDuration\");\n            return this;\n        }\n\n        /**\n         * Sets the re-open behavior.\n         *\n         * @param reOpen whether to close/reopen the file between chunks\n         * @return Builder with specific re-open behavior\n         */\n        public Builder withReOpen(final boolean reOpen) {\n            this.reOpen = reOpen;\n            return this;\n        }\n\n        /**\n         * Sets the daemon thread startup behavior.\n         *\n         * @param startThread whether to create a daemon thread automatically.\n         * @return Builder with specific daemon thread startup behavior.\n         */\n        public Builder withStartThread(final boolean startThread) {\n            this.startThread = startThread;\n            return this;\n        }\n\n        /**\n         * Sets the tail start behavior.\n         *\n         * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n         * @return Builder with specific tail start behavior.\n         */\n        public Builder withTailFromEnd(final boolean end) {\n            this.end = end;\n            return this;\n        }\n    }\n\n    /**\n     * Bridges random access to a {@link RandomAccessFile}.\n     */\n    private static final class RandomAccessFileBridge implements RandomAccessResourceBridge {\n\n        private final RandomAccessFile randomAccessFile;\n\n        private RandomAccessFileBridge(final File file, final String mode) throws FileNotFoundException {\n            randomAccessFile = new RandomAccessFile(file, mode);\n        }\n\n        @Override\n        public void close() throws IOException {\n            randomAccessFile.close();\n        }\n\n        @Override\n        public long getPointer() throws IOException {\n            return randomAccessFile.getFilePointer();\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return randomAccessFile.read(b);\n        }\n\n        @Override\n        public void seek(final long position) throws IOException {\n            randomAccessFile.seek(position);\n        }\n\n    }\n\n    /**\n     * Bridges access to a resource for random access, normally a file. Allows substitution of remote files for example\n     * using jCIFS.\n     *\n     * @since 2.12.0\n     */\n    public interface RandomAccessResourceBridge extends Closeable {\n\n        /**\n         * Gets the current offset in this tailable.\n         *\n         * @return the offset from the beginning of the tailable, in bytes, at which the next read or write occurs.\n         * @throws IOException if an I/O error occurs.\n         */\n        long getPointer() throws IOException;\n\n        /**\n         * Reads up to {@code b.length} bytes of data from this tailable into an array of bytes. This method blocks until at\n         * least one byte of input is available.\n         *\n         * @param b the buffer into which the data is read.\n         * @return the total number of bytes read into the buffer, or {@code -1} if there is no more data because the end of\n         *         this tailable has been reached.\n         * @throws IOException If the first byte cannot be read for any reason other than end of tailable, or if the random\n         *         access tailable has been closed, or if some other I/O error occurs.\n         */\n        int read(final byte[] b) throws IOException;\n\n        /**\n         * Sets the file-pointer offset, measured from the beginning of this tailable, at which the next read or write occurs.\n         * The offset may be set beyond the end of the tailable. Setting the offset beyond the end of the tailable does not\n         * change the tailable length. The tailable length will change only by writing after the offset has been set beyond the\n         * end of the tailable.\n         *\n         * @param pos the offset position, measured in bytes from the beginning of the tailable, at which to set the tailable\n         *        pointer.\n         * @throws IOException if {@code pos} is less than {@code 0} or if an I/O error occurs.\n         */\n        void seek(final long pos) throws IOException;\n    }\n\n    /**\n     * A tailable resource like a file.\n     *\n     * @since 2.12.0\n     */\n    public interface Tailable {\n\n        /**\n         * Creates a random access file stream to read from.\n         *\n         * @param mode the access mode {@link RandomAccessFile}\n         * @return a random access file stream to read from\n         * @throws FileNotFoundException if the tailable object does not exist\n         */\n        RandomAccessResourceBridge getRandomAccess(final String mode) throws FileNotFoundException;\n\n        /**\n         * Tests if this tailable is newer than the specified {@code FileTime}.\n         *\n         * @param fileTime the file time reference.\n         * @return true if the {@code File} exists and has been modified after the given {@code FileTime}.\n         * @throws IOException if an I/O error occurs.\n         */\n        boolean isNewer(final FileTime fileTime) throws IOException;\n\n        /**\n         * Gets the last modification {@link FileTime}.\n         *\n         * @return See {@link java.nio.file.Files#getLastModifiedTime(Path, LinkOption...)}.\n         * @throws IOException if an I/O error occurs.\n         */\n        FileTime lastModifiedFileTime() throws IOException;\n\n        /**\n         * Gets the size of this tailable.\n         *\n         * @return The size, in bytes, of this tailable, or {@code 0} if the file does not exist. Some operating systems may\n         *         return {@code 0} for path names denoting system-dependent entities such as devices or pipes.\n         * @throws IOException if an I/O error occurs.\n         */\n        long size() throws IOException;\n    }\n\n    /**\n     * A tailable for a file {@link Path}.\n     */\n    private static final class TailablePath implements Tailable {\n\n        private final Path path;\n        private final LinkOption[] linkOptions;\n\n        private TailablePath(final Path path, final LinkOption... linkOptions) {\n            this.path = Objects.requireNonNull(path, \"path\");\n            this.linkOptions = linkOptions;\n        }\n\n        Path getPath() {\n            return path;\n        }\n\n        @Override\n        public RandomAccessResourceBridge getRandomAccess(final String mode) throws FileNotFoundException {\n            return new RandomAccessFileBridge(path.toFile(), mode);\n        }\n\n        @Override\n        public boolean isNewer(final FileTime fileTime) throws IOException {\n            return PathUtils.isNewer(path, fileTime, linkOptions);\n        }\n\n        @Override\n        public FileTime lastModifiedFileTime() throws IOException {\n            return Files.getLastModifiedTime(path, linkOptions);\n        }\n\n        @Override\n        public long size() throws IOException {\n            return Files.size(path);\n        }\n\n        @Override\n        public String toString() {\n            return \"TailablePath [file=\" + path + \", linkOptions=\" + Arrays.toString(linkOptions) + \"]\";\n        }\n    }\n\n    private static final int DEFAULT_DELAY_MILLIS = 1000;\n\n    private static final String RAF_READ_ONLY_MODE = \"r\";\n\n    // The default charset used for reading files\n    private static final Charset DEFAULT_CHARSET = Charset.defaultCharset();\n\n    /**\n     * Creates and starts a Tailer for the given file.\n     *\n     * @param file the file to follow.\n     * @param charset the character set to use for reading the file.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen whether to close/reopen the file between chunks.\n     * @param bufferSize buffer size.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end,\n        final boolean reOpen, final int bufferSize) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withCharset(charset)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withReOpen(reOpen)\n                .withBufferSize(bufferSize)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file, starting at the beginning of the file with the default delay of 1.0s\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener) {\n        return new Builder(file, listener).build();\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file, starting at the beginning of the file\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file with default buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file with default buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen whether to close/reopen the file between chunks.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withReOpen(reOpen)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen whether to close/reopen the file between chunks.\n     * @param bufferSize buffer size.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,\n        final int bufferSize) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withReOpen(reOpen)\n                .withBufferSize(bufferSize)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param bufferSize buffer size.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withBufferSize(bufferSize)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Buffer on top of RandomAccessResourceBridge.\n     */\n    private final byte[] inbuf;\n\n    /**\n     * The file which will be tailed.\n     */\n    private final Tailable tailable;\n\n    /**\n     * The character set that will be used to read the file.\n     */\n    private final Charset charset;\n\n    /**\n     * The amount of time to wait for the file to be updated.\n     */\n    private final Duration delayDuration;\n\n    /**\n     * Whether to tail from the end or start of file\n     */\n    private final boolean tailAtEnd;\n\n    /**\n     * The listener to notify of events when tailing.\n     */\n    private final TailerListener listener;\n\n    /**\n     * Whether to close and reopen the file whilst waiting for more input.\n     */\n    private final boolean reOpen;\n\n    /**\n     * The tailer will run as long as this value is true.\n     */\n    private volatile boolean run = true;\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param file the file to follow.\n     * @param charset the Charset to be used for reading the file\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @param bufSize Buffer size\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,\n        final int bufSize) {\n        this(new TailablePath(file.toPath()), charset, listener, Duration.ofMillis(delayMillis), end, reOpen, bufSize);\n    }\n\n    /**\n     * Creates a Tailer for the given file, starting from the beginning, with the default delay of 1.0s.\n     *\n     * @param file The file to follow.\n     * @param listener the TailerListener to use.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener) {\n        this(file, listener, DEFAULT_DELAY_MILLIS);\n    }\n\n    /**\n     * Creates a Tailer for the given file, starting from the beginning.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis) {\n        this(file, listener, delayMillis, false);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a delay other than the default 1.0s.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end) {\n        this(file, listener, delayMillis, end, IOUtils.DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a delay other than the default 1.0s.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {\n        this(file, listener, delayMillis, end, reOpen, IOUtils.DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @param bufferSize Buffer size\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen, final int bufferSize) {\n        this(file, DEFAULT_CHARSET, listener, delayMillis, end, reOpen, bufferSize);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param bufferSize Buffer size\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {\n        this(file, listener, delayMillis, end, false, bufferSize);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param tailable the file to follow.\n     * @param charset the Charset to be used for reading the file\n     * @param listener the TailerListener to use.\n     * @param delayDuration the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @param bufferSize Buffer size\n     */\n    private Tailer(final Tailable tailable, final Charset charset, final TailerListener listener, final Duration delayDuration, final boolean end,\n        final boolean reOpen, final int bufferSize) {\n        this.tailable = tailable;\n        this.delayDuration = delayDuration;\n        this.tailAtEnd = end;\n        this.inbuf = IOUtils.byteArray(bufferSize);\n\n        // Save and prepare the listener\n        this.listener = listener;\n        listener.init(this);\n        this.reOpen = reOpen;\n        this.charset = charset;\n    }\n\n    /**\n     * Requests the tailer to complete its current loop and return.\n     */\n    @Override\n    public void close() {\n        this.run = false;\n    }\n\n    /**\n     * Gets the delay in milliseconds.\n     *\n     * @return the delay in milliseconds.\n     * @deprecated Use {@link #getDelayDuration()}.\n     */\n    @Deprecated\n    public long getDelay() {\n        return delayDuration.toMillis();\n    }\n\n    /**\n     * Gets the delay Duration.\n     *\n     * @return the delay Duration.\n     * @since 2.12.0\n     */\n    public Duration getDelayDuration() {\n        return delayDuration;\n    }\n\n    /**\n     * Gets the file.\n     *\n     * @return the file\n     * @throws IllegalStateException if constructed using a user provided {@link Tailable} implementation\n     */\n    public File getFile() {\n        if (tailable instanceof TailablePath) {\n            return ((TailablePath) tailable).getPath().toFile();\n        }\n        throw new IllegalStateException(\"Cannot extract java.io.File from \" + tailable.getClass().getName());\n    }\n\n    /**\n     * Gets whether to keep on running.\n     *\n     * @return whether to keep on running.\n     * @since 2.5\n     */\n    protected boolean getRun() {\n        return run;\n    }\n\n    /**\n     * Gets the Tailable.\n     *\n     * @return the Tailable\n     * @since 2.12.0\n     */\n    public Tailable getTailable() {\n        return tailable;\n    }\n\n    /**\n     * Reads new lines.\n     *\n     * @param reader The file to read\n     * @return The new position after the lines have been read\n     * @throws java.io.IOException if an I/O error occurs.\n     */\n    private long readLines(final RandomAccessResourceBridge reader) throws IOException {\n        try (ByteArrayOutputStream lineBuf = new ByteArrayOutputStream(64)) {\n            long pos = reader.getPointer();\n            long rePos = pos; // position to re-read\n            int num;\n            boolean seenCR = false;\n            while (getRun() && ((num = reader.read(inbuf)) != EOF)) {\n                for (int i = 0; i < num; i++) {\n                    final byte ch = inbuf[i];\n                    switch (ch) {\n                    case LF:\n                        seenCR = false; // swallow CR before LF\n                        listener.handle(new String(lineBuf.toByteArray(), charset));\n                        lineBuf.reset();\n                        rePos = pos + i + 1;\n                        break;\n                    case CR:\n                        if (seenCR) {\n                            lineBuf.write(CR);\n                        }\n                        seenCR = true;\n                        break;\n                    default:\n                        if (seenCR) {\n                            seenCR = false; // swallow final CR\n                            listener.handle(new String(lineBuf.toByteArray(), charset));\n                            lineBuf.reset();\n                            rePos = pos + i + 1;\n                        }\n                        lineBuf.write(ch);\n                    }\n                }\n                pos = reader.getPointer();\n            }\n\n            reader.seek(rePos); // Ensure we can re-read if necessary\n\n            if (listener instanceof TailerListenerAdapter) {\n                ((TailerListenerAdapter) listener).endOfFileReached();\n            }\n\n            return rePos;\n        }\n    }\n\n    /**\n     * Follows changes in the file, calling {@link TailerListener#handle(String)} with each new line.\n     */\n    @Override\n    public void run() {\n        RandomAccessResourceBridge reader = null;\n        try {\n            FileTime last = FileTimes.EPOCH; // The last time the file was checked for changes\n            long position = 0; // position within the file\n            // Open the file\n            while (getRun() && reader == null) {\n                try {\n                    reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);\n                } catch (final FileNotFoundException e) {\n                    listener.fileNotFound();\n                }\n                if (reader == null) {\n                    Thread.sleep(delayDuration.toMillis());\n                } else {\n                    // The current position in the file\n                    position = tailAtEnd ? tailable.size() : 0;\n                    last = tailable.lastModifiedFileTime();\n                    reader.seek(position);\n                }\n            }\n            while (getRun()) {\n                final boolean newer = tailable.isNewer(last); // IO-279, must be done first\n                // Check the file length to see if it was rotated\n                final long length = tailable.size();\n                if (length < position) {\n                    // File was rotated\n                    listener.fileRotated();\n                    // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n                    // successfully\n                    try (RandomAccessResourceBridge save = reader) {\n                        reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);\n                        // At this point, we're sure that the old file is rotated\n                        // Finish scanning the old file and then we'll start with the new one\n                        try {\n                            readLines(save);\n                        } catch (final IOException ioe) {\n                            listener.handle(ioe);\n                        }\n                        position = 0;\n                    } catch (final FileNotFoundException e) {\n                        // in this case we continue to use the previous reader and position values\n                        listener.fileNotFound();\n                        Thread.sleep(delayDuration.toMillis());\n                    }\n                    continue;\n                }\n                // File was not rotated\n                // See if the file needs to be read again\n                if (length > position) {\n                    // The file has more content than it did last time\n                    position = readLines(reader);\n                    last = tailable.lastModifiedFileTime();\n                } else if (newer) {\n                    /*\n                     * This can happen if the file is truncated or overwritten with the exact same length of information. In cases like\n                     * this, the file position needs to be reset\n                     */\n                    position = 0;\n                    reader.seek(position); // cannot be null here\n\n                    // Now we can read new lines\n                    position = readLines(reader);\n                    last = tailable.lastModifiedFileTime();\n                }\n                if (reOpen && reader != null) {\n                    reader.close();\n                }\n                Thread.sleep(delayDuration.toMillis());\n                if (getRun() && reOpen) {\n                    reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);\n                    reader.seek(position);\n                }\n            }\n        } catch (final InterruptedException e) {\n            Thread.currentThread().interrupt();\n            listener.handle(e);\n        } catch (final Exception e) {\n            listener.handle(e);\n        } finally {\n            try {\n                IOUtils.close(reader);\n            } catch (final IOException e) {\n                listener.handle(e);\n            }\n            close();\n        }\n    }\n\n    /**\n     * Requests the tailer to complete its current loop and return.\n     *\n     * @deprecated Use {@link #close()}.\n     */\n    @Deprecated\n    public void stop() {\n        close();\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Requests the tailer to complete its current loop and return.\n     */\n    @Override\n    public void close() {\n        this.run = false;\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Requests the tailer to complete its current loop and return.\n     *\n     * @deprecated Use {@link #close()}.\n     */\n    @Deprecated\n    public void stop() {\n        close();\n    }\n/**\n     * Requests the tailer to complete its current loop and return.\n     */\n    @Override\n    public void close() {\n        this.run = false;\n    }", "diffSourceCode": "   771:     /**\n-  772:      * Gets the delay in milliseconds.\n-  773:      *\n-  774:      * @return the delay in milliseconds.\n-  775:      * @deprecated Use {@link #getDelayDuration()}.\n-  776:      */\n-  777:     @Deprecated\n-  970:     /**\n-  971:      * Requests the tailer to complete its current loop and return.\n-  972:      */\n-  973:     public void stop() {\n-  974:         this.run = false;\n-  975:     }\n+  772:      * Requests the tailer to complete its current loop and return.\n+  773:      */\n+  774:     @Override\n+  775:     public void close() {\n+  776:         this.run = false;\n+  777:     }\n+  970:                 IOUtils.close(reader);\n+  971:             } catch (final IOException e) {\n+  972:                 listener.handle(e);\n+  973:             }\n+  974:             close();\n+  975:         }\n+  978:     /**\n+  979:      * Requests the tailer to complete its current loop and return.\n+  980:      *\n+  981:      * @deprecated Use {@link #close()}.\n+  982:      */\n+  983:     @Deprecated\n+  984:     public void stop() {\n+  985:         close();\n+  986:     }\n", "uniqueId": "69e3b819a154793128ec7c0336d33623f6cc8a21_970_975_771_777_978_986", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `stop` method in the `Tailer` class, we can extract the logic of stopping the tailer into a separate method. This will make the `stop` method more descriptive and allow for easier modifications in the future if needed.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\npublic void stop() {\n    setRunningState(false);\n}\n\nprivate void setRunningState(boolean state) {\n    this.run = state;\n}\n##########################\n```\n\nIn this refactoring:\n- The `stop` method now calls a new method `setRunningState`, which encapsulates the logic of changing the `run` state. \n- This makes the `stop` method clearer in its intent and separates the concern of managing the running state into its own method, which can be useful if additional logic is needed in the future.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Requests the tailer to complete its current loop and return.\n     */\n    public void stop() {\n        this.run = false;\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.apache.commons.io.IOUtils.CR;\nimport static org.apache.commons.io.IOUtils.EOF;\nimport static org.apache.commons.io.IOUtils.LF;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.FileTime;\nimport java.time.Duration;\nimport java.util.Arrays;\nimport java.util.Objects;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.file.PathUtils;\nimport org.apache.commons.io.file.attribute.FileTimes;\n\n/**\n * Simple implementation of the UNIX \"tail -f\" functionality.\n *\n * <h2>1. Create a TailerListener implementation</h2>\n * <p>\n * First you need to create a {@link TailerListener} implementation; ({@link TailerListenerAdapter} is provided for\n * convenience so that you don't have to implement every method).\n * </p>\n *\n * <p>\n * For example:\n * </p>\n *\n * <pre>\n * public class MyTailerListener extends TailerListenerAdapter {\n *     public void handle(String line) {\n *         System.out.println(line);\n *     }\n * }\n * </pre>\n *\n * <h2>2. Using a Tailer</h2>\n *\n * <p>\n * You can create and use a Tailer in one of four ways:\n * </p>\n * <ul>\n * <li>Using a {@link Builder}</li>\n * <li>Using one of the static helper methods:\n * <ul>\n * <li>{@link Tailer#create(File, TailerListener)}</li>\n * <li>{@link Tailer#create(File, TailerListener, long)}</li>\n * <li>{@link Tailer#create(File, TailerListener, long, boolean)}</li>\n * </ul>\n * </li>\n * <li>Using an {@link java.util.concurrent.Executor}</li>\n * <li>Using a {@link Thread}</li>\n * </ul>\n *\n * <p>\n * An example of each is shown below.\n * </p>\n *\n * <h3>2.1 Using a Builder</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = new Tailer.Builder(file, listener).withDelayDuration(delay).build();\n * </pre>\n *\n * <h3>2.2 Using the static helper method</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = Tailer.create(file, listener, delay);\n * </pre>\n *\n * <h3>2.3 Using an Executor</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = new Tailer(file, listener, delay);\n *\n * // stupid executor impl. for demo purposes\n * Executor executor = new Executor() {\n *     public void execute(Runnable command) {\n *         command.run();\n *     }\n * };\n *\n * executor.execute(tailer);\n * </pre>\n *\n *\n * <h3>2.4 Using a Thread</h3>\n *\n * <pre>\n * TailerListener listener = new MyTailerListener();\n * Tailer tailer = new Tailer(file, listener, delay);\n * Thread thread = new Thread(tailer);\n * thread.setDaemon(true); // optional\n * thread.start();\n * </pre>\n *\n * <h2>3. Stopping a Tailer</h2>\n * <p>\n * Remember to stop the tailer when you have done with it:\n * </p>\n *\n * <pre>\n * tailer.stop();\n * </pre>\n *\n * <h2>4. Interrupting a Tailer</h2>\n * <p>\n * You can interrupt the thread a tailer is running on by calling {@link Thread#interrupt()}.\n * </p>\n *\n * <pre>\n * thread.interrupt();\n * </pre>\n * <p>\n * If you interrupt a tailer, the tailer listener is called with the {@link InterruptedException}.\n * </p>\n * <p>\n * The file is read using the default Charset; this can be overridden if necessary.\n * </p>\n *\n * @see TailerListener\n * @see TailerListenerAdapter\n * @since 2.0\n * @since 2.5 Updated behavior and documentation for {@link Thread#interrupt()}.\n * @since 2.12.0 Add {@link Tailable} and {@link RandomAccessResourceBridge} interfaces to tail of files accessed using\n *        alternative libraries such as jCIFS or <a href=\"https://commons.apache.org/proper/commons-vfs/\">Apache Commons\n *        VFS</a>.\n */\npublic class Tailer implements Runnable {\n\n    /**\n     * Builds a {@link Tailer} with default values.\n     *\n     * @since 2.12.0\n     */\n    public static class Builder {\n\n        private final Tailable tailable;\n        private final TailerListener tailerListener;\n        private Charset charset = DEFAULT_CHARSET;\n        private int bufferSize = IOUtils.DEFAULT_BUFFER_SIZE;\n        private Duration delayDuration = Duration.ofMillis(DEFAULT_DELAY_MILLIS);\n        private boolean end;\n        private boolean reOpen;\n        private boolean startThread = true;\n\n        /**\n         * Creates a builder.\n         *\n         * @param file the file to follow.\n         * @param listener the TailerListener to use.\n         */\n        public Builder(final File file, final TailerListener listener) {\n            this(file.toPath(), listener);\n        }\n\n        /**\n         * Creates a builder.\n         *\n         * @param file the file to follow.\n         * @param listener the TailerListener to use.\n         */\n        public Builder(final Path file, final TailerListener listener) {\n            this(new TailablePath(file), listener);\n        }\n\n        /**\n         * Creates a builder.\n         *\n         * @param tailable the tailable to follow.\n         * @param tailerListener the TailerListener to use.\n         */\n        public Builder(final Tailable tailable, final TailerListener tailerListener) {\n            this.tailable = Objects.requireNonNull(tailable, \"tailable\");\n            this.tailerListener = Objects.requireNonNull(tailerListener, \"tailerListener\");\n        }\n\n        /**\n         * Builds a new configured instance.\n         *\n         * @return a new configured instance.\n         */\n        public Tailer build() {\n            final Tailer tailer = new Tailer(tailable, charset, tailerListener, delayDuration, end, reOpen, bufferSize);\n            if (startThread) {\n                final Thread thread = new Thread(tailer);\n                thread.setDaemon(true);\n                thread.start();\n            }\n            return tailer;\n        }\n\n        /**\n         * Sets the buffer size.\n         *\n         * @param bufferSize Buffer size.\n         * @return Builder with specific buffer size.\n         */\n        public Builder withBufferSize(final int bufferSize) {\n            this.bufferSize = bufferSize;\n            return this;\n        }\n\n        /**\n         * Sets the Charset.\n         *\n         * @param charset the Charset to be used for reading the file.\n         * @return Builder with specific Charset.\n         */\n        public Builder withCharset(final Charset charset) {\n            this.charset = Objects.requireNonNull(charset, \"charset\");\n            return this;\n        }\n\n        /**\n         * Sets the delay duration.\n         *\n         * @param delayDuration the delay between checks of the file for new content.\n         * @return Builder with specific delay duration.\n         */\n        public Builder withDelayDuration(final Duration delayDuration) {\n            this.delayDuration = Objects.requireNonNull(delayDuration, \"delayDuration\");\n            return this;\n        }\n\n        /**\n         * Sets the re-open behavior.\n         *\n         * @param reOpen whether to close/reopen the file between chunks\n         * @return Builder with specific re-open behavior\n         */\n        public Builder withReOpen(final boolean reOpen) {\n            this.reOpen = reOpen;\n            return this;\n        }\n\n        /**\n         * Sets the daemon thread startup behavior.\n         *\n         * @param startThread whether to create a daemon thread automatically.\n         * @return Builder with specific daemon thread startup behavior.\n         */\n        public Builder withStartThread(final boolean startThread) {\n            this.startThread = startThread;\n            return this;\n        }\n\n        /**\n         * Sets the tail start behavior.\n         *\n         * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n         * @return Builder with specific tail start behavior.\n         */\n        public Builder withTailFromEnd(final boolean end) {\n            this.end = end;\n            return this;\n        }\n    }\n\n    /**\n     * Bridges random access to a {@link RandomAccessFile}.\n     */\n    private static final class RandomAccessFileBridge implements RandomAccessResourceBridge {\n\n        private final RandomAccessFile randomAccessFile;\n\n        private RandomAccessFileBridge(final File file, final String mode) throws FileNotFoundException {\n            randomAccessFile = new RandomAccessFile(file, mode);\n        }\n\n        @Override\n        public void close() throws IOException {\n            randomAccessFile.close();\n        }\n\n        @Override\n        public long getPointer() throws IOException {\n            return randomAccessFile.getFilePointer();\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return randomAccessFile.read(b);\n        }\n\n        @Override\n        public void seek(final long position) throws IOException {\n            randomAccessFile.seek(position);\n        }\n\n    }\n\n    /**\n     * Bridges access to a resource for random access, normally a file. Allows substitution of remote files for example\n     * using jCIFS.\n     *\n     * @since 2.12.0\n     */\n    public interface RandomAccessResourceBridge extends Closeable {\n\n        /**\n         * Gets the current offset in this tailable.\n         *\n         * @return the offset from the beginning of the tailable, in bytes, at which the next read or write occurs.\n         * @throws IOException if an I/O error occurs.\n         */\n        long getPointer() throws IOException;\n\n        /**\n         * Reads up to {@code b.length} bytes of data from this tailable into an array of bytes. This method blocks until at\n         * least one byte of input is available.\n         *\n         * @param b the buffer into which the data is read.\n         * @return the total number of bytes read into the buffer, or {@code -1} if there is no more data because the end of\n         *         this tailable has been reached.\n         * @throws IOException If the first byte cannot be read for any reason other than end of tailable, or if the random\n         *         access tailable has been closed, or if some other I/O error occurs.\n         */\n        int read(final byte[] b) throws IOException;\n\n        /**\n         * Sets the file-pointer offset, measured from the beginning of this tailable, at which the next read or write occurs.\n         * The offset may be set beyond the end of the tailable. Setting the offset beyond the end of the tailable does not\n         * change the tailable length. The tailable length will change only by writing after the offset has been set beyond the\n         * end of the tailable.\n         *\n         * @param pos the offset position, measured in bytes from the beginning of the tailable, at which to set the tailable\n         *        pointer.\n         * @throws IOException if {@code pos} is less than {@code 0} or if an I/O error occurs.\n         */\n        void seek(final long pos) throws IOException;\n    }\n\n    /**\n     * A tailable resource like a file.\n     *\n     * @since 2.12.0\n     */\n    public interface Tailable {\n\n        /**\n         * Creates a random access file stream to read from.\n         *\n         * @param mode the access mode {@link RandomAccessFile}\n         * @return a random access file stream to read from\n         * @throws FileNotFoundException if the tailable object does not exist\n         */\n        RandomAccessResourceBridge getRandomAccess(final String mode) throws FileNotFoundException;\n\n        /**\n         * Tests if this tailable is newer than the specified {@code FileTime}.\n         *\n         * @param fileTime the file time reference.\n         * @return true if the {@code File} exists and has been modified after the given {@code FileTime}.\n         * @throws IOException if an I/O error occurs.\n         */\n        boolean isNewer(final FileTime fileTime) throws IOException;\n\n        /**\n         * Gets the last modification {@link FileTime}.\n         *\n         * @return See {@link java.nio.file.Files#getLastModifiedTime(Path, LinkOption...)}.\n         * @throws IOException if an I/O error occurs.\n         */\n        FileTime lastModifiedFileTime() throws IOException;\n\n        /**\n         * Gets the size of this tailable.\n         *\n         * @return The size, in bytes, of this tailable, or {@code 0} if the file does not exist. Some operating systems may\n         *         return {@code 0} for path names denoting system-dependent entities such as devices or pipes.\n         * @throws IOException if an I/O error occurs.\n         */\n        long size() throws IOException;\n    }\n\n    /**\n     * A tailable for a file {@link Path}.\n     */\n    private static final class TailablePath implements Tailable {\n\n        private final Path path;\n        private final LinkOption[] linkOptions;\n\n        private TailablePath(final Path path, final LinkOption... linkOptions) {\n            this.path = Objects.requireNonNull(path, \"path\");\n            this.linkOptions = linkOptions;\n        }\n\n        Path getPath() {\n            return path;\n        }\n\n        @Override\n        public RandomAccessResourceBridge getRandomAccess(final String mode) throws FileNotFoundException {\n            return new RandomAccessFileBridge(path.toFile(), mode);\n        }\n\n        @Override\n        public boolean isNewer(final FileTime fileTime) throws IOException {\n            return PathUtils.isNewer(path, fileTime, linkOptions);\n        }\n\n        @Override\n        public FileTime lastModifiedFileTime() throws IOException {\n            return Files.getLastModifiedTime(path, linkOptions);\n        }\n\n        @Override\n        public long size() throws IOException {\n            return Files.size(path);\n        }\n\n        @Override\n        public String toString() {\n            return \"TailablePath [file=\" + path + \", linkOptions=\" + Arrays.toString(linkOptions) + \"]\";\n        }\n    }\n\n    private static final int DEFAULT_DELAY_MILLIS = 1000;\n\n    private static final String RAF_READ_ONLY_MODE = \"r\";\n\n    // The default charset used for reading files\n    private static final Charset DEFAULT_CHARSET = Charset.defaultCharset();\n\n    /**\n     * Creates and starts a Tailer for the given file.\n     *\n     * @param file the file to follow.\n     * @param charset the character set to use for reading the file.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen whether to close/reopen the file between chunks.\n     * @param bufferSize buffer size.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end,\n        final boolean reOpen, final int bufferSize) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withCharset(charset)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withReOpen(reOpen)\n                .withBufferSize(bufferSize)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file, starting at the beginning of the file with the default delay of 1.0s\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener) {\n        return new Builder(file, listener).build();\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file, starting at the beginning of the file\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file with default buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file with default buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen whether to close/reopen the file between chunks.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withReOpen(reOpen)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen whether to close/reopen the file between chunks.\n     * @param bufferSize buffer size.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,\n        final int bufferSize) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withReOpen(reOpen)\n                .withBufferSize(bufferSize)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Creates and starts a Tailer for the given file.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param bufferSize buffer size.\n     * @return The new tailer.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public static Tailer create(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {\n        //@formatter:off\n        return new Builder(file, listener)\n                .withDelayDuration(Duration.ofMillis(delayMillis))\n                .withTailFromEnd(end)\n                .withBufferSize(bufferSize)\n                .build();\n        //@formatter:on\n    }\n\n    /**\n     * Buffer on top of RandomAccessResourceBridge.\n     */\n    private final byte[] inbuf;\n\n    /**\n     * The file which will be tailed.\n     */\n    private final Tailable tailable;\n\n    /**\n     * The character set that will be used to read the file.\n     */\n    private final Charset charset;\n\n    /**\n     * The amount of time to wait for the file to be updated.\n     */\n    private final Duration delayDuration;\n\n    /**\n     * Whether to tail from the end or start of file\n     */\n    private final boolean tailAtEnd;\n\n    /**\n     * The listener to notify of events when tailing.\n     */\n    private final TailerListener listener;\n\n    /**\n     * Whether to close and reopen the file whilst waiting for more input.\n     */\n    private final boolean reOpen;\n\n    /**\n     * The tailer will run as long as this value is true.\n     */\n    private volatile boolean run = true;\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param file the file to follow.\n     * @param charset the Charset to be used for reading the file\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @param bufSize Buffer size\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final Charset charset, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen,\n        final int bufSize) {\n        this(new TailablePath(file.toPath()), charset, listener, Duration.ofMillis(delayMillis), end, reOpen, bufSize);\n    }\n\n    /**\n     * Creates a Tailer for the given file, starting from the beginning, with the default delay of 1.0s.\n     *\n     * @param file The file to follow.\n     * @param listener the TailerListener to use.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener) {\n        this(file, listener, DEFAULT_DELAY_MILLIS);\n    }\n\n    /**\n     * Creates a Tailer for the given file, starting from the beginning.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis) {\n        this(file, listener, delayMillis, false);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a delay other than the default 1.0s.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end) {\n        this(file, listener, delayMillis, end, IOUtils.DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a delay other than the default 1.0s.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen) {\n        this(file, listener, delayMillis, end, reOpen, IOUtils.DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @param bufferSize Buffer size\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final boolean reOpen, final int bufferSize) {\n        this(file, DEFAULT_CHARSET, listener, delayMillis, end, reOpen, bufferSize);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param file the file to follow.\n     * @param listener the TailerListener to use.\n     * @param delayMillis the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param bufferSize Buffer size\n     * @deprecated Use {@link Builder}.\n     */\n    @Deprecated\n    public Tailer(final File file, final TailerListener listener, final long delayMillis, final boolean end, final int bufferSize) {\n        this(file, listener, delayMillis, end, false, bufferSize);\n    }\n\n    /**\n     * Creates a Tailer for the given file, with a specified buffer size.\n     *\n     * @param tailable the file to follow.\n     * @param charset the Charset to be used for reading the file\n     * @param listener the TailerListener to use.\n     * @param delayDuration the delay between checks of the file for new content in milliseconds.\n     * @param end Set to true to tail from the end of the file, false to tail from the beginning of the file.\n     * @param reOpen if true, close and reopen the file between reading chunks\n     * @param bufferSize Buffer size\n     */\n    private Tailer(final Tailable tailable, final Charset charset, final TailerListener listener, final Duration delayDuration, final boolean end,\n        final boolean reOpen, final int bufferSize) {\n        this.tailable = tailable;\n        this.delayDuration = delayDuration;\n        this.tailAtEnd = end;\n        this.inbuf = IOUtils.byteArray(bufferSize);\n\n        // Save and prepare the listener\n        this.listener = listener;\n        listener.init(this);\n        this.reOpen = reOpen;\n        this.charset = charset;\n    }\n\n    /**\n     * Gets the delay in milliseconds.\n     *\n     * @return the delay in milliseconds.\n     * @deprecated Use {@link #getDelayDuration()}.\n     */\n    @Deprecated\n    public long getDelay() {\n        return delayDuration.toMillis();\n    }\n\n    /**\n     * Gets the delay Duration.\n     *\n     * @return the delay Duration.\n     * @since 2.12.0\n     */\n    public Duration getDelayDuration() {\n        return delayDuration;\n    }\n\n    /**\n     * Gets the file.\n     *\n     * @return the file\n     * @throws IllegalStateException if constructed using a user provided {@link Tailable} implementation\n     */\n    public File getFile() {\n        if (tailable instanceof TailablePath) {\n            return ((TailablePath) tailable).getPath().toFile();\n        }\n        throw new IllegalStateException(\"Cannot extract java.io.File from \" + tailable.getClass().getName());\n    }\n\n    /**\n     * Gets whether to keep on running.\n     *\n     * @return whether to keep on running.\n     * @since 2.5\n     */\n    protected boolean getRun() {\n        return run;\n    }\n\n    /**\n     * Gets the Tailable.\n     *\n     * @return the Tailable\n     * @since 2.12.0\n     */\n    public Tailable getTailable() {\n        return tailable;\n    }\n\n    /**\n     * Reads new lines.\n     *\n     * @param reader The file to read\n     * @return The new position after the lines have been read\n     * @throws java.io.IOException if an I/O error occurs.\n     */\n    private long readLines(final RandomAccessResourceBridge reader) throws IOException {\n        try (ByteArrayOutputStream lineBuf = new ByteArrayOutputStream(64)) {\n            long pos = reader.getPointer();\n            long rePos = pos; // position to re-read\n            int num;\n            boolean seenCR = false;\n            while (getRun() && ((num = reader.read(inbuf)) != EOF)) {\n                for (int i = 0; i < num; i++) {\n                    final byte ch = inbuf[i];\n                    switch (ch) {\n                    case LF:\n                        seenCR = false; // swallow CR before LF\n                        listener.handle(new String(lineBuf.toByteArray(), charset));\n                        lineBuf.reset();\n                        rePos = pos + i + 1;\n                        break;\n                    case CR:\n                        if (seenCR) {\n                            lineBuf.write(CR);\n                        }\n                        seenCR = true;\n                        break;\n                    default:\n                        if (seenCR) {\n                            seenCR = false; // swallow final CR\n                            listener.handle(new String(lineBuf.toByteArray(), charset));\n                            lineBuf.reset();\n                            rePos = pos + i + 1;\n                        }\n                        lineBuf.write(ch);\n                    }\n                }\n                pos = reader.getPointer();\n            }\n\n            reader.seek(rePos); // Ensure we can re-read if necessary\n\n            if (listener instanceof TailerListenerAdapter) {\n                ((TailerListenerAdapter) listener).endOfFileReached();\n            }\n\n            return rePos;\n        }\n    }\n\n    /**\n     * Follows changes in the file, calling {@link TailerListener#handle(String)} with each new line.\n     */\n    @Override\n    public void run() {\n        RandomAccessResourceBridge reader = null;\n        try {\n            FileTime last = FileTimes.EPOCH; // The last time the file was checked for changes\n            long position = 0; // position within the file\n            // Open the file\n            while (getRun() && reader == null) {\n                try {\n                    reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);\n                } catch (final FileNotFoundException e) {\n                    listener.fileNotFound();\n                }\n                if (reader == null) {\n                    Thread.sleep(delayDuration.toMillis());\n                } else {\n                    // The current position in the file\n                    position = tailAtEnd ? tailable.size() : 0;\n                    last = tailable.lastModifiedFileTime();\n                    reader.seek(position);\n                }\n            }\n            while (getRun()) {\n                final boolean newer = tailable.isNewer(last); // IO-279, must be done first\n                // Check the file length to see if it was rotated\n                final long length = tailable.size();\n                if (length < position) {\n                    // File was rotated\n                    listener.fileRotated();\n                    // Reopen the reader after rotation ensuring that the old file is closed iff we re-open it\n                    // successfully\n                    try (RandomAccessResourceBridge save = reader) {\n                        reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);\n                        // At this point, we're sure that the old file is rotated\n                        // Finish scanning the old file and then we'll start with the new one\n                        try {\n                            readLines(save);\n                        } catch (final IOException ioe) {\n                            listener.handle(ioe);\n                        }\n                        position = 0;\n                    } catch (final FileNotFoundException e) {\n                        // in this case we continue to use the previous reader and position values\n                        listener.fileNotFound();\n                        Thread.sleep(delayDuration.toMillis());\n                    }\n                    continue;\n                }\n                // File was not rotated\n                // See if the file needs to be read again\n                if (length > position) {\n                    // The file has more content than it did last time\n                    position = readLines(reader);\n                    last = tailable.lastModifiedFileTime();\n                } else if (newer) {\n                    /*\n                     * This can happen if the file is truncated or overwritten with the exact same length of information. In cases like\n                     * this, the file position needs to be reset\n                     */\n                    position = 0;\n                    reader.seek(position); // cannot be null here\n\n                    // Now we can read new lines\n                    position = readLines(reader);\n                    last = tailable.lastModifiedFileTime();\n                }\n                if (reOpen && reader != null) {\n                    reader.close();\n                }\n                Thread.sleep(delayDuration.toMillis());\n                if (getRun() && reOpen) {\n                    reader = tailable.getRandomAccess(RAF_READ_ONLY_MODE);\n                    reader.seek(position);\n                }\n            }\n        } catch (final InterruptedException e) {\n            Thread.currentThread().interrupt();\n            listener.handle(e);\n        } catch (final Exception e) {\n            listener.handle(e);\n        } finally {\n            try {\n                IOUtils.close(reader);\n            } catch (final IOException e) {\n                listener.handle(e);\n            }\n            stop();\n        }\n    }\n\n    /**\n     * Requests the tailer to complete its current loop and return.\n     */\n    public void stop() {\n        this.run = false;\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic createRandomAccessFile() : RandomAccessFile extracted from public testFileCleanerFile() : void in class org.apache.commons.io.FileCleaningTrackerTestCase", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "startLine": 274, "endLine": 295, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "startLine": 279, "endLine": 300, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "startLine": 54, "endLine": 56, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "isPureRefactoring": true, "commitId": "e95c77c48c15243128da550f068b8c25cedefb0f", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.FileCleaningTrackerTestCase", "methodNameBefore": "org.apache.commons.io.FileCleaningTrackerTestCase#testFileCleanerFile", "invokedMethod": "methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#waitUntilTrackCount\n methodBody: private void waitUntilTrackCount() throws Exception {\nSystem.gc();\nTestUtils.sleep(500);\nint count=0;\nwhile(theInstance.getTrackCount() != 0 && count++ < 5){List<String> list=new ArrayList<>();\ntrylong i=0;\nwhile(theInstance.getTrackCount() != 0){list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n}catch(final Throwable ignored)list=null;\nSystem.gc();\nTestUtils.sleep(1000);\n}if(theInstance.getTrackCount() != 0){throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n}}\nmethodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#showFailures\n methodBody: private String showFailures() {\nif(theInstance.deleteFailures.size() == 1){return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n}return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n}\nmethodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#pauseForDeleteToComplete\n methodBody: private void pauseForDeleteToComplete(File file) {\nint count=0;\nwhile(file.exists() && count++ < 40){tryTestUtils.sleep(500L);\ncatch(final InterruptedException ignore)file=new File(file.getPath());\n}}", "classSignatureBefore": "public class FileCleaningTrackerTestCase ", "methodNameBeforeSet": ["org.apache.commons.io.FileCleaningTrackerTestCase#testFileCleanerFile"], "classNameBeforeSet": ["org.apache.commons.io.FileCleaningTrackerTestCase"], "classSignatureBeforeSet": ["public class FileCleaningTrackerTestCase "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.ref.ReferenceQueue;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * This is used to test {@link FileCleaningTracker} for correctness.\n *\n * @see FileCleaningTracker\n */\npublic class FileCleaningTrackerTestCase {\n\n    @TempDir\n    public File temporaryFolder;\n\n    private File testFile;\n\n    private FileCleaningTracker theInstance;\n    protected FileCleaningTracker newInstance() {\n        return new FileCleaningTracker();\n    }\n\n    private void pauseForDeleteToComplete(File file) {\n        int count = 0;\n        while(file.exists() && count++ < 40) {\n            try {\n                TestUtils.sleep(500L);\n            } catch (final InterruptedException ignore) {\n            }\n            file = new File(file.getPath());\n        }\n    }\n\n    /**\n     */\n    @BeforeEach\n    public void setUp() {\n        testFile = new File(temporaryFolder, \"file-test.txt\");\n        theInstance = newInstance();\n    }\n\n    private String showFailures() {\n        if (theInstance.deleteFailures.size() == 1) {\n            return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n        }\n        return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n    }\n\n    @AfterEach\n    public void tearDown() {\n\n        // reset file cleaner class, so as not to break other tests\n\n        /**\n         * The following block of code can possibly be removed when the deprecated {@link FileCleaner} is gone. The\n         * question is, whether we want to support reuse of {@link FileCleaningTracker} instances, which we should, IMO,\n         * not.\n         */\n        {\n            if (theInstance != null) {\n                theInstance.q = new ReferenceQueue<>();\n                theInstance.trackers.clear();\n                theInstance.deleteFailures.clear();\n                theInstance.exitWhenFinished = false;\n                theInstance.reaper = null;\n            }\n        }\n\n        theInstance = null;\n    }\n\n    @Test\n    public void testFileCleanerDirectory() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerDirectory_ForceStrategy() throws Exception {\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            TestUtils.generateTestData(output, 100);\n        }\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, FileDeleteStrategy.FORCE);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(testFile.getParentFile());\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(testFile.getPath()).exists(), showFailures());\n        assertFalse(testFile.getParentFile().exists(), showFailures());\n    }\n\n    @Test\n    public void testFileCleanerDirectory_NullStrategy() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, null);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished_NoTrackAfter() {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        final String path = testFile.getPath();\n        final Object marker = new Object();\n        try {\n            theInstance.track(path, marker);\n            fail();\n        } catch (final IllegalStateException ex) {\n            // expected\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinishedFirst() throws Exception {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\n    @Test\n    public void testFileCleanerNull() {\n        try {\n            theInstance.track((File) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((File) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n    }\n\n    private void waitUntilTrackCount() throws Exception {\n        System.gc();\n        TestUtils.sleep(500);\n        int count = 0;\n        while(theInstance.getTrackCount() != 0 && count++ < 5) {\n            List<String> list = new ArrayList<>();\n            try {\n                long i = 0;\n                while (theInstance.getTrackCount() != 0) {\n                    list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n                }\n            } catch (final Throwable ignored) {\n            }\n            list = null;\n            System.gc();\n            TestUtils.sleep(1000);\n        }\n        if (theInstance.getTrackCount() != 0) {\n            throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n        }\n\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.ref.ReferenceQueue;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * This is used to test {@link FileCleaningTracker} for correctness.\n *\n * @see FileCleaningTracker\n */\npublic class FileCleaningTrackerTestCase {\n\n    @TempDir\n    public File temporaryFolder;\n\n    private File testFile;\n\n    private FileCleaningTracker theInstance;\n    public RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n        return new RandomAccessFile(testFile, \"rw\");\n    }\n\n    protected FileCleaningTracker newInstance() {\n        return new FileCleaningTracker();\n    }\n\n    private void pauseForDeleteToComplete(File file) {\n        int count = 0;\n        while(file.exists() && count++ < 40) {\n            try {\n                TestUtils.sleep(500L);\n            } catch (final InterruptedException ignore) {\n            }\n            file = new File(file.getPath());\n        }\n    }\n\n    /**\n     */\n    @BeforeEach\n    public void setUp() {\n        testFile = new File(temporaryFolder, \"file-test.txt\");\n        theInstance = newInstance();\n    }\n\n    private String showFailures() {\n        if (theInstance.deleteFailures.size() == 1) {\n            return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n        }\n        return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n    }\n\n    @AfterEach\n    public void tearDown() {\n\n        // reset file cleaner class, so as not to break other tests\n\n        /**\n         * The following block of code can possibly be removed when the deprecated {@link FileCleaner} is gone. The\n         * question is, whether we want to support reuse of {@link FileCleaningTracker} instances, which we should, IMO,\n         * not.\n         */\n        {\n            if (theInstance != null) {\n                theInstance.q = new ReferenceQueue<>();\n                theInstance.trackers.clear();\n                theInstance.deleteFailures.clear();\n                theInstance.exitWhenFinished = false;\n                theInstance.reaper = null;\n            }\n        }\n\n        theInstance = null;\n    }\n\n    @Test\n    public void testFileCleanerDirectory() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerDirectory_ForceStrategy() throws Exception {\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            TestUtils.generateTestData(output, 100);\n        }\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, FileDeleteStrategy.FORCE);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(testFile.getParentFile());\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(testFile.getPath()).exists(), showFailures());\n        assertFalse(testFile.getParentFile().exists(), showFailures());\n    }\n\n    @Test\n    public void testFileCleanerDirectory_NullStrategy() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, null);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished_NoTrackAfter() {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        final String path = testFile.getPath();\n        final Object marker = new Object();\n        try {\n            theInstance.track(path, marker);\n            fail();\n        } catch (final IllegalStateException ex) {\n            // expected\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinishedFirst() throws Exception {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\n    @Test\n    public void testFileCleanerNull() {\n        try {\n            theInstance.track((File) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((File) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n    }\n\n    private void waitUntilTrackCount() throws Exception {\n        System.gc();\n        TestUtils.sleep(500);\n        int count = 0;\n        while(theInstance.getTrackCount() != 0 && count++ < 5) {\n            List<String> list = new ArrayList<>();\n            try {\n                long i = 0;\n                while (theInstance.getTrackCount() != 0) {\n                    list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n                }\n            } catch (final Throwable ignored) {\n            }\n            list = null;\n            System.gc();\n            TestUtils.sleep(1000);\n        }\n        if (theInstance.getTrackCount() != 0) {\n            throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n        }\n\n    }\n}\n", "diffSourceCodeSet": ["public RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n        return new RandomAccessFile(testFile, \"rw\");\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#waitUntilTrackCount\n methodBody: private void waitUntilTrackCount() throws Exception {\nSystem.gc();\nTestUtils.sleep(500);\nint count=0;\nwhile(theInstance.getTrackCount() != 0 && count++ < 5){List<String> list=new ArrayList<>();\ntrylong i=0;\nwhile(theInstance.getTrackCount() != 0){list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n}catch(final Throwable ignored)list=null;\nSystem.gc();\nTestUtils.sleep(1000);\n}if(theInstance.getTrackCount() != 0){throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n}}", "methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#showFailures\n methodBody: private String showFailures() {\nif(theInstance.deleteFailures.size() == 1){return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n}return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n}", "methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#pauseForDeleteToComplete\n methodBody: private void pauseForDeleteToComplete(File file) {\nint count=0;\nwhile(file.exists() && count++ < 40){tryTestUtils.sleep(500L);\ncatch(final InterruptedException ignore)file=new File(file.getPath());\n}}"], "sourceCodeAfterRefactoring": "@Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\npublic RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n        return new RandomAccessFile(testFile, \"rw\");\n    }", "diffSourceCode": "-   54:         return new FileCleaningTracker();\n-   55:     }\n-   56: \n-  274:     @Test\n-  275:     public void testFileCleanerFile() throws Exception {\n-  276:         final String path = testFile.getPath();\n-  277: \n-  278:         assertFalse(testFile.exists());\n-  279:         RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n-  280:         assertTrue(testFile.exists());\n-  281: \n-  282:         assertEquals(0, theInstance.getTrackCount());\n-  283:         theInstance.track(path, r);\n-  284:         assertEquals(1, theInstance.getTrackCount());\n-  285: \n-  286:         r.close();\n-  287:         testFile = null;\n-  288:         r = null;\n-  289: \n-  290:         waitUntilTrackCount();\n-  291:         pauseForDeleteToComplete(new File(path));\n-  292: \n-  293:         assertEquals(0, theInstance.getTrackCount());\n-  294:         assertFalse(new File(path).exists(), showFailures());\n-  295:     }\n-  296:     @Test\n-  297:     public void testFileCleanerNull() {\n-  298:         try {\n-  299:             theInstance.track((File) null, new Object());\n-  300:             fail();\n+   54:     public RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n+   55:         return new RandomAccessFile(testFile, \"rw\");\n+   56:     }\n+  274:         assertEquals(0, theInstance.getTrackCount());\n+  275:         assertTrue(theInstance.exitWhenFinished);\n+  276:         assertNull(theInstance.reaper);\n+  277:     }\n+  278: \n+  279:     @Test\n+  280:     public void testFileCleanerFile() throws Exception {\n+  281:         final String path = testFile.getPath();\n+  282: \n+  283:         assertFalse(testFile.exists());\n+  284:         RandomAccessFile r = createRandomAccessFile();\n+  285:         assertTrue(testFile.exists());\n+  286: \n+  287:         assertEquals(0, theInstance.getTrackCount());\n+  288:         theInstance.track(path, r);\n+  289:         assertEquals(1, theInstance.getTrackCount());\n+  290: \n+  291:         r.close();\n+  292:         testFile = null;\n+  293:         r = null;\n+  294: \n+  295:         waitUntilTrackCount();\n+  296:         pauseForDeleteToComplete(new File(path));\n+  297: \n+  298:         assertEquals(0, theInstance.getTrackCount());\n+  299:         assertFalse(new File(path).exists(), showFailures());\n+  300:     }\n", "uniqueId": "e95c77c48c15243128da550f068b8c25cedefb0f_274_295_54_56_279_300", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testFileCleanerFile` method, we can extract the logic related to file tracking and cleanup into a separate method. This will help to encapsulate the functionality and make the test method more concise.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\nprivate void trackAndCleanFile(String path) throws Exception {\n    assertFalse(testFile.exists());\n    try (RandomAccessFile r = new RandomAccessFile(testFile, \"rw\")) {\n        assertTrue(testFile.exists());\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n    }\n\n    testFile = null;\n\n    waitUntilTrackCount();\n    pauseForDeleteToComplete(new File(path));\n\n    assertEquals(0, theInstance.getTrackCount());\n    assertFalse(new File(path).exists(), showFailures());\n}\n\n@Test\npublic void testFileCleanerFile() throws Exception {\n    final String path = testFile.getPath();\n    trackAndCleanFile(path);\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic for tracking and cleaning the file has been extracted into a new method called `trackAndCleanFile`. This method takes the file path as a parameter and encapsulates the functionality related to file operations.\n2. **Try-With-Resources**: The `RandomAccessFile` is now managed using a try-with-resources statement, which ensures that the file is closed automatically, improving resource management.\n3. **Simplified Test Method**: The `testFileCleanerFile` method now simply calls the new method, making it easier to read and understand the intent of the test.\n\nThis refactoring enhances the modularity of the code and makes it easier to maintain in the future.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.ref.ReferenceQueue;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * This is used to test {@link FileCleaningTracker} for correctness.\n *\n * @see FileCleaningTracker\n */\npublic class FileCleaningTrackerTestCase {\n\n    @TempDir\n    public File temporaryFolder;\n\n    private File testFile;\n\n    private FileCleaningTracker theInstance;\n    protected FileCleaningTracker newInstance() {\n        return new FileCleaningTracker();\n    }\n\n    private void pauseForDeleteToComplete(File file) {\n        int count = 0;\n        while(file.exists() && count++ < 40) {\n            try {\n                TestUtils.sleep(500L);\n            } catch (final InterruptedException ignore) {\n            }\n            file = new File(file.getPath());\n        }\n    }\n\n    /**\n     */\n    @BeforeEach\n    public void setUp() {\n        testFile = new File(temporaryFolder, \"file-test.txt\");\n        theInstance = newInstance();\n    }\n\n    private String showFailures() {\n        if (theInstance.deleteFailures.size() == 1) {\n            return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n        }\n        return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n    }\n\n    @AfterEach\n    public void tearDown() {\n\n        // reset file cleaner class, so as not to break other tests\n\n        /**\n         * The following block of code can possibly be removed when the deprecated {@link FileCleaner} is gone. The\n         * question is, whether we want to support reuse of {@link FileCleaningTracker} instances, which we should, IMO,\n         * not.\n         */\n        {\n            if (theInstance != null) {\n                theInstance.q = new ReferenceQueue<>();\n                theInstance.trackers.clear();\n                theInstance.deleteFailures.clear();\n                theInstance.exitWhenFinished = false;\n                theInstance.reaper = null;\n            }\n        }\n\n        theInstance = null;\n    }\n\n    @Test\n    public void testFileCleanerDirectory() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerDirectory_ForceStrategy() throws Exception {\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            TestUtils.generateTestData(output, 100);\n        }\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, FileDeleteStrategy.FORCE);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(testFile.getParentFile());\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(testFile.getPath()).exists(), showFailures());\n        assertFalse(testFile.getParentFile().exists(), showFailures());\n    }\n\n    @Test\n    public void testFileCleanerDirectory_NullStrategy() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, null);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished_NoTrackAfter() {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        final String path = testFile.getPath();\n        final Object marker = new Object();\n        try {\n            theInstance.track(path, marker);\n            fail();\n        } catch (final IllegalStateException ex) {\n            // expected\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinishedFirst() throws Exception {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\n    @Test\n    public void testFileCleanerNull() {\n        try {\n            theInstance.track((File) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((File) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n    }\n\n    private void waitUntilTrackCount() throws Exception {\n        System.gc();\n        TestUtils.sleep(500);\n        int count = 0;\n        while(theInstance.getTrackCount() != 0 && count++ < 5) {\n            List<String> list = new ArrayList<>();\n            try {\n                long i = 0;\n                while (theInstance.getTrackCount() != 0) {\n                    list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n                }\n            } catch (final Throwable ignored) {\n            }\n            list = null;\n            System.gc();\n            TestUtils.sleep(1000);\n        }\n        if (theInstance.getTrackCount() != 0) {\n            throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n        }\n\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic createRandomAccessFile() : RandomAccessFile extracted from public testFileCleanerExitWhenFinished2() : void in class org.apache.commons.io.FileCleaningTrackerTestCase", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "startLine": 225, "endLine": 258, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "startLine": 230, "endLine": 263, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "startLine": 54, "endLine": 56, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "isPureRefactoring": true, "commitId": "e95c77c48c15243128da550f068b8c25cedefb0f", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.FileCleaningTrackerTestCase", "methodNameBefore": "org.apache.commons.io.FileCleaningTrackerTestCase#testFileCleanerExitWhenFinished2", "invokedMethod": "methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#waitUntilTrackCount\n methodBody: private void waitUntilTrackCount() throws Exception {\nSystem.gc();\nTestUtils.sleep(500);\nint count=0;\nwhile(theInstance.getTrackCount() != 0 && count++ < 5){List<String> list=new ArrayList<>();\ntrylong i=0;\nwhile(theInstance.getTrackCount() != 0){list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n}catch(final Throwable ignored)list=null;\nSystem.gc();\nTestUtils.sleep(1000);\n}if(theInstance.getTrackCount() != 0){throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n}}\nmethodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#showFailures\n methodBody: private String showFailures() {\nif(theInstance.deleteFailures.size() == 1){return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n}return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n}\nmethodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#pauseForDeleteToComplete\n methodBody: private void pauseForDeleteToComplete(File file) {\nint count=0;\nwhile(file.exists() && count++ < 40){tryTestUtils.sleep(500L);\ncatch(final InterruptedException ignore)file=new File(file.getPath());\n}}", "classSignatureBefore": "public class FileCleaningTrackerTestCase ", "methodNameBeforeSet": ["org.apache.commons.io.FileCleaningTrackerTestCase#testFileCleanerExitWhenFinished2"], "classNameBeforeSet": ["org.apache.commons.io.FileCleaningTrackerTestCase"], "classSignatureBeforeSet": ["public class FileCleaningTrackerTestCase "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.ref.ReferenceQueue;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * This is used to test {@link FileCleaningTracker} for correctness.\n *\n * @see FileCleaningTracker\n */\npublic class FileCleaningTrackerTestCase {\n\n    @TempDir\n    public File temporaryFolder;\n\n    private File testFile;\n\n    private FileCleaningTracker theInstance;\n    protected FileCleaningTracker newInstance() {\n        return new FileCleaningTracker();\n    }\n\n    private void pauseForDeleteToComplete(File file) {\n        int count = 0;\n        while(file.exists() && count++ < 40) {\n            try {\n                TestUtils.sleep(500L);\n            } catch (final InterruptedException ignore) {\n            }\n            file = new File(file.getPath());\n        }\n    }\n\n    /**\n     */\n    @BeforeEach\n    public void setUp() {\n        testFile = new File(temporaryFolder, \"file-test.txt\");\n        theInstance = newInstance();\n    }\n\n    private String showFailures() {\n        if (theInstance.deleteFailures.size() == 1) {\n            return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n        }\n        return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n    }\n\n    @AfterEach\n    public void tearDown() {\n\n        // reset file cleaner class, so as not to break other tests\n\n        /**\n         * The following block of code can possibly be removed when the deprecated {@link FileCleaner} is gone. The\n         * question is, whether we want to support reuse of {@link FileCleaningTracker} instances, which we should, IMO,\n         * not.\n         */\n        {\n            if (theInstance != null) {\n                theInstance.q = new ReferenceQueue<>();\n                theInstance.trackers.clear();\n                theInstance.deleteFailures.clear();\n                theInstance.exitWhenFinished = false;\n                theInstance.reaper = null;\n            }\n        }\n\n        theInstance = null;\n    }\n\n    @Test\n    public void testFileCleanerDirectory() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerDirectory_ForceStrategy() throws Exception {\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            TestUtils.generateTestData(output, 100);\n        }\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, FileDeleteStrategy.FORCE);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(testFile.getParentFile());\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(testFile.getPath()).exists(), showFailures());\n        assertFalse(testFile.getParentFile().exists(), showFailures());\n    }\n\n    @Test\n    public void testFileCleanerDirectory_NullStrategy() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, null);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished_NoTrackAfter() {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        final String path = testFile.getPath();\n        final Object marker = new Object();\n        try {\n            theInstance.track(path, marker);\n            fail();\n        } catch (final IllegalStateException ex) {\n            // expected\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinishedFirst() throws Exception {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\n    @Test\n    public void testFileCleanerNull() {\n        try {\n            theInstance.track((File) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((File) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n    }\n\n    private void waitUntilTrackCount() throws Exception {\n        System.gc();\n        TestUtils.sleep(500);\n        int count = 0;\n        while(theInstance.getTrackCount() != 0 && count++ < 5) {\n            List<String> list = new ArrayList<>();\n            try {\n                long i = 0;\n                while (theInstance.getTrackCount() != 0) {\n                    list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n                }\n            } catch (final Throwable ignored) {\n            }\n            list = null;\n            System.gc();\n            TestUtils.sleep(1000);\n        }\n        if (theInstance.getTrackCount() != 0) {\n            throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n        }\n\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.ref.ReferenceQueue;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * This is used to test {@link FileCleaningTracker} for correctness.\n *\n * @see FileCleaningTracker\n */\npublic class FileCleaningTrackerTestCase {\n\n    @TempDir\n    public File temporaryFolder;\n\n    private File testFile;\n\n    private FileCleaningTracker theInstance;\n    public RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n        return new RandomAccessFile(testFile, \"rw\");\n    }\n\n    protected FileCleaningTracker newInstance() {\n        return new FileCleaningTracker();\n    }\n\n    private void pauseForDeleteToComplete(File file) {\n        int count = 0;\n        while(file.exists() && count++ < 40) {\n            try {\n                TestUtils.sleep(500L);\n            } catch (final InterruptedException ignore) {\n            }\n            file = new File(file.getPath());\n        }\n    }\n\n    /**\n     */\n    @BeforeEach\n    public void setUp() {\n        testFile = new File(temporaryFolder, \"file-test.txt\");\n        theInstance = newInstance();\n    }\n\n    private String showFailures() {\n        if (theInstance.deleteFailures.size() == 1) {\n            return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n        }\n        return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n    }\n\n    @AfterEach\n    public void tearDown() {\n\n        // reset file cleaner class, so as not to break other tests\n\n        /**\n         * The following block of code can possibly be removed when the deprecated {@link FileCleaner} is gone. The\n         * question is, whether we want to support reuse of {@link FileCleaningTracker} instances, which we should, IMO,\n         * not.\n         */\n        {\n            if (theInstance != null) {\n                theInstance.q = new ReferenceQueue<>();\n                theInstance.trackers.clear();\n                theInstance.deleteFailures.clear();\n                theInstance.exitWhenFinished = false;\n                theInstance.reaper = null;\n            }\n        }\n\n        theInstance = null;\n    }\n\n    @Test\n    public void testFileCleanerDirectory() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerDirectory_ForceStrategy() throws Exception {\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            TestUtils.generateTestData(output, 100);\n        }\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, FileDeleteStrategy.FORCE);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(testFile.getParentFile());\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(testFile.getPath()).exists(), showFailures());\n        assertFalse(testFile.getParentFile().exists(), showFailures());\n    }\n\n    @Test\n    public void testFileCleanerDirectory_NullStrategy() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, null);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished_NoTrackAfter() {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        final String path = testFile.getPath();\n        final Object marker = new Object();\n        try {\n            theInstance.track(path, marker);\n            fail();\n        } catch (final IllegalStateException ex) {\n            // expected\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinishedFirst() throws Exception {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\n    @Test\n    public void testFileCleanerNull() {\n        try {\n            theInstance.track((File) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((File) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n    }\n\n    private void waitUntilTrackCount() throws Exception {\n        System.gc();\n        TestUtils.sleep(500);\n        int count = 0;\n        while(theInstance.getTrackCount() != 0 && count++ < 5) {\n            List<String> list = new ArrayList<>();\n            try {\n                long i = 0;\n                while (theInstance.getTrackCount() != 0) {\n                    list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n                }\n            } catch (final Throwable ignored) {\n            }\n            list = null;\n            System.gc();\n            TestUtils.sleep(1000);\n        }\n        if (theInstance.getTrackCount() != 0) {\n            throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n        }\n\n    }\n}\n", "diffSourceCodeSet": ["public RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n        return new RandomAccessFile(testFile, \"rw\");\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#waitUntilTrackCount\n methodBody: private void waitUntilTrackCount() throws Exception {\nSystem.gc();\nTestUtils.sleep(500);\nint count=0;\nwhile(theInstance.getTrackCount() != 0 && count++ < 5){List<String> list=new ArrayList<>();\ntrylong i=0;\nwhile(theInstance.getTrackCount() != 0){list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n}catch(final Throwable ignored)list=null;\nSystem.gc();\nTestUtils.sleep(1000);\n}if(theInstance.getTrackCount() != 0){throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n}}", "methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#showFailures\n methodBody: private String showFailures() {\nif(theInstance.deleteFailures.size() == 1){return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n}return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n}", "methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#pauseForDeleteToComplete\n methodBody: private void pauseForDeleteToComplete(File file) {\nint count=0;\nwhile(file.exists() && count++ < 40){tryTestUtils.sleep(500L);\ncatch(final InterruptedException ignore)file=new File(file.getPath());\n}}"], "sourceCodeAfterRefactoring": "@Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\npublic RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n        return new RandomAccessFile(testFile, \"rw\");\n    }", "diffSourceCode": "-   54:         return new FileCleaningTracker();\n-   55:     }\n-   56: \n-  225:     @Test\n-  226:     public void testFileCleanerExitWhenFinished2() throws Exception {\n-  227:         final String path = testFile.getPath();\n-  228: \n-  229:         assertFalse(testFile.exists());\n-  230:         RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n-  231:         assertTrue(testFile.exists());\n-  232: \n-  233:         assertEquals(0, theInstance.getTrackCount());\n-  234:         theInstance.track(path, r);\n-  235:         assertEquals(1, theInstance.getTrackCount());\n-  236:         assertFalse(theInstance.exitWhenFinished);\n-  237:         assertTrue(theInstance.reaper.isAlive());\n-  238: \n-  239:         r.close();\n-  240:         testFile = null;\n-  241:         r = null;\n-  242: \n-  243:         waitUntilTrackCount();\n-  244:         pauseForDeleteToComplete(new File(path));\n-  245: \n-  246:         assertEquals(0, theInstance.getTrackCount());\n-  247:         assertFalse(new File(path).exists(), showFailures());\n-  248:         assertFalse(theInstance.exitWhenFinished);\n-  249:         assertTrue(theInstance.reaper.isAlive());\n+   54:     public RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n+   55:         return new RandomAccessFile(testFile, \"rw\");\n+   56:     }\n+  225:         assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n+  226:         assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n+  227:         assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n+  228:     }\n+  229: \n+  230:     @Test\n+  231:     public void testFileCleanerExitWhenFinished2() throws Exception {\n+  232:         final String path = testFile.getPath();\n+  233: \n+  234:         assertFalse(testFile.exists());\n+  235:         RandomAccessFile r = createRandomAccessFile();\n+  236:         assertTrue(testFile.exists());\n+  237: \n+  238:         assertEquals(0, theInstance.getTrackCount());\n+  239:         theInstance.track(path, r);\n+  240:         assertEquals(1, theInstance.getTrackCount());\n+  241:         assertFalse(theInstance.exitWhenFinished);\n+  242:         assertTrue(theInstance.reaper.isAlive());\n+  243: \n+  244:         r.close();\n+  245:         testFile = null;\n+  246:         r = null;\n+  247: \n+  248:         waitUntilTrackCount();\n+  249:         pauseForDeleteToComplete(new File(path));\n   250: \n-  251:         assertFalse(theInstance.exitWhenFinished);\n-  252:         theInstance.exitWhenFinished();\n-  253:         for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n-  254:             TestUtils.sleep(500L);  // allow reaper thread to die\n-  255:         }\n-  256:         assertTrue(theInstance.exitWhenFinished);\n-  257:         assertFalse(theInstance.reaper.isAlive());\n-  258:     }\n-  259: \n-  260:     @Test\n-  261:     public void testFileCleanerExitWhenFinishedFirst() throws Exception {\n-  262:         assertFalse(theInstance.exitWhenFinished);\n-  263:         theInstance.exitWhenFinished();\n+  251:         assertEquals(0, theInstance.getTrackCount());\n+  252:         assertFalse(new File(path).exists(), showFailures());\n+  253:         assertFalse(theInstance.exitWhenFinished);\n+  254:         assertTrue(theInstance.reaper.isAlive());\n+  255: \n+  256:         assertFalse(theInstance.exitWhenFinished);\n+  257:         theInstance.exitWhenFinished();\n+  258:         for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n+  259:             TestUtils.sleep(500L);  // allow reaper thread to die\n+  260:         }\n+  261:         assertTrue(theInstance.exitWhenFinished);\n+  262:         assertFalse(theInstance.reaper.isAlive());\n+  263:     }\n", "uniqueId": "e95c77c48c15243128da550f068b8c25cedefb0f_225_258_54_56_230_263", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testFileCleanerExitWhenFinished2` method, we can extract several logical blocks of code into separate methods. This will help to clarify the purpose of each block and reduce the complexity of the test method.\n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n@Test\npublic void testFileCleanerExitWhenFinished2() throws Exception {\n    final String path = testFile.getPath();\n\n    assertFileDoesNotExist();\n    RandomAccessFile r = createTestFile();\n    assertFileExists();\n\n    assertInitialTrackingState(path, r);\n\n    closeResources(r);\n    waitForFileDeletion(path);\n\n    assertFinalTrackingState(path);\n}\n\nprivate void assertFileDoesNotExist() {\n    assertFalse(testFile.exists());\n}\n\nprivate RandomAccessFile createTestFile() throws IOException {\n    return new RandomAccessFile(testFile, \"rw\");\n}\n\nprivate void assertFileExists() {\n    assertTrue(testFile.exists());\n}\n\nprivate void assertInitialTrackingState(String path, RandomAccessFile r) {\n    assertEquals(0, theInstance.getTrackCount());\n    theInstance.track(path, r);\n    assertEquals(1, theInstance.getTrackCount());\n    assertFalse(theInstance.exitWhenFinished);\n    assertTrue(theInstance.reaper.isAlive());\n}\n\nprivate void closeResources(RandomAccessFile r) throws IOException {\n    r.close();\n    testFile = null;\n    r = null;\n}\n\nprivate void waitForFileDeletion(String path) throws Exception {\n    waitUntilTrackCount();\n    pauseForDeleteToComplete(new File(path));\n}\n\nprivate void assertFinalTrackingState(String path) {\n    assertEquals(0, theInstance.getTrackCount());\n    assertFalse(new File(path).exists(), showFailures());\n    assertFalse(theInstance.exitWhenFinished);\n    assertTrue(theInstance.reaper.isAlive());\n\n    theInstance.exitWhenFinished();\n    waitForReaperToDie();\n    assertTrue(theInstance.exitWhenFinished);\n    assertFalse(theInstance.reaper.isAlive());\n}\n\nprivate void waitForReaperToDie() throws InterruptedException {\n    for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n        TestUtils.sleep(500L);  // allow reaper thread to die\n    }\n}\n```\n\n### Explanation of Changes:\n1. **Extracted Methods**: The code has been broken down into smaller methods that each handle a specific part of the logic. This makes the main test method (`testFileCleanerExitWhenFinished2`) much clearer and easier to read.\n2. **Method Naming**: Each extracted method has been given a descriptive name that indicates its purpose, which enhances code readability.\n3. **Reduced Complexity**: By extracting methods, we reduce the cognitive load required to understand the test's flow, making it easier for future developers to maintain or modify the test.\n\nThis refactoring improves the overall structure of the test case while preserving its functionality.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.ref.ReferenceQueue;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * This is used to test {@link FileCleaningTracker} for correctness.\n *\n * @see FileCleaningTracker\n */\npublic class FileCleaningTrackerTestCase {\n\n    @TempDir\n    public File temporaryFolder;\n\n    private File testFile;\n\n    private FileCleaningTracker theInstance;\n    protected FileCleaningTracker newInstance() {\n        return new FileCleaningTracker();\n    }\n\n    private void pauseForDeleteToComplete(File file) {\n        int count = 0;\n        while(file.exists() && count++ < 40) {\n            try {\n                TestUtils.sleep(500L);\n            } catch (final InterruptedException ignore) {\n            }\n            file = new File(file.getPath());\n        }\n    }\n\n    /**\n     */\n    @BeforeEach\n    public void setUp() {\n        testFile = new File(temporaryFolder, \"file-test.txt\");\n        theInstance = newInstance();\n    }\n\n    private String showFailures() {\n        if (theInstance.deleteFailures.size() == 1) {\n            return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n        }\n        return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n    }\n\n    @AfterEach\n    public void tearDown() {\n\n        // reset file cleaner class, so as not to break other tests\n\n        /**\n         * The following block of code can possibly be removed when the deprecated {@link FileCleaner} is gone. The\n         * question is, whether we want to support reuse of {@link FileCleaningTracker} instances, which we should, IMO,\n         * not.\n         */\n        {\n            if (theInstance != null) {\n                theInstance.q = new ReferenceQueue<>();\n                theInstance.trackers.clear();\n                theInstance.deleteFailures.clear();\n                theInstance.exitWhenFinished = false;\n                theInstance.reaper = null;\n            }\n        }\n\n        theInstance = null;\n    }\n\n    @Test\n    public void testFileCleanerDirectory() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerDirectory_ForceStrategy() throws Exception {\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            TestUtils.generateTestData(output, 100);\n        }\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, FileDeleteStrategy.FORCE);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(testFile.getParentFile());\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(testFile.getPath()).exists(), showFailures());\n        assertFalse(testFile.getParentFile().exists(), showFailures());\n    }\n\n    @Test\n    public void testFileCleanerDirectory_NullStrategy() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, null);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished_NoTrackAfter() {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        final String path = testFile.getPath();\n        final Object marker = new Object();\n        try {\n            theInstance.track(path, marker);\n            fail();\n        } catch (final IllegalStateException ex) {\n            // expected\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinishedFirst() throws Exception {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\n    @Test\n    public void testFileCleanerNull() {\n        try {\n            theInstance.track((File) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((File) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n    }\n\n    private void waitUntilTrackCount() throws Exception {\n        System.gc();\n        TestUtils.sleep(500);\n        int count = 0;\n        while(theInstance.getTrackCount() != 0 && count++ < 5) {\n            List<String> list = new ArrayList<>();\n            try {\n                long i = 0;\n                while (theInstance.getTrackCount() != 0) {\n                    list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n                }\n            } catch (final Throwable ignored) {\n            }\n            list = null;\n            System.gc();\n            TestUtils.sleep(1000);\n        }\n        if (theInstance.getTrackCount() != 0) {\n            throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n        }\n\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic createRandomAccessFile() : RandomAccessFile extracted from public testFileCleanerExitWhenFinished1() : void in class org.apache.commons.io.FileCleaningTrackerTestCase", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "startLine": 193, "endLine": 223, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "startLine": 198, "endLine": 228, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "startLine": 54, "endLine": 56, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "isPureRefactoring": true, "commitId": "e95c77c48c15243128da550f068b8c25cedefb0f", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.FileCleaningTrackerTestCase", "methodNameBefore": "org.apache.commons.io.FileCleaningTrackerTestCase#testFileCleanerExitWhenFinished1", "invokedMethod": "methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#waitUntilTrackCount\n methodBody: private void waitUntilTrackCount() throws Exception {\nSystem.gc();\nTestUtils.sleep(500);\nint count=0;\nwhile(theInstance.getTrackCount() != 0 && count++ < 5){List<String> list=new ArrayList<>();\ntrylong i=0;\nwhile(theInstance.getTrackCount() != 0){list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n}catch(final Throwable ignored)list=null;\nSystem.gc();\nTestUtils.sleep(1000);\n}if(theInstance.getTrackCount() != 0){throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n}}\nmethodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#showFailures\n methodBody: private String showFailures() {\nif(theInstance.deleteFailures.size() == 1){return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n}return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n}\nmethodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#pauseForDeleteToComplete\n methodBody: private void pauseForDeleteToComplete(File file) {\nint count=0;\nwhile(file.exists() && count++ < 40){tryTestUtils.sleep(500L);\ncatch(final InterruptedException ignore)file=new File(file.getPath());\n}}", "classSignatureBefore": "public class FileCleaningTrackerTestCase ", "methodNameBeforeSet": ["org.apache.commons.io.FileCleaningTrackerTestCase#testFileCleanerExitWhenFinished1"], "classNameBeforeSet": ["org.apache.commons.io.FileCleaningTrackerTestCase"], "classSignatureBeforeSet": ["public class FileCleaningTrackerTestCase "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.ref.ReferenceQueue;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * This is used to test {@link FileCleaningTracker} for correctness.\n *\n * @see FileCleaningTracker\n */\npublic class FileCleaningTrackerTestCase {\n\n    @TempDir\n    public File temporaryFolder;\n\n    private File testFile;\n\n    private FileCleaningTracker theInstance;\n    protected FileCleaningTracker newInstance() {\n        return new FileCleaningTracker();\n    }\n\n    private void pauseForDeleteToComplete(File file) {\n        int count = 0;\n        while(file.exists() && count++ < 40) {\n            try {\n                TestUtils.sleep(500L);\n            } catch (final InterruptedException ignore) {\n            }\n            file = new File(file.getPath());\n        }\n    }\n\n    /**\n     */\n    @BeforeEach\n    public void setUp() {\n        testFile = new File(temporaryFolder, \"file-test.txt\");\n        theInstance = newInstance();\n    }\n\n    private String showFailures() {\n        if (theInstance.deleteFailures.size() == 1) {\n            return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n        }\n        return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n    }\n\n    @AfterEach\n    public void tearDown() {\n\n        // reset file cleaner class, so as not to break other tests\n\n        /**\n         * The following block of code can possibly be removed when the deprecated {@link FileCleaner} is gone. The\n         * question is, whether we want to support reuse of {@link FileCleaningTracker} instances, which we should, IMO,\n         * not.\n         */\n        {\n            if (theInstance != null) {\n                theInstance.q = new ReferenceQueue<>();\n                theInstance.trackers.clear();\n                theInstance.deleteFailures.clear();\n                theInstance.exitWhenFinished = false;\n                theInstance.reaper = null;\n            }\n        }\n\n        theInstance = null;\n    }\n\n    @Test\n    public void testFileCleanerDirectory() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerDirectory_ForceStrategy() throws Exception {\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            TestUtils.generateTestData(output, 100);\n        }\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, FileDeleteStrategy.FORCE);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(testFile.getParentFile());\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(testFile.getPath()).exists(), showFailures());\n        assertFalse(testFile.getParentFile().exists(), showFailures());\n    }\n\n    @Test\n    public void testFileCleanerDirectory_NullStrategy() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, null);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished_NoTrackAfter() {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        final String path = testFile.getPath();\n        final Object marker = new Object();\n        try {\n            theInstance.track(path, marker);\n            fail();\n        } catch (final IllegalStateException ex) {\n            // expected\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinishedFirst() throws Exception {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\n    @Test\n    public void testFileCleanerNull() {\n        try {\n            theInstance.track((File) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((File) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n    }\n\n    private void waitUntilTrackCount() throws Exception {\n        System.gc();\n        TestUtils.sleep(500);\n        int count = 0;\n        while(theInstance.getTrackCount() != 0 && count++ < 5) {\n            List<String> list = new ArrayList<>();\n            try {\n                long i = 0;\n                while (theInstance.getTrackCount() != 0) {\n                    list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n                }\n            } catch (final Throwable ignored) {\n            }\n            list = null;\n            System.gc();\n            TestUtils.sleep(1000);\n        }\n        if (theInstance.getTrackCount() != 0) {\n            throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n        }\n\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/FileCleaningTrackerTestCase.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.ref.ReferenceQueue;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * This is used to test {@link FileCleaningTracker} for correctness.\n *\n * @see FileCleaningTracker\n */\npublic class FileCleaningTrackerTestCase {\n\n    @TempDir\n    public File temporaryFolder;\n\n    private File testFile;\n\n    private FileCleaningTracker theInstance;\n    public RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n        return new RandomAccessFile(testFile, \"rw\");\n    }\n\n    protected FileCleaningTracker newInstance() {\n        return new FileCleaningTracker();\n    }\n\n    private void pauseForDeleteToComplete(File file) {\n        int count = 0;\n        while(file.exists() && count++ < 40) {\n            try {\n                TestUtils.sleep(500L);\n            } catch (final InterruptedException ignore) {\n            }\n            file = new File(file.getPath());\n        }\n    }\n\n    /**\n     */\n    @BeforeEach\n    public void setUp() {\n        testFile = new File(temporaryFolder, \"file-test.txt\");\n        theInstance = newInstance();\n    }\n\n    private String showFailures() {\n        if (theInstance.deleteFailures.size() == 1) {\n            return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n        }\n        return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n    }\n\n    @AfterEach\n    public void tearDown() {\n\n        // reset file cleaner class, so as not to break other tests\n\n        /**\n         * The following block of code can possibly be removed when the deprecated {@link FileCleaner} is gone. The\n         * question is, whether we want to support reuse of {@link FileCleaningTracker} instances, which we should, IMO,\n         * not.\n         */\n        {\n            if (theInstance != null) {\n                theInstance.q = new ReferenceQueue<>();\n                theInstance.trackers.clear();\n                theInstance.deleteFailures.clear();\n                theInstance.exitWhenFinished = false;\n                theInstance.reaper = null;\n            }\n        }\n\n        theInstance = null;\n    }\n\n    @Test\n    public void testFileCleanerDirectory() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerDirectory_ForceStrategy() throws Exception {\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            TestUtils.generateTestData(output, 100);\n        }\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, FileDeleteStrategy.FORCE);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(testFile.getParentFile());\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(testFile.getPath()).exists(), showFailures());\n        assertFalse(testFile.getParentFile().exists(), showFailures());\n    }\n\n    @Test\n    public void testFileCleanerDirectory_NullStrategy() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, null);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished_NoTrackAfter() {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        final String path = testFile.getPath();\n        final Object marker = new Object();\n        try {\n            theInstance.track(path, marker);\n            fail();\n        } catch (final IllegalStateException ex) {\n            // expected\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinishedFirst() throws Exception {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\n    @Test\n    public void testFileCleanerNull() {\n        try {\n            theInstance.track((File) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((File) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n    }\n\n    private void waitUntilTrackCount() throws Exception {\n        System.gc();\n        TestUtils.sleep(500);\n        int count = 0;\n        while(theInstance.getTrackCount() != 0 && count++ < 5) {\n            List<String> list = new ArrayList<>();\n            try {\n                long i = 0;\n                while (theInstance.getTrackCount() != 0) {\n                    list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n                }\n            } catch (final Throwable ignored) {\n            }\n            list = null;\n            System.gc();\n            TestUtils.sleep(1000);\n        }\n        if (theInstance.getTrackCount() != 0) {\n            throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n        }\n\n    }\n}\n", "diffSourceCodeSet": ["public RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n        return new RandomAccessFile(testFile, \"rw\");\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#waitUntilTrackCount\n methodBody: private void waitUntilTrackCount() throws Exception {\nSystem.gc();\nTestUtils.sleep(500);\nint count=0;\nwhile(theInstance.getTrackCount() != 0 && count++ < 5){List<String> list=new ArrayList<>();\ntrylong i=0;\nwhile(theInstance.getTrackCount() != 0){list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n}catch(final Throwable ignored)list=null;\nSystem.gc();\nTestUtils.sleep(1000);\n}if(theInstance.getTrackCount() != 0){throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n}}", "methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#showFailures\n methodBody: private String showFailures() {\nif(theInstance.deleteFailures.size() == 1){return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n}return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n}", "methodSignature: org.apache.commons.io.FileCleaningTrackerTestCase#pauseForDeleteToComplete\n methodBody: private void pauseForDeleteToComplete(File file) {\nint count=0;\nwhile(file.exists() && count++ < 40){tryTestUtils.sleep(500L);\ncatch(final InterruptedException ignore)file=new File(file.getPath());\n}}"], "sourceCodeAfterRefactoring": "@Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = createRandomAccessFile();\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\npublic RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n        return new RandomAccessFile(testFile, \"rw\");\n    }", "diffSourceCode": "-   54:         return new FileCleaningTracker();\n-   55:     }\n-   56: \n-  193:     @Test\n-  194:     public void testFileCleanerExitWhenFinished1() throws Exception {\n-  195:         final String path = testFile.getPath();\n-  196: \n-  197:         assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n-  198:         RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n-  199:         assertTrue(testFile.exists(), \"2-testFile exists\");\n-  200: \n-  201:         assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n-  202:         theInstance.track(path, r);\n-  203:         assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n-  204:         assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n-  205:         assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n-  206: \n-  207:         assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n-  208:         theInstance.exitWhenFinished();\n-  209:         assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n-  210:         assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n+   54:     public RandomAccessFile createRandomAccessFile() throws FileNotFoundException {\n+   55:         return new RandomAccessFile(testFile, \"rw\");\n+   56:     }\n+  193:         }\n+  194:         assertTrue(theInstance.exitWhenFinished);\n+  195:         assertNull(theInstance.reaper);\n+  196:     }\n+  197: \n+  198:     @Test\n+  199:     public void testFileCleanerExitWhenFinished1() throws Exception {\n+  200:         final String path = testFile.getPath();\n+  201: \n+  202:         assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n+  203:         RandomAccessFile r = createRandomAccessFile();\n+  204:         assertTrue(testFile.exists(), \"2-testFile exists\");\n+  205: \n+  206:         assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n+  207:         theInstance.track(path, r);\n+  208:         assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n+  209:         assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n+  210:         assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n   211: \n-  212:         r.close();\n-  213:         testFile = null;\n-  214:         r = null;\n-  215: \n-  216:         waitUntilTrackCount();\n-  217:         pauseForDeleteToComplete(new File(path));\n-  218: \n-  219:         assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n-  220:         assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n-  221:         assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n-  222:         assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n-  223:     }\n-  224: \n-  225:     @Test\n-  226:     public void testFileCleanerExitWhenFinished2() throws Exception {\n-  227:         final String path = testFile.getPath();\n-  228: \n+  212:         assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n+  213:         theInstance.exitWhenFinished();\n+  214:         assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n+  215:         assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n+  216: \n+  217:         r.close();\n+  218:         testFile = null;\n+  219:         r = null;\n+  220: \n+  221:         waitUntilTrackCount();\n+  222:         pauseForDeleteToComplete(new File(path));\n+  223: \n+  224:         assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n+  225:         assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n+  226:         assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n+  227:         assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n+  228:     }\n", "uniqueId": "e95c77c48c15243128da550f068b8c25cedefb0f_193_223_54_56_198_228", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testFileCleanerExitWhenFinished1` method, we can extract several logical blocks of code into separate methods. This will help to clarify the purpose of each block and reduce the complexity of the test method.\n\nHere\u2019s the refactored code with the extracted methods:\n\n```java\n##########################\n@Test\npublic void testFileCleanerExitWhenFinished1() throws Exception {\n    final String path = testFile.getPath();\n\n    assertFileDoesNotExist(\"1-testFile exists: \", testFile);\n    RandomAccessFile r = createRandomAccessFile(testFile);\n    assertFileExists(\"2-testFile exists\", testFile);\n\n    assertTrackCount(0, \"3-Track Count\");\n    theInstance.track(path, r);\n    assertTrackCount(1, \"4-Track Count\");\n    assertExitWhenFinishedState(false, \"5-exitWhenFinished\");\n    assertReaperIsAlive(\"6-reaper.isAlive\");\n\n    theInstance.exitWhenFinished();\n    assertExitWhenFinishedState(true, \"8-exitWhenFinished\");\n    assertReaperIsAlive(\"9-reaper.isAlive\");\n\n    closeResources(r);\n    waitUntilTrackCount();\n    pauseForDeleteToComplete(new File(path));\n\n    assertTrackCount(0, \"10-Track Count\");\n    assertFileDoesNotExist(\"11-testFile exists \" + showFailures(), new File(path));\n    assertExitWhenFinishedState(true, \"12-exitWhenFinished\");\n    assertReaperIsNotAlive(\"13-reaper.isAlive\");\n}\n\nprivate void assertFileDoesNotExist(String message, File file) {\n    assertFalse(file.exists(), message);\n}\n\nprivate RandomAccessFile createRandomAccessFile(File file) throws IOException {\n    return new RandomAccessFile(file, \"rw\");\n}\n\nprivate void assertFileExists(String message, File file) {\n    assertTrue(file.exists(), message);\n}\n\nprivate void assertTrackCount(int expectedCount, String message) {\n    assertEquals(expectedCount, theInstance.getTrackCount(), message);\n}\n\nprivate void assertExitWhenFinishedState(boolean expectedState, String message) {\n    assertEquals(expectedState, theInstance.exitWhenFinished, message);\n}\n\nprivate void assertReaperIsAlive(String message) {\n    assertTrue(theInstance.reaper.isAlive(), message);\n}\n\nprivate void assertReaperIsNotAlive(String message) {\n    assertFalse(theInstance.reaper.isAlive(), message);\n}\n\nprivate void closeResources(RandomAccessFile r) throws IOException {\n    if (r != null) {\n        r.close();\n    }\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Methods**: \n   - `assertFileDoesNotExist`: Checks if a file does not exist.\n   - `createRandomAccessFile`: Creates a `RandomAccessFile` for the given file.\n   - `assertFileExists`: Checks if a file exists.\n   - `assertTrackCount`: Asserts the track count.\n   - `assertExitWhenFinishedState`: Asserts the state of `exitWhenFinished`.\n   - `assertReaperIsAlive`: Asserts that the reaper thread is alive.\n   - `assertReaperIsNotAlive`: Asserts that the reaper thread is not alive.\n   - `closeResources`: Closes the `RandomAccessFile`.\n\n2. **Improved Readability**: The main test method is now cleaner and easier to read, with each assertion clearly defined by its purpose.\n\n3. **Maintainability**: If any of the assertions need to change in the future, they can be modified in one place, reducing the risk of errors.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.lang.ref.ReferenceQueue;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.test.TestUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.io.TempDir;\n\n/**\n * This is used to test {@link FileCleaningTracker} for correctness.\n *\n * @see FileCleaningTracker\n */\npublic class FileCleaningTrackerTestCase {\n\n    @TempDir\n    public File temporaryFolder;\n\n    private File testFile;\n\n    private FileCleaningTracker theInstance;\n    protected FileCleaningTracker newInstance() {\n        return new FileCleaningTracker();\n    }\n\n    private void pauseForDeleteToComplete(File file) {\n        int count = 0;\n        while(file.exists() && count++ < 40) {\n            try {\n                TestUtils.sleep(500L);\n            } catch (final InterruptedException ignore) {\n            }\n            file = new File(file.getPath());\n        }\n    }\n\n    /**\n     */\n    @BeforeEach\n    public void setUp() {\n        testFile = new File(temporaryFolder, \"file-test.txt\");\n        theInstance = newInstance();\n    }\n\n    private String showFailures() {\n        if (theInstance.deleteFailures.size() == 1) {\n            return \"[Delete Failed: \" + theInstance.deleteFailures.get(0) + \"]\";\n        }\n        return \"[Delete Failures: \" + theInstance.deleteFailures.size() + \"]\";\n    }\n\n    @AfterEach\n    public void tearDown() {\n\n        // reset file cleaner class, so as not to break other tests\n\n        /**\n         * The following block of code can possibly be removed when the deprecated {@link FileCleaner} is gone. The\n         * question is, whether we want to support reuse of {@link FileCleaningTracker} instances, which we should, IMO,\n         * not.\n         */\n        {\n            if (theInstance != null) {\n                theInstance.q = new ReferenceQueue<>();\n                theInstance.trackers.clear();\n                theInstance.deleteFailures.clear();\n                theInstance.exitWhenFinished = false;\n                theInstance.reaper = null;\n            }\n        }\n\n        theInstance = null;\n    }\n\n    @Test\n    public void testFileCleanerDirectory() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerDirectory_ForceStrategy() throws Exception {\n        if (!testFile.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(Files.newOutputStream(testFile.toPath()))) {\n            TestUtils.generateTestData(output, 100);\n        }\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, FileDeleteStrategy.FORCE);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(testFile.getParentFile());\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(testFile.getPath()).exists(), showFailures());\n        assertFalse(testFile.getParentFile().exists(), showFailures());\n    }\n\n    @Test\n    public void testFileCleanerDirectory_NullStrategy() throws Exception {\n        TestUtils.createFile(testFile, 100);\n        assertTrue(testFile.exists());\n        assertTrue(temporaryFolder.exists());\n\n        Object obj = new Object();\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(temporaryFolder, obj, null);\n        assertEquals(1, theInstance.getTrackCount());\n\n        obj = null;\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(testFile.exists());  // not deleted, as dir not empty\n        assertTrue(testFile.getParentFile().exists());  // not deleted, as dir not empty\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished_NoTrackAfter() {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        final String path = testFile.getPath();\n        final Object marker = new Object();\n        try {\n            theInstance.track(path, marker);\n            fail();\n        } catch (final IllegalStateException ex) {\n            // expected\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished1() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists(), \"1-testFile exists: \" + testFile);\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists(), \"2-testFile exists\");\n\n        assertEquals(0, theInstance.getTrackCount(), \"3-Track Count\");\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount(), \"4-Track Count\");\n        assertFalse(theInstance.exitWhenFinished, \"5-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"6-reaper.isAlive\");\n\n        assertFalse(theInstance.exitWhenFinished, \"7-exitWhenFinished\");\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished, \"8-exitWhenFinished\");\n        assertTrue(theInstance.reaper.isAlive(), \"9-reaper.isAlive\");\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount(), \"10-Track Count\");\n        assertFalse(new File(path).exists(), \"11-testFile exists \" + showFailures());\n        assertTrue(theInstance.exitWhenFinished, \"12-exitWhenFinished\");\n        assertFalse(theInstance.reaper.isAlive(), \"13-reaper.isAlive\");\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinished2() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n        assertFalse(theInstance.exitWhenFinished);\n        assertTrue(theInstance.reaper.isAlive());\n\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        for (int i = 0; i < 20 && theInstance.reaper.isAlive(); i++) {\n            TestUtils.sleep(500L);  // allow reaper thread to die\n        }\n        assertTrue(theInstance.exitWhenFinished);\n        assertFalse(theInstance.reaper.isAlive());\n    }\n\n    @Test\n    public void testFileCleanerExitWhenFinishedFirst() throws Exception {\n        assertFalse(theInstance.exitWhenFinished);\n        theInstance.exitWhenFinished();\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n\n        waitUntilTrackCount();\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertTrue(theInstance.exitWhenFinished);\n        assertNull(theInstance.reaper);\n    }\n\n    @Test\n    public void testFileCleanerFile() throws Exception {\n        final String path = testFile.getPath();\n\n        assertFalse(testFile.exists());\n        RandomAccessFile r = new RandomAccessFile(testFile, \"rw\");\n        assertTrue(testFile.exists());\n\n        assertEquals(0, theInstance.getTrackCount());\n        theInstance.track(path, r);\n        assertEquals(1, theInstance.getTrackCount());\n\n        r.close();\n        testFile = null;\n        r = null;\n\n        waitUntilTrackCount();\n        pauseForDeleteToComplete(new File(path));\n\n        assertEquals(0, theInstance.getTrackCount());\n        assertFalse(new File(path).exists(), showFailures());\n    }\n    @Test\n    public void testFileCleanerNull() {\n        try {\n            theInstance.track((File) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((File) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object());\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n        try {\n            theInstance.track((String) null, new Object(), FileDeleteStrategy.NORMAL);\n            fail();\n        } catch (final NullPointerException ex) {\n            // expected\n        }\n    }\n\n    private void waitUntilTrackCount() throws Exception {\n        System.gc();\n        TestUtils.sleep(500);\n        int count = 0;\n        while(theInstance.getTrackCount() != 0 && count++ < 5) {\n            List<String> list = new ArrayList<>();\n            try {\n                long i = 0;\n                while (theInstance.getTrackCount() != 0) {\n                    list.add(\"A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String A Big String \" + (i++));\n                }\n            } catch (final Throwable ignored) {\n            }\n            list = null;\n            System.gc();\n            TestUtils.sleep(1000);\n        }\n        if (theInstance.getTrackCount() != 0) {\n            throw new IllegalStateException(\"Your JVM is not releasing References, try running the testcase with less memory (-Xmx)\");\n        }\n\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate writeOneAtATime(bytes byte[], out WriterOutputStream) : void extracted from private testWithSingleByteWrite(testString String, charsetName String) : void in class org.apache.commons.io.output.WriterOutputStreamTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "startLine": 186, "endLine": 195, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "startLine": 194, "endLine": 207, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "startLine": 229, "endLine": 233, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "isPureRefactoring": true, "commitId": "7ecca22f175c644da3096940a4ce899be5b33740", "packageNameBefore": "org.apache.commons.io.output", "classNameBefore": "org.apache.commons.io.output.WriterOutputStreamTest", "methodNameBefore": "org.apache.commons.io.output.WriterOutputStreamTest#testWithSingleByteWrite", "invokedMethod": "methodSignature: org.apache.commons.io.input.Tailer.TailablePath#toString\n methodBody: public String toString() {\nreturn \"TailablePath [file=\" + path + \", linkOptions=\" + Arrays.toString(linkOptions) + \"]\";\n}\nmethodSignature: org.apache.commons.io.filefilter.WildcardFileFilter#toString\n methodBody: public String toString() {\nfinal StringBuilder buffer=new StringBuilder();\nbuffer.append(super.toString());\nbuffer.append(\"(\");\nappend(wildcards,buffer);\nbuffer.append(\")\");\nreturn buffer.toString();\n}\nmethodSignature: org.apache.commons.io.output.WriterOutputStream#write\n methodBody: public void write(final int b) throws IOException {\nwrite(new byte[]{(byte)b},0,1);\n}\nmethodSignature: org.apache.commons.io.output.XmlStreamWriter#write\n methodBody: public void write(final char[] cbuf, final int off, final int len) throws IOException {\nif(prologWriter != null){detectEncoding(cbuf,off,len);\n}{writer.write(cbuf,off,len);\n}}\nmethodSignature: org.apache.commons.io.input.ReversedLinesFileReader#toString\n methodBody: public String toString(final int lineCount) throws IOException {\nfinal List<String> lines=readLines(lineCount);\nCollections.reverse(lines);\nreturn lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(),lines) + System.lineSeparator();\n}\nmethodSignature: org.apache.commons.io.output.LockableFileWriter#write\n methodBody: public void write(final String str, final int off, final int len) throws IOException {\nout.write(str,off,len);\n}\nmethodSignature: org.apache.commons.io.input.TailerTest#write\n methodBody: private void write(final File file, final String... lines) throws IOException {\ntry(Writer writer=Files.newBufferedWriter(file.toPath(),StandardOpenOption.APPEND))for(final String line: lines){writer.write(line + \"\\n\");\n}}", "classSignatureBefore": "public class WriterOutputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.output.WriterOutputStreamTest#testWithSingleByteWrite"], "classNameBeforeSet": ["org.apache.commons.io.output.WriterOutputStreamTest"], "classSignatureBeforeSet": ["public class WriterOutputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.charset.CharsetDecoders;\nimport org.junit.jupiter.api.Test;\n\npublic class WriterOutputStreamTest {\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i=0; i<100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    public void testFlush() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, false)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(0, writer.getBuffer().length());\n            out.flush();\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testNullCharsetDecoderWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (CharsetDecoder) null);\n    }\n\n    @Test\n    public void testNullCharsetNameWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (String) null);\n    }\n\n    @Test\n    public void testNullCharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (Charset) null);\n    }\n\n    @Test\n    public void testUTF16BEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16BEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16LEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16LEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16WithBufferedWrite() throws IOException {\n        try {\n            testWithBufferedWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e) {\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")) {\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteWrite() throws IOException {\n        try {\n            testWithSingleByteWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e){\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")){\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            int offset = 0;\n            while (offset < expected.length) {\n                final int length = Math.min(random.nextInt(128), expected.length - offset);\n                out.write(expected, offset, length);\n                offset += length;\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n\n    private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    @Test\n    public void testWriteImmediately() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, true)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.charset.CharsetDecoders;\nimport org.junit.jupiter.api.Test;\n\npublic class WriterOutputStreamTest {\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i=0; i<100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    public void testFlush() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, false)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(0, writer.getBuffer().length());\n            out.flush();\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testNullCharsetDecoderWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (CharsetDecoder) null);\n    }\n\n    @Test\n    public void testNullCharsetNameWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (String) null);\n    }\n\n    @Test\n    public void testNullCharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (Charset) null);\n    }\n\n    @Test\n    public void testUTF16BEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16BEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16LEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16LEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16WithBufferedWrite() throws IOException {\n        try {\n            testWithBufferedWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e) {\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")) {\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteWrite() throws IOException {\n        try {\n            testWithSingleByteWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e){\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")){\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charsetName).get()) {\n            int offset = 0;\n            while (offset < expected.length) {\n                final int length = Math.min(random.nextInt(128), expected.length - offset);\n                out.write(expected, offset, length);\n                offset += length;\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n\n    private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charset).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharsetDecoder(charsetDecoder).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charsetName).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    @Test\n    public void testWriteImmediately() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, true)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abc\", writer.toString());\n        }\n        // @formatter:off\n        try (WriterOutputStream out = WriterOutputStream.builder()\n                .setWriter(writer)\n                .setCharset(\"us-ascii\")\n                .setBufferSize(1024)\n                .setWriteImmediately(true)\n                .get()) {\n            // @formatter:on\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abcabc\", writer.toString());\n        }\n    }\n\n    private void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }\n}\n", "diffSourceCodeSet": ["private void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.Tailer.TailablePath#toString\n methodBody: public String toString() {\nreturn \"TailablePath [file=\" + path + \", linkOptions=\" + Arrays.toString(linkOptions) + \"]\";\n}", "methodSignature: org.apache.commons.io.filefilter.WildcardFileFilter#toString\n methodBody: public String toString() {\nfinal StringBuilder buffer=new StringBuilder();\nbuffer.append(super.toString());\nbuffer.append(\"(\");\nappend(wildcards,buffer);\nbuffer.append(\")\");\nreturn buffer.toString();\n}", "methodSignature: org.apache.commons.io.output.WriterOutputStream#write\n methodBody: public void write(final int b) throws IOException {\nwrite(new byte[]{(byte)b},0,1);\n}", "methodSignature: org.apache.commons.io.output.XmlStreamWriter#write\n methodBody: public void write(final char[] cbuf, final int off, final int len) throws IOException {\nif(prologWriter != null){detectEncoding(cbuf,off,len);\n}{writer.write(cbuf,off,len);\n}}", "methodSignature: org.apache.commons.io.input.ReversedLinesFileReader#toString\n methodBody: public String toString(final int lineCount) throws IOException {\nfinal List<String> lines=readLines(lineCount);\nCollections.reverse(lines);\nreturn lines.isEmpty() ? EMPTY_STRING : String.join(System.lineSeparator(),lines) + System.lineSeparator();\n}", "methodSignature: org.apache.commons.io.output.LockableFileWriter#write\n methodBody: public void write(final String str, final int off, final int len) throws IOException {\nout.write(str,off,len);\n}", "methodSignature: org.apache.commons.io.input.TailerTest#write\n methodBody: private void write(final File file, final String... lines) throws IOException {\ntry(Writer writer=Files.newBufferedWriter(file.toPath(),StandardOpenOption.APPEND))for(final String line: lines){writer.write(line + \"\\n\");\n}}"], "sourceCodeAfterRefactoring": "private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n        //\n        writer = new StringWriter();\n        try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charsetName).get()) {\n            writeOneAtATime(bytes, out);\n        }\n        assertEquals(testString, writer.toString());\n    }\nprivate void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }", "diffSourceCode": "-  186:     private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n-  187:         final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n-  188:         final StringWriter writer = new StringWriter();\n-  189:         try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n-  190:             for (final byte b : bytes) {\n-  191:                 out.write(b);\n-  192:             }\n-  193:         }\n-  194:         assertEquals(testString, writer.toString());\n-  195:     }\n-  196: \n-  197:     @Test\n-  198:     public void testWriteImmediately() throws IOException {\n-  199:         final StringWriter writer = new StringWriter();\n-  200:         try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, true)) {\n-  201:             out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n-  202:             assertEquals(\"abc\", writer.toString());\n-  203:         }\n-  204:     }\n-  205: }\n+  186:         //\n+  187:         writer = new StringWriter();\n+  188:         try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharsetDecoder(charsetDecoder).get()) {\n+  189:             writeOneAtATime(bytes, out);\n+  190:         }\n+  191:         assertEquals(testString, writer.toString());\n+  192:     }\n+  193: \n+  194:     private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n+  195:         final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n+  196:         StringWriter writer = new StringWriter();\n+  197:         try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n+  198:             writeOneAtATime(bytes, out);\n+  199:         }\n+  200:         assertEquals(testString, writer.toString());\n+  201:         //\n+  202:         writer = new StringWriter();\n+  203:         try (WriterOutputStream out = WriterOutputStream.builder().setWriter(writer).setCharset(charsetName).get()) {\n+  204:             writeOneAtATime(bytes, out);\n+  205:         }\n+  206:         assertEquals(testString, writer.toString());\n+  207:     }\n+  229:     private void writeOneAtATime(final byte[] bytes, WriterOutputStream out) throws IOException {\n+  230:         for (final byte b : bytes) {\n+  231:             out.write(b);\n+  232:         }\n+  233:     }\n", "uniqueId": "7ecca22f175c644da3096940a4ce899be5b33740_186_195_229_233_194_207", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testWithSingleByteWrite` method, we can extract the common logic of writing bytes to a `WriterOutputStream` into a separate method. This will reduce code duplication and make the code easier to understand.\n\nHere's the refactored method code:\n\n##########################\n```java\nprivate void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n    final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n    assertWrittenStringEquals(testString, bytes, charsetName);\n}\n\nprivate void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n    final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n    assertWrittenStringEquals(testString, bytes, charset);\n}\n\nprivate void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n    final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n    assertWrittenStringEquals(testString, bytes, charsetDecoder);\n}\n\nprivate void assertWrittenStringEquals(final String expectedString, final byte[] bytes, final String charsetName) throws IOException {\n    final StringWriter writer = new StringWriter();\n    try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }\n    assertEquals(expectedString, writer.toString());\n}\n\nprivate void assertWrittenStringEquals(final String expectedString, final byte[] bytes, final Charset charset) throws IOException {\n    final StringWriter writer = new StringWriter();\n    try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }\n    assertEquals(expectedString, writer.toString());\n}\n\nprivate void assertWrittenStringEquals(final String expectedString, final byte[] bytes, final CharsetDecoder charsetDecoder) throws IOException {\n    final StringWriter writer = new StringWriter();\n    try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n        for (final byte b : bytes) {\n            out.write(b);\n        }\n    }\n    assertEquals(expectedString, writer.toString());\n}\n```\n##########################\n\nIn this refactoring, the common logic of writing bytes to the `WriterOutputStream` and asserting the result has been extracted into a new method called `assertWrittenStringEquals`. This method is overloaded to handle different types of charset inputs (String, Charset, CharsetDecoder). This reduces redundancy and improves the clarity of the test methods.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.charset.CharsetDecoders;\nimport org.junit.jupiter.api.Test;\n\npublic class WriterOutputStreamTest {\n    private static final String UTF_16LE = StandardCharsets.UTF_16LE.name();\n    private static final String UTF_16BE = StandardCharsets.UTF_16BE.name();\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i=0; i<100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    public void testFlush() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, false)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(0, writer.getBuffer().length());\n            out.flush();\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8CharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, StandardCharsets.UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testNullCharsetDecoderWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (CharsetDecoder) null);\n    }\n\n    @Test\n    public void testNullCharsetNameWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (String) null);\n    }\n\n    @Test\n    public void testNullCharsetWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, (Charset) null);\n    }\n\n    @Test\n    public void testUTF16BEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16BEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16BE);\n    }\n\n    @Test\n    public void testUTF16LEWithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16LEWithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_16LE);\n    }\n\n    @Test\n    public void testUTF16WithBufferedWrite() throws IOException {\n        try {\n            testWithBufferedWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e) {\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")) {\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteWrite() throws IOException {\n        try {\n            testWithSingleByteWrite(TEST_STRING, UTF_16);\n        } catch (final UnsupportedOperationException e){\n            if (!System.getProperty(\"java.vendor\").contains(\"IBM\")){\n                fail(\"This test should only throw UOE on IBM JDKs with broken UTF-16\");\n            }\n        }\n    }\n\n    @Test\n    public void testUTF8WithBufferedWrite() throws IOException {\n        testWithBufferedWrite(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteWrite() throws IOException {\n        testWithSingleByteWrite(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            int offset = 0;\n            while (offset < expected.length) {\n                final int length = Math.min(random.nextInt(128), expected.length - offset);\n                out.write(expected, offset, length);\n                offset += length;\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n\n    private void testWithSingleByteWrite(final String testString, final Charset charset) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charset));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charset)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final CharsetDecoder charsetDecoder) throws IOException {\n        final byte[] bytes = testString.getBytes(CharsetDecoders.toCharsetDecoder(charsetDecoder).charset());\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetDecoder)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    private void testWithSingleByteWrite(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(Charsets.toCharset(charsetName));\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, charsetName)) {\n            for (final byte b : bytes) {\n                out.write(b);\n            }\n        }\n        assertEquals(testString, writer.toString());\n    }\n\n    @Test\n    public void testWriteImmediately() throws IOException {\n        final StringWriter writer = new StringWriter();\n        try (WriterOutputStream out = new WriterOutputStream(writer, \"us-ascii\", 1024, true)) {\n            out.write(\"abc\".getBytes(StandardCharsets.US_ASCII));\n            assertEquals(\"abc\", writer.toString());\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate testReadZero(inStr String, inputStream ReaderInputStream) : void extracted from public testReadZero() : void in class org.apache.commons.io.input.ReaderInputStreamTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java", "startLine": 169, "endLine": 180, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java", "startLine": 211, "endLine": 221, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java", "startLine": 223, "endLine": 229, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZero() throws Exception {\n        final String inStr = \"test\";\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n            final byte[] bytes = new byte[30];\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java", "isPureRefactoring": true, "commitId": "7ecca22f175c644da3096940a4ce899be5b33740", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.ReaderInputStreamTest", "methodNameBefore": "org.apache.commons.io.input.ReaderInputStreamTest#testReadZero", "invokedMethod": "methodSignature: org.apache.commons.io.input.XmlStreamReader#read\n methodBody: public int read(final char[] buf, final int offset, final int len) throws IOException {\nreturn reader.read(buf,offset,len);\n}\nmethodSignature: org.apache.commons.io.input.Tailer.RandomAccessFileBridge#read\n methodBody: public int read(final byte[] b) throws IOException {\nreturn randomAccessFile.read(b);\n}\nmethodSignature: org.apache.commons.io.input.Tailer.RandomAccessResourceBridge#read\n methodBody: int read(final byte[] b) throws IOException;\nmethodSignature: org.apache.commons.io.FileUtilsTest.ShorterFile#length\n methodBody: public long length() {\nreturn super.length() - 1;\n}\nmethodSignature: org.apache.commons.io.input.BOMInputStream#read\n methodBody: public int read(final byte[] buf, int off, int len) throws IOException {\nint firstCount=0;\nint b=0;\nwhile(len > 0 && b >= 0){b=readFirstBytes();\nif(b >= 0){buf[off++]=(byte)(b & 0xFF);\nlen--;\nfirstCount++;\n}}final int secondCount=in.read(buf,off,len);\nreturn secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount;\n}\nmethodSignature: org.apache.commons.io.input.BufferedFileChannelInputStream#read\n methodBody: public synchronized int read(final byte[] b, final int offset, int len) throws IOException {\nif(offset < 0 || len < 0 || offset + len < 0 || offset + len > b.length){throw new IndexOutOfBoundsException();\n}if(!refill()){return EOF;\n}len=Math.min(len,byteBuffer.remaining());\nbyteBuffer.get(b,offset,len);\nreturn len;\n}\nmethodSignature: org.apache.commons.io.input.MemoryMappedFileInputStream#read\n methodBody: public int read(final byte[] b, final int off, final int len) throws IOException {\nensureOpen();\nif(!buffer.hasRemaining()){nextBuffer();\nif(!buffer.hasRemaining()){return EOF;\n}}final int numBytes=Math.min(buffer.remaining(),len);\nbuffer.get(b,off,numBytes);\nreturn numBytes;\n}\nmethodSignature: org.apache.commons.io.input.ReaderInputStream#read\n methodBody: public int read(final byte[] array, int off, int len) throws IOException {\nObjects.requireNonNull(array,\"array\");\nif(len < 0 || off < 0 || off + len > array.length){throw new IndexOutOfBoundsException(\"Array size=\" + array.length + \", offset=\" + off + \", length=\" + len);\n}int read=0;\nif(len == 0){return 0;\n}while(len > 0){if(encoderOut.hasRemaining()){final int c=Math.min(encoderOut.remaining(),len);\nencoderOut.get(array,off,c);\noff+=c;\nlen-=c;\nread+=c;\n}if(endOfInput){break;\n}{fillBuffer();\n}}return read == 0 && endOfInput ? EOF : read;\n}\nmethodSignature: org.apache.commons.io.input.RandomAccessFileInputStream#read\n methodBody: public int read(final byte[] bytes, final int offset, final int length) throws IOException {\nreturn randomAccessFile.read(bytes,offset,length);\n}\nmethodSignature: org.apache.commons.io.input.ReadAheadInputStream#read\n methodBody: public int read(final byte[] b, final int offset, int len) throws IOException {\nif(offset < 0 || len < 0 || len > b.length - offset){throw new IndexOutOfBoundsException();\n}if(len == 0){return 0;\n}if(!activeBuffer.hasRemaining()){stateChangeLock.lock();\ntrywaitForAsyncReadComplete();\nif(!readAheadBuffer.hasRemaining()){readAsync();\nwaitForAsyncReadComplete();\nif(isEndOfStream()){return EOF;\n}}swapBuffers();\nreadAsync();\nfinallystateChangeLock.unlock();\n}len=Math.min(len,activeBuffer.remaining());\nactiveBuffer.get(b,offset,len);\nreturn len;\n}\nmethodSignature: org.apache.commons.io.input.BOMInputStreamTest.ExpectCloseInputStream#read\n methodBody: public int read() throws IOException {\nreturn -1;\n}\nmethodSignature: org.apache.commons.io.input.SequenceReaderTest.CustomReader#read\n methodBody: public int read(final char[] cbuf, final int off, final int len) throws IOException {\ncheckOpen();\nclose();\nreturn EOF;\n}", "classSignatureBefore": "public class ReaderInputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.input.ReaderInputStreamTest#testReadZero"], "classNameBeforeSet": ["org.apache.commons.io.input.ReaderInputStreamTest"], "classSignatureBeforeSet": ["public class ReaderInputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.CharArrayReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class ReaderInputStreamTest {\n\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i = 0; i < 100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    static Stream<Arguments> charsetData() {\n        // @formatter:off\n        return Stream.of(\n                Arguments.of(\"Cp930\", \"\\u0391\"),\n                Arguments.of(\"ISO_8859_1\", \"A\"),\n                Arguments.of(UTF_8, \"\\u0391\"));\n        // @formatter:on\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testBufferSmallest() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        try (InputStream in = new ReaderInputStream(new StringReader(\"\\uD800\"), charset, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            in.read();\n        }\n    }\n\n    @Test\n    public void testBufferTooSmall() {\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, -1));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 0));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 1));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"charsetData\")\n    public void testCharsetEncoderFlush(final String charsetName, final String data) throws IOException {\n        final Charset charset = Charset.forName(charsetName);\n        final byte[] expected = data.getBytes(charset);\n        try (InputStream in = new ReaderInputStream(new StringReader(data), charset)) {\n            final byte[] actual = IOUtils.toByteArray(in);\n            assertEquals(Arrays.toString(expected), Arrays.toString(actual));\n        }\n    }\n\n    /*\n     * Tests https://issues.apache.org/jira/browse/IO-277\n     */\n    @Test\n    public void testCharsetMismatchInfiniteLoop() throws IOException {\n        // Input is UTF-8 bytes: 0xE0 0xB2 0xA0\n        final char[] inputChars = {(char) 0xE0, (char) 0xB2, (char) 0xA0};\n        // Charset charset = Charset.forName(\"UTF-8\"); // works\n        final Charset charset = StandardCharsets.US_ASCII; // infinite loop\n        try (ReaderInputStream stream = new ReaderInputStream(new CharArrayReader(inputChars), charset)) {\n            IOUtils.toCharArray(stream, charset);\n        }\n    }\n\n    /**\n     * Tests IO-717 to avoid infinite loops.\n     *\n     * ReaderInputStream does not throw exception with {@link CodingErrorAction#REPORT}.\n     */\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testCodingErrorAction() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        final CharsetEncoder encoder = charset.newEncoder().onMalformedInput(CodingErrorAction.REPORT);\n        try (InputStream in = new ReaderInputStream(new StringReader(\"\\uD800aa\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            assertThrows(CharacterCodingException.class, in::read);\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharset() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final Charset encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final CharsetEncoder encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetNameEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final String encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZero() throws Exception {\n        final String inStr = \"test\";\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n            final byte[] bytes = new byte[30];\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n        }\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZeroEmptyString() throws Exception {\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(\"\"))) {\n            final byte[] bytes = new byte[30];\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_16);\n    }\n\n    @Test\n    public void testUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            final byte[] buffer = new byte[128];\n            int offset = 0;\n            while (true) {\n                int bufferOffset = random.nextInt(64);\n                final int bufferLength = random.nextInt(64);\n                int read = in.read(buffer, bufferOffset, bufferLength);\n                if (read == -1) {\n                    assertEquals(offset, expected.length);\n                    break;\n                }\n                assertTrue(read <= bufferLength);\n                while (read > 0) {\n                    assertTrue(offset < expected.length);\n                    assertEquals(expected[offset], buffer[bufferOffset]);\n                    offset++;\n                    bufferOffset++;\n                    read--;\n                }\n            }\n        }\n    }\n\n    private void testWithSingleByteRead(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            for (final byte b : bytes) {\n                final int read = in.read();\n                assertTrue(read >= 0);\n                assertTrue(read <= 255);\n                assertEquals(b, (byte) read);\n            }\n            assertEquals(-1, in.read());\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.CharArrayReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class ReaderInputStreamTest {\n\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i = 0; i < 100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    static Stream<Arguments> charsetData() {\n        // @formatter:off\n        return Stream.of(\n                Arguments.of(\"Cp930\", \"\\u0391\"),\n                Arguments.of(\"ISO_8859_1\", \"A\"),\n                Arguments.of(UTF_8, \"\\u0391\"));\n        // @formatter:on\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testBufferSmallest() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        // @formatter:off\n        try (InputStream in = new ReaderInputStream(\n                new StringReader(\"\\uD800\"),\n                charset, (int)\n                ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            in.read();\n        }\n        try (InputStream in = ReaderInputStream.builder()\n                .setReader(new StringReader(\"\\uD800\"))\n                .setCharset(charset)\n                .setBufferSize((int) ReaderInputStream.minBufferSize(charset.newEncoder()))\n                .get()) {\n            in.read();\n        }\n        // @formatter:on\n    }\n\n    @Test\n    public void testBufferTooSmall() {\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, -1));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 0));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 1));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"charsetData\")\n    public void testCharsetEncoderFlush(final String charsetName, final String data) throws IOException {\n        final Charset charset = Charset.forName(charsetName);\n        final byte[] expected = data.getBytes(charset);\n        try (InputStream in = new ReaderInputStream(new StringReader(data), charset)) {\n            assertEquals(Arrays.toString(expected), Arrays.toString(IOUtils.toByteArray(in)));\n        }\n        try (InputStream in = ReaderInputStream.builder().setReader(new StringReader(data)).setCharset(charset).get()) {\n            assertEquals(Arrays.toString(expected), Arrays.toString(IOUtils.toByteArray(in)));\n        }\n    }\n\n    /*\n     * Tests https://issues.apache.org/jira/browse/IO-277\n     */\n    @Test\n    public void testCharsetMismatchInfiniteLoop() throws IOException {\n        // Input is UTF-8 bytes: 0xE0 0xB2 0xA0\n        final char[] inputChars = { (char) 0xE0, (char) 0xB2, (char) 0xA0 };\n        // Charset charset = Charset.forName(\"UTF-8\"); // works\n        final Charset charset = StandardCharsets.US_ASCII; // infinite loop\n        try (ReaderInputStream stream = new ReaderInputStream(new CharArrayReader(inputChars), charset)) {\n            IOUtils.toCharArray(stream, charset);\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testCodingError() throws IOException {\n        // Encoder which throws on malformed or unmappable input\n        CharsetEncoder encoder = StandardCharsets.UTF_8.newEncoder();\n        try (final ReaderInputStream in = new ReaderInputStream(new StringReader(\"\\uD800\"), encoder)) {\n            // Does not throws an exception because the input is an underflow and not an error\n            assertDoesNotThrow(() -> in.read());\n            // assertThrows(IllegalStateException.class, () -> in.read());\n        }\n        encoder = StandardCharsets.UTF_8.newEncoder();\n        try (final ReaderInputStream in = ReaderInputStream.builder().setReader(new StringReader(\"\\uD800\")).setCharsetEncoder(encoder).get()) {\n            // TODO WIP\n            assertDoesNotThrow(() -> in.read());\n            // assertThrows(IllegalStateException.class, () -> in.read());\n        }\n    }\n\n    /**\n     * Tests IO-717 to avoid infinite loops.\n     *\n     * ReaderInputStream does not throw exception with {@link CodingErrorAction#REPORT}.\n     */\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testCodingErrorAction() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        final CharsetEncoder encoder = charset.newEncoder().onMalformedInput(CodingErrorAction.REPORT);\n        try (InputStream in = new ReaderInputStream(new StringReader(\"\\uD800aa\"), encoder, (int) ReaderInputStream.minBufferSize(encoder))) {\n            assertThrows(CharacterCodingException.class, in::read);\n        }\n        try (InputStream in = ReaderInputStream.builder().setReader(new StringReader(\"\\uD800aa\")).setCharsetEncoder(encoder)\n                .setBufferSize((int) ReaderInputStream.minBufferSize(charset.newEncoder())).get()) {\n            assertThrows(CharacterCodingException.class, in::read);\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharset() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final Charset encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final CharsetEncoder encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetNameEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final String charsetName = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), charsetName, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n        try (ReaderInputStream in = ReaderInputStream.builder().setReader(new StringReader(\"ABC\")).setCharset(charsetName)\n                .setBufferSize((int) ReaderInputStream.minBufferSize(charset.newEncoder())).get()) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZero() throws Exception {\n        final String inStr = \"test\";\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n            testReadZero(inStr, inputStream);\n        }\n        try (ReaderInputStream inputStream = ReaderInputStream.builder().setReader(new StringReader(inStr)).get()) {\n            testReadZero(inStr, inputStream);\n        }\n    }\n\n    private void testReadZero(final String inStr, final ReaderInputStream inputStream) throws IOException {\n        final byte[] bytes = new byte[30];\n        assertEquals(0, inputStream.read(bytes, 0, 0));\n        assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n        // Should always return 0 for length == 0\n        assertEquals(0, inputStream.read(bytes, 0, 0));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZeroEmptyString() throws Exception {\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(\"\"))) {\n            final byte[] bytes = new byte[30];\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_16);\n    }\n\n    @Test\n    public void testUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            testWithBufferedRead(expected, in);\n        }\n        try (ReaderInputStream in = ReaderInputStream.builder().setReader(new StringReader(testString)).setCharset(charsetName).get()) {\n            testWithBufferedRead(expected, in);\n        }\n    }\n\n    private void testWithBufferedRead(final byte[] expected, final ReaderInputStream in) throws IOException {\n        final byte[] buffer = new byte[128];\n        int offset = 0;\n        while (true) {\n            int bufferOffset = random.nextInt(64);\n            final int bufferLength = random.nextInt(64);\n            int read = in.read(buffer, bufferOffset, bufferLength);\n            if (read == -1) {\n                assertEquals(offset, expected.length);\n                break;\n            }\n            assertTrue(read <= bufferLength);\n            while (read > 0) {\n                assertTrue(offset < expected.length);\n                assertEquals(expected[offset], buffer[bufferOffset]);\n                offset++;\n                bufferOffset++;\n                read--;\n            }\n        }\n    }\n\n    private void testWithSingleByteRead(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            for (final byte b : bytes) {\n                final int read = in.read();\n                assertTrue(read >= 0);\n                assertTrue(read <= 255);\n                assertEquals(b, (byte) read);\n            }\n            assertEquals(-1, in.read());\n        }\n    }\n}\n", "diffSourceCodeSet": ["private void testReadZero(final String inStr, final ReaderInputStream inputStream) throws IOException {\n        final byte[] bytes = new byte[30];\n        assertEquals(0, inputStream.read(bytes, 0, 0));\n        assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n        // Should always return 0 for length == 0\n        assertEquals(0, inputStream.read(bytes, 0, 0));\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.XmlStreamReader#read\n methodBody: public int read(final char[] buf, final int offset, final int len) throws IOException {\nreturn reader.read(buf,offset,len);\n}", "methodSignature: org.apache.commons.io.input.Tailer.RandomAccessFileBridge#read\n methodBody: public int read(final byte[] b) throws IOException {\nreturn randomAccessFile.read(b);\n}", "methodSignature: org.apache.commons.io.input.Tailer.RandomAccessResourceBridge#read\n methodBody: int read(final byte[] b) throws IOException;", "methodSignature: org.apache.commons.io.FileUtilsTest.ShorterFile#length\n methodBody: public long length() {\nreturn super.length() - 1;\n}", "methodSignature: org.apache.commons.io.input.BOMInputStream#read\n methodBody: public int read(final byte[] buf, int off, int len) throws IOException {\nint firstCount=0;\nint b=0;\nwhile(len > 0 && b >= 0){b=readFirstBytes();\nif(b >= 0){buf[off++]=(byte)(b & 0xFF);\nlen--;\nfirstCount++;\n}}final int secondCount=in.read(buf,off,len);\nreturn secondCount < 0 ? firstCount > 0 ? firstCount : EOF : firstCount + secondCount;\n}", "methodSignature: org.apache.commons.io.input.BufferedFileChannelInputStream#read\n methodBody: public synchronized int read(final byte[] b, final int offset, int len) throws IOException {\nif(offset < 0 || len < 0 || offset + len < 0 || offset + len > b.length){throw new IndexOutOfBoundsException();\n}if(!refill()){return EOF;\n}len=Math.min(len,byteBuffer.remaining());\nbyteBuffer.get(b,offset,len);\nreturn len;\n}", "methodSignature: org.apache.commons.io.input.MemoryMappedFileInputStream#read\n methodBody: public int read(final byte[] b, final int off, final int len) throws IOException {\nensureOpen();\nif(!buffer.hasRemaining()){nextBuffer();\nif(!buffer.hasRemaining()){return EOF;\n}}final int numBytes=Math.min(buffer.remaining(),len);\nbuffer.get(b,off,numBytes);\nreturn numBytes;\n}", "methodSignature: org.apache.commons.io.input.ReaderInputStream#read\n methodBody: public int read(final byte[] array, int off, int len) throws IOException {\nObjects.requireNonNull(array,\"array\");\nif(len < 0 || off < 0 || off + len > array.length){throw new IndexOutOfBoundsException(\"Array size=\" + array.length + \", offset=\" + off + \", length=\" + len);\n}int read=0;\nif(len == 0){return 0;\n}while(len > 0){if(encoderOut.hasRemaining()){final int c=Math.min(encoderOut.remaining(),len);\nencoderOut.get(array,off,c);\noff+=c;\nlen-=c;\nread+=c;\n}if(endOfInput){break;\n}{fillBuffer();\n}}return read == 0 && endOfInput ? EOF : read;\n}", "methodSignature: org.apache.commons.io.input.RandomAccessFileInputStream#read\n methodBody: public int read(final byte[] bytes, final int offset, final int length) throws IOException {\nreturn randomAccessFile.read(bytes,offset,length);\n}", "methodSignature: org.apache.commons.io.input.ReadAheadInputStream#read\n methodBody: public int read(final byte[] b, final int offset, int len) throws IOException {\nif(offset < 0 || len < 0 || len > b.length - offset){throw new IndexOutOfBoundsException();\n}if(len == 0){return 0;\n}if(!activeBuffer.hasRemaining()){stateChangeLock.lock();\ntrywaitForAsyncReadComplete();\nif(!readAheadBuffer.hasRemaining()){readAsync();\nwaitForAsyncReadComplete();\nif(isEndOfStream()){return EOF;\n}}swapBuffers();\nreadAsync();\nfinallystateChangeLock.unlock();\n}len=Math.min(len,activeBuffer.remaining());\nactiveBuffer.get(b,offset,len);\nreturn len;\n}", "methodSignature: org.apache.commons.io.input.BOMInputStreamTest.ExpectCloseInputStream#read\n methodBody: public int read() throws IOException {\nreturn -1;\n}", "methodSignature: org.apache.commons.io.input.SequenceReaderTest.CustomReader#read\n methodBody: public int read(final char[] cbuf, final int off, final int len) throws IOException {\ncheckOpen();\nclose();\nreturn EOF;\n}"], "sourceCodeAfterRefactoring": "@SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZero() throws Exception {\n        final String inStr = \"test\";\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n            testReadZero(inStr, inputStream);\n        }\n        try (ReaderInputStream inputStream = ReaderInputStream.builder().setReader(new StringReader(inStr)).get()) {\n            testReadZero(inStr, inputStream);\n        }\n    }\nprivate void testReadZero(final String inStr, final ReaderInputStream inputStream) throws IOException {\n        final byte[] bytes = new byte[30];\n        assertEquals(0, inputStream.read(bytes, 0, 0));\n        assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n        // Should always return 0 for length == 0\n        assertEquals(0, inputStream.read(bytes, 0, 0));\n    }", "diffSourceCode": "-  169:     @SuppressWarnings(\"deprecation\")\n-  170:     @Test\n-  171:     public void testReadZero() throws Exception {\n-  172:         final String inStr = \"test\";\n-  173:         try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n-  174:             final byte[] bytes = new byte[30];\n-  175:             assertEquals(0, inputStream.read(bytes, 0, 0));\n-  176:             assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n-  177:             // Should always return 0 for length == 0\n-  178:             assertEquals(0, inputStream.read(bytes, 0, 0));\n-  179:         }\n-  180:     }\n-  211:         final byte[] expected = testString.getBytes(charsetName);\n-  212:         try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n-  213:             final byte[] buffer = new byte[128];\n-  214:             int offset = 0;\n-  215:             while (true) {\n-  216:                 int bufferOffset = random.nextInt(64);\n-  217:                 final int bufferLength = random.nextInt(64);\n-  218:                 int read = in.read(buffer, bufferOffset, bufferLength);\n-  219:                 if (read == -1) {\n-  220:                     assertEquals(offset, expected.length);\n-  221:                     break;\n-  223:                 assertTrue(read <= bufferLength);\n-  224:                 while (read > 0) {\n-  225:                     assertTrue(offset < expected.length);\n-  226:                     assertEquals(expected[offset], buffer[bufferOffset]);\n-  227:                     offset++;\n-  228:                     bufferOffset++;\n-  229:                     read--;\n+  169:             IOUtils.toByteArray(in);\n+  170:             assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n+  171:         }\n+  172:     }\n+  173: \n+  174:     @Test\n+  175:     @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n+  176:     public void testConstructNullCharsetEncoder() throws IOException {\n+  177:         final Charset charset = Charset.defaultCharset();\n+  178:         final CharsetEncoder encoder = null;\n+  179:         try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n+  180:             IOUtils.toByteArray(in);\n+  211:     @SuppressWarnings(\"deprecation\")\n+  212:     @Test\n+  213:     public void testReadZero() throws Exception {\n+  214:         final String inStr = \"test\";\n+  215:         try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n+  216:             testReadZero(inStr, inputStream);\n+  217:         }\n+  218:         try (ReaderInputStream inputStream = ReaderInputStream.builder().setReader(new StringReader(inStr)).get()) {\n+  219:             testReadZero(inStr, inputStream);\n+  220:         }\n+  221:     }\n+  223:     private void testReadZero(final String inStr, final ReaderInputStream inputStream) throws IOException {\n+  224:         final byte[] bytes = new byte[30];\n+  225:         assertEquals(0, inputStream.read(bytes, 0, 0));\n+  226:         assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n+  227:         // Should always return 0 for length == 0\n+  228:         assertEquals(0, inputStream.read(bytes, 0, 0));\n+  229:     }\n", "uniqueId": "7ecca22f175c644da3096940a4ce899be5b33740_169_180_223_229_211_221", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testReadZero` method, we can extract the logic for reading from the `ReaderInputStream` into a separate method. This will help to clarify the purpose of the test and reduce the complexity of the test method itself.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\nprivate void assertReadZero(ReaderInputStream inputStream, String inStr) throws IOException {\n    final byte[] bytes = new byte[30];\n    assertEquals(0, inputStream.read(bytes, 0, 0));\n    assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n    // Should always return 0 for length == 0\n    assertEquals(0, inputStream.read(bytes, 0, 0));\n}\n\n@Test\n@SuppressWarnings(\"deprecation\")\npublic void testReadZero() throws Exception {\n    final String inStr = \"test\";\n    try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n        assertReadZero(inputStream, inStr);\n    }\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic for reading from the `ReaderInputStream` has been moved to a new method called `assertReadZero`. This method takes the `ReaderInputStream` and the input string as parameters and performs the assertions.\n2. **Simplified Test Method**: The `testReadZero` method now simply sets up the test and calls the extracted method, making it clearer and easier to read.\n3. **Maintainability**: If the logic for reading changes in the future, it can be updated in one place (the `assertReadZero` method) rather than in multiple test methods.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZero() throws Exception {\n        final String inStr = \"test\";\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n            final byte[] bytes = new byte[30];\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.CharArrayReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class ReaderInputStreamTest {\n\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n    private static final String LARGE_TEST_STRING;\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i = 0; i < 100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    static Stream<Arguments> charsetData() {\n        // @formatter:off\n        return Stream.of(\n                Arguments.of(\"Cp930\", \"\\u0391\"),\n                Arguments.of(\"ISO_8859_1\", \"A\"),\n                Arguments.of(UTF_8, \"\\u0391\"));\n        // @formatter:on\n    }\n\n    private final Random random = new Random();\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testBufferSmallest() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        try (InputStream in = new ReaderInputStream(new StringReader(\"\\uD800\"), charset, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            in.read();\n        }\n    }\n\n    @Test\n    public void testBufferTooSmall() {\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, -1));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 0));\n        assertThrows(IllegalArgumentException.class, () -> new ReaderInputStream(new StringReader(\"\\uD800\"), StandardCharsets.UTF_8, 1));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"charsetData\")\n    public void testCharsetEncoderFlush(final String charsetName, final String data) throws IOException {\n        final Charset charset = Charset.forName(charsetName);\n        final byte[] expected = data.getBytes(charset);\n        try (InputStream in = new ReaderInputStream(new StringReader(data), charset)) {\n            final byte[] actual = IOUtils.toByteArray(in);\n            assertEquals(Arrays.toString(expected), Arrays.toString(actual));\n        }\n    }\n\n    /*\n     * Tests https://issues.apache.org/jira/browse/IO-277\n     */\n    @Test\n    public void testCharsetMismatchInfiniteLoop() throws IOException {\n        // Input is UTF-8 bytes: 0xE0 0xB2 0xA0\n        final char[] inputChars = {(char) 0xE0, (char) 0xB2, (char) 0xA0};\n        // Charset charset = Charset.forName(\"UTF-8\"); // works\n        final Charset charset = StandardCharsets.US_ASCII; // infinite loop\n        try (ReaderInputStream stream = new ReaderInputStream(new CharArrayReader(inputChars), charset)) {\n            IOUtils.toCharArray(stream, charset);\n        }\n    }\n\n    /**\n     * Tests IO-717 to avoid infinite loops.\n     *\n     * ReaderInputStream does not throw exception with {@link CodingErrorAction#REPORT}.\n     */\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testCodingErrorAction() throws IOException {\n        final Charset charset = StandardCharsets.UTF_8;\n        final CharsetEncoder encoder = charset.newEncoder().onMalformedInput(CodingErrorAction.REPORT);\n        try (InputStream in = new ReaderInputStream(new StringReader(\"\\uD800aa\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            assertThrows(CharacterCodingException.class, in::read);\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharset() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final Charset encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final CharsetEncoder encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    @Timeout(value = 500, unit = TimeUnit.MILLISECONDS)\n    public void testConstructNullCharsetNameEncoder() throws IOException {\n        final Charset charset = Charset.defaultCharset();\n        final String encoder = null;\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(\"ABC\"), encoder, (int) ReaderInputStream.minBufferSize(charset.newEncoder()))) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    public void testLargeUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZero() throws Exception {\n        final String inStr = \"test\";\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(inStr))) {\n            final byte[] bytes = new byte[30];\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(inStr.length(), inputStream.read(bytes, 0, inStr.length() + 1));\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n        }\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void testReadZeroEmptyString() throws Exception {\n        try (ReaderInputStream inputStream = new ReaderInputStream(new StringReader(\"\"))) {\n            final byte[] bytes = new byte[30];\n            // Should always return 0 for length == 0\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n            assertEquals(0, inputStream.read(bytes, 0, 0));\n            assertEquals(-1, inputStream.read(bytes, 0, 1));\n        }\n    }\n\n    @Test\n    public void testUTF16WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_16);\n    }\n\n    @Test\n    public void testUTF8WithBufferedRead() throws IOException {\n        testWithBufferedRead(TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testUTF8WithSingleByteRead() throws IOException {\n        testWithSingleByteRead(TEST_STRING, UTF_8);\n    }\n\n    private void testWithBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            final byte[] buffer = new byte[128];\n            int offset = 0;\n            while (true) {\n                int bufferOffset = random.nextInt(64);\n                final int bufferLength = random.nextInt(64);\n                int read = in.read(buffer, bufferOffset, bufferLength);\n                if (read == -1) {\n                    assertEquals(offset, expected.length);\n                    break;\n                }\n                assertTrue(read <= bufferLength);\n                while (read > 0) {\n                    assertTrue(offset < expected.length);\n                    assertEquals(expected[offset], buffer[bufferOffset]);\n                    offset++;\n                    bufferOffset++;\n                    read--;\n                }\n            }\n        }\n    }\n\n    private void testWithSingleByteRead(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(charsetName);\n        try (ReaderInputStream in = new ReaderInputStream(new StringReader(testString), charsetName)) {\n            for (final byte b : bytes) {\n                final int read = in.read();\n                assertTrue(read >= 0);\n                assertTrue(read <= 255);\n                assertEquals(b, (byte) read);\n            }\n            assertEquals(-1, in.read());\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpackage throwIOException(message String) : T extracted from private throwIOException() : T in class org.apache.commons.io.function.TestConstants", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/function/TestConstants.java", "startLine": 65, "endLine": 67, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/function/TestConstants.java", "startLine": 65, "endLine": 67, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/function/TestConstants.java", "startLine": 69, "endLine": 71, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private static <T> T throwIOException() throws IOException {\n        throw new IOException(\"Failure\");\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/function/TestConstants.java", "isPureRefactoring": true, "commitId": "4ea91d20dfa730bf2ce2120f7bdfbe0384d0c29a", "packageNameBefore": "org.apache.commons.io.function", "classNameBefore": "org.apache.commons.io.function.TestConstants", "methodNameBefore": "org.apache.commons.io.function.TestConstants#throwIOException", "classSignatureBefore": "class TestConstants ", "methodNameBeforeSet": ["org.apache.commons.io.function.TestConstants#throwIOException"], "classNameBeforeSet": ["org.apache.commons.io.function.TestConstants"], "classSignatureBeforeSet": ["class TestConstants "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All the mappings are matched! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Predicate;\n\n/**\n * Test fixtures for this package.\n */\nclass TestConstants {\n\n    static final Path ABS_PATH_A = Paths.get(\"LICENSE.txt\").toAbsolutePath();\n\n    static final Path ABS_PATH_B = Paths.get(\"NOTICE.txt\").toAbsolutePath();\n\n    static IOBiConsumer<Object, Object> THROWING_IO_BI_CONSUMER = (t, u) -> throwIOException();\n\n    static IOBiFunction<Object, Object, Object> THROWING_IO_BI_FUNCTION = (t, u) -> throwIOException();\n\n    static IOBinaryOperator<?> THROWING_IO_BINARY_OPERATOR = (t, u) -> throwIOException();\n\n    static IOComparator<Object> THROWING_IO_COMPARATOR = (t, u) -> throwIOException();\n\n    static IOConsumer<Object> THROWING_IO_CONSUMER = t -> throwIOException();\n\n    static IOFunction<Object, Object> THROWING_IO_FUNCTION = t -> throwIOException();\n\n    static IOPredicate<Object> THROWING_IO_PREDICATE = t -> throwIOException();\n\n    static IOQuadFunction<Object, Object, Object, Object, Object> THROWING_IO_QUAD_FUNCTION = (t, u, v, w) -> throwIOException();\n\n    static IORunnable THROWING_IO_RUNNABLE = () -> throwIOException();\n\n    static IOSupplier<Object> THROWING_IO_SUPPLIER = () -> throwIOException();\n\n    static IOTriConsumer<Object, Object, Object> THROWING_IO_TRI_CONSUMER = (t, u, v) -> throwIOException();\n\n    static IOTriFunction<Object, Object, Object, Object> THROWING_IO_TRI_FUNCTION = (t, u, v) -> throwIOException();\n\n    static IOUnaryOperator<?> THROWING_IO_UNARY_OPERATOR = t -> throwIOException();\n\n    static Predicate<Object> THROWING_PREDICATE = t -> {\n        throw new UncheckedIOException(new IOException(\"Failure\"));\n    };\n\n    private static <T> T throwIOException() throws IOException {\n        throw new IOException(\"Failure\");\n    }\n\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/function/TestConstants.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Predicate;\n\n/**\n * Test fixtures for this package.\n */\nclass TestConstants {\n\n    static final Path ABS_PATH_A = Paths.get(\"LICENSE.txt\").toAbsolutePath();\n\n    static final Path ABS_PATH_B = Paths.get(\"NOTICE.txt\").toAbsolutePath();\n\n    static IOBiConsumer<Object, Object> THROWING_IO_BI_CONSUMER = (t, u) -> throwIOException();\n\n    static IOBiFunction<Object, Object, Object> THROWING_IO_BI_FUNCTION = (t, u) -> throwIOException();\n\n    static IOBinaryOperator<?> THROWING_IO_BINARY_OPERATOR = (t, u) -> throwIOException();\n\n    static IOComparator<Object> THROWING_IO_COMPARATOR = (t, u) -> throwIOException();\n\n    static IOConsumer<Object> THROWING_IO_CONSUMER = t -> throwIOException();\n\n    static IOFunction<Object, Object> THROWING_IO_FUNCTION = t -> throwIOException();\n\n    static IOPredicate<Object> THROWING_IO_PREDICATE = t -> throwIOException();\n\n    static IOQuadFunction<Object, Object, Object, Object, Object> THROWING_IO_QUAD_FUNCTION = (t, u, v, w) -> throwIOException();\n\n    static IORunnable THROWING_IO_RUNNABLE = () -> throwIOException();\n\n    static IOSupplier<Object> THROWING_IO_SUPPLIER = () -> throwIOException();\n\n    static IOTriConsumer<Object, Object, Object> THROWING_IO_TRI_CONSUMER = (t, u, v) -> throwIOException();\n\n    static IOTriFunction<Object, Object, Object, Object> THROWING_IO_TRI_FUNCTION = (t, u, v) -> throwIOException();\n\n    static IOUnaryOperator<?> THROWING_IO_UNARY_OPERATOR = t -> throwIOException();\n\n    static Predicate<Object> THROWING_PREDICATE = t -> {\n        throw new UncheckedIOException(new IOException(\"Failure\"));\n    };\n\n    static <T> T throwIOException() throws IOException {\n        return throwIOException(\"Failure\");\n    }\n\n    static <T> T throwIOException(final String message) throws IOException {\n        throw new IOException(message);\n    }\n\n    static <T> T throwRuntimeException(final String message) {\n        throw new RuntimeException(message);\n    }\n\n}\n", "diffSourceCodeSet": ["static <T> T throwIOException(final String message) throws IOException {\n        throw new IOException(message);\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "static <T> T throwIOException() throws IOException {\n        return throwIOException(\"Failure\");\n    }\nstatic <T> T throwIOException(final String message) throws IOException {\n        throw new IOException(message);\n    }", "diffSourceCode": "-   65:     private static <T> T throwIOException() throws IOException {\n-   66:         throw new IOException(\"Failure\");\n+   65:     static <T> T throwIOException() throws IOException {\n+   66:         return throwIOException(\"Failure\");\n    67:     }\n-   69: }\n+   69:     static <T> T throwIOException(final String message) throws IOException {\n+   70:         throw new IOException(message);\n+   71:     }\n", "uniqueId": "4ea91d20dfa730bf2ce2120f7bdfbe0384d0c29a_65_67_69_71_65_67", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the code, we can extract the `throwIOException` method into a separate method that clearly indicates its purpose. This will help in understanding the code better and will also allow for easier modifications in the future if the exception handling needs to change.\n\nHere\u2019s the refactored method code:\n\n##########################\nprivate static <T> T throwIOException() throws IOException {\n    return throwIOException(\"Failure\");\n}\n\nprivate static <T> T throwIOException(String message) throws IOException {\n    throw new IOException(message);\n}\n########################## \n\nIn this refactoring, we have created a new method `throwIOException(String message)` that takes a message as a parameter. The original `throwIOException()` method now calls this new method with a default message. This makes it easier to customize the message in the future if needed, while keeping the original method signature intact for existing usages.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate static <T> T throwIOException() throws IOException {\n        throw new IOException(\"Failure\");\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.function.Predicate;\n\n/**\n * Test fixtures for this package.\n */\nclass TestConstants {\n\n    static final Path ABS_PATH_A = Paths.get(\"LICENSE.txt\").toAbsolutePath();\n\n    static final Path ABS_PATH_B = Paths.get(\"NOTICE.txt\").toAbsolutePath();\n\n    static IOBiConsumer<Object, Object> THROWING_IO_BI_CONSUMER = (t, u) -> throwIOException();\n\n    static IOBiFunction<Object, Object, Object> THROWING_IO_BI_FUNCTION = (t, u) -> throwIOException();\n\n    static IOBinaryOperator<?> THROWING_IO_BINARY_OPERATOR = (t, u) -> throwIOException();\n\n    static IOComparator<Object> THROWING_IO_COMPARATOR = (t, u) -> throwIOException();\n\n    static IOConsumer<Object> THROWING_IO_CONSUMER = t -> throwIOException();\n\n    static IOFunction<Object, Object> THROWING_IO_FUNCTION = t -> throwIOException();\n\n    static IOPredicate<Object> THROWING_IO_PREDICATE = t -> throwIOException();\n\n    static IOQuadFunction<Object, Object, Object, Object, Object> THROWING_IO_QUAD_FUNCTION = (t, u, v, w) -> throwIOException();\n\n    static IORunnable THROWING_IO_RUNNABLE = () -> throwIOException();\n\n    static IOSupplier<Object> THROWING_IO_SUPPLIER = () -> throwIOException();\n\n    static IOTriConsumer<Object, Object, Object> THROWING_IO_TRI_CONSUMER = (t, u, v) -> throwIOException();\n\n    static IOTriFunction<Object, Object, Object, Object> THROWING_IO_TRI_FUNCTION = (t, u, v) -> throwIOException();\n\n    static IOUnaryOperator<?> THROWING_IO_UNARY_OPERATOR = t -> throwIOException();\n\n    static Predicate<Object> THROWING_PREDICATE = t -> {\n        throw new UncheckedIOException(new IOException(\"Failure\"));\n    };\n\n    private static <T> T throwIOException() throws IOException {\n        throw new IOException(\"Failure\");\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate size(causeList List<? extends Throwable>) : int extracted from private isEmpty(causeList List<? extends Throwable>) : boolean in class org.apache.commons.io.IOExceptionList", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/IOExceptionList.java", "startLine": 53, "endLine": 55, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/IOExceptionList.java", "startLine": 53, "endLine": 55, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/IOExceptionList.java", "startLine": 57, "endLine": 59, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private static boolean isEmpty(final List<? extends Throwable> causeList) {\n        return causeList == null || causeList.isEmpty();\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/IOExceptionList.java", "isPureRefactoring": true, "commitId": "153a91c1271f4a07d56230670253e94c5ed94683", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.IOExceptionList", "methodNameBefore": "org.apache.commons.io.IOExceptionList#isEmpty", "invokedMethod": "methodSignature: org.apache.commons.io.IOExceptionList#isEmpty\n methodBody: private static boolean isEmpty(final List<? extends Throwable> causeList) {\nreturn causeList == null || causeList.isEmpty();\n}", "classSignatureBefore": "public class IOExceptionList extends IOException implements Iterable<Throwable> ", "methodNameBeforeSet": ["org.apache.commons.io.IOExceptionList#isEmpty"], "classNameBeforeSet": ["org.apache.commons.io.IOExceptionList"], "classSignatureBeforeSet": ["public class IOExceptionList extends IOException implements Iterable<Throwable> "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * An IOException based on a list of Throwable causes.\n * <p>\n * The first exception in the list is used as this exception's cause and is accessible with the usual\n * {@link #getCause()} while the complete list is accessible with {@link #getCauseList()}.\n * </p>\n *\n * @since 2.7\n */\npublic class IOExceptionList extends IOException implements Iterable<Throwable> {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Throws this exception if the list is not null or empty.\n     *\n     * @param causeList The list to test.\n     * @param message The detail message, see {@link #getMessage()}.\n     * @throws IOExceptionList if the list is not null or empty.\n     * @since 2.12.0\n     */\n    public static void checkEmpty(final List<? extends Throwable> causeList, final Object message) throws IOExceptionList {\n        if (!isEmpty(causeList)) {\n            throw new IOExceptionList(Objects.toString(message, null), causeList);\n        }\n    }\n\n    private static boolean isEmpty(final List<? extends Throwable> causeList) {\n        return causeList == null || causeList.isEmpty();\n    }\n\n    private static String toMessage(final List<? extends Throwable> causeList) {\n        return String.format(\"%,d exception(s): %s\", causeList == null ? 0 : causeList.size(), causeList);\n    }\n\n    private final List<? extends Throwable> causeList;\n\n    /**\n     * Creates a new exception caused by a list of exceptions.\n     *\n     * @param causeList a list of cause exceptions.\n     */\n    public IOExceptionList(final List<? extends Throwable> causeList) {\n        this(toMessage(causeList), causeList);\n    }\n\n    /**\n     * Creates a new exception caused by a list of exceptions.\n     *\n     * @param message The detail message, see {@link #getMessage()}.\n     * @param causeList a list of cause exceptions.\n     * @since 2.9.0\n     */\n    public IOExceptionList(final String message, final List<? extends Throwable> causeList) {\n        super(message != null ? message : toMessage(causeList), isEmpty(causeList) ? null : causeList.get(0));\n        this.causeList = causeList == null ? Collections.emptyList() : causeList;\n    }\n\n    /**\n     * Gets the cause exception at the given index.\n     *\n     * @param <T> type of exception to return.\n     * @param index index in the cause list.\n     * @return The list of causes.\n     */\n    public <T extends Throwable> T getCause(final int index) {\n        return (T) causeList.get(index);\n    }\n\n    /**\n     * Gets the cause exception at the given index.\n     *\n     * @param <T> type of exception to return.\n     * @param index index in the cause list.\n     * @param clazz type of exception to return.\n     * @return The list of causes.\n     */\n    public <T extends Throwable> T getCause(final int index, final Class<T> clazz) {\n        return clazz.cast(getCause(index));\n    }\n\n    /**\n     * Gets the cause list.\n     *\n     * @param <T> type of exception to return.\n     * @return The list of causes.\n     */\n    public <T extends Throwable> List<T> getCauseList() {\n        return (List<T>) causeList;\n    }\n\n    /**\n     * Works around Throwable and Generics, may fail at runtime depending on the argument value.\n     *\n     * @param <T> type of exception to return.\n     * @param clazz the target type\n     * @return The list of causes.\n     */\n    public <T extends Throwable> List<T> getCauseList(final Class<T> clazz) {\n        return (List<T>) causeList;\n    }\n\n    @Override\n    public Iterator<Throwable> iterator() {\n        return getCauseList().iterator();\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/IOExceptionList.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * An IOException based on a list of Throwable causes.\n * <p>\n * The first exception in the list is used as this exception's cause and is accessible with the usual\n * {@link #getCause()} while the complete list is accessible with {@link #getCauseList()}.\n * </p>\n *\n * @since 2.7\n */\npublic class IOExceptionList extends IOException implements Iterable<Throwable> {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Throws this exception if the list is not null or empty.\n     *\n     * @param causeList The list to test.\n     * @param message The detail message, see {@link #getMessage()}.\n     * @throws IOExceptionList if the list is not null or empty.\n     * @since 2.12.0\n     */\n    public static void checkEmpty(final List<? extends Throwable> causeList, final Object message) throws IOExceptionList {\n        if (!isEmpty(causeList)) {\n            throw new IOExceptionList(Objects.toString(message, null), causeList);\n        }\n    }\n\n    private static boolean isEmpty(final List<? extends Throwable> causeList) {\n        return size(causeList) == 0;\n    }\n\n    private static int size(final List<? extends Throwable> causeList) {\n        return causeList != null ? causeList.size() : 0;\n    }\n\n    private static String toMessage(final List<? extends Throwable> causeList) {\n        return String.format(\"%,d exception(s): %s\", size(causeList), causeList);\n    }\n\n    private final List<? extends Throwable> causeList;\n\n    /**\n     * Creates a new exception caused by a list of exceptions.\n     *\n     * @param causeList a list of cause exceptions.\n     */\n    public IOExceptionList(final List<? extends Throwable> causeList) {\n        this(toMessage(causeList), causeList);\n    }\n\n    /**\n     * Creates a new exception caused by a list of exceptions.\n     *\n     * @param message The detail message, see {@link #getMessage()}.\n     * @param causeList a list of cause exceptions.\n     * @since 2.9.0\n     */\n    public IOExceptionList(final String message, final List<? extends Throwable> causeList) {\n        super(message != null ? message : toMessage(causeList), isEmpty(causeList) ? null : causeList.get(0));\n        this.causeList = causeList == null ? Collections.emptyList() : causeList;\n    }\n\n    /**\n     * Gets the cause exception at the given index.\n     *\n     * @param <T> type of exception to return.\n     * @param index index in the cause list.\n     * @return The list of causes.\n     */\n    public <T extends Throwable> T getCause(final int index) {\n        return (T) causeList.get(index);\n    }\n\n    /**\n     * Gets the cause exception at the given index.\n     *\n     * @param <T> type of exception to return.\n     * @param index index in the cause list.\n     * @param clazz type of exception to return.\n     * @return The list of causes.\n     */\n    public <T extends Throwable> T getCause(final int index, final Class<T> clazz) {\n        return clazz.cast(getCause(index));\n    }\n\n    /**\n     * Gets the cause list.\n     *\n     * @param <T> type of exception to return.\n     * @return The list of causes.\n     */\n    public <T extends Throwable> List<T> getCauseList() {\n        return (List<T>) causeList;\n    }\n\n    /**\n     * Works around Throwable and Generics, may fail at runtime depending on the argument value.\n     *\n     * @param <T> type of exception to return.\n     * @param clazz the target type\n     * @return The list of causes.\n     */\n    public <T extends Throwable> List<T> getCauseList(final Class<T> clazz) {\n        return (List<T>) causeList;\n    }\n\n    @Override\n    public Iterator<Throwable> iterator() {\n        return getCauseList().iterator();\n    }\n\n}\n", "diffSourceCodeSet": ["private static int size(final List<? extends Throwable> causeList) {\n        return causeList != null ? causeList.size() : 0;\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.IOExceptionList#isEmpty\n methodBody: private static boolean isEmpty(final List<? extends Throwable> causeList) {\nreturn causeList == null || causeList.isEmpty();\n}"], "sourceCodeAfterRefactoring": "private static boolean isEmpty(final List<? extends Throwable> causeList) {\n        return size(causeList) == 0;\n    }\nprivate static int size(final List<? extends Throwable> causeList) {\n        return causeList != null ? causeList.size() : 0;\n    }", "diffSourceCode": "    53:     private static boolean isEmpty(final List<? extends Throwable> causeList) {\n-   54:         return causeList == null || causeList.isEmpty();\n+   54:         return size(causeList) == 0;\n    55:     }\n-   57:     private static String toMessage(final List<? extends Throwable> causeList) {\n-   58:         return String.format(\"%,d exception(s): %s\", causeList == null ? 0 : causeList.size(), causeList);\n+   57:     private static int size(final List<? extends Throwable> causeList) {\n+   58:         return causeList != null ? causeList.size() : 0;\n    59:     }\n", "uniqueId": "153a91c1271f4a07d56230670253e94c5ed94683_53_55_57_59_53_55", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 9}, "BRANCH": {"missed": 0, "covered": 4}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 3}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `isEmpty` method, we can extract the null check and the empty check into a separate method. This will make the `isEmpty` method more concise and easier to understand. \n\nHere\u2019s the refactored code:\n\n```java\nprivate static boolean isEmpty(final List<? extends Throwable> causeList) {\n    return isNull(causeList) || isListEmpty(causeList);\n}\n\nprivate static boolean isNull(final List<? extends Throwable> list) {\n    return list == null;\n}\n\nprivate static boolean isListEmpty(final List<? extends Throwable> list) {\n    return list.isEmpty();\n}\n```\n\nNow, the `isEmpty` method uses two new methods: `isNull` and `isListEmpty`, which encapsulate the logic for checking if the list is null and if the list is empty, respectively. This enhances the clarity of the code.\n\nHere\u2019s the output in the required format:\n\n##########################\n```java\nprivate static boolean isEmpty(final List<? extends Throwable> causeList) {\n    return isNull(causeList) || isListEmpty(causeList);\n}\n\nprivate static boolean isNull(final List<? extends Throwable> list) {\n    return list == null;\n}\n\nprivate static boolean isListEmpty(final List<? extends Throwable> list) {\n    return list.isEmpty();\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate static boolean isEmpty(final List<? extends Throwable> causeList) {\n        return causeList == null || causeList.isEmpty();\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * An IOException based on a list of Throwable causes.\n * <p>\n * The first exception in the list is used as this exception's cause and is accessible with the usual\n * {@link #getCause()} while the complete list is accessible with {@link #getCauseList()}.\n * </p>\n *\n * @since 2.7\n */\npublic class IOExceptionList extends IOException implements Iterable<Throwable> {\n\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * Throws this exception if the list is not null or empty.\n     *\n     * @param causeList The list to test.\n     * @param message The detail message, see {@link #getMessage()}.\n     * @throws IOExceptionList if the list is not null or empty.\n     * @since 2.12.0\n     */\n    public static void checkEmpty(final List<? extends Throwable> causeList, final Object message) throws IOExceptionList {\n        if (!isEmpty(causeList)) {\n            throw new IOExceptionList(Objects.toString(message, null), causeList);\n        }\n    }\n\n    private static boolean isEmpty(final List<? extends Throwable> causeList) {\n        return causeList == null || causeList.isEmpty();\n    }\n\n    private static String toMessage(final List<? extends Throwable> causeList) {\n        return String.format(\"%,d exception(s): %s\", causeList == null ? 0 : causeList.size(), causeList);\n    }\n\n    private final List<? extends Throwable> causeList;\n\n    /**\n     * Creates a new exception caused by a list of exceptions.\n     *\n     * @param causeList a list of cause exceptions.\n     */\n    public IOExceptionList(final List<? extends Throwable> causeList) {\n        this(toMessage(causeList), causeList);\n    }\n\n    /**\n     * Creates a new exception caused by a list of exceptions.\n     *\n     * @param message The detail message, see {@link #getMessage()}.\n     * @param causeList a list of cause exceptions.\n     * @since 2.9.0\n     */\n    public IOExceptionList(final String message, final List<? extends Throwable> causeList) {\n        super(message != null ? message : toMessage(causeList), isEmpty(causeList) ? null : causeList.get(0));\n        this.causeList = causeList == null ? Collections.emptyList() : causeList;\n    }\n\n    /**\n     * Gets the cause exception at the given index.\n     *\n     * @param <T> type of exception to return.\n     * @param index index in the cause list.\n     * @return The list of causes.\n     */\n    public <T extends Throwable> T getCause(final int index) {\n        return (T) causeList.get(index);\n    }\n\n    /**\n     * Gets the cause exception at the given index.\n     *\n     * @param <T> type of exception to return.\n     * @param index index in the cause list.\n     * @param clazz type of exception to return.\n     * @return The list of causes.\n     */\n    public <T extends Throwable> T getCause(final int index, final Class<T> clazz) {\n        return clazz.cast(getCause(index));\n    }\n\n    /**\n     * Gets the cause list.\n     *\n     * @param <T> type of exception to return.\n     * @return The list of causes.\n     */\n    public <T extends Throwable> List<T> getCauseList() {\n        return (List<T>) causeList;\n    }\n\n    /**\n     * Works around Throwable and Generics, may fail at runtime depending on the argument value.\n     *\n     * @param <T> type of exception to return.\n     * @param clazz the target type\n     * @return The list of causes.\n     */\n    public <T extends Throwable> List<T> getCauseList(final Class<T> clazz) {\n        return (List<T>) causeList;\n    }\n\n    @Override\n    public Iterator<Throwable> iterator() {\n        return getCauseList().iterator();\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpackage toIOConsumer(action IOConsumer<T>) : IOConsumer<T> extracted from package forEachIndexed(stream Stream<T>, action IOConsumer<T>, exSupplier BiFunction<Integer,IOException,IOException>) : void in class org.apache.commons.io.function.IOStreams", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/function/IOStreams.java", "startLine": 40, "endLine": 60, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/function/IOStreams.java", "startLine": 56, "endLine": 76, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/function/IOStreams.java", "startLine": 128, "endLine": 130, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "static <T> void forEachIndexed(final Stream<T> stream, final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier)\n        throws IOExceptionList {\n        final AtomicReference<List<IOException>> causeList = new AtomicReference<>();\n        final AtomicInteger index = new AtomicInteger();\n        final IOConsumer<T> actualAction = action != null ? action : IOConsumer.noop();\n        if (stream != null) {\n            stream.forEach(e -> {\n                try {\n                    actualAction.accept(e);\n                } catch (final IOException ioex) {\n                    if (causeList.get() == null) {\n                        causeList.set(new ArrayList<>());\n                    }\n                    if (exSupplier != null) {\n                        causeList.get().add(exSupplier.apply(index.get(), ioex));\n                    }\n                }\n                index.incrementAndGet();\n            });\n            IOExceptionList.checkEmpty(causeList.get(), null);\n        }}", "filePathBefore": "src/main/java/org/apache/commons/io/function/IOStreams.java", "isPureRefactoring": true, "commitId": "323d376b4a934a5a6ebdc552dc923db9e267e569", "packageNameBefore": "org.apache.commons.io.function", "classNameBefore": "org.apache.commons.io.function.IOStreams", "methodNameBefore": "org.apache.commons.io.function.IOStreams#forEachIndexed", "invokedMethod": "methodSignature: org.apache.commons.io.function.IOStreams#forEach\n methodBody: static <T> void forEach(final Stream<T> stream, final IOConsumer<T> action) throws IOException {\nforEachIndexed(stream,action,(i,e) -> e);\n}\nmethodSignature: org.apache.commons.io.input.ObservableInputStream#add\n methodBody: public void add(final Observer observer) {\nobservers.add(observer);\n}\nmethodSignature: org.apache.commons.io.function.IOConsumer#forEach\n methodBody: static <T> void forEach(final T[] array, final IOConsumer<T> action) throws IOException {\nIOStreams.forEach(IOStreams.of(array),action);\n}\nmethodSignature: org.apache.commons.io.function.IOConsumer#noop\n methodBody: static <T> IOConsumer<T> noop() {\nreturn (IOConsumer<T>)NOOP_IO_CONSUMER;\n}\nmethodSignature: org.apache.commons.io.function.IOConsumer#accept\n methodBody: void accept(T t) throws IOException;", "classSignatureBefore": "class IOStreams ", "methodNameBeforeSet": ["org.apache.commons.io.function.IOStreams#forEachIndexed"], "classNameBeforeSet": ["org.apache.commons.io.function.IOStreams"], "classSignatureBeforeSet": ["class IOStreams "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.BiFunction;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOExceptionList;\n\n/**\n * Keep this code package-private for now.\n */\nclass IOStreams {\n\n    static <T> void forEach(final Stream<T> stream, final IOConsumer<T> action) throws IOException {\n        forEachIndexed(stream, action, (i, e) -> e);\n    }\n\n    static <T> void forEachIndexed(final Stream<T> stream, final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier)\n        throws IOExceptionList {\n        final AtomicReference<List<IOException>> causeList = new AtomicReference<>();\n        final AtomicInteger index = new AtomicInteger();\n        final IOConsumer<T> actualAction = action != null ? action : IOConsumer.noop();\n        if (stream != null) {\n            stream.forEach(e -> {\n                try {\n                    actualAction.accept(e);\n                } catch (final IOException ioex) {\n                    if (causeList.get() == null) {\n                        causeList.set(new ArrayList<>());\n                    }\n                    if (exSupplier != null) {\n                        causeList.get().add(exSupplier.apply(index.get(), ioex));\n                    }\n                }\n                index.incrementAndGet();\n            });\n            IOExceptionList.checkEmpty(causeList.get(), null);\n        }}\n\n    /**\n     * Null-safe version of {@link Collection#stream()}.\n     *\n     * Copied from Apache Commons Lang.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new stream on {@code values} or {@link Stream#empty()}.\n     */\n    static <T> Stream<T> of(final Collection<T> values) {\n        return values == null ? Stream.empty() : values.stream();\n    }\n\n    /**\n     * Null-safe version of {@link Stream#of(Object[])}.\n     *\n     * Copied from Apache Commons Lang.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new stream on {@code values} or {@link Stream#empty()}.\n     */\n    @SafeVarargs // Creating a stream from an array is safe\n    static <T> Stream<T> of(final T... values) {\n        return values == null ? Stream.empty() : Stream.of(values);\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/function/IOStreams.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.BiFunction;\nimport java.util.stream.Stream;\nimport java.util.stream.StreamSupport;\n\nimport org.apache.commons.io.IOExceptionList;\n\n/**\n * Keep this code package-private for now.\n */\nclass IOStreams {\n\n    /**\n     * Accepts and throws an IOException.\n     *\n     * @param <T> The consumer type.\n     * @param consumer The consumer to accept.\n     * @param t the input argument.\n     * @throws IOException if an I/O error occurs; erased for the compiler.\n     */\n    static <T> void accept(final IOConsumer<T> consumer, T t) {\n        try {\n            consumer.accept(t);\n        } catch (IOException ex) {\n            rethrow(ex);\n        }\n    }\n\n    static <T> void forAll(final Stream<T> stream, final IOConsumer<T> action) throws IOExceptionList {\n        forAll(stream, action, (i, e) -> e);\n    }\n\n    static <T> void forAll(final Stream<T> stream, final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier)\n        throws IOExceptionList {\n        final AtomicReference<List<IOException>> causeList = new AtomicReference<>();\n        final AtomicInteger index = new AtomicInteger();\n        final IOConsumer<T> actualAction = toIOConsumer(action);\n        of(stream).forEach(e -> {\n            try {\n                actualAction.accept(e);\n            } catch (IOException ex) {\n                if (causeList.get() == null) {\n                    // Only allocate if required\n                    causeList.set(new ArrayList<>());\n                }\n                if (exSupplier != null) {\n                    causeList.get().add(exSupplier.apply(index.get(), ex));\n                }\n            }\n            index.incrementAndGet();\n        });\n        IOExceptionList.checkEmpty(causeList.get(), null);\n    }\n\n    @SuppressWarnings(\"unused\") // IOStreams.rethrow() throws\n    static <T> void forEach(final Stream<T> stream, final IOConsumer<T> action) throws IOException {\n        final IOConsumer<T> actualAction = toIOConsumer(action);\n        of(stream).forEach(e -> accept(actualAction, e));\n    }\n\n    /**\n     * Null-safe version of {@link StreamSupport#stream(java.util.Spliterator, boolean)}.\n     *\n     * Copied from Apache Commons Lang.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new stream on {@code values} or {@link Stream#empty()}.\n     */\n    static <T> Stream<T> of(final Iterable<T> values) {\n        return values == null ? Stream.empty() : StreamSupport.stream(values.spliterator(), false);\n    }\n\n    static <T> Stream<T> of(final Stream<T> stream) {\n        return stream == null ? Stream.empty() : stream;\n    }\n\n    /**\n     * Null-safe version of {@link Stream#of(Object[])}.\n     *\n     * Copied from Apache Commons Lang.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new stream on {@code values} or {@link Stream#empty()}.\n     */\n    @SafeVarargs // Creating a stream from an array is safe\n    static <T> Stream<T> of(final T... values) {\n        return values == null ? Stream.empty() : Stream.of(values);\n    }\n\n    /**\n     * Throws the given throwable.\n     *\n     * @param <T> The throwable cast type.\n     * @param throwable The throwable to rethrow.\n     * @return nothing because we throw.\n     * @throws T Always thrown.\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <T extends Throwable> RuntimeException rethrow(final Throwable throwable) throws T {\n        throw (T) throwable; // hack\n    }\n\n    static <T> IOConsumer<T> toIOConsumer(final IOConsumer<T> action) {\n        return action != null ? action : IOConsumer.noop();\n    }\n}\n", "diffSourceCodeSet": ["static <T> IOConsumer<T> toIOConsumer(final IOConsumer<T> action) {\n        return action != null ? action : IOConsumer.noop();\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.function.IOStreams#forEach\n methodBody: static <T> void forEach(final Stream<T> stream, final IOConsumer<T> action) throws IOException {\nforEachIndexed(stream,action,(i,e) -> e);\n}", "methodSignature: org.apache.commons.io.input.ObservableInputStream#add\n methodBody: public void add(final Observer observer) {\nobservers.add(observer);\n}", "methodSignature: org.apache.commons.io.function.IOConsumer#forEach\n methodBody: static <T> void forEach(final T[] array, final IOConsumer<T> action) throws IOException {\nIOStreams.forEach(IOStreams.of(array),action);\n}", "methodSignature: org.apache.commons.io.function.IOConsumer#noop\n methodBody: static <T> IOConsumer<T> noop() {\nreturn (IOConsumer<T>)NOOP_IO_CONSUMER;\n}", "methodSignature: org.apache.commons.io.function.IOConsumer#accept\n methodBody: void accept(T t) throws IOException;"], "sourceCodeAfterRefactoring": "static <T> void forAll(final Stream<T> stream, final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier)\n        throws IOExceptionList {\n        final AtomicReference<List<IOException>> causeList = new AtomicReference<>();\n        final AtomicInteger index = new AtomicInteger();\n        final IOConsumer<T> actualAction = toIOConsumer(action);\n        of(stream).forEach(e -> {\n            try {\n                actualAction.accept(e);\n            } catch (IOException ex) {\n                if (causeList.get() == null) {\n                    // Only allocate if required\n                    causeList.set(new ArrayList<>());\n                }\n                if (exSupplier != null) {\n                    causeList.get().add(exSupplier.apply(index.get(), ex));\n                }\n            }\n            index.incrementAndGet();\n        });\n        IOExceptionList.checkEmpty(causeList.get(), null);\n    }\nstatic <T> IOConsumer<T> toIOConsumer(final IOConsumer<T> action) {\n        return action != null ? action : IOConsumer.noop();\n    }", "diffSourceCode": "-   40:     static <T> void forEachIndexed(final Stream<T> stream, final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier)\n-   41:         throws IOExceptionList {\n-   42:         final AtomicReference<List<IOException>> causeList = new AtomicReference<>();\n-   43:         final AtomicInteger index = new AtomicInteger();\n-   44:         final IOConsumer<T> actualAction = action != null ? action : IOConsumer.noop();\n-   45:         if (stream != null) {\n-   46:             stream.forEach(e -> {\n-   47:                 try {\n-   48:                     actualAction.accept(e);\n-   49:                 } catch (final IOException ioex) {\n-   50:                     if (causeList.get() == null) {\n-   51:                         causeList.set(new ArrayList<>());\n-   52:                     }\n-   53:                     if (exSupplier != null) {\n-   54:                         causeList.get().add(exSupplier.apply(index.get(), ioex));\n-   55:                     }\n-   56:                 }\n-   57:                 index.incrementAndGet();\n-   58:             });\n-   59:             IOExceptionList.checkEmpty(causeList.get(), null);\n-   60:         }}\n-   61: \n-   62:     /**\n-   63:      * Null-safe version of {@link Collection#stream()}.\n-   64:      *\n-   65:      * Copied from Apache Commons Lang.\n-   66:      *\n-   67:      * @param <T> the type of stream elements.\n-   68:      * @param values the elements of the new stream, may be {@code null}.\n-   69:      * @return the new stream on {@code values} or {@link Stream#empty()}.\n-   70:      */\n-   71:     static <T> Stream<T> of(final Collection<T> values) {\n-   72:         return values == null ? Stream.empty() : values.stream();\n-   73:     }\n-   74: \n-   75:     /**\n-   76:      * Null-safe version of {@link Stream#of(Object[])}.\n+   40:      * @param consumer The consumer to accept.\n+   41:      * @param t the input argument.\n+   42:      * @throws IOException if an I/O error occurs; erased for the compiler.\n+   43:      */\n+   44:     static <T> void accept(final IOConsumer<T> consumer, T t) {\n+   45:         try {\n+   46:             consumer.accept(t);\n+   47:         } catch (IOException ex) {\n+   48:             rethrow(ex);\n+   49:         }\n+   50:     }\n+   51: \n+   52:     static <T> void forAll(final Stream<T> stream, final IOConsumer<T> action) throws IOExceptionList {\n+   53:         forAll(stream, action, (i, e) -> e);\n+   54:     }\n+   55: \n+   56:     static <T> void forAll(final Stream<T> stream, final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier)\n+   57:         throws IOExceptionList {\n+   58:         final AtomicReference<List<IOException>> causeList = new AtomicReference<>();\n+   59:         final AtomicInteger index = new AtomicInteger();\n+   60:         final IOConsumer<T> actualAction = toIOConsumer(action);\n+   61:         of(stream).forEach(e -> {\n+   62:             try {\n+   63:                 actualAction.accept(e);\n+   64:             } catch (IOException ex) {\n+   65:                 if (causeList.get() == null) {\n+   66:                     // Only allocate if required\n+   67:                     causeList.set(new ArrayList<>());\n+   68:                 }\n+   69:                 if (exSupplier != null) {\n+   70:                     causeList.get().add(exSupplier.apply(index.get(), ex));\n+   71:                 }\n+   72:             }\n+   73:             index.incrementAndGet();\n+   74:         });\n+   75:         IOExceptionList.checkEmpty(causeList.get(), null);\n+   76:     }\n+  128:     static <T> IOConsumer<T> toIOConsumer(final IOConsumer<T> action) {\n+  129:         return action != null ? action : IOConsumer.noop();\n+  130:     }\n", "uniqueId": "323d376b4a934a5a6ebdc552dc923db9e267e569_40_60_128_130_56_76", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 1, "covered": 28}, "BRANCH": {"missed": 2, "covered": 2}, "LINE": {"missed": 0, "covered": 7}, "COMPLEXITY": {"missed": 2, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `forEachIndexed` method, we can extract the logic that handles exceptions into a separate method. This will help to clarify the main flow of the `forEachIndexed` method and encapsulate the error handling logic.\n\nHere\u2019s the refactored code with the extracted method:\n\n```java\n##########################\nstatic <T> void forEachIndexed(final Stream<T> stream, final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier)\n        throws IOExceptionList {\n    final AtomicReference<List<IOException>> causeList = new AtomicReference<>();\n    final AtomicInteger index = new AtomicInteger();\n    final IOConsumer<T> actualAction = action != null ? action : IOConsumer.noop();\n    if (stream != null) {\n        stream.forEach(e -> processElement(e, actualAction, index, causeList, exSupplier));\n        IOExceptionList.checkEmpty(causeList.get(), null);\n    }\n}\n\nprivate static <T> void processElement(T element, IOConsumer<T> action, AtomicInteger index, AtomicReference<List<IOException>> causeList, BiFunction<Integer, IOException, IOException> exSupplier) {\n    try {\n        action.accept(element);\n    } catch (final IOException ioex) {\n        if (causeList.get() == null) {\n            causeList.set(new ArrayList<>());\n        }\n        if (exSupplier != null) {\n            causeList.get().add(exSupplier.apply(index.get(), ioex));\n        }\n    }\n    index.incrementAndGet();\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic for processing each element of the stream, including exception handling, has been moved to a new method called `processElement`. This method takes the necessary parameters to perform its task.\n2. **Improved Readability**: The main `forEachIndexed` method is now cleaner and focuses on the overall flow, while the details of processing each element are encapsulated in `processElement`.\n3. **Maintainability**: If any changes are needed in the way elements are processed or exceptions are handled, they can be made in one place (the `processElement` method) without affecting the main logic of `forEachIndexed`.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nstatic <T> void forEachIndexed(final Stream<T> stream, final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier)\n        throws IOExceptionList {\n        final AtomicReference<List<IOException>> causeList = new AtomicReference<>();\n        final AtomicInteger index = new AtomicInteger();\n        final IOConsumer<T> actualAction = action != null ? action : IOConsumer.noop();\n        if (stream != null) {\n            stream.forEach(e -> {\n                try {\n                    actualAction.accept(e);\n                } catch (final IOException ioex) {\n                    if (causeList.get() == null) {\n                        causeList.set(new ArrayList<>());\n                    }\n                    if (exSupplier != null) {\n                        causeList.get().add(exSupplier.apply(index.get(), ioex));\n                    }\n                }\n                index.incrementAndGet();\n            });\n            IOExceptionList.checkEmpty(causeList.get(), null);\n        }}\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.BiFunction;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.IOExceptionList;\n\n/**\n * Keep this code package-private for now.\n */\nclass IOStreams {\n\n    static <T> void forEach(final Stream<T> stream, final IOConsumer<T> action) throws IOException {\n        forEachIndexed(stream, action, (i, e) -> e);\n    }\n\n    static <T> void forEachIndexed(final Stream<T> stream, final IOConsumer<T> action, final BiFunction<Integer, IOException, IOException> exSupplier)\n        throws IOExceptionList {\n        final AtomicReference<List<IOException>> causeList = new AtomicReference<>();\n        final AtomicInteger index = new AtomicInteger();\n        final IOConsumer<T> actualAction = action != null ? action : IOConsumer.noop();\n        if (stream != null) {\n            stream.forEach(e -> {\n                try {\n                    actualAction.accept(e);\n                } catch (final IOException ioex) {\n                    if (causeList.get() == null) {\n                        causeList.set(new ArrayList<>());\n                    }\n                    if (exSupplier != null) {\n                        causeList.get().add(exSupplier.apply(index.get(), ioex));\n                    }\n                }\n                index.incrementAndGet();\n            });\n            IOExceptionList.checkEmpty(causeList.get(), null);\n        }}\n\n    /**\n     * Null-safe version of {@link Collection#stream()}.\n     *\n     * Copied from Apache Commons Lang.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new stream on {@code values} or {@link Stream#empty()}.\n     */\n    static <T> Stream<T> of(final Collection<T> values) {\n        return values == null ? Stream.empty() : values.stream();\n    }\n\n    /**\n     * Null-safe version of {@link Stream#of(Object[])}.\n     *\n     * Copied from Apache Commons Lang.\n     *\n     * @param <T> the type of stream elements.\n     * @param values the elements of the new stream, may be {@code null}.\n     * @return the new stream on {@code values} or {@link Stream#empty()}.\n     */\n    @SafeVarargs // Creating a stream from an array is safe\n    static <T> Stream<T> of(final T... values) {\n        return values == null ? Stream.empty() : Stream.of(values);\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate current() : Path extracted from public testReadAttributesPosix() : void in class org.apache.commons.io.file.PathUtilsTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "startLine": 335, "endLine": 345, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "startLine": 376, "endLine": 386, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "startLine": 94, "endLine": 96, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(PathUtils.current(), PosixFileAttributes.class) != null);\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "isPureRefactoring": true, "commitId": "cb6f3aabcf872aeab3bb4c975d163f340b93f051", "packageNameBefore": "org.apache.commons.io.file", "classNameBefore": "org.apache.commons.io.file.PathUtilsTest", "methodNameBefore": "org.apache.commons.io.file.PathUtilsTest#testReadAttributesPosix", "invokedMethod": "methodSignature: org.apache.commons.io.file.PathUtils#current\n methodBody: public static Path current() {\nreturn Paths.get(\".\");\n}\nmethodSignature: org.apache.commons.io.file.PathUtils#readAttributes\n methodBody: public static <A extends BasicFileAttributes> A readAttributes(final Path path, final Class<A> type, final LinkOption... options) {\ntryreturn path == null ? null : UncheckedIO.apply(Files::readAttributes,path,type,options);\ncatch(final UnsupportedOperationException e)return null;\n}", "classSignatureBefore": "public class PathUtilsTest extends AbstractTempDirTest ", "methodNameBeforeSet": ["org.apache.commons.io.file.PathUtilsTest#testReadAttributesPosix"], "classNameBeforeSet": ["org.apache.commons.io.file.PathUtilsTest"], "classSignatureBeforeSet": ["public class PathUtilsTest extends AbstractTempDirTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "", "description": "Argument replaced with return expression - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertThrowsExactly;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileAlreadyExistsException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link PathUtils}.\n */\npublic class PathUtilsTest extends AbstractTempDirTest {\n\n    private static final String STRING_FIXTURE = \"Hello World\";\n\n    private static final byte[] BYTE_ARRAY_FIXTURE = STRING_FIXTURE.getBytes(StandardCharsets.UTF_8);\n\n    private static final String TEST_JAR_NAME = \"test.jar\";\n\n    private static final String TEST_JAR_PATH = \"src/test/resources/org/apache/commons/io/test.jar\";\n\n    private static final String PATH_FIXTURE = \"NOTICE.txt\";\n\n    /**\n     * Creates directory test fixtures.\n     * <ol>\n     * <li>tempDirPath/subdir</li>\n     * <li>tempDirPath/symlinked-dir -> tempDirPath/subdir</li>\n     * </ol>\n     *\n     * @return Path to tempDirPath/subdir\n     * @throws IOException if an I/O error occurs or the parent directory does not exist.\n     */\n    private Path createTempSymlinkedRelativeDir() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symlinkDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symlinkDir, targetDir);\n        return symlinkDir;\n    }\n\n    private Long getLastModifiedMillis(final Path file) throws IOException {\n        return Files.getLastModifiedTime(file).toMillis();\n    }\n\n    private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n        if (createNew) {\n            final Map<String, String> env = new HashMap<>();\n            env.put(\"create\", \"true\");\n            final URI fileUri = p.toAbsolutePath().toUri();\n            final URI uri = URI.create(\"jar:\" + fileUri.toASCIIString());\n            return FileSystems.newFileSystem(uri, env, null);\n        }\n        return FileSystems.newFileSystem(p, (ClassLoader) null);\n    }\n\n    private void setLastModifiedMillis(final Path file, final long millis) throws IOException {\n        Files.setLastModifiedTime(file, FileTime.fromMillis(millis));\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false)) {\n            // relative jar -> absolute dir\n            Path sourceDir = archive.getPath(\"dir1\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"f1\")));\n\n            // absolute jar -> absolute dir\n            sourceDir = archive.getPath(\"/next\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"dir\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // absolute dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\").toAbsolutePath();\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // absolute dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false);\n            final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            final Path targetDir = targetArchive.getPath(\"targetDir\");\n            Files.createDirectory(targetDir);\n            // relative jar -> relative dir\n            Path sourceDir = archive.getPath(\"next\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dir\")));\n\n            // absolute jar -> relative dir\n            sourceDir = archive.getPath(\"/dir1\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"f1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // relative dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // relative dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyFile() throws IOException {\n        final Path sourceFile = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-1-file-size-1/file-size-1.bin\");\n        final Path targetFile = PathUtils.copyFileToDirectory(sourceFile, tempDirPath);\n        assertTrue(Files.exists(targetFile));\n        assertEquals(Files.size(sourceFile), Files.size(targetFile));\n    }\n\n    @Test\n    public void testCreateDirectoriesAlreadyExists() throws IOException {\n        assertEquals(tempDirPath.getParent(), PathUtils.createParentDirectories(tempDirPath));\n    }\n\n    @SuppressWarnings(\"resource\") // FileSystems.getDefault() is a singleton\n    @Test\n    public void testCreateDirectoriesForRoots() throws IOException {\n        for (final Path path : FileSystems.getDefault().getRootDirectories()) {\n            final Path parent = path.getParent();\n            assertNull(parent);\n            assertEquals(parent, PathUtils.createParentDirectories(path));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesForRootsLinkOptionNull() throws IOException {\n        for (final File f : File.listRoots()) {\n            final Path path = f.toPath();\n            assertEquals(path.getParent(), PathUtils.createParentDirectories(path, (LinkOption) null));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesNew() throws IOException {\n        assertEquals(tempDirPath, PathUtils.createParentDirectories(tempDirPath.resolve(\"child\")));\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlink() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        final String leafDirName = \"child\";\n        final Path newDirFollowed = PathUtils.createParentDirectories(symlinkedDir.resolve(leafDirName), PathUtils.NULL_LINK_OPTION);\n        assertEquals(Files.readSymbolicLink(symlinkedDir), newDirFollowed);\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlinkClashing() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        assertThrowsExactly(FileAlreadyExistsException.class, () -> PathUtils.createParentDirectories(symlinkedDir.resolve(\"child\")));\n    }\n\n    @Test\n    public void testGetTempDirectory() {\n        final Path tempDirectory = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n        assertEquals(tempDirectory, PathUtils.getTempDirectory());\n    }\n\n    @Test\n    public void testIsDirectory() throws IOException {\n        assertFalse(PathUtils.isDirectory(null));\n\n        assertTrue(PathUtils.isDirectory(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertFalse(PathUtils.isDirectory(testFile1.get()));\n\n            Path ref = null;\n            try (TempDirectory tempDir = TempDirectory.create(getClass().getCanonicalName())) {\n                ref = tempDir.get();\n                assertTrue(PathUtils.isDirectory(tempDir.get()));\n            }\n            assertFalse(PathUtils.isDirectory(ref));\n        }\n    }\n\n    @Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(PathUtils.current()));\n    }\n\n    @Test\n    public void testIsRegularFile() throws IOException {\n        assertFalse(PathUtils.isRegularFile(null));\n\n        assertFalse(PathUtils.isRegularFile(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertTrue(PathUtils.isRegularFile(testFile1.get()));\n\n            Files.delete(testFile1.get());\n            assertFalse(PathUtils.isRegularFile(testFile1.get()));\n        }\n    }\n\n    @Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n        final Path file = writeToNewOutputStream(true);\n        assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n    }\n\n    public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n        final Path file = writeToNewOutputStream(append);\n        assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileInsideExistingSymlinkedDir() throws IOException {\n        final Path symlinkDir = createTempSymlinkedRelativeDir();\n        final Path file = symlinkDir.resolve(\"test.txt\");\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, null)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, true)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, false)) {\n            // empty\n        }\n    }\n\n    @Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(PathUtils.current(), PosixFileAttributes.class) != null);\n    }\n\n    @Test\n    public void testReadStringEmptyFile() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-empty.bin\");\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testReadStringSimpleUtf8() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-simple-utf8.bin\");\n        final String expected = \"ABC\\r\\n\";\n        assertEquals(expected, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(expected, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testSetReadOnlyFile() throws IOException {\n        final Path resolved = tempDirPath.resolve(\"testSetReadOnlyFile.txt\");\n        // Ask now, as we are allowed before editing parent permissions.\n        final boolean isPosix = PathUtils.isPosix(tempDirPath);\n\n        // TEMP HACK\n        assumeFalse(SystemUtils.IS_OS_LINUX);\n\n        PathUtils.writeString(resolved, \"test\", StandardCharsets.UTF_8);\n        final boolean readable = Files.isReadable(resolved);\n        final boolean writable = Files.isWritable(resolved);\n        final boolean regularFile = Files.isRegularFile(resolved);\n        final boolean executable = Files.isExecutable(resolved);\n        final boolean hidden = Files.isHidden(resolved);\n        final boolean directory = Files.isDirectory(resolved);\n        final boolean symbolicLink = Files.isSymbolicLink(resolved);\n        // Sanity checks\n        assertTrue(readable);\n        assertTrue(writable);\n        // Test A\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        // Again, shouldn't blow up.\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        //\n        assertEquals(regularFile, Files.isReadable(resolved));\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        // Test B\n        PathUtils.setReadOnly(resolved, true);\n        if (isPosix) {\n            // On POSIX, now that the parent is not WX, the file is not readable.\n            assertFalse(Files.isReadable(resolved), \"isReadable\");\n        } else {\n            assertTrue(Files.isReadable(resolved), \"isReadable\");\n        }\n        assertFalse(Files.isWritable(resolved), \"isWritable\");\n        final DosFileAttributeView dosFileAttributeView = PathUtils.getDosFileAttributeView(resolved);\n        if (dosFileAttributeView != null) {\n            assertTrue(dosFileAttributeView.readAttributes().isReadOnly());\n        }\n        if (isPosix) {\n            assertFalse(Files.isReadable(resolved));\n        } else {\n            assertEquals(regularFile, Files.isReadable(resolved));\n        }\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        //\n        PathUtils.setReadOnly(resolved, false);\n        PathUtils.deleteFile(resolved);\n    }\n\n    @Test\n    public void testTouch() throws IOException {\n        assertThrows(NullPointerException.class, () -> FileUtils.touch(null));\n\n        final Path file = managedTempDirPath.resolve(\"touch.txt\");\n        Files.deleteIfExists(file);\n        assertFalse(Files.exists(file), \"Bad test: test file still exists\");\n        PathUtils.touch(file);\n        assertTrue(Files.exists(file), \"touch() created file\");\n        try (OutputStream out = Files.newOutputStream(file)) {\n            assertEquals(0, Files.size(file), \"Created empty file.\");\n            out.write(0);\n        }\n        assertEquals(1, Files.size(file), \"Wrote one byte to file\");\n        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();\n        setLastModifiedMillis(file, y2k);  // 0L fails on Win98\n        assertEquals(y2k, getLastModifiedMillis(file), \"Bad test: set lastModified set incorrect value\");\n        final long nowMillis = System.currentTimeMillis();\n        PathUtils.touch(file);\n        assertEquals(1, Files.size(file), \"FileUtils.touch() didn't empty the file.\");\n        assertNotEquals(y2k, getLastModifiedMillis(file), \"FileUtils.touch() changed lastModified\");\n        final int delta = 3000;\n        assertTrue(getLastModifiedMillis(file) >= nowMillis - delta, \"FileUtils.touch() changed lastModified to more than now-3s\");\n        assertTrue(getLastModifiedMillis(file) <= nowMillis + delta, \"FileUtils.touch() changed lastModified to less than now+3s\");\n    }\n\n    @Test\n    public void testWriteStringToFile1() throws Exception {\n        final Path file = tempDirPath.resolve(\"write.txt\");\n        PathUtils.writeString(file, \"Hello /u1234\", StandardCharsets.UTF_8);\n        final byte[] text = \"Hello /u1234\".getBytes(StandardCharsets.UTF_8);\n        TestUtils.assertEqualContent(text, file);\n    }\n\n    /**\n     * Tests newOutputStream() here and don't use Files.write obviously.\n     */\n    private Path writeToNewOutputStream(final boolean append) throws IOException {\n        final Path file = tempDirPath.resolve(\"test1.txt\");\n        try (OutputStream os = PathUtils.newOutputStream(file, append)) {\n            os.write(BYTE_ARRAY_FIXTURE);\n        }\n        return file;\n    }\n\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertThrowsExactly;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileAlreadyExistsException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link PathUtils}.\n */\npublic class PathUtilsTest extends AbstractTempDirTest {\n\n    private static final String STRING_FIXTURE = \"Hello World\";\n\n    private static final byte[] BYTE_ARRAY_FIXTURE = STRING_FIXTURE.getBytes(StandardCharsets.UTF_8);\n\n    private static final String TEST_JAR_NAME = \"test.jar\";\n\n    private static final String TEST_JAR_PATH = \"src/test/resources/org/apache/commons/io/test.jar\";\n\n    private static final String PATH_FIXTURE = \"NOTICE.txt\";\n\n    /**\n     * Creates directory test fixtures.\n     * <ol>\n     * <li>tempDirPath/subdir</li>\n     * <li>tempDirPath/symlinked-dir -> tempDirPath/subdir</li>\n     * </ol>\n     *\n     * @return Path to tempDirPath/subdir\n     * @throws IOException if an I/O error occurs or the parent directory does not exist.\n     */\n    private Path createTempSymlinkedRelativeDir() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symlinkDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symlinkDir, targetDir);\n        return symlinkDir;\n    }\n\n    private Path current() {\n        return PathUtils.current();\n    }\n\n    private Long getLastModifiedMillis(final Path file) throws IOException {\n        return Files.getLastModifiedTime(file).toMillis();\n    }\n\n    private Path getNonExistantPath() {\n        return Paths.get(\"/does not exist/for/certain\");\n    }\n\n    private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n        if (createNew) {\n            final Map<String, String> env = new HashMap<>();\n            env.put(\"create\", \"true\");\n            final URI fileUri = p.toAbsolutePath().toUri();\n            final URI uri = URI.create(\"jar:\" + fileUri.toASCIIString());\n            return FileSystems.newFileSystem(uri, env, null);\n        }\n        return FileSystems.newFileSystem(p, (ClassLoader) null);\n    }\n\n    private void setLastModifiedMillis(final Path file, final long millis) throws IOException {\n        Files.setLastModifiedTime(file, FileTime.fromMillis(millis));\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false)) {\n            // relative jar -> absolute dir\n            Path sourceDir = archive.getPath(\"dir1\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"f1\")));\n\n            // absolute jar -> absolute dir\n            sourceDir = archive.getPath(\"/next\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"dir\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // absolute dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\").toAbsolutePath();\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // absolute dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false);\n            final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            final Path targetDir = targetArchive.getPath(\"targetDir\");\n            Files.createDirectory(targetDir);\n            // relative jar -> relative dir\n            Path sourceDir = archive.getPath(\"next\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dir\")));\n\n            // absolute jar -> relative dir\n            sourceDir = archive.getPath(\"/dir1\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"f1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // relative dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // relative dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyFile() throws IOException {\n        final Path sourceFile = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-1-file-size-1/file-size-1.bin\");\n        final Path targetFile = PathUtils.copyFileToDirectory(sourceFile, tempDirPath);\n        assertTrue(Files.exists(targetFile));\n        assertEquals(Files.size(sourceFile), Files.size(targetFile));\n    }\n\n    @Test\n    public void testCreateDirectoriesAlreadyExists() throws IOException {\n        assertEquals(tempDirPath.getParent(), PathUtils.createParentDirectories(tempDirPath));\n    }\n\n    @SuppressWarnings(\"resource\") // FileSystems.getDefault() is a singleton\n    @Test\n    public void testCreateDirectoriesForRoots() throws IOException {\n        for (final Path path : FileSystems.getDefault().getRootDirectories()) {\n            final Path parent = path.getParent();\n            assertNull(parent);\n            assertEquals(parent, PathUtils.createParentDirectories(path));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesForRootsLinkOptionNull() throws IOException {\n        for (final File f : File.listRoots()) {\n            final Path path = f.toPath();\n            assertEquals(path.getParent(), PathUtils.createParentDirectories(path, (LinkOption) null));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesNew() throws IOException {\n        assertEquals(tempDirPath, PathUtils.createParentDirectories(tempDirPath.resolve(\"child\")));\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlink() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        final String leafDirName = \"child\";\n        final Path newDirFollowed = PathUtils.createParentDirectories(symlinkedDir.resolve(leafDirName), PathUtils.NULL_LINK_OPTION);\n        assertEquals(Files.readSymbolicLink(symlinkedDir), newDirFollowed);\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlinkClashing() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        assertThrowsExactly(FileAlreadyExistsException.class, () -> PathUtils.createParentDirectories(symlinkedDir.resolve(\"child\")));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_File_Present() throws IOException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current().toFile()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_Path_Absent() throws IOException {\n        assertNull(PathUtils.getLastModifiedFileTime(getNonExistantPath()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_Path_FileTime_Absent() throws IOException {\n        final FileTime fromMillis = FileTime.fromMillis(0);\n        assertEquals(fromMillis, PathUtils.getLastModifiedFileTime(getNonExistantPath(), fromMillis));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_Path_Present() throws IOException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_URI_Present() throws IOException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current().toUri()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_URL_Present() throws IOException, URISyntaxException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current().toUri().toURL()));\n    }\n\n    @Test\n    public void testGetTempDirectory() {\n        final Path tempDirectory = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n        assertEquals(tempDirectory, PathUtils.getTempDirectory());\n    }\n\n    @Test\n    public void testIsDirectory() throws IOException {\n        assertFalse(PathUtils.isDirectory(null));\n\n        assertTrue(PathUtils.isDirectory(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertFalse(PathUtils.isDirectory(testFile1.get()));\n\n            Path ref = null;\n            try (TempDirectory tempDir = TempDirectory.create(getClass().getCanonicalName())) {\n                ref = tempDir.get();\n                assertTrue(PathUtils.isDirectory(tempDir.get()));\n            }\n            assertFalse(PathUtils.isDirectory(ref));\n        }\n    }\n\n    @Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(current()));\n    }\n\n    @Test\n    public void testIsRegularFile() throws IOException {\n        assertFalse(PathUtils.isRegularFile(null));\n\n        assertFalse(PathUtils.isRegularFile(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertTrue(PathUtils.isRegularFile(testFile1.get()));\n\n            Files.delete(testFile1.get());\n            assertFalse(PathUtils.isRegularFile(testFile1.get()));\n        }\n    }\n\n    @Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n        final Path file = writeToNewOutputStream(true);\n        assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n    }\n\n    public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n        final Path file = writeToNewOutputStream(append);\n        assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileInsideExistingSymlinkedDir() throws IOException {\n        final Path symlinkDir = createTempSymlinkedRelativeDir();\n        final Path file = symlinkDir.resolve(\"test.txt\");\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, null)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, true)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, false)) {\n            // empty\n        }\n    }\n\n    @Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(current(), PosixFileAttributes.class) != null);\n    }\n\n    @Test\n    public void testReadStringEmptyFile() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-empty.bin\");\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testReadStringSimpleUtf8() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-simple-utf8.bin\");\n        final String expected = \"ABC\\r\\n\";\n        assertEquals(expected, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(expected, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testSetReadOnlyFile() throws IOException {\n        final Path resolved = tempDirPath.resolve(\"testSetReadOnlyFile.txt\");\n        // Ask now, as we are allowed before editing parent permissions.\n        final boolean isPosix = PathUtils.isPosix(tempDirPath);\n\n        // TEMP HACK\n        assumeFalse(SystemUtils.IS_OS_LINUX);\n\n        PathUtils.writeString(resolved, \"test\", StandardCharsets.UTF_8);\n        final boolean readable = Files.isReadable(resolved);\n        final boolean writable = Files.isWritable(resolved);\n        final boolean regularFile = Files.isRegularFile(resolved);\n        final boolean executable = Files.isExecutable(resolved);\n        final boolean hidden = Files.isHidden(resolved);\n        final boolean directory = Files.isDirectory(resolved);\n        final boolean symbolicLink = Files.isSymbolicLink(resolved);\n        // Sanity checks\n        assertTrue(readable);\n        assertTrue(writable);\n        // Test A\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        // Again, shouldn't blow up.\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        //\n        assertEquals(regularFile, Files.isReadable(resolved));\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        // Test B\n        PathUtils.setReadOnly(resolved, true);\n        if (isPosix) {\n            // On POSIX, now that the parent is not WX, the file is not readable.\n            assertFalse(Files.isReadable(resolved), \"isReadable\");\n        } else {\n            assertTrue(Files.isReadable(resolved), \"isReadable\");\n        }\n        assertFalse(Files.isWritable(resolved), \"isWritable\");\n        final DosFileAttributeView dosFileAttributeView = PathUtils.getDosFileAttributeView(resolved);\n        if (dosFileAttributeView != null) {\n            assertTrue(dosFileAttributeView.readAttributes().isReadOnly());\n        }\n        if (isPosix) {\n            assertFalse(Files.isReadable(resolved));\n        } else {\n            assertEquals(regularFile, Files.isReadable(resolved));\n        }\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        //\n        PathUtils.setReadOnly(resolved, false);\n        PathUtils.deleteFile(resolved);\n    }\n\n    @Test\n    public void testTouch() throws IOException {\n        assertThrows(NullPointerException.class, () -> FileUtils.touch(null));\n\n        final Path file = managedTempDirPath.resolve(\"touch.txt\");\n        Files.deleteIfExists(file);\n        assertFalse(Files.exists(file), \"Bad test: test file still exists\");\n        PathUtils.touch(file);\n        assertTrue(Files.exists(file), \"touch() created file\");\n        try (OutputStream out = Files.newOutputStream(file)) {\n            assertEquals(0, Files.size(file), \"Created empty file.\");\n            out.write(0);\n        }\n        assertEquals(1, Files.size(file), \"Wrote one byte to file\");\n        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();\n        setLastModifiedMillis(file, y2k);  // 0L fails on Win98\n        assertEquals(y2k, getLastModifiedMillis(file), \"Bad test: set lastModified set incorrect value\");\n        final long nowMillis = System.currentTimeMillis();\n        PathUtils.touch(file);\n        assertEquals(1, Files.size(file), \"FileUtils.touch() didn't empty the file.\");\n        assertNotEquals(y2k, getLastModifiedMillis(file), \"FileUtils.touch() changed lastModified\");\n        final int delta = 3000;\n        assertTrue(getLastModifiedMillis(file) >= nowMillis - delta, \"FileUtils.touch() changed lastModified to more than now-3s\");\n        assertTrue(getLastModifiedMillis(file) <= nowMillis + delta, \"FileUtils.touch() changed lastModified to less than now+3s\");\n    }\n\n    @Test\n    public void testWriteStringToFile1() throws Exception {\n        final Path file = tempDirPath.resolve(\"write.txt\");\n        PathUtils.writeString(file, \"Hello /u1234\", StandardCharsets.UTF_8);\n        final byte[] text = \"Hello /u1234\".getBytes(StandardCharsets.UTF_8);\n        TestUtils.assertEqualContent(text, file);\n    }\n\n    /**\n     * Tests newOutputStream() here and don't use Files.write obviously.\n     */\n    private Path writeToNewOutputStream(final boolean append) throws IOException {\n        final Path file = tempDirPath.resolve(\"test1.txt\");\n        try (OutputStream os = PathUtils.newOutputStream(file, append)) {\n            os.write(BYTE_ARRAY_FIXTURE);\n        }\n        return file;\n    }\n\n}\n", "diffSourceCodeSet": ["private Path current() {\n        return PathUtils.current();\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.file.PathUtils#current\n methodBody: public static Path current() {\nreturn Paths.get(\".\");\n}", "methodSignature: org.apache.commons.io.file.PathUtils#readAttributes\n methodBody: public static <A extends BasicFileAttributes> A readAttributes(final Path path, final Class<A> type, final LinkOption... options) {\ntryreturn path == null ? null : UncheckedIO.apply(Files::readAttributes,path,type,options);\ncatch(final UnsupportedOperationException e)return null;\n}"], "sourceCodeAfterRefactoring": "@Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(current(), PosixFileAttributes.class) != null);\n    }\nprivate Path current() {\n        return PathUtils.current();\n    }", "diffSourceCode": "-   94:     }\n-   95: \n-   96:     private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n-  335:     @Test\n-  336:     public void testReadAttributesPosix() throws IOException {\n-  337:         boolean isPosix;\n-  338:         try {\n-  339:             Files.getPosixFilePermissions(PathUtils.current());\n-  340:             isPosix = true;\n-  341:         } catch (final UnsupportedOperationException e) {\n-  342:             isPosix = false;\n-  343:         }\n-  344:         assertEquals(isPosix, PathUtils.readAttributes(PathUtils.current(), PosixFileAttributes.class) != null);\n-  345:     }\n-  376:         final boolean hidden = Files.isHidden(resolved);\n-  377:         final boolean directory = Files.isDirectory(resolved);\n-  378:         final boolean symbolicLink = Files.isSymbolicLink(resolved);\n-  379:         // Sanity checks\n-  380:         assertTrue(readable);\n-  381:         assertTrue(writable);\n-  382:         // Test A\n-  383:         PathUtils.setReadOnly(resolved, false);\n-  384:         assertTrue(Files.isReadable(resolved), \"isReadable\");\n-  385:         assertTrue(Files.isWritable(resolved), \"isWritable\");\n-  386:         // Again, shouldn't blow up.\n+   94:     private Path current() {\n+   95:         return PathUtils.current();\n+   96:     }\n+  335: \n+  336:     @Test\n+  337:     public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n+  338:         testNewOutputStreamNewFile(true);\n+  339:         final Path file = writeToNewOutputStream(true);\n+  340:         assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n+  341:     }\n+  342: \n+  343:     public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n+  344:         final Path file = writeToNewOutputStream(append);\n+  345:         assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n+  376:     @Test\n+  377:     public void testReadAttributesPosix() throws IOException {\n+  378:         boolean isPosix;\n+  379:         try {\n+  380:             Files.getPosixFilePermissions(current());\n+  381:             isPosix = true;\n+  382:         } catch (final UnsupportedOperationException e) {\n+  383:             isPosix = false;\n+  384:         }\n+  385:         assertEquals(isPosix, PathUtils.readAttributes(current(), PosixFileAttributes.class) != null);\n+  386:     }\n", "uniqueId": "cb6f3aabcf872aeab3bb4c975d163f340b93f051_335_345_94_96_376_386", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testReadAttributesPosix` method, we can extract the logic that checks if the file system supports POSIX file permissions into a separate method. This will make the test method cleaner and more focused on its primary purpose, which is to assert the expected behavior.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\nprivate boolean isPosixFileSystem() {\n    try {\n        Files.getPosixFilePermissions(PathUtils.current());\n        return true;\n    } catch (final UnsupportedOperationException e) {\n        return false;\n    }\n}\n\n@Test\npublic void testReadAttributesPosix() throws IOException {\n    boolean isPosix = isPosixFileSystem();\n    assertEquals(isPosix, PathUtils.readAttributes(PathUtils.current(), PosixFileAttributes.class) != null);\n}\n##########################\n```\n\nIn this refactoring:\n- The logic to determine if the file system is POSIX-compliant has been extracted into a new method called `isPosixFileSystem()`.\n- The `testReadAttributesPosix` method now simply calls this new method, making it clearer and easier to understand.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(PathUtils.current(), PosixFileAttributes.class) != null);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertThrowsExactly;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileAlreadyExistsException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link PathUtils}.\n */\npublic class PathUtilsTest extends AbstractTempDirTest {\n\n    private static final String STRING_FIXTURE = \"Hello World\";\n\n    private static final byte[] BYTE_ARRAY_FIXTURE = STRING_FIXTURE.getBytes(StandardCharsets.UTF_8);\n\n    private static final String TEST_JAR_NAME = \"test.jar\";\n\n    private static final String TEST_JAR_PATH = \"src/test/resources/org/apache/commons/io/test.jar\";\n\n    private static final String PATH_FIXTURE = \"NOTICE.txt\";\n\n    /**\n     * Creates directory test fixtures.\n     * <ol>\n     * <li>tempDirPath/subdir</li>\n     * <li>tempDirPath/symlinked-dir -> tempDirPath/subdir</li>\n     * </ol>\n     *\n     * @return Path to tempDirPath/subdir\n     * @throws IOException if an I/O error occurs or the parent directory does not exist.\n     */\n    private Path createTempSymlinkedRelativeDir() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symlinkDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symlinkDir, targetDir);\n        return symlinkDir;\n    }\n\n    private Long getLastModifiedMillis(final Path file) throws IOException {\n        return Files.getLastModifiedTime(file).toMillis();\n    }\n\n    private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n        if (createNew) {\n            final Map<String, String> env = new HashMap<>();\n            env.put(\"create\", \"true\");\n            final URI fileUri = p.toAbsolutePath().toUri();\n            final URI uri = URI.create(\"jar:\" + fileUri.toASCIIString());\n            return FileSystems.newFileSystem(uri, env, null);\n        }\n        return FileSystems.newFileSystem(p, (ClassLoader) null);\n    }\n\n    private void setLastModifiedMillis(final Path file, final long millis) throws IOException {\n        Files.setLastModifiedTime(file, FileTime.fromMillis(millis));\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false)) {\n            // relative jar -> absolute dir\n            Path sourceDir = archive.getPath(\"dir1\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"f1\")));\n\n            // absolute jar -> absolute dir\n            sourceDir = archive.getPath(\"/next\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"dir\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // absolute dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\").toAbsolutePath();\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // absolute dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false);\n            final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            final Path targetDir = targetArchive.getPath(\"targetDir\");\n            Files.createDirectory(targetDir);\n            // relative jar -> relative dir\n            Path sourceDir = archive.getPath(\"next\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dir\")));\n\n            // absolute jar -> relative dir\n            sourceDir = archive.getPath(\"/dir1\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"f1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // relative dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // relative dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyFile() throws IOException {\n        final Path sourceFile = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-1-file-size-1/file-size-1.bin\");\n        final Path targetFile = PathUtils.copyFileToDirectory(sourceFile, tempDirPath);\n        assertTrue(Files.exists(targetFile));\n        assertEquals(Files.size(sourceFile), Files.size(targetFile));\n    }\n\n    @Test\n    public void testCreateDirectoriesAlreadyExists() throws IOException {\n        assertEquals(tempDirPath.getParent(), PathUtils.createParentDirectories(tempDirPath));\n    }\n\n    @SuppressWarnings(\"resource\") // FileSystems.getDefault() is a singleton\n    @Test\n    public void testCreateDirectoriesForRoots() throws IOException {\n        for (final Path path : FileSystems.getDefault().getRootDirectories()) {\n            final Path parent = path.getParent();\n            assertNull(parent);\n            assertEquals(parent, PathUtils.createParentDirectories(path));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesForRootsLinkOptionNull() throws IOException {\n        for (final File f : File.listRoots()) {\n            final Path path = f.toPath();\n            assertEquals(path.getParent(), PathUtils.createParentDirectories(path, (LinkOption) null));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesNew() throws IOException {\n        assertEquals(tempDirPath, PathUtils.createParentDirectories(tempDirPath.resolve(\"child\")));\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlink() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        final String leafDirName = \"child\";\n        final Path newDirFollowed = PathUtils.createParentDirectories(symlinkedDir.resolve(leafDirName), PathUtils.NULL_LINK_OPTION);\n        assertEquals(Files.readSymbolicLink(symlinkedDir), newDirFollowed);\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlinkClashing() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        assertThrowsExactly(FileAlreadyExistsException.class, () -> PathUtils.createParentDirectories(symlinkedDir.resolve(\"child\")));\n    }\n\n    @Test\n    public void testGetTempDirectory() {\n        final Path tempDirectory = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n        assertEquals(tempDirectory, PathUtils.getTempDirectory());\n    }\n\n    @Test\n    public void testIsDirectory() throws IOException {\n        assertFalse(PathUtils.isDirectory(null));\n\n        assertTrue(PathUtils.isDirectory(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertFalse(PathUtils.isDirectory(testFile1.get()));\n\n            Path ref = null;\n            try (TempDirectory tempDir = TempDirectory.create(getClass().getCanonicalName())) {\n                ref = tempDir.get();\n                assertTrue(PathUtils.isDirectory(tempDir.get()));\n            }\n            assertFalse(PathUtils.isDirectory(ref));\n        }\n    }\n\n    @Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(PathUtils.current()));\n    }\n\n    @Test\n    public void testIsRegularFile() throws IOException {\n        assertFalse(PathUtils.isRegularFile(null));\n\n        assertFalse(PathUtils.isRegularFile(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertTrue(PathUtils.isRegularFile(testFile1.get()));\n\n            Files.delete(testFile1.get());\n            assertFalse(PathUtils.isRegularFile(testFile1.get()));\n        }\n    }\n\n    @Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n        final Path file = writeToNewOutputStream(true);\n        assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n    }\n\n    public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n        final Path file = writeToNewOutputStream(append);\n        assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileInsideExistingSymlinkedDir() throws IOException {\n        final Path symlinkDir = createTempSymlinkedRelativeDir();\n        final Path file = symlinkDir.resolve(\"test.txt\");\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, null)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, true)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, false)) {\n            // empty\n        }\n    }\n\n    @Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(PathUtils.current(), PosixFileAttributes.class) != null);\n    }\n\n    @Test\n    public void testReadStringEmptyFile() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-empty.bin\");\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testReadStringSimpleUtf8() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-simple-utf8.bin\");\n        final String expected = \"ABC\\r\\n\";\n        assertEquals(expected, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(expected, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testSetReadOnlyFile() throws IOException {\n        final Path resolved = tempDirPath.resolve(\"testSetReadOnlyFile.txt\");\n        // Ask now, as we are allowed before editing parent permissions.\n        final boolean isPosix = PathUtils.isPosix(tempDirPath);\n\n        // TEMP HACK\n        assumeFalse(SystemUtils.IS_OS_LINUX);\n\n        PathUtils.writeString(resolved, \"test\", StandardCharsets.UTF_8);\n        final boolean readable = Files.isReadable(resolved);\n        final boolean writable = Files.isWritable(resolved);\n        final boolean regularFile = Files.isRegularFile(resolved);\n        final boolean executable = Files.isExecutable(resolved);\n        final boolean hidden = Files.isHidden(resolved);\n        final boolean directory = Files.isDirectory(resolved);\n        final boolean symbolicLink = Files.isSymbolicLink(resolved);\n        // Sanity checks\n        assertTrue(readable);\n        assertTrue(writable);\n        // Test A\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        // Again, shouldn't blow up.\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        //\n        assertEquals(regularFile, Files.isReadable(resolved));\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        // Test B\n        PathUtils.setReadOnly(resolved, true);\n        if (isPosix) {\n            // On POSIX, now that the parent is not WX, the file is not readable.\n            assertFalse(Files.isReadable(resolved), \"isReadable\");\n        } else {\n            assertTrue(Files.isReadable(resolved), \"isReadable\");\n        }\n        assertFalse(Files.isWritable(resolved), \"isWritable\");\n        final DosFileAttributeView dosFileAttributeView = PathUtils.getDosFileAttributeView(resolved);\n        if (dosFileAttributeView != null) {\n            assertTrue(dosFileAttributeView.readAttributes().isReadOnly());\n        }\n        if (isPosix) {\n            assertFalse(Files.isReadable(resolved));\n        } else {\n            assertEquals(regularFile, Files.isReadable(resolved));\n        }\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        //\n        PathUtils.setReadOnly(resolved, false);\n        PathUtils.deleteFile(resolved);\n    }\n\n    @Test\n    public void testTouch() throws IOException {\n        assertThrows(NullPointerException.class, () -> FileUtils.touch(null));\n\n        final Path file = managedTempDirPath.resolve(\"touch.txt\");\n        Files.deleteIfExists(file);\n        assertFalse(Files.exists(file), \"Bad test: test file still exists\");\n        PathUtils.touch(file);\n        assertTrue(Files.exists(file), \"touch() created file\");\n        try (OutputStream out = Files.newOutputStream(file)) {\n            assertEquals(0, Files.size(file), \"Created empty file.\");\n            out.write(0);\n        }\n        assertEquals(1, Files.size(file), \"Wrote one byte to file\");\n        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();\n        setLastModifiedMillis(file, y2k);  // 0L fails on Win98\n        assertEquals(y2k, getLastModifiedMillis(file), \"Bad test: set lastModified set incorrect value\");\n        final long nowMillis = System.currentTimeMillis();\n        PathUtils.touch(file);\n        assertEquals(1, Files.size(file), \"FileUtils.touch() didn't empty the file.\");\n        assertNotEquals(y2k, getLastModifiedMillis(file), \"FileUtils.touch() changed lastModified\");\n        final int delta = 3000;\n        assertTrue(getLastModifiedMillis(file) >= nowMillis - delta, \"FileUtils.touch() changed lastModified to more than now-3s\");\n        assertTrue(getLastModifiedMillis(file) <= nowMillis + delta, \"FileUtils.touch() changed lastModified to less than now+3s\");\n    }\n\n    @Test\n    public void testWriteStringToFile1() throws Exception {\n        final Path file = tempDirPath.resolve(\"write.txt\");\n        PathUtils.writeString(file, \"Hello /u1234\", StandardCharsets.UTF_8);\n        final byte[] text = \"Hello /u1234\".getBytes(StandardCharsets.UTF_8);\n        TestUtils.assertEqualContent(text, file);\n    }\n\n    /**\n     * Tests newOutputStream() here and don't use Files.write obviously.\n     */\n    private Path writeToNewOutputStream(final boolean append) throws IOException {\n        final Path file = tempDirPath.resolve(\"test1.txt\");\n        try (OutputStream os = PathUtils.newOutputStream(file, append)) {\n            os.write(BYTE_ARRAY_FIXTURE);\n        }\n        return file;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic testApply3() : void from class org.apache.commons.io.UncheckIOTest to public testApply3() : void from class org.apache.commons.io.function.UncheckTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "startLine": 88, "endLine": 97, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "startLine": 142, "endLine": 151, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "isPureRefactoring": true, "commitId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.UncheckIOTest", "methodNameBefore": "org.apache.commons.io.UncheckIOTest#testApply3", "invokedMethod": "methodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}", "classSignatureBefore": "public class UncheckIOTest ", "methodNameBeforeSet": ["org.apache.commons.io.UncheckIOTest#testApply3"], "classNameBeforeSet": ["org.apache.commons.io.UncheckIOTest"], "classSignatureBeforeSet": ["public class UncheckIOTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckTest {\n\n    private static final byte[] BYTES = { 'a', 'b' };\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n\n    private AtomicInteger atomicInt;\n    private AtomicReference<String> ref1;\n    private AtomicReference<String> ref2;\n    private AtomicReference<String> ref3;\n    private AtomicReference<String> ref4;\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    @BeforeEach\n    public void initEach() {\n        ref1 = new AtomicReference<>();\n        ref2 = new AtomicReference<>();\n        ref3 = new AtomicReference<>();\n        ref4 = new AtomicReference<>();\n        atomicInt = new AtomicInteger();\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    @Test\n    public void testAcceptIOBiConsumerOfTUTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_BI_CONSUMER, null, null));\n        Uncheck.accept((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n        }, \"new1\", \"new2\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testAcceptIOConsumerOfTT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestUtils.throwingIOConsumer(), null));\n        Uncheck.accept(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testAcceptIOTriConsumerOfTUVTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_TRI_CONSUMER, null, null, null));\n        Uncheck.accept((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n        }, \"new1\", \"new2\", \"new3\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    @Test\n    public void testApplyIOBiFunctionOfTURTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_BI_FUNCTION, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            return \"new0\";\n        }, \"new1\", \"new2\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testApplyIOFunctionOfTRT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_FUNCTION, null));\n        Uncheck.apply(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testApplyIOQuadFunctionOfTUVWRTUVW() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v, w) -> {\n            throw new IOException();\n        }, null, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_QUAD_FUNCTION, null, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v, w) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            TestUtils.compareAndSetThrowsIO(ref4, w);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\", \"new4\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n        assertEquals(\"new4\", ref4.get());\n    }\n\n    @Test\n    public void testApplyIOTriFunctionOfTUVRTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_TRI_FUNCTION, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(TestConstants.THROWING_IO_SUPPLIER));\n        assertEquals(\"new1\", Uncheck.get(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\")));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testGetAsInt() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(TestConstants.THROWING_IO_INT_SUPPLIER));\n        assertEquals(1, Uncheck.getAsInt(() -> TestUtils.compareAndSetThrowsIO(atomicInt, 1)));\n        assertEquals(1, atomicInt.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        //\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(TestConstants.THROWING_IO_RUNNABLE));\n        Uncheck.run(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    @Test\n    public void testTest() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(TestConstants.THROWING_IO_PREDICATE, null));\n        assertTrue(Uncheck.test(t -> TestUtils.compareAndSetThrowsIO(ref1, t).equals(t), \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }", "diffSourceCode": "-   88:     /**\n-   89:      * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n-   90:      */\n-   91:     @Test\n-   92:     public void testApply3() {\n-   93:         final ByteArrayInputStream stream = newInputStream();\n-   94:         final byte[] buf = new byte[BYTES.length];\n-   95:         assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n-   96:         assertEquals('a', buf[0]);\n-   97:     }\n-  142:         final ByteArrayInputStream stream = newInputStream();\n-  143:         Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n-  144:         assertEquals('b', Uncheck.get(stream::read).intValue());\n-  145:         final IOException expected = new IOException(CAUSE_MESSAGE);\n-  146:         // Exception\n-  147:         try {\n-  148:             Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n-  149:             fail();\n-  150:         } catch (final UncheckedIOException e) {\n-  151:             assertUncheckedIOException(expected, e);\n+   88:             TestUtils.compareAndSetThrowsIO(ref1, t);\n+   89:             TestUtils.compareAndSetThrowsIO(ref2, u);\n+   90:         }, \"new1\", \"new2\");\n+   91:         assertEquals(\"new1\", ref1.get());\n+   92:         assertEquals(\"new2\", ref2.get());\n+   93:     }\n+   94: \n+   95:     @Test\n+   96:     public void testAcceptIOConsumerOfTT() {\n+   97:         assertThrows(UncheckedIOException.class, () -> Uncheck.accept(t -> {\n+  142:     /**\n+  143:      * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n+  144:      */\n+  145:     @Test\n+  146:     public void testApply3() {\n+  147:         final ByteArrayInputStream stream = newInputStream();\n+  148:         final byte[] buf = new byte[BYTES.length];\n+  149:         assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n+  150:         assertEquals('a', buf[0]);\n+  151:     }\n", "uniqueId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52_88_97__142_151", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the `testApply3` method from the `UncheckIOTest` class to an existing test class that is relevant to the functionality being tested. Given the context of the method, it seems appropriate to move it to the `UncheckTest` class, which is likely to contain tests related to the `Uncheck` functionality.\n\nHere\u2019s how the refactoring will be structured:\n\n1. **Target File Path**: We will move the method to `src/test/java/org/apache/commons/io/function/UncheckTest.java`.\n2. **Moved Class Code**: The `testApply3` method will be moved to the `UncheckTest` class and updated to be a public static method.\n3. **Refactored Method Code**: The `UncheckIOTest` class will be updated to call the moved method.\n\n### Moved Method Code\n```java\n/**\n * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n */\npublic static void testApply3() {\n    final ByteArrayInputStream stream = newInputStream();\n    final byte[] buf = new byte[BYTES.length];\n    assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n    assertEquals('a', buf[0]);\n}\n```\n\n### Refactored Method Code\n```java\n/**\n * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n */\n@Test\npublic void testApply3() {\n    UncheckTest.testApply3();\n}\n```\n\n### Output\nHere is the output in the specified format:\n\n##########################\nsrc/test/java/org/apache/commons/io/function/UncheckTest.java\n##########################\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckTest {\n    // Other test methods...\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    public static void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n}\n##########################\n@Test\npublic void testApply3() {\n    UncheckTest.testApply3();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryBaseTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsMultithreadedSkipTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/RandomAccessFilesTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/build/AbstractOriginTest.java', 'src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java', 'src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java', 'src/test/java/org/apache/commons/io/build/FileOriginTest.java', 'src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/PathOriginTest.java', 'src/test/java/org/apache/commons/io/build/ReaderOriginTest.java', 'src/test/java/org/apache/commons/io/build/URIOriginTest.java', 'src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/PathWrapper.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIntSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOLongSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic testApply2() : void from class org.apache.commons.io.UncheckIOTest to public testApply2() : void from class org.apache.commons.io.function.UncheckTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "startLine": 77, "endLine": 86, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "startLine": 131, "endLine": 140, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "isPureRefactoring": true, "commitId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.UncheckIOTest", "methodNameBefore": "org.apache.commons.io.UncheckIOTest#testApply2", "invokedMethod": "methodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}", "classSignatureBefore": "public class UncheckIOTest ", "methodNameBeforeSet": ["org.apache.commons.io.UncheckIOTest#testApply2"], "classNameBeforeSet": ["org.apache.commons.io.UncheckIOTest"], "classSignatureBeforeSet": ["public class UncheckIOTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckTest {\n\n    private static final byte[] BYTES = { 'a', 'b' };\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n\n    private AtomicInteger atomicInt;\n    private AtomicReference<String> ref1;\n    private AtomicReference<String> ref2;\n    private AtomicReference<String> ref3;\n    private AtomicReference<String> ref4;\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    @BeforeEach\n    public void initEach() {\n        ref1 = new AtomicReference<>();\n        ref2 = new AtomicReference<>();\n        ref3 = new AtomicReference<>();\n        ref4 = new AtomicReference<>();\n        atomicInt = new AtomicInteger();\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    @Test\n    public void testAcceptIOBiConsumerOfTUTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_BI_CONSUMER, null, null));\n        Uncheck.accept((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n        }, \"new1\", \"new2\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testAcceptIOConsumerOfTT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestUtils.throwingIOConsumer(), null));\n        Uncheck.accept(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testAcceptIOTriConsumerOfTUVTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_TRI_CONSUMER, null, null, null));\n        Uncheck.accept((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n        }, \"new1\", \"new2\", \"new3\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    @Test\n    public void testApplyIOBiFunctionOfTURTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_BI_FUNCTION, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            return \"new0\";\n        }, \"new1\", \"new2\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testApplyIOFunctionOfTRT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_FUNCTION, null));\n        Uncheck.apply(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testApplyIOQuadFunctionOfTUVWRTUVW() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v, w) -> {\n            throw new IOException();\n        }, null, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_QUAD_FUNCTION, null, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v, w) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            TestUtils.compareAndSetThrowsIO(ref4, w);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\", \"new4\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n        assertEquals(\"new4\", ref4.get());\n    }\n\n    @Test\n    public void testApplyIOTriFunctionOfTUVRTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_TRI_FUNCTION, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(TestConstants.THROWING_IO_SUPPLIER));\n        assertEquals(\"new1\", Uncheck.get(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\")));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testGetAsInt() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(TestConstants.THROWING_IO_INT_SUPPLIER));\n        assertEquals(1, Uncheck.getAsInt(() -> TestUtils.compareAndSetThrowsIO(atomicInt, 1)));\n        assertEquals(1, atomicInt.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        //\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(TestConstants.THROWING_IO_RUNNABLE));\n        Uncheck.run(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    @Test\n    public void testTest() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(TestConstants.THROWING_IO_PREDICATE, null));\n        assertTrue(Uncheck.test(t -> TestUtils.compareAndSetThrowsIO(ref1, t).equals(t), \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }", "diffSourceCode": "-   77:     /**\n-   78:      * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n-   79:      */\n-   80:     @Test\n-   81:     public void testApply2() {\n-   82:         final ByteArrayInputStream stream = newInputStream();\n-   83:         final byte[] buf = new byte[BYTES.length];\n-   84:         assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n-   85:         assertEquals('a', buf[0]);\n-   86:     }\n-  131:         assertEquals('b', Uncheck.get(stream::read).intValue());\n-  132:     }\n-  133: \n-  134:     /**\n-  135:      * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n-  136:      *\n-  137:      * @throws IOException\n-  138:      */\n-  139:     @Test\n-  140:     public void testRunMessage() throws IOException {\n+   77:         Uncheck.accept(n -> stream.skip(n), 1);\n+   78:         assertEquals('b', Uncheck.get(stream::read).intValue());\n+   79:     }\n+   80: \n+   81:     @Test\n+   82:     public void testAcceptIOBiConsumerOfTUTU() {\n+   83:         assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u) -> {\n+   84:             throw new IOException();\n+   85:         }, null, null));\n+   86:         assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_BI_CONSUMER, null, null));\n+  131:     /**\n+  132:      * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n+  133:      */\n+  134:     @Test\n+  135:     public void testApply2() {\n+  136:         final ByteArrayInputStream stream = newInputStream();\n+  137:         final byte[] buf = new byte[BYTES.length];\n+  138:         assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n+  139:         assertEquals('a', buf[0]);\n+  140:     }\n", "uniqueId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52_77_86__131_140", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the `testApply2` method from the `UncheckIOTest` class to an existing test class that is relevant to the functionality being tested. Given the context of the method, it seems appropriate to move it to the `UncheckTest` class, which is likely to contain tests related to the `Uncheck` utility class.\n\nHere\u2019s how the refactoring will be structured:\n\n1. **Target File Path**: We will move the method to `src/test/java/org/apache/commons/io/function/UncheckTest.java`.\n2. **Moved Class Code**: The `testApply2` method will be modified to be a public static method.\n3. **Refactored Method Code**: The original `testApply2` method in `UncheckIOTest` will be updated to call the newly moved method.\n\n### Moved Method Code\n```java\n/**\n * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n */\npublic static void testApply2() {\n    final ByteArrayInputStream stream = new ByteArrayInputStream(BYTES);\n    final byte[] buf = new byte[BYTES.length];\n    assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n    assertEquals('a', buf[0]);\n}\n```\n\n### Refactored Method Code\n```java\n/**\n * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n */\n@Test\npublic void testApply2() {\n    UncheckTest.testApply2();\n}\n```\n\n### Output\nHere is the output in the requested format:\n\n##########################\nsrc/test/java/org/apache/commons/io/function/UncheckTest.java\n##########################\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckTest {\n    // Other test methods...\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    public static void testApply2() {\n        final ByteArrayInputStream stream = new ByteArrayInputStream(BYTES);\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n}\n##########################\n@Test\npublic void testApply2() {\n    UncheckTest.testApply2();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryBaseTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsMultithreadedSkipTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/RandomAccessFilesTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/build/AbstractOriginTest.java', 'src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java', 'src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java', 'src/test/java/org/apache/commons/io/build/FileOriginTest.java', 'src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/PathOriginTest.java', 'src/test/java/org/apache/commons/io/build/ReaderOriginTest.java', 'src/test/java/org/apache/commons/io/build/URIOriginTest.java', 'src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/PathWrapper.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIntSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOLongSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic testApply1() : void from class org.apache.commons.io.UncheckIOTest to public testApply1() : void from class org.apache.commons.io.function.UncheckTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "startLine": 67, "endLine": 75, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "startLine": 121, "endLine": 129, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "isPureRefactoring": true, "commitId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.UncheckIOTest", "methodNameBefore": "org.apache.commons.io.UncheckIOTest#testApply1", "invokedMethod": "methodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}", "classSignatureBefore": "public class UncheckIOTest ", "methodNameBeforeSet": ["org.apache.commons.io.UncheckIOTest#testApply1"], "classNameBeforeSet": ["org.apache.commons.io.UncheckIOTest"], "classSignatureBeforeSet": ["public class UncheckIOTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckTest {\n\n    private static final byte[] BYTES = { 'a', 'b' };\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n\n    private AtomicInteger atomicInt;\n    private AtomicReference<String> ref1;\n    private AtomicReference<String> ref2;\n    private AtomicReference<String> ref3;\n    private AtomicReference<String> ref4;\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    @BeforeEach\n    public void initEach() {\n        ref1 = new AtomicReference<>();\n        ref2 = new AtomicReference<>();\n        ref3 = new AtomicReference<>();\n        ref4 = new AtomicReference<>();\n        atomicInt = new AtomicInteger();\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    @Test\n    public void testAcceptIOBiConsumerOfTUTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_BI_CONSUMER, null, null));\n        Uncheck.accept((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n        }, \"new1\", \"new2\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testAcceptIOConsumerOfTT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestUtils.throwingIOConsumer(), null));\n        Uncheck.accept(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testAcceptIOTriConsumerOfTUVTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_TRI_CONSUMER, null, null, null));\n        Uncheck.accept((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n        }, \"new1\", \"new2\", \"new3\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    @Test\n    public void testApplyIOBiFunctionOfTURTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_BI_FUNCTION, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            return \"new0\";\n        }, \"new1\", \"new2\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testApplyIOFunctionOfTRT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_FUNCTION, null));\n        Uncheck.apply(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testApplyIOQuadFunctionOfTUVWRTUVW() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v, w) -> {\n            throw new IOException();\n        }, null, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_QUAD_FUNCTION, null, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v, w) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            TestUtils.compareAndSetThrowsIO(ref4, w);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\", \"new4\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n        assertEquals(\"new4\", ref4.get());\n    }\n\n    @Test\n    public void testApplyIOTriFunctionOfTUVRTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_TRI_FUNCTION, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(TestConstants.THROWING_IO_SUPPLIER));\n        assertEquals(\"new1\", Uncheck.get(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\")));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testGetAsInt() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(TestConstants.THROWING_IO_INT_SUPPLIER));\n        assertEquals(1, Uncheck.getAsInt(() -> TestUtils.compareAndSetThrowsIO(atomicInt, 1)));\n        assertEquals(1, atomicInt.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        //\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(TestConstants.THROWING_IO_RUNNABLE));\n        Uncheck.run(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    @Test\n    public void testTest() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(TestConstants.THROWING_IO_PREDICATE, null));\n        assertTrue(Uncheck.test(t -> TestUtils.compareAndSetThrowsIO(ref1, t).equals(t), \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }", "diffSourceCode": "-   67:     /**\n-   68:      * Tests {@link Uncheck#apply(IOFunction, Object)}.\n-   69:      */\n-   70:     @Test\n-   71:     public void testApply1() {\n-   72:         final ByteArrayInputStream stream = newInputStream();\n-   73:         assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n-   74:         assertEquals('b', Uncheck.get(stream::read).intValue());\n-   75:     }\n-  121:         }\n-  122:     }\n-  123: \n-  124:     /**\n-  125:      * Tests {@link Uncheck#run(IORunnable)}.\n-  126:      */\n-  127:     @Test\n-  128:     public void testRun() {\n-  129:         final ByteArrayInputStream stream = newInputStream();\n+   67:     private ByteArrayInputStream newInputStream() {\n+   68:         return new ByteArrayInputStream(BYTES);\n+   69:     }\n+   70: \n+   71:     /**\n+   72:      * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n+   73:      */\n+   74:     @Test\n+   75:     public void testAccept() {\n+  121:     /**\n+  122:      * Tests {@link Uncheck#apply(IOFunction, Object)}.\n+  123:      */\n+  124:     @Test\n+  125:     public void testApply1() {\n+  126:         final ByteArrayInputStream stream = newInputStream();\n+  127:         assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n+  128:         assertEquals('b', Uncheck.get(stream::read).intValue());\n+  129:     }\n", "uniqueId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52_67_75__121_129", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the `testApply1` method from the `UncheckIOTest` class to an existing test class that is relevant to the functionality being tested. Given the context of the `Uncheck` class and its methods, it would be appropriate to move the test to the `UncheckTest` class, which is likely to contain tests related to the `Uncheck` functionality.\n\n### Target File Path\nThe target file path for the moved method will be:\n```\nsrc/test/java/org/apache/commons/io/function/UncheckTest.java\n```\n\n### Moved Class Code\nThe moved method code will be as follows:\n```java\n/**\n * Tests {@link Uncheck#apply(IOFunction, Object)}.\n */\n@Test\npublic void testApply1() {\n    final ByteArrayInputStream stream = newInputStream();\n    assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n    assertEquals('b', Uncheck.get(stream::read).intValue());\n}\n```\n\n### Refactored Method Code\nThe refactored method code in the `UncheckIOTest` class will now call the moved method from the `UncheckTest` class. However, since the `testApply1` method is a test method, it is not typically called from other test methods. Instead, we will keep the `testApply1` method in `UncheckTest` and remove it from `UncheckIOTest`. \n\nHere\u2019s how the `UncheckIOTest` class will look after the refactoring (removing the `testApply1` method):\n\n```java\n// Other test methods remain unchanged\n\n// Removed the testApply1 method\n```\n\n### Final Output\nHere is the final output in the requested format:\n\n##########################\nsrc/test/java/org/apache/commons/io/function/UncheckTest.java\n##########################\n/**\n * Tests {@link Uncheck#apply(IOFunction, Object)}.\n */\n@Test\npublic void testApply1() {\n    final ByteArrayInputStream stream = newInputStream();\n    assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n    assertEquals('b', Uncheck.get(stream::read).intValue());\n}\n##########################\npublic void testApply1() {\n    final ByteArrayInputStream stream = newInputStream();\n    assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n    assertEquals('b', Uncheck.get(stream::read).intValue());\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryBaseTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsMultithreadedSkipTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/RandomAccessFilesTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/build/AbstractOriginTest.java', 'src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java', 'src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java', 'src/test/java/org/apache/commons/io/build/FileOriginTest.java', 'src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/PathOriginTest.java', 'src/test/java/org/apache/commons/io/build/ReaderOriginTest.java', 'src/test/java/org/apache/commons/io/build/URIOriginTest.java', 'src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/PathWrapper.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIntSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOLongSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tprivate newInputStream() : ByteArrayInputStream from class org.apache.commons.io.UncheckIOTest to private newInputStream() : ByteArrayInputStream from class org.apache.commons.io.function.UncheckTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "startLine": 53, "endLine": 55, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "startLine": 67, "endLine": 69, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "isPureRefactoring": true, "commitId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.UncheckIOTest", "methodNameBefore": "org.apache.commons.io.UncheckIOTest#newInputStream", "classSignatureBefore": "public class UncheckIOTest ", "methodNameBeforeSet": ["org.apache.commons.io.UncheckIOTest#newInputStream"], "classNameBeforeSet": ["org.apache.commons.io.UncheckIOTest"], "classSignatureBeforeSet": ["public class UncheckIOTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckTest {\n\n    private static final byte[] BYTES = { 'a', 'b' };\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n\n    private AtomicInteger atomicInt;\n    private AtomicReference<String> ref1;\n    private AtomicReference<String> ref2;\n    private AtomicReference<String> ref3;\n    private AtomicReference<String> ref4;\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    @BeforeEach\n    public void initEach() {\n        ref1 = new AtomicReference<>();\n        ref2 = new AtomicReference<>();\n        ref3 = new AtomicReference<>();\n        ref4 = new AtomicReference<>();\n        atomicInt = new AtomicInteger();\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    @Test\n    public void testAcceptIOBiConsumerOfTUTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_BI_CONSUMER, null, null));\n        Uncheck.accept((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n        }, \"new1\", \"new2\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testAcceptIOConsumerOfTT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestUtils.throwingIOConsumer(), null));\n        Uncheck.accept(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testAcceptIOTriConsumerOfTUVTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_TRI_CONSUMER, null, null, null));\n        Uncheck.accept((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n        }, \"new1\", \"new2\", \"new3\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    @Test\n    public void testApplyIOBiFunctionOfTURTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_BI_FUNCTION, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            return \"new0\";\n        }, \"new1\", \"new2\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testApplyIOFunctionOfTRT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_FUNCTION, null));\n        Uncheck.apply(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testApplyIOQuadFunctionOfTUVWRTUVW() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v, w) -> {\n            throw new IOException();\n        }, null, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_QUAD_FUNCTION, null, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v, w) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            TestUtils.compareAndSetThrowsIO(ref4, w);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\", \"new4\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n        assertEquals(\"new4\", ref4.get());\n    }\n\n    @Test\n    public void testApplyIOTriFunctionOfTUVRTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_TRI_FUNCTION, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(TestConstants.THROWING_IO_SUPPLIER));\n        assertEquals(\"new1\", Uncheck.get(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\")));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testGetAsInt() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(TestConstants.THROWING_IO_INT_SUPPLIER));\n        assertEquals(1, Uncheck.getAsInt(() -> TestUtils.compareAndSetThrowsIO(atomicInt, 1)));\n        assertEquals(1, atomicInt.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        //\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(TestConstants.THROWING_IO_RUNNABLE));\n        Uncheck.run(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    @Test\n    public void testTest() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(TestConstants.THROWING_IO_PREDICATE, null));\n        assertTrue(Uncheck.test(t -> TestUtils.compareAndSetThrowsIO(ref1, t).equals(t), \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }", "diffSourceCode": "-   53:     private ByteArrayInputStream newInputStream() {\n-   54:         return new ByteArrayInputStream(BYTES);\n-   55:     }\n-   67:     /**\n-   68:      * Tests {@link Uncheck#apply(IOFunction, Object)}.\n-   69:      */\n+   53:         final IOException cause = e.getCause();\n+   54:         assertEquals(expected.getClass(), cause.getClass());\n+   55:         assertEquals(CAUSE_MESSAGE, cause.getMessage());\n+   67:     private ByteArrayInputStream newInputStream() {\n+   68:         return new ByteArrayInputStream(BYTES);\n+   69:     }\n", "uniqueId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52_53_55__67_69", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": true, "refactoredCode": "To perform the requested refactoring, we will move the `newInputStream` method from the `UncheckIOTest` class to a more appropriate existing class. Given the context of the method, it seems to be related to input streams, so a suitable target class could be `UncheckedBufferedReaderTest` or any other class that deals with input streams.\n\nFor this example, let's assume we are moving the method to `UncheckedBufferedReaderTest.java`. Here\u2019s how the refactoring will look:\n\n1. **Target File Path**: `src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java`\n2. **Moved Class Code**: The `newInputStream` method will be added as a public static method in the `UncheckedBufferedReaderTest` class.\n3. **Refactored Method Code**: The `newInputStream` method will be called from the `UncheckIOTest` class.\n\nHere\u2019s the output in the specified format:\n\n##########################\nsrc/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java\n##########################\npackage org.apache.commons.io.input;\n\nimport java.io.ByteArrayInputStream;\n\npublic class UncheckedBufferedReaderTest {\n    // Other existing methods and fields...\n\n    public static ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(new byte[] { 'a', 'b' });\n    }\n}\n##########################\nprivate ByteArrayInputStream newInputStream() {\n    return UncheckedBufferedReaderTest.newInputStream();\n}\n########################## \n\nThis refactoring improves modularity by separating the input stream creation logic into a dedicated class, making it easier to maintain and reuse in other tests or classes.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryBaseTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsMultithreadedSkipTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/RandomAccessFilesTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/build/AbstractOriginTest.java', 'src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java', 'src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java', 'src/test/java/org/apache/commons/io/build/FileOriginTest.java', 'src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/PathOriginTest.java', 'src/test/java/org/apache/commons/io/build/ReaderOriginTest.java', 'src/test/java/org/apache/commons/io/build/URIOriginTest.java', 'src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/PathWrapper.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIntSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOLongSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tprivate getRequiredCharsetNames() : Set<String> from class org.apache.commons.io.input.CharSequenceInputStreamTest to public getRequiredCharsetNames() : Set<String> from class org.apache.commons.io.CharsetsTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java", "startLine": 67, "endLine": 69, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/CharsetsTest.java", "startLine": 53, "endLine": 60, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "private Set<String> getRequiredCharsetNames() {\n        return Charsets.requiredCharsets().keySet();\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java", "isPureRefactoring": true, "commitId": "d18e81487493ae6eedd03dbe27ff699f7f410523", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.CharSequenceInputStreamTest", "methodNameBefore": "org.apache.commons.io.input.CharSequenceInputStreamTest#getRequiredCharsetNames", "classSignatureBefore": "public class CharSequenceInputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.input.CharSequenceInputStreamTest#getRequiredCharsetNames"], "classNameBeforeSet": ["org.apache.commons.io.input.CharSequenceInputStreamTest"], "classSignatureBeforeSet": ["public class CharSequenceInputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\nimport java.util.Set;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.CharsetsTest;\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class CharSequenceInputStreamTest {\n\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    private static final String LARGE_TEST_STRING;\n\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i = 0; i < 100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    private int checkAvail(final InputStream is, final int min) throws Exception {\n        final int available = is.available();\n        assertTrue(available >= min, \"avail should be >= \" + min + \", but was \" + available);\n        return available;\n    }\n\n    private Set<String> getRequiredCharsetNames() {\n        return Charsets.requiredCharsets().keySet();\n    }\n\n    private boolean isAvailabilityTestableForCharset(final String csName) {\n        return Charset.forName(csName).canEncode()\n                && !\"COMPOUND_TEXT\".equalsIgnoreCase(csName) && !\"x-COMPOUND_TEXT\".equalsIgnoreCase(csName)\n                && !isOddBallLegacyCharsetThatDoesNotSupportFrenchCharacters(csName);\n    }\n\n    private boolean isOddBallLegacyCharsetThatDoesNotSupportFrenchCharacters(final String csName) {\n        return \"x-IBM1388\".equalsIgnoreCase(csName) ||\n                \"ISO-2022-CN\".equalsIgnoreCase(csName) ||\n                \"ISO-2022-JP\".equalsIgnoreCase(csName) ||\n                \"Shift_JIS\".equalsIgnoreCase(csName);\n    }\n\n    @ParameterizedTest(name = \"{0}\")\n    @MethodSource(CharsetsTest.AVAIL_CHARSETS)\n    public void testAvailable(final String csName) throws Exception {\n        // prevent java.lang.UnsupportedOperationException at sun.nio.cs.ext.ISO2022_CN.newEncoder.\n        // also try and avoid the following exception\n//            java.lang.UnsupportedOperationException: null\n//            at java.nio.CharBuffer.array(CharBuffer.java:940)\n//            at sun.nio.cs.ext.COMPOUND_TEXT_Encoder.encodeLoop(COMPOUND_TEXT_Encoder.java:75)\n//            at java.nio.charset.CharsetEncoder.encode(CharsetEncoder.java:544)\n//            at org.apache.commons.io.input.CharSequenceInputStream.fillBuffer(CharSequenceInputStream.java:120)\n//            at org.apache.commons.io.input.CharSequenceInputStream.read(CharSequenceInputStream.java:151)\n//            at org.apache.commons.io.input.CharSequenceInputStreamTest.testAvailableRead(CharSequenceInputStreamTest.java:412)\n//            at org.apache.commons.io.input.CharSequenceInputStreamTest.testAvailable(CharSequenceInputStreamTest.java:424)\n\n        try {\n            if (isAvailabilityTestableForCharset(csName)) {\n                testAvailableSkip(csName);\n                testAvailableRead(csName);\n            }\n        } catch (final UnsupportedOperationException e) {\n            fail(\"Operation not supported for \" + csName);\n        }\n    }\n\n    private void testAvailableRead(final String csName) throws Exception {\n        final String input = \"test\";\n        try (InputStream r = new CharSequenceInputStream(input, csName)) {\n            int available = checkAvail(r, input.length());\n            assertEquals(available - 1, r.skip(available - 1)); // skip all but one\n            available = checkAvail(r, 1);\n            final byte[] buff = new byte[available];\n            assertEquals(available, r.read(buff, 0, available));\n        }\n    }\n\n    private void testAvailableSkip(final String csName) throws Exception {\n        final String input = \"test\";\n        try (InputStream r = new CharSequenceInputStream(input, csName)) {\n            int available = checkAvail(r, input.length());\n            assertEquals(available - 1, r.skip(available - 1)); // skip all but one\n            available = checkAvail(r, 1);\n            assertEquals(1, r.skip(1));\n            available = checkAvail(r, 0);\n        }\n    }\n\n    private void testBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (InputStream in = new CharSequenceInputStream(testString, charsetName, 512)) {\n            final byte[] buffer = new byte[128];\n            int offset = 0;            while (true) {\n                int bufferOffset = random.nextInt(64);\n                final int bufferLength = random.nextInt(64);\n                int read = in.read(buffer, bufferOffset, bufferLength);\n                if (read == -1) {\n                    assertEquals(expected.length, offset, \"EOF: offset should equal length for charset \" + charsetName);\n                    break;\n                }\n                assertTrue(read <= bufferLength, \"Read \" + read + \" <= \" + bufferLength);\n                while (read > 0) {\n                    assertTrue(offset < expected.length,\n                            \"offset for \" + charsetName + \" \" + offset + \" < \" + expected.length);\n                    assertEquals(expected[offset], buffer[bufferOffset], \"bytes should agree for \" + charsetName);\n                    offset++;\n                    bufferOffset++;\n                    read--;\n                }\n            }\n        }\n    }\n\n    //    Unfortunately checking canEncode does not seem to work for all charsets:\n//    testBufferedRead_AvailableCharset(org.apache.commons.io.input.CharSequenceInputStreamTest)  Time elapsed: 0.682 sec  <<< ERROR!\n//    java.lang.UnsupportedOperationException: null\n//        at java.nio.CharBuffer.array(CharBuffer.java:940)\n//        at sun.nio.cs.ext.COMPOUND_TEXT_Encoder.encodeLoop(COMPOUND_TEXT_Encoder.java:75)\n//        at java.nio.charset.CharsetEncoder.encode(CharsetEncoder.java:544)\n//        at org.apache.commons.io.input.CharSequenceInputStream.fillBuffer(CharSequenceInputStream.java:111)\n    @ParameterizedTest(name = \"{0}\")\n    @MethodSource(CharsetsTest.AVAIL_CHARSETS)\n    public void testBufferedRead_AvailableCharset(final String csName) throws IOException {\n        // prevent java.lang.UnsupportedOperationException at sun.nio.cs.ext.ISO2022_CN.newEncoder.\n        if (isAvailabilityTestableForCharset(csName)) {\n            testBufferedRead(TEST_STRING, csName);\n        }\n    }\n\n    @Test\n    public void testBufferedRead_RequiredCharset() throws IOException {\n        for (final String csName : getRequiredCharsetNames()) {\n            testBufferedRead(TEST_STRING, csName);\n        }\n    }\n\n    @Test\n    public void testBufferedRead_UTF8() throws IOException {\n        testBufferedRead(TEST_STRING, UTF_8);\n    }\n\n    private void testCharsetMismatchInfiniteLoop(final String csName) throws IOException {\n        // Input is UTF-8 bytes: 0xE0 0xB2 0xA0\n        final char[] inputChars = { (char) 0xE0, (char) 0xB2, (char) 0xA0 };\n        final Charset charset = Charset.forName(csName); // infinite loop for US-ASCII, UTF-8 OK\n        try (InputStream stream = new CharSequenceInputStream(new String(inputChars), charset, 512)) {\n            IOUtils.toCharArray(stream, charset);\n        }\n        try (InputStream stream = CharSequenceInputStream.builder().setCharSequence(new String(inputChars)).setCharset(charset).setBufferSize(512).get()) {\n            IOUtils.toCharArray(stream, charset);\n        }\n    }\n\n    @Test\n    public void testCharsetMismatchInfiniteLoop_RequiredCharsets() throws IOException {\n        for (final String csName : getRequiredCharsetNames()) {\n            testCharsetMismatchInfiniteLoop(csName);\n        }\n    }\n\n    // Test is broken if readFirst > 0\n    // This is because the initial read fills the buffer from the CharSequence\n    // so data1 gets the first buffer full; data2 will get the next buffer full\n    private void testIO_356(final int bufferSize, final int dataSize, final int readFirst, final String csName) throws Exception {\n        final byte[] data1;\n        final byte[] data2;\n        try (CharSequenceInputStream is = new CharSequenceInputStream(ALPHABET, csName, bufferSize)) {\n            for (int i = 0; i < readFirst; i++) {\n                final int ch = is.read();\n                assertNotEquals(-1, ch);\n            }\n\n            is.mark(dataSize);\n\n            data1 = new byte[dataSize];\n            final int readCount1 = is.read(data1);\n            assertEquals(dataSize, readCount1);\n\n            is.reset(); // should allow data to be re-read\n\n            data2 = new byte[dataSize];\n            final int readCount2 = is.read(data2);\n            assertEquals(dataSize, readCount2);\n        }\n\n        // data buffers should be identical\n        assertArrayEquals(data1, data2, \"bufferSize=\" + bufferSize + \" dataSize=\" + dataSize);\n    }\n\n    @Test\n    public void testIO_356_B10_D10_S0_UTF16() throws Exception {\n        testIO_356(10, 10, 0, UTF_16);\n    }\n\n    @Test\n    public void testIO_356_B10_D10_S0_UTF8() throws Exception {\n        testIO_356(10, 10, 0, UTF_8);\n    }\n\n    @Test\n    public void testIO_356_B10_D10_S1_UTF8() throws Exception {\n        testIO_356(10, 10, 1, UTF_8);\n    }\n\n    @Test\n    public void testIO_356_B10_D10_S2_UTF8() throws Exception {\n        testIO_356(10, 10, 2, UTF_8);\n    }\n\n    @Test\n    public void testIO_356_B10_D13_S0_UTF8() throws Exception {\n        testIO_356(10, 13, 0, UTF_8);\n    }\n\n    @Test\n    public void testIO_356_B10_D13_S1_UTF8() throws Exception {\n        testIO_356(10, 13, 1, UTF_8);\n    }\n\n    @Test\n    public void testIO_356_B10_D20_S0_UTF8() throws Exception {\n        testIO_356(10, 20, 0, UTF_8);\n    }\n\n    private void testIO_356_Loop(final String csName, final int maxBytesPerChar) throws Exception {\n        for (int bufferSize = maxBytesPerChar; bufferSize <= 10; bufferSize++) {\n            for (int dataSize = 1; dataSize <= 20; dataSize++) {\n                testIO_356(bufferSize, dataSize, 0, csName);\n            }\n        }\n    }\n\n    @Test\n    public void testIO_356_Loop_UTF16() throws Exception {\n        final Charset charset = StandardCharsets.UTF_16;\n        testIO_356_Loop(charset.displayName(), (int) ReaderInputStream.minBufferSize(charset.newEncoder()));\n    }\n\n    @Test\n    public void testIO_356_Loop_UTF8() throws Exception {\n        final Charset charset = StandardCharsets.UTF_8;\n        testIO_356_Loop(charset.displayName(), (int) ReaderInputStream.minBufferSize(charset.newEncoder()));\n    }\n\n    @Test\n    public void testLargeBufferedRead_RequiredCharsets() throws IOException {\n        for (final String csName : getRequiredCharsetNames()) {\n            testBufferedRead(LARGE_TEST_STRING, csName);\n        }\n    }\n\n    @Test\n    public void testLargeBufferedRead_UTF8() throws IOException {\n        testBufferedRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeSingleByteRead_RequiredCharsets() throws IOException {\n        for (final String csName : getRequiredCharsetNames()) {\n            testSingleByteRead(LARGE_TEST_STRING, csName);\n        }\n    }\n\n    @Test\n    public void testLargeSingleByteRead_UTF8() throws IOException {\n        testSingleByteRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    // This test is broken for charsets that don't create a single byte for each char\n    private void testMarkReset(final String csName) throws Exception {\n        try (InputStream r = new CharSequenceInputStream(\"test\", csName)) {\n            assertEquals(2, r.skip(2));\n            r.mark(0);\n            assertEquals('s', r.read(), csName);\n            assertEquals('t', r.read(), csName);\n            assertEquals(-1, r.read(), csName);\n            r.reset();\n            assertEquals('s', r.read(), csName);\n            assertEquals('t', r.read(), csName);\n            assertEquals(-1, r.read(), csName);\n            r.reset();\n            r.reset();\n        }\n    }\n\n    @Test\n    @Disabled // Test broken for charsets that create multiple bytes for a single char\n    public void testMarkReset_RequiredCharsets() throws Exception {\n        for (final String csName : getRequiredCharsetNames()) {\n            testMarkReset(csName);\n        }\n    }\n\n    @Test\n    public void testMarkReset_USASCII() throws Exception {\n        testMarkReset(\"US-ASCII\");\n    }\n\n    @Test\n    public void testMarkReset_UTF8() throws Exception {\n        testMarkReset(UTF_8);\n    }\n\n    @Test\n    public void testMarkSupported() throws Exception {\n        try (@SuppressWarnings(\"deprecation\")\n        InputStream r = new CharSequenceInputStream(\"test\", UTF_8)) {\n            assertTrue(r.markSupported());\n        }\n        try (InputStream r = CharSequenceInputStream.builder().setCharSequence(\"test\").setCharset(UTF_8).get()) {\n            assertTrue(r.markSupported());\n        }\n    }\n\n    @Test\n    public void testNullCharset() throws IOException {\n        try (CharSequenceInputStream in = new CharSequenceInputStream(\"A\", (Charset) null)) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n        try (CharSequenceInputStream in = CharSequenceInputStream.builder().setCharSequence(\"test\").setCharset((Charset) null).get()) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    public void testNullCharsetName() throws IOException {\n        try (CharSequenceInputStream in = new CharSequenceInputStream(\"A\", (String) null)) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n        try (CharSequenceInputStream in = CharSequenceInputStream.builder().setCharSequence(\"test\").setCharset((String) null).get()) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    private void testReadZero(final String csName) throws Exception {\n        try (InputStream r = new CharSequenceInputStream(\"test\", csName)) {\n            final byte[] bytes = new byte[30];\n            assertEquals(0, r.read(bytes, 0, 0));\n        }\n    }\n\n    @Test\n    public void testReadZero_EmptyString() throws Exception {\n        try (InputStream r = new CharSequenceInputStream(\"\", UTF_8)) {\n            final byte[] bytes = new byte[30];\n            assertEquals(0, r.read(bytes, 0, 0));\n        }\n    }\n\n    @Test\n    public void testReadZero_RequiredCharsets() throws Exception {\n        for (final String csName : getRequiredCharsetNames()) {\n            testReadZero(csName);\n        }\n    }\n\n    private void testResetBeforeEnd(final CharSequenceInputStream inputStream) throws IOException {\n        inputStream.mark(1);\n        assertEquals('1', inputStream.read());\n        inputStream.reset();\n        assertEquals('1', inputStream.read());\n        assertEquals('2', inputStream.read());\n        inputStream.reset();\n        assertEquals('1', inputStream.read());\n        assertEquals('2', inputStream.read());\n        assertEquals('3', inputStream.read());\n        inputStream.reset();\n        assertEquals('1', inputStream.read());\n        assertEquals('2', inputStream.read());\n        assertEquals('3', inputStream.read());\n        assertEquals('4', inputStream.read());\n        inputStream.reset();\n        assertEquals('1', inputStream.read());\n    }\n\n    @Test\n    @Disabled(\"[IO-795] CharSequenceInputStream.reset() only works once\")\n    public void testResetBeforeEndSetCharSequence() throws IOException {\n        try (final CharSequenceInputStream inputStream = CharSequenceInputStream.builder().setCharSequence(\"1234\").get()) {\n            testResetBeforeEnd(inputStream);\n        }\n    }\n\n    @Test\n    public void testResetCharset() {\n        assertNotNull(CharSequenceInputStream.builder().setReader(new StringReader(\"\\uD800\")).setCharset((Charset) null).getCharset());\n    }\n\n    @Test\n    public void testResetCharsetEncoder() {\n        assertNotNull(CharSequenceInputStream.builder().setReader(new StringReader(\"\\uD800\")).setCharsetEncoder(null).getCharsetEncoder());\n    }\n\n    @Test\n    public void testResetCharsetName() {\n        assertNotNull(CharSequenceInputStream.builder().setReader(new StringReader(\"\\uD800\")).setCharset((String) null).getCharset());\n    }\n\n    private void testSingleByteRead(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(charsetName);\n        try (InputStream in = new CharSequenceInputStream(testString, charsetName, 512)) {\n            for (final byte b : bytes) {\n                final int read = in.read();\n                assertTrue(read >= 0, \"read \" + read + \" >=0 \");\n                assertTrue(read <= 255, \"read \" + read + \" <= 255\");\n                assertEquals(b, (byte) read, \"Should agree with input\");\n            }\n            assertEquals(-1, in.read());\n        }\n    }\n\n    @Test\n    public void testSingleByteRead_RequiredCharsets() throws IOException {\n        for (final String csName : getRequiredCharsetNames()) {\n            testSingleByteRead(TEST_STRING, csName);\n        }\n    }\n\n    @Test\n    public void testSingleByteRead_UTF16() throws IOException {\n        testSingleByteRead(TEST_STRING, UTF_16);\n    }\n\n    @Test\n    public void testSingleByteRead_UTF8() throws IOException {\n        testSingleByteRead(TEST_STRING, UTF_8);\n    }\n\n\n    @Test\n    public void testSkip_RequiredCharsets() throws Exception {\n        for (final String csName : getRequiredCharsetNames()) {\n            try (InputStream r = new CharSequenceInputStream(\"test\", csName)) {\n                assertEquals(1, r.skip(1));\n                assertEquals(2, r.skip(2));\n                r.skip(100);\n                assertEquals(-1, r.read(), csName);\n            }\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/CharsetsTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Set;\nimport java.util.SortedMap;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Charsets}.\n */\n@SuppressWarnings(\"deprecation\") // testing deprecated code\npublic class CharsetsTest {\n\n    /**\n     * For parameterized tests.\n     */\n    public static final String AVAIL_CHARSETS = \"org.apache.commons.io.CharsetsTest#availableCharsetsKeySet\";\n    /**\n     * For parameterized tests.\n     */\n    public static final String REQUIRED_CHARSETS = \"org.apache.commons.io.CharsetsTest#getRequiredCharsetNames\";\n\n    /**\n     * For parameterized tests.\n     *\n     * @return {@code Charset.availableCharsets().keySet()}.\n     */\n    public static Set<String> availableCharsetsKeySet() {\n        return Charset.availableCharsets().keySet();\n    }\n\n    /**\n     * For parameterized tests.\n     *\n     * @return {@code Charset.requiredCharsets().keySet()}.\n     */\n    public static Set<String> getRequiredCharsetNames() {\n        return Charsets.requiredCharsets().keySet();\n    }\n\n    @Test\n    public void testIso8859_1() {\n        assertEquals(\"ISO-8859-1\", Charsets.ISO_8859_1.name());\n    }\n\n    @Test\n    public void testRequiredCharsets() {\n        final SortedMap<String, Charset> requiredCharsets = Charsets.requiredCharsets();\n        // test for what we expect to be there as of Java 6\n        // Make sure the object at the given key is the right one\n        assertEquals(requiredCharsets.get(\"US-ASCII\").name(), \"US-ASCII\");\n        assertEquals(requiredCharsets.get(\"ISO-8859-1\").name(), \"ISO-8859-1\");\n        assertEquals(requiredCharsets.get(\"UTF-8\").name(), \"UTF-8\");\n        assertEquals(requiredCharsets.get(\"UTF-16\").name(), \"UTF-16\");\n        assertEquals(requiredCharsets.get(\"UTF-16BE\").name(), \"UTF-16BE\");\n        assertEquals(requiredCharsets.get(\"UTF-16LE\").name(), \"UTF-16LE\");\n    }\n\n    @Test\n    public void testToCharset_String() {\n        assertEquals(Charset.defaultCharset(), Charsets.toCharset((String) null));\n        assertEquals(Charset.defaultCharset(), Charsets.toCharset((Charset) null));\n        assertEquals(Charset.defaultCharset(), Charsets.toCharset(Charset.defaultCharset()));\n        assertEquals(StandardCharsets.UTF_8, Charsets.toCharset(StandardCharsets.UTF_8));\n    }\n\n    @Test\n    public void testToCharset_String_Charset() {\n        assertEquals(null, Charsets.toCharset((String) null, null));\n        assertEquals(Charset.defaultCharset(), Charsets.toCharset((String) null, Charset.defaultCharset()));\n        assertEquals(Charset.defaultCharset(), Charsets.toCharset((Charset) null, Charset.defaultCharset()));\n        assertEquals(null, Charsets.toCharset((Charset) null, null));\n        assertEquals(Charset.defaultCharset(), Charsets.toCharset(Charset.defaultCharset(), Charset.defaultCharset()));\n        assertEquals(StandardCharsets.UTF_8, Charsets.toCharset(StandardCharsets.UTF_8, Charset.defaultCharset()));\n        assertEquals(StandardCharsets.UTF_8, Charsets.toCharset(StandardCharsets.UTF_8, null));\n    }\n\n    @Test\n    public void testUsAscii() {\n        assertEquals(\"US-ASCII\", Charsets.US_ASCII.name());\n    }\n\n    @Test\n    public void testUtf16() {\n        assertEquals(\"UTF-16\", Charsets.UTF_16.name());\n    }\n\n    @Test\n    public void testUtf16Be() {\n        assertEquals(\"UTF-16BE\", Charsets.UTF_16BE.name());\n    }\n\n    @Test\n    public void testUtf16Le() {\n        assertEquals(\"UTF-16LE\", Charsets.UTF_16LE.name());\n    }\n\n    @Test\n    public void testUtf8() {\n        assertEquals(\"UTF-8\", Charsets.UTF_8.name());\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * For parameterized tests.\n     *\n     * @return {@code Charset.requiredCharsets().keySet()}.\n     */\n    public static Set<String> getRequiredCharsetNames() {\n        return Charsets.requiredCharsets().keySet();\n    }", "diffSourceCode": "-   53:         for (int i = 0; i < 100; i++) {\n-   54:             buffer.append(TEST_STRING);\n-   55:         }\n-   56:         LARGE_TEST_STRING = buffer.toString();\n-   57:     }\n-   58: \n-   59:     private final Random random = new Random();\n-   60: \n-   67:     private Set<String> getRequiredCharsetNames() {\n-   68:         return Charsets.requiredCharsets().keySet();\n-   69:     }\n+   53:     /**\n+   54:      * For parameterized tests.\n+   55:      *\n+   56:      * @return {@code Charset.requiredCharsets().keySet()}.\n+   57:      */\n+   58:     public static Set<String> getRequiredCharsetNames() {\n+   59:         return Charsets.requiredCharsets().keySet();\n+   60:     }\n+   67:     @Test\n+   68:     public void testRequiredCharsets() {\n+   69:         final SortedMap<String, Charset> requiredCharsets = Charsets.requiredCharsets();\n", "uniqueId": "d18e81487493ae6eedd03dbe27ff699f7f410523_67_69__53_60", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code by moving the `getRequiredCharsetNames` method to an existing class, we will analyze the project structure and find a suitable class to contain this method. \n\n### Analysis\nThe `getRequiredCharsetNames` method retrieves a set of required charset names from the `Charsets` class. A logical place to move this method would be to the `CharsetsTest` class, as it seems to be related to charset operations and testing.\n\n### Refactoring Steps\n1. **Move the Method**: We will move `getRequiredCharsetNames` to the `CharsetsTest` class and make it a public static method.\n2. **Update the Original Class**: We will update the `CharSequenceInputStreamTest` class to call the moved method from the `CharsetsTest` class.\n\n### Target File Path\nThe target file path for the moved method will be:\n```\nsrc/test/java/org/apache/commons/io/CharsetsTest.java\n```\n\n### Moved Class Code\nHere is the code for the `CharsetsTest` class with the moved method:\n```java\npackage org.apache.commons.io;\n\nimport java.util.Set;\n\npublic class CharsetsTest {\n    // Other existing methods and fields...\n\n    public static Set<String> getRequiredCharsetNames() {\n        return Charsets.requiredCharsets().keySet();\n    }\n}\n```\n\n### Refactored Method Code\nHere is the updated `getRequiredCharsetNames` method in the `CharSequenceInputStreamTest` class:\n```java\nprivate Set<String> getRequiredCharsetNames() {\n    return CharsetsTest.getRequiredCharsetNames();\n}\n```\n\n### Final Output\nNow, we will format the output as requested:\n\n##########################\nsrc/test/java/org/apache/commons/io/CharsetsTest.java\n##########################\npublic class CharsetsTest {\n    // Other existing methods and fields...\n\n    public static Set<String> getRequiredCharsetNames() {\n        return Charsets.requiredCharsets().keySet();\n    }\n}\n##########################\nprivate Set<String> getRequiredCharsetNames() {\n    return CharsetsTest.getRequiredCharsetNames();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\nprivate Set<String> getRequiredCharsetNames() {\n        return Charsets.requiredCharsets().keySet();\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Random;\nimport java.util.Set;\n\nimport org.apache.commons.io.Charsets;\nimport org.apache.commons.io.CharsetsTest;\nimport org.apache.commons.io.IOUtils;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.MethodSource;\n\npublic class CharSequenceInputStreamTest {\n\n    private static final String UTF_16 = StandardCharsets.UTF_16.name();\n    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n    private static final String ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    private static final String LARGE_TEST_STRING;\n\n    private static final String TEST_STRING = \"\\u00e0 peine arriv\\u00e9s nous entr\\u00e2mes dans sa chambre\";\n\n    static {\n        final StringBuilder buffer = new StringBuilder();\n        for (int i = 0; i < 100; i++) {\n            buffer.append(TEST_STRING);\n        }\n        LARGE_TEST_STRING = buffer.toString();\n    }\n\n    private final Random random = new Random();\n\n    private int checkAvail(final InputStream is, final int min) throws Exception {\n        final int available = is.available();\n        assertTrue(available >= min, \"avail should be >= \" + min + \", but was \" + available);\n        return available;\n    }\n\n    private Set<String> getRequiredCharsetNames() {\n        return Charsets.requiredCharsets().keySet();\n    }\n\n    private boolean isAvailabilityTestableForCharset(final String csName) {\n        return Charset.forName(csName).canEncode()\n                && !\"COMPOUND_TEXT\".equalsIgnoreCase(csName) && !\"x-COMPOUND_TEXT\".equalsIgnoreCase(csName)\n                && !isOddBallLegacyCharsetThatDoesNotSupportFrenchCharacters(csName);\n    }\n\n    private boolean isOddBallLegacyCharsetThatDoesNotSupportFrenchCharacters(final String csName) {\n        return \"x-IBM1388\".equalsIgnoreCase(csName) ||\n                \"ISO-2022-CN\".equalsIgnoreCase(csName) ||\n                \"ISO-2022-JP\".equalsIgnoreCase(csName) ||\n                \"Shift_JIS\".equalsIgnoreCase(csName);\n    }\n\n    @ParameterizedTest(name = \"{0}\")\n    @MethodSource(CharsetsTest.AVAIL_CHARSETS)\n    public void testAvailable(final String csName) throws Exception {\n        // prevent java.lang.UnsupportedOperationException at sun.nio.cs.ext.ISO2022_CN.newEncoder.\n        // also try and avoid the following exception\n//            java.lang.UnsupportedOperationException: null\n//            at java.nio.CharBuffer.array(CharBuffer.java:940)\n//            at sun.nio.cs.ext.COMPOUND_TEXT_Encoder.encodeLoop(COMPOUND_TEXT_Encoder.java:75)\n//            at java.nio.charset.CharsetEncoder.encode(CharsetEncoder.java:544)\n//            at org.apache.commons.io.input.CharSequenceInputStream.fillBuffer(CharSequenceInputStream.java:120)\n//            at org.apache.commons.io.input.CharSequenceInputStream.read(CharSequenceInputStream.java:151)\n//            at org.apache.commons.io.input.CharSequenceInputStreamTest.testAvailableRead(CharSequenceInputStreamTest.java:412)\n//            at org.apache.commons.io.input.CharSequenceInputStreamTest.testAvailable(CharSequenceInputStreamTest.java:424)\n\n        try {\n            if (isAvailabilityTestableForCharset(csName)) {\n                testAvailableSkip(csName);\n                testAvailableRead(csName);\n            }\n        } catch (final UnsupportedOperationException e) {\n            fail(\"Operation not supported for \" + csName);\n        }\n    }\n\n    private void testAvailableRead(final String csName) throws Exception {\n        final String input = \"test\";\n        try (InputStream r = new CharSequenceInputStream(input, csName)) {\n            int available = checkAvail(r, input.length());\n            assertEquals(available - 1, r.skip(available - 1)); // skip all but one\n            available = checkAvail(r, 1);\n            final byte[] buff = new byte[available];\n            assertEquals(available, r.read(buff, 0, available));\n        }\n    }\n\n    private void testAvailableSkip(final String csName) throws Exception {\n        final String input = \"test\";\n        try (InputStream r = new CharSequenceInputStream(input, csName)) {\n            int available = checkAvail(r, input.length());\n            assertEquals(available - 1, r.skip(available - 1)); // skip all but one\n            available = checkAvail(r, 1);\n            assertEquals(1, r.skip(1));\n            available = checkAvail(r, 0);\n        }\n    }\n\n    private void testBufferedRead(final String testString, final String charsetName) throws IOException {\n        final byte[] expected = testString.getBytes(charsetName);\n        try (InputStream in = new CharSequenceInputStream(testString, charsetName, 512)) {\n            final byte[] buffer = new byte[128];\n            int offset = 0;            while (true) {\n                int bufferOffset = random.nextInt(64);\n                final int bufferLength = random.nextInt(64);\n                int read = in.read(buffer, bufferOffset, bufferLength);\n                if (read == -1) {\n                    assertEquals(expected.length, offset, \"EOF: offset should equal length for charset \" + charsetName);\n                    break;\n                }\n                assertTrue(read <= bufferLength, \"Read \" + read + \" <= \" + bufferLength);\n                while (read > 0) {\n                    assertTrue(offset < expected.length,\n                            \"offset for \" + charsetName + \" \" + offset + \" < \" + expected.length);\n                    assertEquals(expected[offset], buffer[bufferOffset], \"bytes should agree for \" + charsetName);\n                    offset++;\n                    bufferOffset++;\n                    read--;\n                }\n            }\n        }\n    }\n\n    //    Unfortunately checking canEncode does not seem to work for all charsets:\n//    testBufferedRead_AvailableCharset(org.apache.commons.io.input.CharSequenceInputStreamTest)  Time elapsed: 0.682 sec  <<< ERROR!\n//    java.lang.UnsupportedOperationException: null\n//        at java.nio.CharBuffer.array(CharBuffer.java:940)\n//        at sun.nio.cs.ext.COMPOUND_TEXT_Encoder.encodeLoop(COMPOUND_TEXT_Encoder.java:75)\n//        at java.nio.charset.CharsetEncoder.encode(CharsetEncoder.java:544)\n//        at org.apache.commons.io.input.CharSequenceInputStream.fillBuffer(CharSequenceInputStream.java:111)\n    @ParameterizedTest(name = \"{0}\")\n    @MethodSource(CharsetsTest.AVAIL_CHARSETS)\n    public void testBufferedRead_AvailableCharset(final String csName) throws IOException {\n        // prevent java.lang.UnsupportedOperationException at sun.nio.cs.ext.ISO2022_CN.newEncoder.\n        if (isAvailabilityTestableForCharset(csName)) {\n            testBufferedRead(TEST_STRING, csName);\n        }\n    }\n\n    @Test\n    public void testBufferedRead_RequiredCharset() throws IOException {\n        for (final String csName : getRequiredCharsetNames()) {\n            testBufferedRead(TEST_STRING, csName);\n        }\n    }\n\n    @Test\n    public void testBufferedRead_UTF8() throws IOException {\n        testBufferedRead(TEST_STRING, UTF_8);\n    }\n\n    private void testCharsetMismatchInfiniteLoop(final String csName) throws IOException {\n        // Input is UTF-8 bytes: 0xE0 0xB2 0xA0\n        final char[] inputChars = { (char) 0xE0, (char) 0xB2, (char) 0xA0 };\n        final Charset charset = Charset.forName(csName); // infinite loop for US-ASCII, UTF-8 OK\n        try (InputStream stream = new CharSequenceInputStream(new String(inputChars), charset, 512)) {\n            IOUtils.toCharArray(stream, charset);\n        }\n        try (InputStream stream = CharSequenceInputStream.builder().setCharSequence(new String(inputChars)).setCharset(charset).setBufferSize(512).get()) {\n            IOUtils.toCharArray(stream, charset);\n        }\n    }\n\n    @Test\n    public void testCharsetMismatchInfiniteLoop_RequiredCharsets() throws IOException {\n        for (final String csName : getRequiredCharsetNames()) {\n            testCharsetMismatchInfiniteLoop(csName);\n        }\n    }\n\n    // Test is broken if readFirst > 0\n    // This is because the initial read fills the buffer from the CharSequence\n    // so data1 gets the first buffer full; data2 will get the next buffer full\n    private void testIO_356(final int bufferSize, final int dataSize, final int readFirst, final String csName) throws Exception {\n        final byte[] data1;\n        final byte[] data2;\n        try (CharSequenceInputStream is = new CharSequenceInputStream(ALPHABET, csName, bufferSize)) {\n            for (int i = 0; i < readFirst; i++) {\n                final int ch = is.read();\n                assertNotEquals(-1, ch);\n            }\n\n            is.mark(dataSize);\n\n            data1 = new byte[dataSize];\n            final int readCount1 = is.read(data1);\n            assertEquals(dataSize, readCount1);\n\n            is.reset(); // should allow data to be re-read\n\n            data2 = new byte[dataSize];\n            final int readCount2 = is.read(data2);\n            assertEquals(dataSize, readCount2);\n        }\n\n        // data buffers should be identical\n        assertArrayEquals(data1, data2, \"bufferSize=\" + bufferSize + \" dataSize=\" + dataSize);\n    }\n\n    @Test\n    public void testIO_356_B10_D10_S0_UTF16() throws Exception {\n        testIO_356(10, 10, 0, UTF_16);\n    }\n\n    @Test\n    public void testIO_356_B10_D10_S0_UTF8() throws Exception {\n        testIO_356(10, 10, 0, UTF_8);\n    }\n\n    @Test\n    public void testIO_356_B10_D10_S1_UTF8() throws Exception {\n        testIO_356(10, 10, 1, UTF_8);\n    }\n\n    @Test\n    public void testIO_356_B10_D10_S2_UTF8() throws Exception {\n        testIO_356(10, 10, 2, UTF_8);\n    }\n\n    @Test\n    public void testIO_356_B10_D13_S0_UTF8() throws Exception {\n        testIO_356(10, 13, 0, UTF_8);\n    }\n\n    @Test\n    public void testIO_356_B10_D13_S1_UTF8() throws Exception {\n        testIO_356(10, 13, 1, UTF_8);\n    }\n\n    @Test\n    public void testIO_356_B10_D20_S0_UTF8() throws Exception {\n        testIO_356(10, 20, 0, UTF_8);\n    }\n\n    private void testIO_356_Loop(final String csName, final int maxBytesPerChar) throws Exception {\n        for (int bufferSize = maxBytesPerChar; bufferSize <= 10; bufferSize++) {\n            for (int dataSize = 1; dataSize <= 20; dataSize++) {\n                testIO_356(bufferSize, dataSize, 0, csName);\n            }\n        }\n    }\n\n    @Test\n    public void testIO_356_Loop_UTF16() throws Exception {\n        final Charset charset = StandardCharsets.UTF_16;\n        testIO_356_Loop(charset.displayName(), (int) ReaderInputStream.minBufferSize(charset.newEncoder()));\n    }\n\n    @Test\n    public void testIO_356_Loop_UTF8() throws Exception {\n        final Charset charset = StandardCharsets.UTF_8;\n        testIO_356_Loop(charset.displayName(), (int) ReaderInputStream.minBufferSize(charset.newEncoder()));\n    }\n\n    @Test\n    public void testLargeBufferedRead_RequiredCharsets() throws IOException {\n        for (final String csName : getRequiredCharsetNames()) {\n            testBufferedRead(LARGE_TEST_STRING, csName);\n        }\n    }\n\n    @Test\n    public void testLargeBufferedRead_UTF8() throws IOException {\n        testBufferedRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    @Test\n    public void testLargeSingleByteRead_RequiredCharsets() throws IOException {\n        for (final String csName : getRequiredCharsetNames()) {\n            testSingleByteRead(LARGE_TEST_STRING, csName);\n        }\n    }\n\n    @Test\n    public void testLargeSingleByteRead_UTF8() throws IOException {\n        testSingleByteRead(LARGE_TEST_STRING, UTF_8);\n    }\n\n    // This test is broken for charsets that don't create a single byte for each char\n    private void testMarkReset(final String csName) throws Exception {\n        try (InputStream r = new CharSequenceInputStream(\"test\", csName)) {\n            assertEquals(2, r.skip(2));\n            r.mark(0);\n            assertEquals('s', r.read(), csName);\n            assertEquals('t', r.read(), csName);\n            assertEquals(-1, r.read(), csName);\n            r.reset();\n            assertEquals('s', r.read(), csName);\n            assertEquals('t', r.read(), csName);\n            assertEquals(-1, r.read(), csName);\n            r.reset();\n            r.reset();\n        }\n    }\n\n    @Test\n    @Disabled // Test broken for charsets that create multiple bytes for a single char\n    public void testMarkReset_RequiredCharsets() throws Exception {\n        for (final String csName : getRequiredCharsetNames()) {\n            testMarkReset(csName);\n        }\n    }\n\n    @Test\n    public void testMarkReset_USASCII() throws Exception {\n        testMarkReset(\"US-ASCII\");\n    }\n\n    @Test\n    public void testMarkReset_UTF8() throws Exception {\n        testMarkReset(UTF_8);\n    }\n\n    @Test\n    public void testMarkSupported() throws Exception {\n        try (@SuppressWarnings(\"deprecation\")\n        InputStream r = new CharSequenceInputStream(\"test\", UTF_8)) {\n            assertTrue(r.markSupported());\n        }\n        try (InputStream r = CharSequenceInputStream.builder().setCharSequence(\"test\").setCharset(UTF_8).get()) {\n            assertTrue(r.markSupported());\n        }\n    }\n\n    @Test\n    public void testNullCharset() throws IOException {\n        try (CharSequenceInputStream in = new CharSequenceInputStream(\"A\", (Charset) null)) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n        try (CharSequenceInputStream in = CharSequenceInputStream.builder().setCharSequence(\"test\").setCharset((Charset) null).get()) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    @Test\n    public void testNullCharsetName() throws IOException {\n        try (CharSequenceInputStream in = new CharSequenceInputStream(\"A\", (String) null)) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n        try (CharSequenceInputStream in = CharSequenceInputStream.builder().setCharSequence(\"test\").setCharset((String) null).get()) {\n            IOUtils.toByteArray(in);\n            assertEquals(Charset.defaultCharset(), in.getCharsetEncoder().charset());\n        }\n    }\n\n    private void testReadZero(final String csName) throws Exception {\n        try (InputStream r = new CharSequenceInputStream(\"test\", csName)) {\n            final byte[] bytes = new byte[30];\n            assertEquals(0, r.read(bytes, 0, 0));\n        }\n    }\n\n    @Test\n    public void testReadZero_EmptyString() throws Exception {\n        try (InputStream r = new CharSequenceInputStream(\"\", UTF_8)) {\n            final byte[] bytes = new byte[30];\n            assertEquals(0, r.read(bytes, 0, 0));\n        }\n    }\n\n    @Test\n    public void testReadZero_RequiredCharsets() throws Exception {\n        for (final String csName : getRequiredCharsetNames()) {\n            testReadZero(csName);\n        }\n    }\n\n    private void testResetBeforeEnd(final CharSequenceInputStream inputStream) throws IOException {\n        inputStream.mark(1);\n        assertEquals('1', inputStream.read());\n        inputStream.reset();\n        assertEquals('1', inputStream.read());\n        assertEquals('2', inputStream.read());\n        inputStream.reset();\n        assertEquals('1', inputStream.read());\n        assertEquals('2', inputStream.read());\n        assertEquals('3', inputStream.read());\n        inputStream.reset();\n        assertEquals('1', inputStream.read());\n        assertEquals('2', inputStream.read());\n        assertEquals('3', inputStream.read());\n        assertEquals('4', inputStream.read());\n        inputStream.reset();\n        assertEquals('1', inputStream.read());\n    }\n\n    @Test\n    @Disabled(\"[IO-795] CharSequenceInputStream.reset() only works once\")\n    public void testResetBeforeEndSetCharSequence() throws IOException {\n        try (final CharSequenceInputStream inputStream = CharSequenceInputStream.builder().setCharSequence(\"1234\").get()) {\n            testResetBeforeEnd(inputStream);\n        }\n    }\n\n    @Test\n    public void testResetCharset() {\n        assertNotNull(CharSequenceInputStream.builder().setReader(new StringReader(\"\\uD800\")).setCharset((Charset) null).getCharset());\n    }\n\n    @Test\n    public void testResetCharsetEncoder() {\n        assertNotNull(CharSequenceInputStream.builder().setReader(new StringReader(\"\\uD800\")).setCharsetEncoder(null).getCharsetEncoder());\n    }\n\n    @Test\n    public void testResetCharsetName() {\n        assertNotNull(CharSequenceInputStream.builder().setReader(new StringReader(\"\\uD800\")).setCharset((String) null).getCharset());\n    }\n\n    private void testSingleByteRead(final String testString, final String charsetName) throws IOException {\n        final byte[] bytes = testString.getBytes(charsetName);\n        try (InputStream in = new CharSequenceInputStream(testString, charsetName, 512)) {\n            for (final byte b : bytes) {\n                final int read = in.read();\n                assertTrue(read >= 0, \"read \" + read + \" >=0 \");\n                assertTrue(read <= 255, \"read \" + read + \" <= 255\");\n                assertEquals(b, (byte) read, \"Should agree with input\");\n            }\n            assertEquals(-1, in.read());\n        }\n    }\n\n    @Test\n    public void testSingleByteRead_RequiredCharsets() throws IOException {\n        for (final String csName : getRequiredCharsetNames()) {\n            testSingleByteRead(TEST_STRING, csName);\n        }\n    }\n\n    @Test\n    public void testSingleByteRead_UTF16() throws IOException {\n        testSingleByteRead(TEST_STRING, UTF_16);\n    }\n\n    @Test\n    public void testSingleByteRead_UTF8() throws IOException {\n        testSingleByteRead(TEST_STRING, UTF_8);\n    }\n\n\n    @Test\n    public void testSkip_RequiredCharsets() throws Exception {\n        for (final String csName : getRequiredCharsetNames()) {\n            try (InputStream r = new CharSequenceInputStream(\"test\", csName)) {\n                assertEquals(1, r.skip(1));\n                assertEquals(2, r.skip(2));\n                r.skip(100);\n                assertEquals(-1, r.read(), csName);\n            }\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/AbstractFileUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsMultithreadedSkipTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/RandomAccessFilesTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/StreamIteratorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/build/AbstractOriginTest.java', 'src/test/java/org/apache/commons/io/build/AbstractStreamBuilderTest.java', 'src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java', 'src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java', 'src/test/java/org/apache/commons/io/build/FileOriginTest.java', 'src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/PathOriginTest.java', 'src/test/java/org/apache/commons/io/build/ReaderOriginTest.java', 'src/test/java/org/apache/commons/io/build/URIOriginTest.java', 'src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java', 'src/test/java/org/apache/commons/io/channels/FileChannelsTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractPathWrapper.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractConditionalFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractIOFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/PathMatcherFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIntSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOLongSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/PathUtilsContentEqualsBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate builder() : Builder extracted from public test_ConstructorLjava_io_InputStreamI() : void in class org.apache.commons.io.input.UnsynchronizedBufferedInputStreamTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java", "startLine": 170, "endLine": 194, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java", "startLine": 168, "endLine": 190, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java", "startLine": 73, "endLine": 75, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void test_ConstructorLjava_io_InputStreamI() throws IOException {\n        try (BufferedInputStream str = new BufferedInputStream(null, 1)) {\n            assertThrows(IOException.class, () -> str.read(), \"Expected an IOException\");\n        }\n\n        // Test for method java.io.BufferedInputStream(java.io.InputStream, int)\n\n        // Create buffer with exact size of file\n        is = new BufferedInputStream(isFile, DATA.length());\n        // Ensure buffer gets filled by evaluating one read\n        is.read();\n        // Close underlying FileInputStream, all but 1 buffered bytes should\n        // still be available.\n        isFile.close();\n        // Read the remaining buffered characters, no IOException should\n        // occur.\n        is.skip(DATA.length() - 2);\n        is.read();\n        // is.read should now throw an exception because it will have to be filled.\n        assertThrows(IOException.class, () -> is.read());\n\n        assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null).setBufferSize(100).get());\n        assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null));\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java", "isPureRefactoring": true, "commitId": "269f9921cb022c04672e54f81ba4fb9e139ea277", "packageNameBefore": "org.apache.commons.io.input", "classNameBefore": "org.apache.commons.io.input.UnsynchronizedBufferedInputStreamTest", "methodNameBefore": "org.apache.commons.io.input.UnsynchronizedBufferedInputStreamTest#test_ConstructorLjava_io_InputStreamI", "invokedMethod": "methodSignature: org.apache.commons.io.input.UnsynchronizedBufferedInputStream#read\n methodBody: public int read(final byte[] buffer, int offset, final int length) throws IOException {\nbyte[] localBuf=buffer;\nif(localBuf == null){throw new IOException(\"Stream is closed\");\n}if(offset > buffer.length - length || offset < 0 || length < 0){throw new IndexOutOfBoundsException();\n}if(length == 0){return 0;\n}final InputStream localIn=inputStream;\nif(localIn == null){throw new IOException(\"Stream is closed\");\n}int required;\nif(pos < count){final int copylength=count - pos >= length ? length : count - pos;\nSystem.arraycopy(localBuf,pos,buffer,offset,copylength);\npos+=copylength;\nif(copylength == length || localIn.available() == 0){return copylength;\n}offset+=copylength;\nrequired=length - copylength;\n}{required=length;\n}while(true){final int read;\nif(markPos == IOUtils.EOF && required >= localBuf.length){read=localIn.read(buffer,offset,required);\nif(read == IOUtils.EOF){return required == length ? IOUtils.EOF : length - required;\n}}{if(fillBuffer(localIn,localBuf) == IOUtils.EOF){return required == length ? IOUtils.EOF : length - required;\n}if(localBuf != buffer){localBuf=buffer;\nif(localBuf == null){throw new IOException(\"Stream is closed\");\n}}read=count - pos >= required ? required : count - pos;\nSystem.arraycopy(localBuf,pos,buffer,offset,read);\npos+=read;\n}required-=read;\nif(required == 0){return length;\n}if(localIn.available() == 0){return length - required;\n}offset+=read;\n}}\nmethodSignature: org.apache.commons.io.input.UnsynchronizedBufferedInputStream.Builder#get\n methodBody: public UnsynchronizedBufferedInputStream get() throws IOException {\nreturn new UnsynchronizedBufferedInputStream(getInputStream(),getBufferSize());\n}\nmethodSignature: org.apache.commons.io.input.UnsynchronizedBufferedInputStream#close\n methodBody: public void close() throws IOException {\nbuffer=null;\nfinal InputStream localIn=inputStream;\ninputStream=null;\nif(localIn != null){localIn.close();\n}}\nmethodSignature: org.apache.commons.io.input.UnsynchronizedBufferedInputStream#skip\n methodBody: public long skip(final long amount) throws IOException {\nfinal byte[] localBuf=buffer;\nfinal InputStream localIn=inputStream;\nif(localBuf == null){throw new IOException(\"Stream is closed\");\n}if(amount < 1){return 0;\n}if(localIn == null){throw new IOException(\"Stream is closed\");\n}if(count - pos >= amount){pos+=(int)amount;\nreturn amount;\n}int read=count - pos;\npos=count;\nif(markPos != IOUtils.EOF && amount <= markLimit){if(fillBuffer(localIn,localBuf) == IOUtils.EOF){return read;\n}if(count - pos >= amount - read){pos+=((int)amount) - read;\nreturn amount;\n}read+=count - pos;\npos=count;\nreturn read;\n}return read + localIn.skip(amount - read);\n}", "classSignatureBefore": "public class UnsynchronizedBufferedInputStreamTest ", "methodNameBeforeSet": ["org.apache.commons.io.input.UnsynchronizedBufferedInputStreamTest#test_ConstructorLjava_io_InputStreamI"], "classNameBeforeSet": ["org.apache.commons.io.input.UnsynchronizedBufferedInputStreamTest"], "classSignatureBeforeSet": ["public class UnsynchronizedBufferedInputStreamTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link UnsynchronizedBufferedInputStream}.\n * <p>\n * Provenance: Apache Harmony and modified.\n * </p>\n */\npublic class UnsynchronizedBufferedInputStreamTest {\n\n    private static final int BUFFER_SIZE = 4096;\n\n    public static final String DATA = StringUtils.repeat(\"This is a test.\", 500);\n\n    Path fileName;\n\n    private BufferedInputStream is;\n\n    private InputStream isFile;\n\n    byte[] ibuf = new byte[BUFFER_SIZE];\n\n    /**\n     * Sets up the fixture, for example, open a network connection. This method is called before a test is executed.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException {\n        fileName = Files.createTempFile(getClass().getSimpleName(), \".tst\");\n        Files.write(fileName, DATA.getBytes(StandardCharsets.UTF_8));\n\n        isFile = Files.newInputStream(fileName);\n        is = new BufferedInputStream(isFile);\n    }\n\n    /**\n     * Tears down the fixture, for example, close a network connection. This method is called after a test is executed.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @AfterEach\n    protected void tearDown() throws IOException {\n        IOUtils.closeQuietly(is);\n        Files.deleteIfExists(fileName);\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#available()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_available() throws IOException {\n        assertEquals(DATA.length(), is.available(), \"Returned incorrect number of available bytes\");\n\n        // Test that a closed stream throws an IOE for available()\n        final BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(new byte[] { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' }));\n        final int available = bis.available();\n        bis.close();\n        assertTrue(available != 0);\n\n        assertThrows(IOException.class, () -> bis.available(), \"Expected test to throw IOE.\");\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#close()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_close() throws IOException {\n        new BufferedInputStream(isFile).close();\n\n        // regression for HARMONY-667\n        try (BufferedInputStream buf = new BufferedInputStream(null, 5)) {\n            // closes\n        }\n\n        try (InputStream in = new InputStream() {\n            Object lock = new Object();\n\n            @Override\n            public void close() {\n                synchronized (lock) {\n                    lock.notifyAll();\n                }\n            }\n\n            @Override\n            public int read() {\n                return 1;\n            }\n\n            @Override\n            public int read(final byte[] buf, final int offset, final int length) {\n                synchronized (lock) {\n                    try {\n                        lock.wait(3000);\n                    } catch (final InterruptedException e) {\n                        // Ignore\n                    }\n                }\n                return 1;\n            }\n        }) {\n            final BufferedInputStream bufin = new BufferedInputStream(in);\n            final Thread thread = new Thread(() -> {\n                try {\n                    Thread.sleep(1000);\n                    bufin.close();\n                } catch (final Exception e) {\n                    // Ignored\n                }\n            });\n            thread.start();\n            assertThrows(IOException.class, () -> bufin.read(new byte[100], 0, 99), \"Should throw IOException\");\n        }\n    }\n\n    /*\n     * Tests java.io.BufferedInputStream(InputStream)\n     */\n    @Test\n    public void test_ConstructorLjava_io_InputStream() throws IOException {\n        try (BufferedInputStream str = new BufferedInputStream(null)) {\n            assertThrows(IOException.class, () -> str.read(), \"Expected an IOException\");\n        }\n    }\n\n    /*\n     * Tests java.io.BufferedInputStream(InputStream)\n     */\n    @Test\n    public void test_ConstructorLjava_io_InputStreamI() throws IOException {\n        try (BufferedInputStream str = new BufferedInputStream(null, 1)) {\n            assertThrows(IOException.class, () -> str.read(), \"Expected an IOException\");\n        }\n\n        // Test for method java.io.BufferedInputStream(java.io.InputStream, int)\n\n        // Create buffer with exact size of file\n        is = new BufferedInputStream(isFile, DATA.length());\n        // Ensure buffer gets filled by evaluating one read\n        is.read();\n        // Close underlying FileInputStream, all but 1 buffered bytes should\n        // still be available.\n        isFile.close();\n        // Read the remaining buffered characters, no IOException should\n        // occur.\n        is.skip(DATA.length() - 2);\n        is.read();\n        // is.read should now throw an exception because it will have to be filled.\n        assertThrows(IOException.class, () -> is.read());\n\n        assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null).setBufferSize(100).get());\n        assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null));\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#mark(int)\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_markI() throws IOException {\n        final byte[] buf1 = new byte[100];\n        final byte[] buf2 = new byte[100];\n        is.skip(3000);\n        is.mark(1000);\n        is.read(buf1, 0, buf1.length);\n        is.reset();\n        is.read(buf2, 0, buf2.length);\n        is.reset();\n        assertTrue(new String(buf1, 0, buf1.length).equals(new String(buf2, 0, buf2.length)), \"Failed to mark correct position\");\n\n        byte[] bytes = new byte[256];\n        for (int i = 0; i < 256; i++) {\n            bytes[i] = (byte) i;\n        }\n        InputStream in = new BufferedInputStream(new ByteArrayInputStream(bytes), 12);\n        in.skip(6);\n        in.mark(14);\n        in.read(new byte[14], 0, 14);\n        in.reset();\n        assertTrue(in.read() == 6 && in.read() == 7, \"Wrong bytes\");\n\n        in = new BufferedInputStream(new ByteArrayInputStream(bytes), 12);\n        in.skip(6);\n        in.mark(8);\n        in.skip(7);\n        in.reset();\n        assertTrue(in.read() == 6 && in.read() == 7, \"Wrong bytes 2\");\n\n        BufferedInputStream buf = new BufferedInputStream(new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4 }), 2);\n        buf.mark(3);\n        bytes = new byte[3];\n        int result = buf.read(bytes);\n        assertEquals(3, result);\n        assertEquals(0, bytes[0], \"Assert 0:\");\n        assertEquals(1, bytes[1], \"Assert 1:\");\n        assertEquals(2, bytes[2], \"Assert 2:\");\n        assertEquals(3, buf.read(), \"Assert 3:\");\n\n        buf = new BufferedInputStream(new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4 }), 2);\n        buf.mark(3);\n        bytes = new byte[4];\n        result = buf.read(bytes);\n        assertEquals(4, result);\n        assertEquals(0, bytes[0], \"Assert 4:\");\n        assertEquals(1, bytes[1], \"Assert 5:\");\n        assertEquals(2, bytes[2], \"Assert 6:\");\n        assertEquals(3, bytes[3], \"Assert 7:\");\n        assertEquals(4, buf.read(), \"Assert 8:\");\n        assertEquals(-1, buf.read(), \"Assert 9:\");\n\n        buf = new BufferedInputStream(new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4 }), 2);\n        buf.mark(Integer.MAX_VALUE);\n        buf.read();\n        buf.close();\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#markSupported()\n     */\n    @Test\n    public void test_markSupported() {\n        assertTrue(is.markSupported(), \"markSupported returned incorrect value\");\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#read()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_read() throws IOException {\n        final InputStreamReader isr = new InputStreamReader(is);\n        final int c = isr.read();\n        assertEquals(DATA.charAt(0), c, \"read returned incorrect char\");\n\n        final byte[] bytes = new byte[256];\n        for (int i = 0; i < 256; i++) {\n            bytes[i] = (byte) i;\n        }\n        final InputStream in = new BufferedInputStream(new ByteArrayInputStream(bytes), 12);\n        assertEquals(0, in.read(), \"Wrong initial byte\"); // Fill the buffer\n        final byte[] buf = new byte[14];\n        in.read(buf, 0, 14); // Read greater than the buffer\n        assertTrue(new String(buf, 0, 14).equals(new String(bytes, 1, 14)), \"Wrong block read data\");\n        assertEquals(15, in.read(), \"Wrong bytes\"); // Check next byte\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#read(byte[], int, int)\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_read$BII() throws IOException {\n        final byte[] buf1 = new byte[100];\n        is.skip(3000);\n        is.mark(1000);\n        is.read(buf1, 0, buf1.length);\n        assertTrue(new String(buf1, 0, buf1.length).equals(DATA.substring(3000, 3100)), \"Failed to read correct data\");\n\n        try (BufferedInputStream bufin = new BufferedInputStream(new InputStream() {\n            int size = 2, pos = 0;\n\n            byte[] contents = new byte[size];\n\n            @Override\n            public int available() {\n                return size - pos;\n            }\n\n            @Override\n            public int read() throws IOException {\n                if (pos >= size) {\n                    throw new IOException(\"Read past end of data\");\n                }\n                return contents[pos++];\n            }\n\n            @Override\n            public int read(final byte[] buf, final int off, final int len) throws IOException {\n                if (pos >= size) {\n                    throw new IOException(\"Read past end of data\");\n                }\n                int toRead = len;\n                if (toRead > available()) {\n                    toRead = available();\n                }\n                System.arraycopy(contents, pos, buf, off, toRead);\n                pos += toRead;\n                return toRead;\n            }\n        })) {\n            bufin.read();\n            final int result = bufin.read(new byte[2], 0, 2);\n            assertEquals(1, result, () -> \"Incorrect result: \" + result);\n        }\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#read(byte[], int, int)\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_read$BII_Exception() throws IOException {\n        final BufferedInputStream bis = new BufferedInputStream(null);\n        assertThrows(NullPointerException.class, () -> bis.read(null, -1, -1));\n\n        assertThrows(IndexOutOfBoundsException.class, () -> bis.read(new byte[0], -1, -1));\n        assertThrows(IndexOutOfBoundsException.class, () -> bis.read(new byte[0], 1, -1));\n        assertThrows(IndexOutOfBoundsException.class, () -> bis.read(new byte[0], 1, 1));\n\n        bis.close();\n\n        assertThrows(IOException.class, () -> bis.read(null, -1, -1));\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#reset()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset() throws IOException {\n        final byte[] buf1 = new byte[10];\n        final byte[] buf2 = new byte[10];\n        is.mark(2000);\n        is.read(buf1, 0, 10);\n        is.reset();\n        is.read(buf2, 0, 10);\n        is.reset();\n        assertTrue(new String(buf1, 0, buf1.length).equals(new String(buf2, 0, buf2.length)), \"Reset failed\");\n\n        final BufferedInputStream bIn = new BufferedInputStream(new ByteArrayInputStream(\"1234567890\".getBytes()));\n        bIn.mark(10);\n        for (int i = 0; i < 11; i++) {\n            bIn.read();\n        }\n        bIn.reset();\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#reset()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset_Exception() throws IOException {\n        final BufferedInputStream bis = new BufferedInputStream(null);\n\n        // throws IOException with message \"Mark has been invalidated\"\n        assertThrows(IOException.class, () -> bis.reset());\n\n        // does not throw IOException\n        bis.mark(1);\n        bis.reset();\n\n        bis.close();\n\n        // throws IOException with message \"stream is closed\"\n        assertThrows(IOException.class, () -> bis.reset());\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#reset()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset_scenario1() throws IOException {\n        final byte[] input = \"12345678900\".getBytes();\n        final BufferedInputStream bufin = new BufferedInputStream(new ByteArrayInputStream(input));\n        bufin.read();\n        bufin.mark(5);\n        bufin.skip(5);\n        bufin.reset();\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#reset()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset_scenario2() throws IOException {\n        final byte[] input = \"12345678900\".getBytes();\n        final BufferedInputStream bufin = new BufferedInputStream(new ByteArrayInputStream(input));\n        bufin.mark(5);\n        bufin.skip(6);\n        bufin.reset();\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#skip(long)\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_skip_NullInputStream() throws IOException {\n        try (BufferedInputStream buf = new BufferedInputStream(null, 5)) {\n            assertEquals(0, buf.skip(0));\n        }\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#skip(long)\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_skipJ() throws IOException {\n        final byte[] buf1 = new byte[10];\n        is.mark(2000);\n        is.skip(1000);\n        is.read(buf1, 0, buf1.length);\n        is.reset();\n        assertTrue(new String(buf1, 0, buf1.length).equals(DATA.substring(1000, 1010)), \"Failed to skip to correct position\");\n\n        // regression for HARMONY-667\n        try (BufferedInputStream buf = new BufferedInputStream(null, 5)) {\n            assertThrows(IOException.class, () -> buf.skip(10));\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java", "sourceCodeAfterForWhole": "/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.input.UnsynchronizedBufferedInputStream.Builder;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link UnsynchronizedBufferedInputStream}.\n * <p>\n * Provenance: Apache Harmony and modified.\n * </p>\n */\npublic class UnsynchronizedBufferedInputStreamTest {\n\n    private static final int BUFFER_SIZE = 4096;\n\n    public static final String DATA = StringUtils.repeat(\"This is a test.\", 500);\n\n    Path fileName;\n\n    private UnsynchronizedBufferedInputStream is;\n\n    private InputStream isFile;\n\n    byte[] ibuf = new byte[BUFFER_SIZE];\n\n    /**\n     * Sets up the fixture, for example, open a network connection. This method is called before a test is executed.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException {\n        fileName = Files.createTempFile(getClass().getSimpleName(), \".tst\");\n        Files.write(fileName, DATA.getBytes(StandardCharsets.UTF_8));\n\n        isFile = Files.newInputStream(fileName);\n        is = builder().setInputStream(isFile).get();\n    }\n\n    private Builder builder() {\n        return new UnsynchronizedBufferedInputStream.Builder();\n    }\n\n    /**\n     * Tears down the fixture, for example, close a network connection. This method is called after a test is executed.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @AfterEach\n    protected void tearDown() throws IOException {\n        IOUtils.closeQuietly(is);\n        Files.deleteIfExists(fileName);\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#available()}.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_available() throws IOException {\n        assertEquals(DATA.length(), is.available(), \"Returned incorrect number of available bytes\");\n\n        // Test that a closed stream throws an IOE for available()\n        final UnsynchronizedBufferedInputStream bis = builder()\n                .setInputStream(new ByteArrayInputStream(new byte[] { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' })).get();\n        final int available = bis.available();\n        bis.close();\n        assertTrue(available != 0);\n\n        assertThrows(IOException.class, () -> bis.available(), \"Expected test to throw IOE.\");\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#close()}.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_close() throws IOException {\n        builder().setInputStream(isFile).get().close();\n\n        try (InputStream in = new InputStream() {\n            Object lock = new Object();\n\n            @Override\n            public void close() {\n                synchronized (lock) {\n                    lock.notifyAll();\n                }\n            }\n\n            @Override\n            public int read() {\n                return 1;\n            }\n\n            @Override\n            public int read(final byte[] buf, final int offset, final int length) {\n                synchronized (lock) {\n                    try {\n                        lock.wait(3000);\n                    } catch (final InterruptedException e) {\n                        // Ignore\n                    }\n                }\n                return 1;\n            }\n        }) {\n            final UnsynchronizedBufferedInputStream bufin = builder().setInputStream(in).get();\n            final Thread thread = new Thread(() -> {\n                try {\n                    Thread.sleep(1000);\n                    bufin.close();\n                } catch (final Exception e) {\n                    // Ignored\n                }\n            });\n            thread.start();\n            assertThrows(IOException.class, () -> bufin.read(new byte[100], 0, 99), \"Should throw IOException\");\n        }\n    }\n\n    /*\n     * Tests {@link UnsynchronizedBufferedInputStream#Builder()}.\n     */\n    @Test\n    public void test_ConstructorLjava_io_InputStream() {\n        assertThrows(NullPointerException.class, () -> builder().setInputStream(null).get());\n    }\n\n    /*\n     * Tests {@link UnsynchronizedBufferedInputStream#Builder()}.\n     */\n    @Test\n    public void test_ConstructorLjava_io_InputStreamI() throws IOException {\n        assertThrows(NullPointerException.class, () -> builder().setInputStream(null).setBufferSize(1).get());\n\n        // Test for method UnsynchronizedBufferedInputStream(InputStream, int)\n\n        // Create buffer with exact size of file\n        is = builder().setInputStream(isFile).setBufferSize(DATA.length()).get();\n        // Ensure buffer gets filled by evaluating one read\n        is.read();\n        // Close underlying FileInputStream, all but 1 buffered bytes should\n        // still be available.\n        isFile.close();\n        // Read the remaining buffered characters, no IOException should\n        // occur.\n        is.skip(DATA.length() - 2);\n        is.read();\n        // is.read should now throw an exception because it will have to be filled.\n        assertThrows(IOException.class, () -> is.read());\n\n        assertThrows(NullPointerException.class, () -> builder().setInputStream(null).setBufferSize(100).get());\n        assertThrows(NullPointerException.class, () -> builder().setInputStream(null));\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#mark(int)}.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_markI() throws IOException {\n        final byte[] buf1 = new byte[100];\n        final byte[] buf2 = new byte[100];\n        is.skip(3000);\n        is.mark(1000);\n        is.read(buf1, 0, buf1.length);\n        is.reset();\n        is.read(buf2, 0, buf2.length);\n        is.reset();\n        assertTrue(new String(buf1, 0, buf1.length).equals(new String(buf2, 0, buf2.length)), \"Failed to mark correct position\");\n\n        byte[] bytes = new byte[256];\n        for (int i = 0; i < 256; i++) {\n            bytes[i] = (byte) i;\n        }\n        InputStream in = builder().setInputStream(new ByteArrayInputStream(bytes)).setBufferSize(12).get();\n        in.skip(6);\n        in.mark(14);\n        in.read(new byte[14], 0, 14);\n        in.reset();\n        assertTrue(in.read() == 6 && in.read() == 7, \"Wrong bytes\");\n\n        in = builder().setInputStream(new ByteArrayInputStream(bytes)).setBufferSize(12).get();\n        in.skip(6);\n        in.mark(8);\n        in.skip(7);\n        in.reset();\n        assertTrue(in.read() == 6 && in.read() == 7, \"Wrong bytes 2\");\n\n        UnsynchronizedBufferedInputStream buf = builder().setInputStream(new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4 })).setBufferSize(2).get();\n        buf.mark(3);\n        bytes = new byte[3];\n        int result = buf.read(bytes);\n        assertEquals(3, result);\n        assertEquals(0, bytes[0], \"Assert 0:\");\n        assertEquals(1, bytes[1], \"Assert 1:\");\n        assertEquals(2, bytes[2], \"Assert 2:\");\n        assertEquals(3, buf.read(), \"Assert 3:\");\n\n        buf = builder().setInputStream(new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4 })).setBufferSize(2).get();\n        buf.mark(3);\n        bytes = new byte[4];\n        result = buf.read(bytes);\n        assertEquals(4, result);\n        assertEquals(0, bytes[0], \"Assert 4:\");\n        assertEquals(1, bytes[1], \"Assert 5:\");\n        assertEquals(2, bytes[2], \"Assert 6:\");\n        assertEquals(3, bytes[3], \"Assert 7:\");\n        assertEquals(4, buf.read(), \"Assert 8:\");\n        assertEquals(-1, buf.read(), \"Assert 9:\");\n\n        buf = builder().setInputStream(new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4 })).setBufferSize(2).get();\n        buf.mark(Integer.MAX_VALUE);\n        buf.read();\n        buf.close();\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#markSupported()}.\n     */\n    @Test\n    public void test_markSupported() {\n        assertTrue(is.markSupported(), \"markSupported returned incorrect value\");\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#read()}.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_read() throws IOException {\n        final InputStreamReader isr = new InputStreamReader(is);\n        final int c = isr.read();\n        assertEquals(DATA.charAt(0), c, \"read returned incorrect char\");\n\n        final byte[] bytes = new byte[256];\n        for (int i = 0; i < 256; i++) {\n            bytes[i] = (byte) i;\n        }\n        final InputStream in = builder().setInputStream(new ByteArrayInputStream(bytes)).setBufferSize(12).get();\n        assertEquals(0, in.read(), \"Wrong initial byte\"); // Fill the buffer\n        final byte[] buf = new byte[14];\n        in.read(buf, 0, 14); // Read greater than the buffer\n        assertTrue(new String(buf, 0, 14).equals(new String(bytes, 1, 14)), \"Wrong block read data\");\n        assertEquals(15, in.read(), \"Wrong bytes\"); // Check next byte\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#read(byte[], int, int)}.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_read$BII() throws IOException {\n        final byte[] buf1 = new byte[100];\n        is.skip(3000);\n        is.mark(1000);\n        is.read(buf1, 0, buf1.length);\n        assertTrue(new String(buf1, 0, buf1.length).equals(DATA.substring(3000, 3100)), \"Failed to read correct data\");\n\n        try (UnsynchronizedBufferedInputStream bufin = builder().setInputStream(new InputStream() {\n            int size = 2, pos = 0;\n\n            byte[] contents = new byte[size];\n\n            @Override\n            public int available() {\n                return size - pos;\n            }\n\n            @Override\n            public int read() throws IOException {\n                if (pos >= size) {\n                    throw new IOException(\"Read past end of data\");\n                }\n                return contents[pos++];\n            }\n\n            @Override\n            public int read(final byte[] buf, final int off, final int len) throws IOException {\n                if (pos >= size) {\n                    throw new IOException(\"Read past end of data\");\n                }\n                int toRead = len;\n                if (toRead > available()) {\n                    toRead = available();\n                }\n                System.arraycopy(contents, pos, buf, off, toRead);\n                pos += toRead;\n                return toRead;\n            }\n        }).get()) {\n            bufin.read();\n            final int result = bufin.read(new byte[2], 0, 2);\n            assertEquals(1, result, () -> \"Incorrect result: \" + result);\n        }\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#reset()}.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset() throws IOException {\n        final byte[] buf1 = new byte[10];\n        final byte[] buf2 = new byte[10];\n        is.mark(2000);\n        is.read(buf1, 0, 10);\n        is.reset();\n        is.read(buf2, 0, 10);\n        is.reset();\n        assertTrue(new String(buf1, 0, buf1.length).equals(new String(buf2, 0, buf2.length)), \"Reset failed\");\n\n        final UnsynchronizedBufferedInputStream bIn = builder().setInputStream(new ByteArrayInputStream(\"1234567890\".getBytes())).get();\n        bIn.mark(10);\n        for (int i = 0; i < 11; i++) {\n            bIn.read();\n        }\n        bIn.reset();\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#reset()}.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset_scenario1() throws IOException {\n        final byte[] input = \"12345678900\".getBytes();\n        final UnsynchronizedBufferedInputStream bufin = builder().setInputStream(new ByteArrayInputStream(input)).get();\n        bufin.read();\n        bufin.mark(5);\n        bufin.skip(5);\n        bufin.reset();\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#reset()}.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset_scenario2() throws IOException {\n        final byte[] input = \"12345678900\".getBytes();\n        final UnsynchronizedBufferedInputStream bufin = builder().setInputStream(new ByteArrayInputStream(input)).get();\n        bufin.mark(5);\n        bufin.skip(6);\n        bufin.reset();\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#skip(long)}.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_skip_NullInputStream() throws IOException {\n        assertThrows(NullPointerException.class, () -> builder().setInputStream(null).setBufferSize(5).get());\n    }\n\n    /**\n     * Tests {@link UnsynchronizedBufferedInputStream#skip(long)}.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_skipJ() throws IOException {\n        final byte[] buf1 = new byte[10];\n        is.mark(2000);\n        is.skip(1000);\n        is.read(buf1, 0, buf1.length);\n        is.reset();\n        assertTrue(new String(buf1, 0, buf1.length).equals(DATA.substring(1000, 1010)), \"Failed to skip to correct position\");\n    }\n}\n", "diffSourceCodeSet": ["private Builder builder() {\n        return new UnsynchronizedBufferedInputStream.Builder();\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.input.UnsynchronizedBufferedInputStream#read\n methodBody: public int read(final byte[] buffer, int offset, final int length) throws IOException {\nbyte[] localBuf=buffer;\nif(localBuf == null){throw new IOException(\"Stream is closed\");\n}if(offset > buffer.length - length || offset < 0 || length < 0){throw new IndexOutOfBoundsException();\n}if(length == 0){return 0;\n}final InputStream localIn=inputStream;\nif(localIn == null){throw new IOException(\"Stream is closed\");\n}int required;\nif(pos < count){final int copylength=count - pos >= length ? length : count - pos;\nSystem.arraycopy(localBuf,pos,buffer,offset,copylength);\npos+=copylength;\nif(copylength == length || localIn.available() == 0){return copylength;\n}offset+=copylength;\nrequired=length - copylength;\n}{required=length;\n}while(true){final int read;\nif(markPos == IOUtils.EOF && required >= localBuf.length){read=localIn.read(buffer,offset,required);\nif(read == IOUtils.EOF){return required == length ? IOUtils.EOF : length - required;\n}}{if(fillBuffer(localIn,localBuf) == IOUtils.EOF){return required == length ? IOUtils.EOF : length - required;\n}if(localBuf != buffer){localBuf=buffer;\nif(localBuf == null){throw new IOException(\"Stream is closed\");\n}}read=count - pos >= required ? required : count - pos;\nSystem.arraycopy(localBuf,pos,buffer,offset,read);\npos+=read;\n}required-=read;\nif(required == 0){return length;\n}if(localIn.available() == 0){return length - required;\n}offset+=read;\n}}", "methodSignature: org.apache.commons.io.input.UnsynchronizedBufferedInputStream.Builder#get\n methodBody: public UnsynchronizedBufferedInputStream get() throws IOException {\nreturn new UnsynchronizedBufferedInputStream(getInputStream(),getBufferSize());\n}", "methodSignature: org.apache.commons.io.input.UnsynchronizedBufferedInputStream#close\n methodBody: public void close() throws IOException {\nbuffer=null;\nfinal InputStream localIn=inputStream;\ninputStream=null;\nif(localIn != null){localIn.close();\n}}", "methodSignature: org.apache.commons.io.input.UnsynchronizedBufferedInputStream#skip\n methodBody: public long skip(final long amount) throws IOException {\nfinal byte[] localBuf=buffer;\nfinal InputStream localIn=inputStream;\nif(localBuf == null){throw new IOException(\"Stream is closed\");\n}if(amount < 1){return 0;\n}if(localIn == null){throw new IOException(\"Stream is closed\");\n}if(count - pos >= amount){pos+=(int)amount;\nreturn amount;\n}int read=count - pos;\npos=count;\nif(markPos != IOUtils.EOF && amount <= markLimit){if(fillBuffer(localIn,localBuf) == IOUtils.EOF){return read;\n}if(count - pos >= amount - read){pos+=((int)amount) - read;\nreturn amount;\n}read+=count - pos;\npos=count;\nreturn read;\n}return read + localIn.skip(amount - read);\n}"], "sourceCodeAfterRefactoring": "@Test\n    public void test_ConstructorLjava_io_InputStreamI() throws IOException {\n        assertThrows(NullPointerException.class, () -> builder().setInputStream(null).setBufferSize(1).get());\n\n        // Test for method UnsynchronizedBufferedInputStream(InputStream, int)\n\n        // Create buffer with exact size of file\n        is = builder().setInputStream(isFile).setBufferSize(DATA.length()).get();\n        // Ensure buffer gets filled by evaluating one read\n        is.read();\n        // Close underlying FileInputStream, all but 1 buffered bytes should\n        // still be available.\n        isFile.close();\n        // Read the remaining buffered characters, no IOException should\n        // occur.\n        is.skip(DATA.length() - 2);\n        is.read();\n        // is.read should now throw an exception because it will have to be filled.\n        assertThrows(IOException.class, () -> is.read());\n\n        assertThrows(NullPointerException.class, () -> builder().setInputStream(null).setBufferSize(100).get());\n        assertThrows(NullPointerException.class, () -> builder().setInputStream(null));\n    }\nprivate Builder builder() {\n        return new UnsynchronizedBufferedInputStream.Builder();\n    }", "diffSourceCode": "-   73:     /**\n-   74:      * Tears down the fixture, for example, close a network connection. This method is called after a test is executed.\n-   75:      *\n-  168:      * Tests java.io.BufferedInputStream(InputStream)\n-  169:      */\n-  170:     @Test\n-  171:     public void test_ConstructorLjava_io_InputStreamI() throws IOException {\n-  172:         try (BufferedInputStream str = new BufferedInputStream(null, 1)) {\n-  173:             assertThrows(IOException.class, () -> str.read(), \"Expected an IOException\");\n-  174:         }\n-  175: \n-  176:         // Test for method java.io.BufferedInputStream(java.io.InputStream, int)\n-  177: \n-  178:         // Create buffer with exact size of file\n-  179:         is = new BufferedInputStream(isFile, DATA.length());\n-  180:         // Ensure buffer gets filled by evaluating one read\n-  181:         is.read();\n-  182:         // Close underlying FileInputStream, all but 1 buffered bytes should\n-  183:         // still be available.\n-  184:         isFile.close();\n-  185:         // Read the remaining buffered characters, no IOException should\n-  186:         // occur.\n-  187:         is.skip(DATA.length() - 2);\n-  188:         is.read();\n-  189:         // is.read should now throw an exception because it will have to be filled.\n-  190:         assertThrows(IOException.class, () -> is.read());\n+   73:     private Builder builder() {\n+   74:         return new UnsynchronizedBufferedInputStream.Builder();\n+   75:     }\n+  168:     @Test\n+  169:     public void test_ConstructorLjava_io_InputStreamI() throws IOException {\n+  170:         assertThrows(NullPointerException.class, () -> builder().setInputStream(null).setBufferSize(1).get());\n+  171: \n+  172:         // Test for method UnsynchronizedBufferedInputStream(InputStream, int)\n+  173: \n+  174:         // Create buffer with exact size of file\n+  175:         is = builder().setInputStream(isFile).setBufferSize(DATA.length()).get();\n+  176:         // Ensure buffer gets filled by evaluating one read\n+  177:         is.read();\n+  178:         // Close underlying FileInputStream, all but 1 buffered bytes should\n+  179:         // still be available.\n+  180:         isFile.close();\n+  181:         // Read the remaining buffered characters, no IOException should\n+  182:         // occur.\n+  183:         is.skip(DATA.length() - 2);\n+  184:         is.read();\n+  185:         // is.read should now throw an exception because it will have to be filled.\n+  186:         assertThrows(IOException.class, () -> is.read());\n+  187: \n+  188:         assertThrows(NullPointerException.class, () -> builder().setInputStream(null).setBufferSize(100).get());\n+  189:         assertThrows(NullPointerException.class, () -> builder().setInputStream(null));\n+  190:     }\n   191: \n-  192:         assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null).setBufferSize(100).get());\n-  193:         assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null));\n-  194:     }\n+  192:     /**\n+  193:      * Tests {@link UnsynchronizedBufferedInputStream#mark(int)}.\n+  194:      *\n", "uniqueId": "269f9921cb022c04672e54f81ba4fb9e139ea277_170_194_73_75_168_190", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the provided test method `test_ConstructorLjava_io_InputStreamI`, we can extract several logical blocks of code into separate methods. This will help to clarify the purpose of each block and make the test easier to follow.\n\nHere\u2019s the refactored method code:\n\n```java\n##########################\n@Test\npublic void test_ConstructorLjava_io_InputStreamI() throws IOException {\n    assertIOExceptionOnNullInputStream();\n    testBufferedInputStreamWithExactBufferSize();\n    assertNullPointerExceptionOnBuilderWithNullInputStream();\n}\n\nprivate void assertIOExceptionOnNullInputStream() throws IOException {\n    try (BufferedInputStream str = new BufferedInputStream(null, 1)) {\n        assertThrows(IOException.class, () -> str.read(), \"Expected an IOException\");\n    }\n}\n\nprivate void testBufferedInputStreamWithExactBufferSize() throws IOException {\n    // Create buffer with exact size of file\n    is = new BufferedInputStream(isFile, DATA.length());\n    // Ensure buffer gets filled by evaluating one read\n    is.read();\n    // Close underlying FileInputStream, all but 1 buffered bytes should still be available.\n    isFile.close();\n    // Read the remaining buffered characters, no IOException should occur.\n    is.skip(DATA.length() - 2);\n    is.read();\n    // is.read should now throw an exception because it will have to be filled.\n    assertThrows(IOException.class, () -> is.read());\n}\n\nprivate void assertNullPointerExceptionOnBuilderWithNullInputStream() {\n    assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null).setBufferSize(100).get());\n    assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null));\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Method Extraction**: The original method was broken down into three smaller methods:\n   - `assertIOExceptionOnNullInputStream()`: Tests that an `IOException` is thrown when a null `InputStream` is provided.\n   - `testBufferedInputStreamWithExactBufferSize()`: Tests the behavior of `BufferedInputStream` when initialized with a buffer size equal to the data length.\n   - `assertNullPointerExceptionOnBuilderWithNullInputStream()`: Tests that a `NullPointerException` is thrown when trying to set a null `InputStream` in the builder.\n\n2. **Improved Readability**: Each extracted method has a clear purpose, making the main test method easier to read and understand.\n\n3. **Maintainability**: If any of the test cases need to be modified or extended in the future, changes can be made in isolation within the respective method without affecting the overall structure of the test.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void test_ConstructorLjava_io_InputStreamI() throws IOException {\n        try (BufferedInputStream str = new BufferedInputStream(null, 1)) {\n            assertThrows(IOException.class, () -> str.read(), \"Expected an IOException\");\n        }\n\n        // Test for method java.io.BufferedInputStream(java.io.InputStream, int)\n\n        // Create buffer with exact size of file\n        is = new BufferedInputStream(isFile, DATA.length());\n        // Ensure buffer gets filled by evaluating one read\n        is.read();\n        // Close underlying FileInputStream, all but 1 buffered bytes should\n        // still be available.\n        isFile.close();\n        // Read the remaining buffered characters, no IOException should\n        // occur.\n        is.skip(DATA.length() - 2);\n        is.read();\n        // is.read should now throw an exception because it will have to be filled.\n        assertThrows(IOException.class, () -> is.read());\n\n        assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null).setBufferSize(100).get());\n        assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null));\n    }\n\nClass content:\n/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\npackage org.apache.commons.io.input;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link UnsynchronizedBufferedInputStream}.\n * <p>\n * Provenance: Apache Harmony and modified.\n * </p>\n */\npublic class UnsynchronizedBufferedInputStreamTest {\n\n    private static final int BUFFER_SIZE = 4096;\n\n    public static final String DATA = StringUtils.repeat(\"This is a test.\", 500);\n\n    Path fileName;\n\n    private BufferedInputStream is;\n\n    private InputStream isFile;\n\n    byte[] ibuf = new byte[BUFFER_SIZE];\n\n    /**\n     * Sets up the fixture, for example, open a network connection. This method is called before a test is executed.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException {\n        fileName = Files.createTempFile(getClass().getSimpleName(), \".tst\");\n        Files.write(fileName, DATA.getBytes(StandardCharsets.UTF_8));\n\n        isFile = Files.newInputStream(fileName);\n        is = new BufferedInputStream(isFile);\n    }\n\n    /**\n     * Tears down the fixture, for example, close a network connection. This method is called after a test is executed.\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @AfterEach\n    protected void tearDown() throws IOException {\n        IOUtils.closeQuietly(is);\n        Files.deleteIfExists(fileName);\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#available()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_available() throws IOException {\n        assertEquals(DATA.length(), is.available(), \"Returned incorrect number of available bytes\");\n\n        // Test that a closed stream throws an IOE for available()\n        final BufferedInputStream bis = new BufferedInputStream(new ByteArrayInputStream(new byte[] { 'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd' }));\n        final int available = bis.available();\n        bis.close();\n        assertTrue(available != 0);\n\n        assertThrows(IOException.class, () -> bis.available(), \"Expected test to throw IOE.\");\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#close()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_close() throws IOException {\n        new BufferedInputStream(isFile).close();\n\n        // regression for HARMONY-667\n        try (BufferedInputStream buf = new BufferedInputStream(null, 5)) {\n            // closes\n        }\n\n        try (InputStream in = new InputStream() {\n            Object lock = new Object();\n\n            @Override\n            public void close() {\n                synchronized (lock) {\n                    lock.notifyAll();\n                }\n            }\n\n            @Override\n            public int read() {\n                return 1;\n            }\n\n            @Override\n            public int read(final byte[] buf, final int offset, final int length) {\n                synchronized (lock) {\n                    try {\n                        lock.wait(3000);\n                    } catch (final InterruptedException e) {\n                        // Ignore\n                    }\n                }\n                return 1;\n            }\n        }) {\n            final BufferedInputStream bufin = new BufferedInputStream(in);\n            final Thread thread = new Thread(() -> {\n                try {\n                    Thread.sleep(1000);\n                    bufin.close();\n                } catch (final Exception e) {\n                    // Ignored\n                }\n            });\n            thread.start();\n            assertThrows(IOException.class, () -> bufin.read(new byte[100], 0, 99), \"Should throw IOException\");\n        }\n    }\n\n    /*\n     * Tests java.io.BufferedInputStream(InputStream)\n     */\n    @Test\n    public void test_ConstructorLjava_io_InputStream() throws IOException {\n        try (BufferedInputStream str = new BufferedInputStream(null)) {\n            assertThrows(IOException.class, () -> str.read(), \"Expected an IOException\");\n        }\n    }\n\n    /*\n     * Tests java.io.BufferedInputStream(InputStream)\n     */\n    @Test\n    public void test_ConstructorLjava_io_InputStreamI() throws IOException {\n        try (BufferedInputStream str = new BufferedInputStream(null, 1)) {\n            assertThrows(IOException.class, () -> str.read(), \"Expected an IOException\");\n        }\n\n        // Test for method java.io.BufferedInputStream(java.io.InputStream, int)\n\n        // Create buffer with exact size of file\n        is = new BufferedInputStream(isFile, DATA.length());\n        // Ensure buffer gets filled by evaluating one read\n        is.read();\n        // Close underlying FileInputStream, all but 1 buffered bytes should\n        // still be available.\n        isFile.close();\n        // Read the remaining buffered characters, no IOException should\n        // occur.\n        is.skip(DATA.length() - 2);\n        is.read();\n        // is.read should now throw an exception because it will have to be filled.\n        assertThrows(IOException.class, () -> is.read());\n\n        assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null).setBufferSize(100).get());\n        assertThrows(NullPointerException.class, () -> new UnsynchronizedBufferedInputStream.Builder().setInputStream(null));\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#mark(int)\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_markI() throws IOException {\n        final byte[] buf1 = new byte[100];\n        final byte[] buf2 = new byte[100];\n        is.skip(3000);\n        is.mark(1000);\n        is.read(buf1, 0, buf1.length);\n        is.reset();\n        is.read(buf2, 0, buf2.length);\n        is.reset();\n        assertTrue(new String(buf1, 0, buf1.length).equals(new String(buf2, 0, buf2.length)), \"Failed to mark correct position\");\n\n        byte[] bytes = new byte[256];\n        for (int i = 0; i < 256; i++) {\n            bytes[i] = (byte) i;\n        }\n        InputStream in = new BufferedInputStream(new ByteArrayInputStream(bytes), 12);\n        in.skip(6);\n        in.mark(14);\n        in.read(new byte[14], 0, 14);\n        in.reset();\n        assertTrue(in.read() == 6 && in.read() == 7, \"Wrong bytes\");\n\n        in = new BufferedInputStream(new ByteArrayInputStream(bytes), 12);\n        in.skip(6);\n        in.mark(8);\n        in.skip(7);\n        in.reset();\n        assertTrue(in.read() == 6 && in.read() == 7, \"Wrong bytes 2\");\n\n        BufferedInputStream buf = new BufferedInputStream(new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4 }), 2);\n        buf.mark(3);\n        bytes = new byte[3];\n        int result = buf.read(bytes);\n        assertEquals(3, result);\n        assertEquals(0, bytes[0], \"Assert 0:\");\n        assertEquals(1, bytes[1], \"Assert 1:\");\n        assertEquals(2, bytes[2], \"Assert 2:\");\n        assertEquals(3, buf.read(), \"Assert 3:\");\n\n        buf = new BufferedInputStream(new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4 }), 2);\n        buf.mark(3);\n        bytes = new byte[4];\n        result = buf.read(bytes);\n        assertEquals(4, result);\n        assertEquals(0, bytes[0], \"Assert 4:\");\n        assertEquals(1, bytes[1], \"Assert 5:\");\n        assertEquals(2, bytes[2], \"Assert 6:\");\n        assertEquals(3, bytes[3], \"Assert 7:\");\n        assertEquals(4, buf.read(), \"Assert 8:\");\n        assertEquals(-1, buf.read(), \"Assert 9:\");\n\n        buf = new BufferedInputStream(new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4 }), 2);\n        buf.mark(Integer.MAX_VALUE);\n        buf.read();\n        buf.close();\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#markSupported()\n     */\n    @Test\n    public void test_markSupported() {\n        assertTrue(is.markSupported(), \"markSupported returned incorrect value\");\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#read()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_read() throws IOException {\n        final InputStreamReader isr = new InputStreamReader(is);\n        final int c = isr.read();\n        assertEquals(DATA.charAt(0), c, \"read returned incorrect char\");\n\n        final byte[] bytes = new byte[256];\n        for (int i = 0; i < 256; i++) {\n            bytes[i] = (byte) i;\n        }\n        final InputStream in = new BufferedInputStream(new ByteArrayInputStream(bytes), 12);\n        assertEquals(0, in.read(), \"Wrong initial byte\"); // Fill the buffer\n        final byte[] buf = new byte[14];\n        in.read(buf, 0, 14); // Read greater than the buffer\n        assertTrue(new String(buf, 0, 14).equals(new String(bytes, 1, 14)), \"Wrong block read data\");\n        assertEquals(15, in.read(), \"Wrong bytes\"); // Check next byte\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#read(byte[], int, int)\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_read$BII() throws IOException {\n        final byte[] buf1 = new byte[100];\n        is.skip(3000);\n        is.mark(1000);\n        is.read(buf1, 0, buf1.length);\n        assertTrue(new String(buf1, 0, buf1.length).equals(DATA.substring(3000, 3100)), \"Failed to read correct data\");\n\n        try (BufferedInputStream bufin = new BufferedInputStream(new InputStream() {\n            int size = 2, pos = 0;\n\n            byte[] contents = new byte[size];\n\n            @Override\n            public int available() {\n                return size - pos;\n            }\n\n            @Override\n            public int read() throws IOException {\n                if (pos >= size) {\n                    throw new IOException(\"Read past end of data\");\n                }\n                return contents[pos++];\n            }\n\n            @Override\n            public int read(final byte[] buf, final int off, final int len) throws IOException {\n                if (pos >= size) {\n                    throw new IOException(\"Read past end of data\");\n                }\n                int toRead = len;\n                if (toRead > available()) {\n                    toRead = available();\n                }\n                System.arraycopy(contents, pos, buf, off, toRead);\n                pos += toRead;\n                return toRead;\n            }\n        })) {\n            bufin.read();\n            final int result = bufin.read(new byte[2], 0, 2);\n            assertEquals(1, result, () -> \"Incorrect result: \" + result);\n        }\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#read(byte[], int, int)\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_read$BII_Exception() throws IOException {\n        final BufferedInputStream bis = new BufferedInputStream(null);\n        assertThrows(NullPointerException.class, () -> bis.read(null, -1, -1));\n\n        assertThrows(IndexOutOfBoundsException.class, () -> bis.read(new byte[0], -1, -1));\n        assertThrows(IndexOutOfBoundsException.class, () -> bis.read(new byte[0], 1, -1));\n        assertThrows(IndexOutOfBoundsException.class, () -> bis.read(new byte[0], 1, 1));\n\n        bis.close();\n\n        assertThrows(IOException.class, () -> bis.read(null, -1, -1));\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#reset()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset() throws IOException {\n        final byte[] buf1 = new byte[10];\n        final byte[] buf2 = new byte[10];\n        is.mark(2000);\n        is.read(buf1, 0, 10);\n        is.reset();\n        is.read(buf2, 0, 10);\n        is.reset();\n        assertTrue(new String(buf1, 0, buf1.length).equals(new String(buf2, 0, buf2.length)), \"Reset failed\");\n\n        final BufferedInputStream bIn = new BufferedInputStream(new ByteArrayInputStream(\"1234567890\".getBytes()));\n        bIn.mark(10);\n        for (int i = 0; i < 11; i++) {\n            bIn.read();\n        }\n        bIn.reset();\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#reset()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset_Exception() throws IOException {\n        final BufferedInputStream bis = new BufferedInputStream(null);\n\n        // throws IOException with message \"Mark has been invalidated\"\n        assertThrows(IOException.class, () -> bis.reset());\n\n        // does not throw IOException\n        bis.mark(1);\n        bis.reset();\n\n        bis.close();\n\n        // throws IOException with message \"stream is closed\"\n        assertThrows(IOException.class, () -> bis.reset());\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#reset()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset_scenario1() throws IOException {\n        final byte[] input = \"12345678900\".getBytes();\n        final BufferedInputStream bufin = new BufferedInputStream(new ByteArrayInputStream(input));\n        bufin.read();\n        bufin.mark(5);\n        bufin.skip(5);\n        bufin.reset();\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#reset()\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_reset_scenario2() throws IOException {\n        final byte[] input = \"12345678900\".getBytes();\n        final BufferedInputStream bufin = new BufferedInputStream(new ByteArrayInputStream(input));\n        bufin.mark(5);\n        bufin.skip(6);\n        bufin.reset();\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#skip(long)\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_skip_NullInputStream() throws IOException {\n        try (BufferedInputStream buf = new BufferedInputStream(null, 5)) {\n            assertEquals(0, buf.skip(0));\n        }\n    }\n\n    /**\n     * Tests java.io.BufferedInputStream#skip(long)\n     *\n     * @throws IOException Thrown on test failure.\n     */\n    @Test\n    public void test_skipJ() throws IOException {\n        final byte[] buf1 = new byte[10];\n        is.mark(2000);\n        is.skip(1000);\n        is.read(buf1, 0, buf1.length);\n        is.reset();\n        assertTrue(new String(buf1, 0, buf1.length).equals(DATA.substring(1000, 1010)), \"Failed to skip to correct position\");\n\n        // regression for HARMONY-667\n        try (BufferedInputStream buf = new BufferedInputStream(null, 5)) {\n            assertThrows(IOException.class, () -> buf.skip(10));\n        }\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprotected getOutputStream() : OutputStream extracted from protected getStream() : OutputStream in class org.apache.commons.io.output.ThresholdingOutputStream", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java", "startLine": 144, "endLine": 154, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java", "startLine": 146, "endLine": 157, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java", "startLine": 159, "endLine": 169, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Returns the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n     * ultimately delegate.\n     *\n     * @return The underlying output stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    protected OutputStream getStream() throws IOException {\n        return outputStreamGetter.apply(this);\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java", "isPureRefactoring": true, "commitId": "5035e97fa05344aa3193fb2d916939e4988d38eb", "packageNameBefore": "org.apache.commons.io.output", "classNameBefore": "org.apache.commons.io.output.ThresholdingOutputStream", "methodNameBefore": "org.apache.commons.io.output.ThresholdingOutputStream#getStream", "classSignatureBefore": "public class ThresholdingOutputStream extends OutputStream ", "methodNameBeforeSet": ["org.apache.commons.io.output.ThresholdingOutputStream#getStream"], "classNameBeforeSet": ["org.apache.commons.io.output.ThresholdingOutputStream"], "classSignatureBeforeSet": ["public class ThresholdingOutputStream extends OutputStream "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\n\n/**\n * An output stream which triggers an event when a specified number of bytes of data have been written to it. The event\n * can be used, for example, to throw an exception if a maximum has been reached, or to switch the underlying stream\n * type when the threshold is exceeded.\n * <p>\n * This class overrides all {@link OutputStream} methods. However, these overrides ultimately call the corresponding\n * methods in the underlying output stream implementation.\n * </p>\n * <p>\n * NOTE: This implementation may trigger the event <em>before</em> the threshold is actually reached, since it triggers\n * when a pending write operation would cause the threshold to be exceeded.\n * </p>\n */\npublic class ThresholdingOutputStream extends OutputStream {\n\n    /**\n     * Noop output stream getter function.\n     */\n    private static final IOFunction<ThresholdingOutputStream, OutputStream> NOOP_OS_GETTER = os -> NullOutputStream.INSTANCE;\n\n    /**\n     * The threshold at which the event will be triggered.\n     */\n    private final int threshold;\n\n    /**\n     * Accepts reaching the threshold.\n     */\n    private final IOConsumer<ThresholdingOutputStream> thresholdConsumer;\n\n    /**\n     * Gets the output stream.\n     */\n    private final IOFunction<ThresholdingOutputStream, OutputStream> outputStreamGetter;\n\n    /**\n     * The number of bytes written to the output stream.\n     */\n    private long written;\n\n    /**\n     * Whether or not the configured threshold has been exceeded.\n     */\n    private boolean thresholdExceeded;\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the specified threshold.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     */\n    public ThresholdingOutputStream(final int threshold) {\n        this(threshold, IOConsumer.noop(), NOOP_OS_GETTER);\n    }\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the specified threshold.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param thresholdConsumer Accepts reaching the threshold.\n     * @param outputStreamGetter Gets the output stream.\n     * @since 2.9.0\n     */\n    public ThresholdingOutputStream(final int threshold, final IOConsumer<ThresholdingOutputStream> thresholdConsumer,\n        final IOFunction<ThresholdingOutputStream, OutputStream> outputStreamGetter) {\n        this.threshold = threshold;\n        this.thresholdConsumer = thresholdConsumer == null ? IOConsumer.noop() : thresholdConsumer;\n        this.outputStreamGetter = outputStreamGetter == null ? NOOP_OS_GETTER : outputStreamGetter;\n    }\n\n    /**\n     * Checks to see if writing the specified number of bytes would cause the configured threshold to be exceeded. If\n     * so, triggers an event to allow a concrete implementation to take action on this.\n     *\n     * @param count The number of bytes about to be written to the underlying output stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    protected void checkThreshold(final int count) throws IOException {\n        if (!thresholdExceeded && written + count > threshold) {\n            thresholdExceeded = true;\n            thresholdReached();\n        }\n    }\n\n    /**\n     * Closes this output stream and releases any system resources associated with this stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @Override\n    public void close() throws IOException {\n        try {\n            flush();\n        } catch (final IOException ignored) {\n            // ignore\n        }\n        getStream().close();\n    }\n\n    /**\n     * Flushes this output stream and forces any buffered output bytes to be written out.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void flush() throws IOException {\n        getStream().flush();\n    }\n\n    /**\n     * Returns the number of bytes that have been written to this output stream.\n     *\n     * @return The number of bytes written.\n     */\n    public long getByteCount() {\n        return written;\n    }\n\n    /**\n     * Returns the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n     * ultimately delegate.\n     *\n     * @return The underlying output stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    protected OutputStream getStream() throws IOException {\n        return outputStreamGetter.apply(this);\n    }\n\n    /**\n     * Returns the threshold, in bytes, at which an event will be triggered.\n     *\n     * @return The threshold point, in bytes.\n     */\n    public int getThreshold() {\n        return threshold;\n    }\n\n    /**\n     * Determines whether or not the configured threshold has been exceeded for this output stream.\n     *\n     * @return {@code true} if the threshold has been reached; {@code false} otherwise.\n     */\n    public boolean isThresholdExceeded() {\n        return written > threshold;\n    }\n\n    /**\n     * Resets the byteCount to zero. You can call this from {@link #thresholdReached()} if you want the event to be\n     * triggered again.\n     */\n    protected void resetByteCount() {\n        this.thresholdExceeded = false;\n        this.written = 0;\n    }\n\n    /**\n     * Sets the byteCount to count. Useful for re-opening an output stream that has previously been written to.\n     *\n     * @param count The number of bytes that have already been written to the output stream\n     *\n     * @since 2.5\n     */\n    protected void setByteCount(final long count) {\n        this.written = count;\n    }\n\n    /**\n     * Indicates that the configured threshold has been reached, and that a subclass should take whatever action\n     * necessary on this event. This may include changing the underlying output stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    protected void thresholdReached() throws IOException {\n        thresholdConsumer.accept(this);\n    }\n\n    /**\n     * Writes {@code b.length} bytes from the specified byte array to this output stream.\n     *\n     * @param b The array of bytes to be written.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void write(final byte[] b) throws IOException {\n        checkThreshold(b.length);\n        getStream().write(b);\n        written += b.length;\n    }\n\n    /**\n     * Writes {@code len} bytes from the specified byte array starting at offset {@code off} to this output stream.\n     *\n     * @param b The byte array from which the data will be written.\n     * @param off The start offset in the byte array.\n     * @param len The number of bytes to write.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void write(final byte[] b, final int off, final int len) throws IOException {\n        checkThreshold(len);\n        getStream().write(b, off, len);\n        written += len;\n    }\n\n    /**\n     * Writes the specified byte to this output stream.\n     *\n     * @param b The byte to be written.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void write(final int b) throws IOException {\n        checkThreshold(1);\n        getStream().write(b);\n        written++;\n    }\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\n\n/**\n * An output stream which triggers an event when a specified number of bytes of data have been written to it. The event\n * can be used, for example, to throw an exception if a maximum has been reached, or to switch the underlying stream\n * type when the threshold is exceeded.\n * <p>\n * This class overrides all {@link OutputStream} methods. However, these overrides ultimately call the corresponding\n * methods in the underlying output stream implementation.\n * </p>\n * <p>\n * NOTE: This implementation may trigger the event <em>before</em> the threshold is actually reached, since it triggers\n * when a pending write operation would cause the threshold to be exceeded.\n * </p>\n */\npublic class ThresholdingOutputStream extends OutputStream {\n\n    /**\n     * Noop output stream getter function.\n     */\n    private static final IOFunction<ThresholdingOutputStream, OutputStream> NOOP_OS_GETTER = os -> NullOutputStream.INSTANCE;\n\n    /**\n     * The threshold at which the event will be triggered.\n     */\n    private final int threshold;\n\n    /**\n     * Accepts reaching the threshold.\n     */\n    private final IOConsumer<ThresholdingOutputStream> thresholdConsumer;\n\n    /**\n     * Gets the output stream.\n     */\n    private final IOFunction<ThresholdingOutputStream, OutputStream> outputStreamGetter;\n\n    /**\n     * The number of bytes written to the output stream.\n     */\n    private long written;\n\n    /**\n     * Whether or not the configured threshold has been exceeded.\n     */\n    private boolean thresholdExceeded;\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the specified threshold.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     */\n    public ThresholdingOutputStream(final int threshold) {\n        this(threshold, IOConsumer.noop(), NOOP_OS_GETTER);\n    }\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the specified threshold.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param thresholdConsumer Accepts reaching the threshold.\n     * @param outputStreamGetter Gets the output stream.\n     * @since 2.9.0\n     */\n    public ThresholdingOutputStream(final int threshold, final IOConsumer<ThresholdingOutputStream> thresholdConsumer,\n        final IOFunction<ThresholdingOutputStream, OutputStream> outputStreamGetter) {\n        this.threshold = threshold;\n        this.thresholdConsumer = thresholdConsumer == null ? IOConsumer.noop() : thresholdConsumer;\n        this.outputStreamGetter = outputStreamGetter == null ? NOOP_OS_GETTER : outputStreamGetter;\n    }\n\n    /**\n     * Checks to see if writing the specified number of bytes would cause the configured threshold to be exceeded. If\n     * so, triggers an event to allow a concrete implementation to take action on this.\n     *\n     * @param count The number of bytes about to be written to the underlying output stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    protected void checkThreshold(final int count) throws IOException {\n        if (!thresholdExceeded && written + count > threshold) {\n            thresholdExceeded = true;\n            thresholdReached();\n        }\n    }\n\n    /**\n     * Closes this output stream and releases any system resources associated with this stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @Override\n    public void close() throws IOException {\n        try {\n            flush();\n        } catch (final IOException ignored) {\n            // ignore\n        }\n        // TODO for 4.0: Replace with getOutputStream()\n        getStream().close();\n    }\n\n    /**\n     * Flushes this output stream and forces any buffered output bytes to be written out.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void flush() throws IOException {\n        // TODO for 4.0: Replace with getOutputStream()\n        getStream().flush();\n    }\n\n    /**\n     * Returns the number of bytes that have been written to this output stream.\n     *\n     * @return The number of bytes written.\n     */\n    public long getByteCount() {\n        return written;\n    }\n\n    /**\n     * Gets the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n     * ultimately delegate.\n     *\n     * @return The underlying output stream.\n     * @throws IOException if an error occurs.\n     * @deprecated Use {@link #getOutputStream()}.\n     */\n    @Deprecated\n    protected OutputStream getStream() throws IOException {\n        return getOutputStream();\n    }\n\n    /**\n     * Gets the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n     * ultimately delegate.\n     *\n     * @return The underlying output stream.\n     * @throws IOException if an error occurs.\n     * @since 2.14.0\n     */\n    protected OutputStream getOutputStream() throws IOException {\n        return outputStreamGetter.apply(this);\n    }\n\n    /**\n     * Returns the threshold, in bytes, at which an event will be triggered.\n     *\n     * @return The threshold point, in bytes.\n     */\n    public int getThreshold() {\n        return threshold;\n    }\n\n    /**\n     * Determines whether or not the configured threshold has been exceeded for this output stream.\n     *\n     * @return {@code true} if the threshold has been reached; {@code false} otherwise.\n     */\n    public boolean isThresholdExceeded() {\n        return written > threshold;\n    }\n\n    /**\n     * Resets the byteCount to zero. You can call this from {@link #thresholdReached()} if you want the event to be\n     * triggered again.\n     */\n    protected void resetByteCount() {\n        this.thresholdExceeded = false;\n        this.written = 0;\n    }\n\n    /**\n     * Sets the byteCount to count. Useful for re-opening an output stream that has previously been written to.\n     *\n     * @param count The number of bytes that have already been written to the output stream\n     *\n     * @since 2.5\n     */\n    protected void setByteCount(final long count) {\n        this.written = count;\n    }\n\n    /**\n     * Indicates that the configured threshold has been reached, and that a subclass should take whatever action\n     * necessary on this event. This may include changing the underlying output stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    protected void thresholdReached() throws IOException {\n        thresholdConsumer.accept(this);\n    }\n\n    /**\n     * Writes {@code b.length} bytes from the specified byte array to this output stream.\n     *\n     * @param b The array of bytes to be written.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void write(final byte[] b) throws IOException {\n        checkThreshold(b.length);\n        // TODO for 4.0: Replace with getOutputStream()\n        getStream().write(b);\n        written += b.length;\n    }\n\n    /**\n     * Writes {@code len} bytes from the specified byte array starting at offset {@code off} to this output stream.\n     *\n     * @param b The byte array from which the data will be written.\n     * @param off The start offset in the byte array.\n     * @param len The number of bytes to write.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void write(final byte[] b, final int off, final int len) throws IOException {\n        checkThreshold(len);\n        // TODO for 4.0: Replace with getOutputStream()\n        getStream().write(b, off, len);\n        written += len;\n    }\n\n    /**\n     * Writes the specified byte to this output stream.\n     *\n     * @param b The byte to be written.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void write(final int b) throws IOException {\n        checkThreshold(1);\n        // TODO for 4.0: Replace with getOutputStream()\n        getStream().write(b);\n        written++;\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Gets the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n     * ultimately delegate.\n     *\n     * @return The underlying output stream.\n     * @throws IOException if an error occurs.\n     * @since 2.14.0\n     */\n    protected OutputStream getOutputStream() throws IOException {\n        return outputStreamGetter.apply(this);\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Gets the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n     * ultimately delegate.\n     *\n     * @return The underlying output stream.\n     * @throws IOException if an error occurs.\n     * @deprecated Use {@link #getOutputStream()}.\n     */\n    @Deprecated\n    protected OutputStream getStream() throws IOException {\n        return getOutputStream();\n    }\n/**\n     * Gets the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n     * ultimately delegate.\n     *\n     * @return The underlying output stream.\n     * @throws IOException if an error occurs.\n     * @since 2.14.0\n     */\n    protected OutputStream getOutputStream() throws IOException {\n        return outputStreamGetter.apply(this);\n    }", "diffSourceCode": "-  144:     /**\n-  145:      * Returns the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n-  146:      * ultimately delegate.\n-  147:      *\n-  148:      * @return The underlying output stream.\n+  144:     }\n+  145: \n+  146:     /**\n+  147:      * Gets the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n+  148:      * ultimately delegate.\n   149:      *\n-  150:      * @throws IOException if an error occurs.\n-  151:      */\n-  152:     protected OutputStream getStream() throws IOException {\n-  153:         return outputStreamGetter.apply(this);\n-  154:     }\n-  155: \n-  156:     /**\n-  157:      * Returns the threshold, in bytes, at which an event will be triggered.\n-  159:      * @return The threshold point, in bytes.\n-  160:      */\n-  161:     public int getThreshold() {\n-  162:         return threshold;\n-  163:     }\n-  164: \n-  165:     /**\n-  166:      * Determines whether or not the configured threshold has been exceeded for this output stream.\n-  167:      *\n-  168:      * @return {@code true} if the threshold has been reached; {@code false} otherwise.\n-  169:      */\n+  150:      * @return The underlying output stream.\n+  151:      * @throws IOException if an error occurs.\n+  152:      * @deprecated Use {@link #getOutputStream()}.\n+  153:      */\n+  154:     @Deprecated\n+  155:     protected OutputStream getStream() throws IOException {\n+  156:         return getOutputStream();\n+  157:     }\n+  159:     /**\n+  160:      * Gets the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n+  161:      * ultimately delegate.\n+  162:      *\n+  163:      * @return The underlying output stream.\n+  164:      * @throws IOException if an error occurs.\n+  165:      * @since 2.14.0\n+  166:      */\n+  167:     protected OutputStream getOutputStream() throws IOException {\n+  168:         return outputStreamGetter.apply(this);\n+  169:     }\n", "uniqueId": "5035e97fa05344aa3193fb2d916939e4988d38eb_144_154_159_169_146_157", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 6}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": true, "refactoredCode": "To improve the readability and maintainability of the `getStream` method, we can extract the logic of applying the `outputStreamGetter` function into a separate method. This will make the `getStream` method cleaner and more focused on its primary responsibility, which is to return the underlying output stream.\n\nHere\u2019s the refactored code for the `getStream` method:\n\n```java\n##########################\nprotected OutputStream getStream() throws IOException {\n    return retrieveOutputStream();\n}\n\nprivate OutputStream retrieveOutputStream() throws IOException {\n    return outputStreamGetter.apply(this);\n}\n##########################\n```\n\nIn this refactoring:\n- The `getStream` method now simply calls `retrieveOutputStream`, which encapsulates the logic of applying the `outputStreamGetter` function.\n- This separation enhances clarity and allows for easier modifications in the future if the logic for retrieving the output stream needs to change.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Returns the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n     * ultimately delegate.\n     *\n     * @return The underlying output stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    protected OutputStream getStream() throws IOException {\n        return outputStreamGetter.apply(this);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.output;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\n\n/**\n * An output stream which triggers an event when a specified number of bytes of data have been written to it. The event\n * can be used, for example, to throw an exception if a maximum has been reached, or to switch the underlying stream\n * type when the threshold is exceeded.\n * <p>\n * This class overrides all {@link OutputStream} methods. However, these overrides ultimately call the corresponding\n * methods in the underlying output stream implementation.\n * </p>\n * <p>\n * NOTE: This implementation may trigger the event <em>before</em> the threshold is actually reached, since it triggers\n * when a pending write operation would cause the threshold to be exceeded.\n * </p>\n */\npublic class ThresholdingOutputStream extends OutputStream {\n\n    /**\n     * Noop output stream getter function.\n     */\n    private static final IOFunction<ThresholdingOutputStream, OutputStream> NOOP_OS_GETTER = os -> NullOutputStream.INSTANCE;\n\n    /**\n     * The threshold at which the event will be triggered.\n     */\n    private final int threshold;\n\n    /**\n     * Accepts reaching the threshold.\n     */\n    private final IOConsumer<ThresholdingOutputStream> thresholdConsumer;\n\n    /**\n     * Gets the output stream.\n     */\n    private final IOFunction<ThresholdingOutputStream, OutputStream> outputStreamGetter;\n\n    /**\n     * The number of bytes written to the output stream.\n     */\n    private long written;\n\n    /**\n     * Whether or not the configured threshold has been exceeded.\n     */\n    private boolean thresholdExceeded;\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the specified threshold.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     */\n    public ThresholdingOutputStream(final int threshold) {\n        this(threshold, IOConsumer.noop(), NOOP_OS_GETTER);\n    }\n\n    /**\n     * Constructs an instance of this class which will trigger an event at the specified threshold.\n     *\n     * @param threshold The number of bytes at which to trigger an event.\n     * @param thresholdConsumer Accepts reaching the threshold.\n     * @param outputStreamGetter Gets the output stream.\n     * @since 2.9.0\n     */\n    public ThresholdingOutputStream(final int threshold, final IOConsumer<ThresholdingOutputStream> thresholdConsumer,\n        final IOFunction<ThresholdingOutputStream, OutputStream> outputStreamGetter) {\n        this.threshold = threshold;\n        this.thresholdConsumer = thresholdConsumer == null ? IOConsumer.noop() : thresholdConsumer;\n        this.outputStreamGetter = outputStreamGetter == null ? NOOP_OS_GETTER : outputStreamGetter;\n    }\n\n    /**\n     * Checks to see if writing the specified number of bytes would cause the configured threshold to be exceeded. If\n     * so, triggers an event to allow a concrete implementation to take action on this.\n     *\n     * @param count The number of bytes about to be written to the underlying output stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    protected void checkThreshold(final int count) throws IOException {\n        if (!thresholdExceeded && written + count > threshold) {\n            thresholdExceeded = true;\n            thresholdReached();\n        }\n    }\n\n    /**\n     * Closes this output stream and releases any system resources associated with this stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @Override\n    public void close() throws IOException {\n        try {\n            flush();\n        } catch (final IOException ignored) {\n            // ignore\n        }\n        getStream().close();\n    }\n\n    /**\n     * Flushes this output stream and forces any buffered output bytes to be written out.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void flush() throws IOException {\n        getStream().flush();\n    }\n\n    /**\n     * Returns the number of bytes that have been written to this output stream.\n     *\n     * @return The number of bytes written.\n     */\n    public long getByteCount() {\n        return written;\n    }\n\n    /**\n     * Returns the underlying output stream, to which the corresponding {@link OutputStream} methods in this class will\n     * ultimately delegate.\n     *\n     * @return The underlying output stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    protected OutputStream getStream() throws IOException {\n        return outputStreamGetter.apply(this);\n    }\n\n    /**\n     * Returns the threshold, in bytes, at which an event will be triggered.\n     *\n     * @return The threshold point, in bytes.\n     */\n    public int getThreshold() {\n        return threshold;\n    }\n\n    /**\n     * Determines whether or not the configured threshold has been exceeded for this output stream.\n     *\n     * @return {@code true} if the threshold has been reached; {@code false} otherwise.\n     */\n    public boolean isThresholdExceeded() {\n        return written > threshold;\n    }\n\n    /**\n     * Resets the byteCount to zero. You can call this from {@link #thresholdReached()} if you want the event to be\n     * triggered again.\n     */\n    protected void resetByteCount() {\n        this.thresholdExceeded = false;\n        this.written = 0;\n    }\n\n    /**\n     * Sets the byteCount to count. Useful for re-opening an output stream that has previously been written to.\n     *\n     * @param count The number of bytes that have already been written to the output stream\n     *\n     * @since 2.5\n     */\n    protected void setByteCount(final long count) {\n        this.written = count;\n    }\n\n    /**\n     * Indicates that the configured threshold has been reached, and that a subclass should take whatever action\n     * necessary on this event. This may include changing the underlying output stream.\n     *\n     * @throws IOException if an error occurs.\n     */\n    protected void thresholdReached() throws IOException {\n        thresholdConsumer.accept(this);\n    }\n\n    /**\n     * Writes {@code b.length} bytes from the specified byte array to this output stream.\n     *\n     * @param b The array of bytes to be written.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void write(final byte[] b) throws IOException {\n        checkThreshold(b.length);\n        getStream().write(b);\n        written += b.length;\n    }\n\n    /**\n     * Writes {@code len} bytes from the specified byte array starting at offset {@code off} to this output stream.\n     *\n     * @param b The byte array from which the data will be written.\n     * @param off The start offset in the byte array.\n     * @param len The number of bytes to write.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void write(final byte[] b, final int off, final int len) throws IOException {\n        checkThreshold(len);\n        getStream().write(b, off, len);\n        written += len;\n    }\n\n    /**\n     * Writes the specified byte to this output stream.\n     *\n     * @param b The byte to be written.\n     *\n     * @throws IOException if an error occurs.\n     */\n    @SuppressWarnings(\"resource\") // the underlying stream is managed by a subclass.\n    @Override\n    public void write(final int b) throws IOException {\n        checkThreshold(1);\n        getStream().write(b);\n        written++;\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic testRunMessage() : void from class org.apache.commons.io.UncheckIOTest to public testRunMessage() : void from class org.apache.commons.io.function.UncheckTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "startLine": 134, "endLine": 153, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "startLine": 272, "endLine": 291, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "isPureRefactoring": true, "commitId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.UncheckIOTest", "methodNameBefore": "org.apache.commons.io.UncheckIOTest#testRunMessage", "invokedMethod": "methodSignature: org.apache.commons.io.UncheckIOTest#assertUncheckedIOException\n methodBody: private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\nassertEquals(CUSTOM_MESSAGE,e.getMessage());\nfinal IOException cause=e.getCause();\nassertEquals(expected.getClass(),cause.getClass());\nassertEquals(CAUSE_MESSAGE,cause.getMessage());\n}\nmethodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}", "classSignatureBefore": "public class UncheckIOTest ", "methodNameBeforeSet": ["org.apache.commons.io.UncheckIOTest#testRunMessage"], "classNameBeforeSet": ["org.apache.commons.io.UncheckIOTest"], "classSignatureBeforeSet": ["public class UncheckIOTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckTest {\n\n    private static final byte[] BYTES = { 'a', 'b' };\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n\n    private AtomicInteger atomicInt;\n    private AtomicReference<String> ref1;\n    private AtomicReference<String> ref2;\n    private AtomicReference<String> ref3;\n    private AtomicReference<String> ref4;\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    @BeforeEach\n    public void initEach() {\n        ref1 = new AtomicReference<>();\n        ref2 = new AtomicReference<>();\n        ref3 = new AtomicReference<>();\n        ref4 = new AtomicReference<>();\n        atomicInt = new AtomicInteger();\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    @Test\n    public void testAcceptIOBiConsumerOfTUTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_BI_CONSUMER, null, null));\n        Uncheck.accept((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n        }, \"new1\", \"new2\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testAcceptIOConsumerOfTT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestUtils.throwingIOConsumer(), null));\n        Uncheck.accept(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testAcceptIOTriConsumerOfTUVTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_TRI_CONSUMER, null, null, null));\n        Uncheck.accept((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n        }, \"new1\", \"new2\", \"new3\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    @Test\n    public void testApplyIOBiFunctionOfTURTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_BI_FUNCTION, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            return \"new0\";\n        }, \"new1\", \"new2\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testApplyIOFunctionOfTRT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_FUNCTION, null));\n        Uncheck.apply(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testApplyIOQuadFunctionOfTUVWRTUVW() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v, w) -> {\n            throw new IOException();\n        }, null, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_QUAD_FUNCTION, null, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v, w) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            TestUtils.compareAndSetThrowsIO(ref4, w);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\", \"new4\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n        assertEquals(\"new4\", ref4.get());\n    }\n\n    @Test\n    public void testApplyIOTriFunctionOfTUVRTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_TRI_FUNCTION, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(TestConstants.THROWING_IO_SUPPLIER));\n        assertEquals(\"new1\", Uncheck.get(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\")));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testGetAsInt() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(TestConstants.THROWING_IO_INT_SUPPLIER));\n        assertEquals(1, Uncheck.getAsInt(() -> TestUtils.compareAndSetThrowsIO(atomicInt, 1)));\n        assertEquals(1, atomicInt.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        //\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(TestConstants.THROWING_IO_RUNNABLE));\n        Uncheck.run(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    @Test\n    public void testTest() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(TestConstants.THROWING_IO_PREDICATE, null));\n        assertTrue(Uncheck.test(t -> TestUtils.compareAndSetThrowsIO(ref1, t).equals(t), \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: org.apache.commons.io.UncheckIOTest#assertUncheckedIOException\n methodBody: private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\nassertEquals(CUSTOM_MESSAGE,e.getMessage());\nfinal IOException cause=e.getCause();\nassertEquals(expected.getClass(),cause.getClass());\nassertEquals(CAUSE_MESSAGE,cause.getMessage());\n}", "methodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }", "diffSourceCode": "-  134:     /**\n-  135:      * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n-  136:      *\n-  137:      * @throws IOException\n-  138:      */\n-  139:     @Test\n-  140:     public void testRunMessage() throws IOException {\n-  141:         // No exception\n-  142:         final ByteArrayInputStream stream = newInputStream();\n-  143:         Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n-  144:         assertEquals('b', Uncheck.get(stream::read).intValue());\n-  145:         final IOException expected = new IOException(CAUSE_MESSAGE);\n-  146:         // Exception\n-  147:         try {\n-  148:             Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n-  149:             fail();\n-  150:         } catch (final UncheckedIOException e) {\n-  151:             assertUncheckedIOException(expected, e);\n-  152:         }\n-  153:     }\n+  134:     @Test\n+  135:     public void testApply2() {\n+  136:         final ByteArrayInputStream stream = newInputStream();\n+  137:         final byte[] buf = new byte[BYTES.length];\n+  138:         assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n+  139:         assertEquals('a', buf[0]);\n+  140:     }\n+  141: \n+  142:     /**\n+  143:      * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n+  144:      */\n+  145:     @Test\n+  146:     public void testApply3() {\n+  147:         final ByteArrayInputStream stream = newInputStream();\n+  148:         final byte[] buf = new byte[BYTES.length];\n+  149:         assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n+  150:         assertEquals('a', buf[0]);\n+  151:     }\n+  152: \n+  153:     @Test\n+  272:     /**\n+  273:      * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n+  274:      *\n+  275:      * @throws IOException\n+  276:      */\n+  277:     @Test\n+  278:     public void testRunMessage() throws IOException {\n+  279:         // No exception\n+  280:         final ByteArrayInputStream stream = newInputStream();\n+  281:         Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n+  282:         assertEquals('b', Uncheck.get(stream::read).intValue());\n+  283:         final IOException expected = new IOException(CAUSE_MESSAGE);\n+  284:         // Exception\n+  285:         try {\n+  286:             Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n+  287:             fail();\n+  288:         } catch (final UncheckedIOException e) {\n+  289:             assertUncheckedIOException(expected, e);\n+  290:         }\n+  291:     }\n", "uniqueId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52_134_153__272_291", "moveFileExist": true, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the `testRunMessage` method from the `UncheckIOTest` class to an existing test class that is relevant to the functionality being tested. Given the context of the method, it seems appropriate to move it to the `UncheckedIOExceptionsTest.java` file, as it deals with handling unchecked IO exceptions.\n\nHere\u2019s how the refactoring will be executed:\n\n1. **Target File Path**: We will move the method to `src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java`.\n2. **Moved Class Code**: The `UncheckedIOExceptionsTest` class will be updated to include the `testRunMessage` method as a public static method.\n3. **Refactored Method Code**: The `testRunMessage` method in the `UncheckIOTest` class will be updated to call the moved method from the `UncheckedIOExceptionsTest`.\n\n### Moved Class Code\n```java\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.Uncheck;\nimport org.junit.jupiter.api.Test;\n\npublic class UncheckedIOExceptionsTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private static void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private static ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    public static void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n```\n\n### Refactored Method Code\n```java\n/**\n * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n *\n * @throws IOException\n */\n@Test\npublic void testRunMessage() throws IOException {\n    UncheckedIOExceptionsTest.testRunMessage();\n}\n```\n\n### Final Output\nHere is the output in the requested format:\n\n##########################\nsrc/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java\n##########################\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.Uncheck;\nimport org.junit.jupiter.api.Test;\n\npublic class UncheckedIOExceptionsTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private static void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private static ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    public static void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n##########################\n@Test\npublic void testRunMessage() throws IOException {\n    UncheckedIOExceptionsTest.testRunMessage();\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryBaseTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsMultithreadedSkipTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/RandomAccessFilesTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/build/AbstractOriginTest.java', 'src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java', 'src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java', 'src/test/java/org/apache/commons/io/build/FileOriginTest.java', 'src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/PathOriginTest.java', 'src/test/java/org/apache/commons/io/build/ReaderOriginTest.java', 'src/test/java/org/apache/commons/io/build/URIOriginTest.java', 'src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/PathWrapper.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIntSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOLongSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Move Method", "description": "Move Method\tpublic testGetMessage() : void from class org.apache.commons.io.UncheckIOTest to public testGetMessage() : void from class org.apache.commons.io.function.UncheckTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "startLine": 107, "endLine": 122, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "startLine": 238, "endLine": 253, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/UncheckIOTest.java", "isPureRefactoring": true, "commitId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.UncheckIOTest", "methodNameBefore": "org.apache.commons.io.UncheckIOTest#testGetMessage", "invokedMethod": "methodSignature: org.apache.commons.io.UncheckIOTest#assertUncheckedIOException\n methodBody: private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\nassertEquals(CUSTOM_MESSAGE,e.getMessage());\nfinal IOException cause=e.getCause();\nassertEquals(expected.getClass(),cause.getClass());\nassertEquals(CAUSE_MESSAGE,cause.getMessage());\n}\nmethodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}", "classSignatureBefore": "public class UncheckIOTest ", "methodNameBeforeSet": ["org.apache.commons.io.UncheckIOTest#testGetMessage"], "classNameBeforeSet": ["org.apache.commons.io.UncheckIOTest"], "classSignatureBeforeSet": ["public class UncheckIOTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Identical statements", "description": "There is no replacement! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/function/UncheckTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.function;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Supplier;\n\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckTest {\n\n    private static final byte[] BYTES = { 'a', 'b' };\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n\n    private AtomicInteger atomicInt;\n    private AtomicReference<String> ref1;\n    private AtomicReference<String> ref2;\n    private AtomicReference<String> ref3;\n    private AtomicReference<String> ref4;\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    @BeforeEach\n    public void initEach() {\n        ref1 = new AtomicReference<>();\n        ref2 = new AtomicReference<>();\n        ref3 = new AtomicReference<>();\n        ref4 = new AtomicReference<>();\n        atomicInt = new AtomicInteger();\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    @Test\n    public void testAcceptIOBiConsumerOfTUTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_BI_CONSUMER, null, null));\n        Uncheck.accept((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n        }, \"new1\", \"new2\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testAcceptIOConsumerOfTT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestUtils.throwingIOConsumer(), null));\n        Uncheck.accept(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testAcceptIOTriConsumerOfTUVTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_TRI_CONSUMER, null, null, null));\n        Uncheck.accept((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n        }, \"new1\", \"new2\", \"new3\");\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    @Test\n    public void testApplyIOBiFunctionOfTURTU() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u) -> {\n            throw new IOException();\n        }, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_BI_FUNCTION, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            return \"new0\";\n        }, \"new1\", \"new2\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n    }\n\n    @Test\n    public void testApplyIOFunctionOfTRT() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_FUNCTION, null));\n        Uncheck.apply(t -> TestUtils.compareAndSetThrowsIO(ref1, t), \"new1\");\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testApplyIOQuadFunctionOfTUVWRTUVW() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v, w) -> {\n            throw new IOException();\n        }, null, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_QUAD_FUNCTION, null, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v, w) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            TestUtils.compareAndSetThrowsIO(ref4, w);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\", \"new4\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n        assertEquals(\"new4\", ref4.get());\n    }\n\n    @Test\n    public void testApplyIOTriFunctionOfTUVRTUV() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply((t, u, v) -> {\n            throw new IOException();\n        }, null, null, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.apply(TestConstants.THROWING_IO_TRI_FUNCTION, null, null, null));\n        assertEquals(\"new0\", Uncheck.apply((t, u, v) -> {\n            TestUtils.compareAndSetThrowsIO(ref1, t);\n            TestUtils.compareAndSetThrowsIO(ref2, u);\n            TestUtils.compareAndSetThrowsIO(ref3, v);\n            return \"new0\";\n        }, \"new1\", \"new2\", \"new3\"));\n        assertEquals(\"new1\", ref1.get());\n        assertEquals(\"new2\", ref2.get());\n        assertEquals(\"new3\", ref3.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.get(TestConstants.THROWING_IO_SUPPLIER));\n        assertEquals(\"new1\", Uncheck.get(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\")));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    @Test\n    public void testGetAsInt() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.getAsInt(TestConstants.THROWING_IO_INT_SUPPLIER));\n        assertEquals(1, Uncheck.getAsInt(() -> TestUtils.compareAndSetThrowsIO(atomicInt, 1)));\n        assertEquals(1, atomicInt.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        //\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(() -> {\n            throw new IOException();\n        }));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.run(TestConstants.THROWING_IO_RUNNABLE));\n        Uncheck.run(() -> TestUtils.compareAndSetThrowsIO(ref1, \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    @Test\n    public void testTest() {\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(t -> {\n            throw new IOException();\n        }, null));\n        assertThrows(UncheckedIOException.class, () -> Uncheck.test(TestConstants.THROWING_IO_PREDICATE, null));\n        assertTrue(Uncheck.test(t -> TestUtils.compareAndSetThrowsIO(ref1, t).equals(t), \"new1\"));\n        assertEquals(\"new1\", ref1.get());\n    }\n\n}\n", "diffSourceCodeSet": [], "invokedMethodSet": ["methodSignature: org.apache.commons.io.UncheckIOTest#assertUncheckedIOException\n methodBody: private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\nassertEquals(CUSTOM_MESSAGE,e.getMessage());\nfinal IOException cause=e.getCause();\nassertEquals(expected.getClass(),cause.getClass());\nassertEquals(CAUSE_MESSAGE,cause.getMessage());\n}", "methodSignature: org.apache.commons.io.UncheckIOTest#newInputStream\n methodBody: private ByteArrayInputStream newInputStream() {\nreturn new ByteArrayInputStream(BYTES);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }", "diffSourceCode": "-  107:     /**\n-  108:      * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n-  109:      */\n-  110:     @Test\n-  111:     public void testGetMessage() {\n-  112:         // No exception\n-  113:         assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n-  114:         // Exception\n-  115:         final IOException expected = new IOException(CAUSE_MESSAGE);\n-  116:         try {\n-  117:             Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n-  118:             fail();\n-  119:         } catch (final UncheckedIOException e) {\n-  120:             assertUncheckedIOException(expected, e);\n-  121:         }\n-  122:     }\n+  107:         assertThrows(UncheckedIOException.class, () -> Uncheck.accept((t, u, v) -> {\n+  108:             throw new IOException();\n+  109:         }, null, null, null));\n+  110:         assertThrows(UncheckedIOException.class, () -> Uncheck.accept(TestConstants.THROWING_IO_TRI_CONSUMER, null, null, null));\n+  111:         Uncheck.accept((t, u, v) -> {\n+  112:             TestUtils.compareAndSetThrowsIO(ref1, t);\n+  113:             TestUtils.compareAndSetThrowsIO(ref2, u);\n+  114:             TestUtils.compareAndSetThrowsIO(ref3, v);\n+  115:         }, \"new1\", \"new2\", \"new3\");\n+  116:         assertEquals(\"new1\", ref1.get());\n+  117:         assertEquals(\"new2\", ref2.get());\n+  118:         assertEquals(\"new3\", ref3.get());\n+  119:     }\n+  120: \n+  121:     /**\n+  122:      * Tests {@link Uncheck#apply(IOFunction, Object)}.\n+  238:     /**\n+  239:      * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n+  240:      */\n+  241:     @Test\n+  242:     public void testGetMessage() {\n+  243:         // No exception\n+  244:         assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n+  245:         // Exception\n+  246:         final IOException expected = new IOException(CAUSE_MESSAGE);\n+  247:         try {\n+  248:             Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n+  249:             fail();\n+  250:         } catch (final UncheckedIOException e) {\n+  251:             assertUncheckedIOException(expected, e);\n+  252:         }\n+  253:     }\n", "uniqueId": "d6e836d453c75d3ff5de3860fb863ed7277ddd52_107_122__238_253", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To perform the requested refactoring, we will move the `assertUncheckedIOException` method from the `UncheckIOTest` class to the `UncheckTest` class, which is a suitable existing class for utility methods related to the `Uncheck` functionality. The method will be made `public static` to allow it to be called without an instance of the class.\n\n### Target File Path\nThe target file path for the moved method will be:\n```\nsrc/test/java/org/apache/commons/io/function/UncheckTest.java\n```\n\n### Moved Class Code\nHere is the code for the `assertUncheckedIOException` method that will be moved to `UncheckTest`:\n```java\npublic class UncheckTest {\n    // Other existing methods...\n\n    public static void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n}\n```\n\n### Refactored Method Code\nThe `testGetMessage` method in the `UncheckIOTest` class will be updated to call the moved method from `UncheckTest`:\n```java\n@Test\npublic void testGetMessage() {\n    // No exception\n    assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n    // Exception\n    final IOException expected = new IOException(CAUSE_MESSAGE);\n    try {\n        Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n        fail();\n    } catch (final UncheckedIOException e) {\n        UncheckTest.assertUncheckedIOException(expected, e); // Updated call\n    }\n}\n```\n\n### Final Output\nHere is the complete output in the requested format:\n\n##########################\nsrc/test/java/org/apache/commons/io/function/UncheckTest.java\n##########################\npublic class UncheckTest {\n    // Other existing methods...\n\n    public static void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n}\n##########################\n@Test\npublic void testGetMessage() {\n    // No exception\n    assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n    // Exception\n    final IOException expected = new IOException(CAUSE_MESSAGE);\n    try {\n        Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n        fail();\n    } catch (final UncheckedIOException e) {\n        UncheckTest.assertUncheckedIOException(expected, e); // Updated call\n    }\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\n\nimport org.apache.commons.io.function.IOBiFunction;\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.function.IOFunction;\nimport org.apache.commons.io.function.IORunnable;\nimport org.apache.commons.io.function.IOSupplier;\nimport org.apache.commons.io.function.IOTriFunction;\nimport org.apache.commons.io.function.Uncheck;\nimport org.apache.commons.io.input.BrokenInputStream;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link Uncheck}.\n */\npublic class UncheckIOTest {\n\n    private static final String CAUSE_MESSAGE = \"CauseMessage\";\n    private static final String CUSTOM_MESSAGE = \"Custom message\";\n    private static final byte[] BYTES = { 'a', 'b' };\n\n    private void assertUncheckedIOException(final IOException expected, final UncheckedIOException e) {\n        assertEquals(CUSTOM_MESSAGE, e.getMessage());\n        final IOException cause = e.getCause();\n        assertEquals(expected.getClass(), cause.getClass());\n        assertEquals(CAUSE_MESSAGE, cause.getMessage());\n    }\n\n    private ByteArrayInputStream newInputStream() {\n        return new ByteArrayInputStream(BYTES);\n    }\n\n    /**\n     * Tests {@link Uncheck#accept(IOConsumer, Object)}.\n     */\n    @Test\n    public void testAccept() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.accept(n -> stream.skip(n), 1);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOFunction, Object)}.\n     */\n    @Test\n    public void testApply1() {\n        final ByteArrayInputStream stream = newInputStream();\n        assertEquals(1, Uncheck.apply(n -> stream.skip(n), 1).intValue());\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOBiFunction, Object, Object)}.\n     */\n    @Test\n    public void testApply2() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((o, l) -> stream.read(buf, o, l), 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#apply(IOTriFunction, Object, Object, Object)}.\n     */\n    @Test\n    public void testApply3() {\n        final ByteArrayInputStream stream = newInputStream();\n        final byte[] buf = new byte[BYTES.length];\n        assertEquals(1, Uncheck.apply((b, o, l) -> stream.read(b, o, l), buf, 0, 1).intValue());\n        assertEquals('a', buf[0]);\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier)}.\n     */\n    @Test\n    public void testGet() {\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#get(IOSupplier, Supplier)}.\n     */\n    @Test\n    public void testGetMessage() {\n        // No exception\n        assertEquals('a', Uncheck.get(() -> newInputStream().read()).intValue(), () -> CUSTOM_MESSAGE);\n        // Exception\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        try {\n            Uncheck.get(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable)}.\n     */\n    @Test\n    public void testRun() {\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1));\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n    }\n\n    /**\n     * Tests {@link Uncheck#run(IORunnable, Supplier))}.\n     *\n     * @throws IOException\n     */\n    @Test\n    public void testRunMessage() throws IOException {\n        // No exception\n        final ByteArrayInputStream stream = newInputStream();\n        Uncheck.run(() -> stream.skip(1), () -> CUSTOM_MESSAGE);\n        assertEquals('b', Uncheck.get(stream::read).intValue());\n        final IOException expected = new IOException(CAUSE_MESSAGE);\n        // Exception\n        try {\n            Uncheck.run(() -> new BrokenInputStream(expected).read(), () -> CUSTOM_MESSAGE);\n            fail();\n        } catch (final UncheckedIOException e) {\n            assertUncheckedIOException(expected, e);\n        }\n    }\n}\n\nRefactoring Operation:\nMove Method\n\nProject Structure:\n['src/test/java/org/apache/commons/io/ByteOrderMarkTest.java', 'src/test/java/org/apache/commons/io/ByteOrderParserTest.java', 'src/test/java/org/apache/commons/io/CharsetsTest.java', 'src/test/java/org/apache/commons/io/CopyUtilsTest.java', 'src/test/java/org/apache/commons/io/DeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/DemuxInputStreamTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTest.java', 'src/test/java/org/apache/commons/io/DirectoryWalkerTestCaseJava4.java', 'src/test/java/org/apache/commons/io/EndianUtilsTest.java', 'src/test/java/org/apache/commons/io/FileCleanerTest.java', 'src/test/java/org/apache/commons/io/FileCleaningTrackerTest.java', 'src/test/java/org/apache/commons/io/FileDeleteStrategyTest.java', 'src/test/java/org/apache/commons/io/FileSystemTest.java', 'src/test/java/org/apache/commons/io/FileSystemUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCleanSymlinksTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyDirectoryToDirectoryTest.java', 'src/test/java/org/apache/commons/io/FileUtilsCopyToFileTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryBaseTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryLinuxTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDeleteDirectoryWindowsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsDirectoryContainsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsFileNewerTest.java', 'src/test/java/org/apache/commons/io/FileUtilsListFilesTest.java', 'src/test/java/org/apache/commons/io/FileUtilsTest.java', 'src/test/java/org/apache/commons/io/FileUtilsWaitForTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsTest.java', 'src/test/java/org/apache/commons/io/FilenameUtilsWildcardTest.java', 'src/test/java/org/apache/commons/io/HexDumpTest.java', 'src/test/java/org/apache/commons/io/IOCaseTest.java', 'src/test/java/org/apache/commons/io/IOExceptionListTest.java', 'src/test/java/org/apache/commons/io/IOExceptionWithCauseTest.java', 'src/test/java/org/apache/commons/io/IOIndexedExceptionTest.java', 'src/test/java/org/apache/commons/io/IOUtilsCopyTest.java', 'src/test/java/org/apache/commons/io/IOUtilsMultithreadedSkipTest.java', 'src/test/java/org/apache/commons/io/IOUtilsTest.java', 'src/test/java/org/apache/commons/io/IOUtilsWriteTest.java', 'src/test/java/org/apache/commons/io/LineIteratorTest.java', 'src/test/java/org/apache/commons/io/RandomAccessFilesTest.java', 'src/test/java/org/apache/commons/io/SelectorAdapter.java', 'src/test/java/org/apache/commons/io/StandardLineSeparatorTest.java', 'src/test/java/org/apache/commons/io/TaggedIOExceptionTest.java', 'src/test/java/org/apache/commons/io/TestResources.java', 'src/test/java/org/apache/commons/io/ThreadMonitorTest.java', 'src/test/java/org/apache/commons/io/UncheckedIOExceptionsTest.java', 'src/test/java/org/apache/commons/io/build/AbstractOriginTest.java', 'src/test/java/org/apache/commons/io/build/ByteArrayOriginTest.java', 'src/test/java/org/apache/commons/io/build/CharSequenceOriginTest.java', 'src/test/java/org/apache/commons/io/build/FileOriginTest.java', 'src/test/java/org/apache/commons/io/build/InputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/OutputStreamOriginTest.java', 'src/test/java/org/apache/commons/io/build/PathOriginTest.java', 'src/test/java/org/apache/commons/io/build/ReaderOriginTest.java', 'src/test/java/org/apache/commons/io/build/URIOriginTest.java', 'src/test/java/org/apache/commons/io/build/WriterStreamOriginTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetDecodersTest.java', 'src/test/java/org/apache/commons/io/charset/CharsetEncodersTest.java', 'src/test/java/org/apache/commons/io/comparator/ComparatorAbstractTest.java', 'src/test/java/org/apache/commons/io/comparator/CompositeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DefaultFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/DirectoryFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/ExtensionFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/LastModifiedFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/NameFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/PathFileComparatorTest.java', 'src/test/java/org/apache/commons/io/comparator/SizeFileComparatorTest.java', 'src/test/java/org/apache/commons/io/file/AbstractTempDirTest.java', 'src/test/java/org/apache/commons/io/file/AccumulatorPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CleaningPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CopyDirectoryVisitorTest.java', 'src/test/java/org/apache/commons/io/file/CounterAssertions.java', 'src/test/java/org/apache/commons/io/file/CountersEqualsAndHashCodeTest.java', 'src/test/java/org/apache/commons/io/file/CountersTest.java', 'src/test/java/org/apache/commons/io/file/CountingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DeletablePath.java', 'src/test/java/org/apache/commons/io/file/DeletingPathVisitorTest.java', 'src/test/java/org/apache/commons/io/file/DirectoryStreamFilterTest.java', 'src/test/java/org/apache/commons/io/file/FilesUncheckTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCleanDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsContentEqualsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsCountingTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteFileTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsDeleteTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsIsEmptyTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsTest.java', 'src/test/java/org/apache/commons/io/file/PathUtilsVisitorTest.java', 'src/test/java/org/apache/commons/io/file/PathWrapper.java', 'src/test/java/org/apache/commons/io/file/TempDirectory.java', 'src/test/java/org/apache/commons/io/file/TempDirectoryTest.java', 'src/test/java/org/apache/commons/io/file/TempFile.java', 'src/test/java/org/apache/commons/io/file/TempFileTest.java', 'src/test/java/org/apache/commons/io/file/TestArguments.java', 'src/test/java/org/apache/commons/io/file/attribute/FileTimesTest.java', 'src/test/java/org/apache/commons/io/file/spi/FileSystemProvidersTest.java', 'src/test/java/org/apache/commons/io/filefilter/AbstractFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AgeFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/AndFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/ConditionalFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/DirectoryFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/FileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/IOFileFilterAbstractTest.java', 'src/test/java/org/apache/commons/io/filefilter/NameFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/OrFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/RegexFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilterTest.java', 'src/test/java/org/apache/commons/io/filefilter/WildcardFileFilterTest.java', 'src/test/java/org/apache/commons/io/function/EraseTest.java', 'src/test/java/org/apache/commons/io/function/IOBaseStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOBiConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOBiFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOBinaryOperatorStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOComparatorTest.java', 'src/test/java/org/apache/commons/io/function/IOConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOIntStream.java', 'src/test/java/org/apache/commons/io/function/IOIntStreamAdapter.java', 'src/test/java/org/apache/commons/io/function/IOIntSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorAdapterTest.java', 'src/test/java/org/apache/commons/io/function/IOIteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOLongSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOPredicateTest.java', 'src/test/java/org/apache/commons/io/function/IOQuadFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IORunnableTest.java', 'src/test/java/org/apache/commons/io/function/IOSpliteratorTest.java', 'src/test/java/org/apache/commons/io/function/IOStreamTest.java', 'src/test/java/org/apache/commons/io/function/IOSupplierTest.java', 'src/test/java/org/apache/commons/io/function/IOTriConsumerTest.java', 'src/test/java/org/apache/commons/io/function/IOTriFunctionTest.java', 'src/test/java/org/apache/commons/io/function/IOUnaryOperatorTest.java', 'src/test/java/org/apache/commons/io/function/PathBaseStream.java', 'src/test/java/org/apache/commons/io/function/PathStream.java', 'src/test/java/org/apache/commons/io/function/TestConstants.java', 'src/test/java/org/apache/commons/io/function/TestUtils.java', 'src/test/java/org/apache/commons/io/function/UncheckTest.java', 'src/test/java/org/apache/commons/io/input/AbstractInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/AutoCloseInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BOMInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BoundedReaderTest.java', 'src/test/java/org/apache/commons/io/input/BrokenInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/BrokenReaderTest.java', 'src/test/java/org/apache/commons/io/input/BufferedFileChannelInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ByteBufferCleanerTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CharSequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderIntPredicateTest.java', 'src/test/java/org/apache/commons/io/input/CharacterFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CharacterSetFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/CircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClassLoaderObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/CloseShieldReaderTest.java', 'src/test/java/org/apache/commons/io/input/ClosedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ClosedReaderTest.java', 'src/test/java/org/apache/commons/io/input/CountingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/InfiniteCircularInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MarkShieldInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MemoryMappedFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/MessageDigestCalculatingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/NullReaderTest.java', 'src/test/java/org/apache/commons/io/input/ObservableInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ProxyReaderTest.java', 'src/test/java/org/apache/commons/io/input/QueueInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/RandomAccessFileInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReadAheadInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReaderInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamBlockSize.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestParamFile.java', 'src/test/java/org/apache/commons/io/input/ReversedLinesFileReaderTestSimple.java', 'src/test/java/org/apache/commons/io/input/SequenceReaderTest.java', 'src/test/java/org/apache/commons/io/input/SwappedDataInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TaggedReaderTest.java', 'src/test/java/org/apache/commons/io/input/TailerTest.java', 'src/test/java/org/apache/commons/io/input/TeeInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/TeeReaderTest.java', 'src/test/java/org/apache/commons/io/input/TimestampedObserverTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedBufferedReaderTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UncheckedFilterReaderTest.java', 'src/test/java/org/apache/commons/io/input/UnixLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedBufferedInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/UnsynchronizedFilterInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/WindowsLineEndingInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderTest.java', 'src/test/java/org/apache/commons/io/input/XmlStreamReaderUtilitiesTest.java', 'src/test/java/org/apache/commons/io/input/buffer/CircularBufferInputStreamTest.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReader.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderException.java', 'src/test/java/org/apache/commons/io/input/compatibility/XmlStreamReaderUtilitiesCompatibilityTest.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsInputStreamsBenchmark.java', 'src/test/java/org/apache/commons/io/jmh/IOUtilsContentEqualsReadersBenchmark.java', 'src/test/java/org/apache/commons/io/monitor/AbstractMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/CollectionFileListener.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationMonitorTest.java', 'src/test/java/org/apache/commons/io/monitor/FileAlterationObserverTest.java', 'src/test/java/org/apache/commons/io/monitor/FileEntryTest.java', 'src/test/java/org/apache/commons/io/monitor/SerializableFileTimeTest.java', 'src/test/java/org/apache/commons/io/output/AppendableOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/AppendableWriterTest.java', 'src/test/java/org/apache/commons/io/output/BrokenOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/BrokenWriterTest.java', 'src/test/java/org/apache/commons/io/output/ByteArrayOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ChunkedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/CloseShieldWriterTest.java', 'src/test/java/org/apache/commons/io/output/ClosedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ClosedWriterTest.java', 'src/test/java/org/apache/commons/io/output/CountingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/DeferredFileOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/FileWriterWithEncodingTest.java', 'src/test/java/org/apache/commons/io/output/LockableFileWriterTest.java', 'src/test/java/org/apache/commons/io/output/NullAppendableTest.java', 'src/test/java/org/apache/commons/io/output/NullOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullPrintStreamTest.java', 'src/test/java/org/apache/commons/io/output/NullWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyCollectionWriterTest.java', 'src/test/java/org/apache/commons/io/output/ProxyOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/ProxyWriterTest.java', 'src/test/java/org/apache/commons/io/output/QueueOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/StringBuilderWriterTest.java', 'src/test/java/org/apache/commons/io/output/TaggedOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TaggedWriterTest.java', 'src/test/java/org/apache/commons/io/output/TeeOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/TeeWriterTest.java', 'src/test/java/org/apache/commons/io/output/ThresholdingOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedAppendableTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/UncheckedFilterWriterTest.java', 'src/test/java/org/apache/commons/io/output/WriterOutputStreamTest.java', 'src/test/java/org/apache/commons/io/output/XmlStreamWriterTest.java', 'src/test/java/org/apache/commons/io/serialization/AbstractCloseableListTest.java', 'src/test/java/org/apache/commons/io/serialization/FullClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/MockSerializedClass.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObject.java', 'src/test/java/org/apache/commons/io/serialization/MoreComplexObjectTest.java', 'src/test/java/org/apache/commons/io/serialization/RegexpClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/serialization/ValidatingObjectInputStreamTest.java', 'src/test/java/org/apache/commons/io/serialization/WildcardClassNameMatcherTest.java', 'src/test/java/org/apache/commons/io/test/TestUtils.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseInputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseOutputStream.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseReader.java', 'src/test/java/org/apache/commons/io/test/ThrowOnCloseWriter.java', 'src/test/java/org/apache/commons/io/test/ThrowOnFlushAndCloseOutputStream.java']\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply move method refactoring to the code to be refactored, output the target file path, moved class code, and refactored method code.\nNeed to move to an existing java file\nThe moved method code should be updated to the public static method.\nThe refactored method code should use the moved class to call the moved method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the target file path, moved class code, and refactored method code in the following format:\n##########################\ntarget_file_path\n##########################\nmoved_class_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate current() : Path extracted from public testNewDirectoryStream() : void in class org.apache.commons.io.file.PathUtilsTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "startLine": 278, "endLine": 287, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "startLine": 319, "endLine": 328, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "startLine": 94, "endLine": 96, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "isPureRefactoring": true, "commitId": "cb6f3aabcf872aeab3bb4c975d163f340b93f051", "packageNameBefore": "org.apache.commons.io.file", "classNameBefore": "org.apache.commons.io.file.PathUtilsTest", "methodNameBefore": "org.apache.commons.io.file.PathUtilsTest#testNewDirectoryStream", "invokedMethod": "methodSignature: org.apache.commons.io.file.PathUtils#current\n methodBody: public static Path current() {\nreturn Paths.get(\".\");\n}\nmethodSignature: org.apache.commons.io.file.PathUtils#newDirectoryStream\n methodBody: public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\nreturn Files.newDirectoryStream(dir,new DirectoryStreamFilter(pathFilter));\n}", "classSignatureBefore": "public class PathUtilsTest extends AbstractTempDirTest ", "methodNameBeforeSet": ["org.apache.commons.io.file.PathUtilsTest#testNewDirectoryStream"], "classNameBeforeSet": ["org.apache.commons.io.file.PathUtilsTest"], "classSignatureBeforeSet": ["public class PathUtilsTest extends AbstractTempDirTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "Tolerable changes in the body\n", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertThrowsExactly;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileAlreadyExistsException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link PathUtils}.\n */\npublic class PathUtilsTest extends AbstractTempDirTest {\n\n    private static final String STRING_FIXTURE = \"Hello World\";\n\n    private static final byte[] BYTE_ARRAY_FIXTURE = STRING_FIXTURE.getBytes(StandardCharsets.UTF_8);\n\n    private static final String TEST_JAR_NAME = \"test.jar\";\n\n    private static final String TEST_JAR_PATH = \"src/test/resources/org/apache/commons/io/test.jar\";\n\n    private static final String PATH_FIXTURE = \"NOTICE.txt\";\n\n    /**\n     * Creates directory test fixtures.\n     * <ol>\n     * <li>tempDirPath/subdir</li>\n     * <li>tempDirPath/symlinked-dir -> tempDirPath/subdir</li>\n     * </ol>\n     *\n     * @return Path to tempDirPath/subdir\n     * @throws IOException if an I/O error occurs or the parent directory does not exist.\n     */\n    private Path createTempSymlinkedRelativeDir() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symlinkDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symlinkDir, targetDir);\n        return symlinkDir;\n    }\n\n    private Long getLastModifiedMillis(final Path file) throws IOException {\n        return Files.getLastModifiedTime(file).toMillis();\n    }\n\n    private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n        if (createNew) {\n            final Map<String, String> env = new HashMap<>();\n            env.put(\"create\", \"true\");\n            final URI fileUri = p.toAbsolutePath().toUri();\n            final URI uri = URI.create(\"jar:\" + fileUri.toASCIIString());\n            return FileSystems.newFileSystem(uri, env, null);\n        }\n        return FileSystems.newFileSystem(p, (ClassLoader) null);\n    }\n\n    private void setLastModifiedMillis(final Path file, final long millis) throws IOException {\n        Files.setLastModifiedTime(file, FileTime.fromMillis(millis));\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false)) {\n            // relative jar -> absolute dir\n            Path sourceDir = archive.getPath(\"dir1\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"f1\")));\n\n            // absolute jar -> absolute dir\n            sourceDir = archive.getPath(\"/next\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"dir\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // absolute dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\").toAbsolutePath();\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // absolute dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false);\n            final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            final Path targetDir = targetArchive.getPath(\"targetDir\");\n            Files.createDirectory(targetDir);\n            // relative jar -> relative dir\n            Path sourceDir = archive.getPath(\"next\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dir\")));\n\n            // absolute jar -> relative dir\n            sourceDir = archive.getPath(\"/dir1\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"f1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // relative dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // relative dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyFile() throws IOException {\n        final Path sourceFile = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-1-file-size-1/file-size-1.bin\");\n        final Path targetFile = PathUtils.copyFileToDirectory(sourceFile, tempDirPath);\n        assertTrue(Files.exists(targetFile));\n        assertEquals(Files.size(sourceFile), Files.size(targetFile));\n    }\n\n    @Test\n    public void testCreateDirectoriesAlreadyExists() throws IOException {\n        assertEquals(tempDirPath.getParent(), PathUtils.createParentDirectories(tempDirPath));\n    }\n\n    @SuppressWarnings(\"resource\") // FileSystems.getDefault() is a singleton\n    @Test\n    public void testCreateDirectoriesForRoots() throws IOException {\n        for (final Path path : FileSystems.getDefault().getRootDirectories()) {\n            final Path parent = path.getParent();\n            assertNull(parent);\n            assertEquals(parent, PathUtils.createParentDirectories(path));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesForRootsLinkOptionNull() throws IOException {\n        for (final File f : File.listRoots()) {\n            final Path path = f.toPath();\n            assertEquals(path.getParent(), PathUtils.createParentDirectories(path, (LinkOption) null));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesNew() throws IOException {\n        assertEquals(tempDirPath, PathUtils.createParentDirectories(tempDirPath.resolve(\"child\")));\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlink() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        final String leafDirName = \"child\";\n        final Path newDirFollowed = PathUtils.createParentDirectories(symlinkedDir.resolve(leafDirName), PathUtils.NULL_LINK_OPTION);\n        assertEquals(Files.readSymbolicLink(symlinkedDir), newDirFollowed);\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlinkClashing() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        assertThrowsExactly(FileAlreadyExistsException.class, () -> PathUtils.createParentDirectories(symlinkedDir.resolve(\"child\")));\n    }\n\n    @Test\n    public void testGetTempDirectory() {\n        final Path tempDirectory = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n        assertEquals(tempDirectory, PathUtils.getTempDirectory());\n    }\n\n    @Test\n    public void testIsDirectory() throws IOException {\n        assertFalse(PathUtils.isDirectory(null));\n\n        assertTrue(PathUtils.isDirectory(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertFalse(PathUtils.isDirectory(testFile1.get()));\n\n            Path ref = null;\n            try (TempDirectory tempDir = TempDirectory.create(getClass().getCanonicalName())) {\n                ref = tempDir.get();\n                assertTrue(PathUtils.isDirectory(tempDir.get()));\n            }\n            assertFalse(PathUtils.isDirectory(ref));\n        }\n    }\n\n    @Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(PathUtils.current()));\n    }\n\n    @Test\n    public void testIsRegularFile() throws IOException {\n        assertFalse(PathUtils.isRegularFile(null));\n\n        assertFalse(PathUtils.isRegularFile(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertTrue(PathUtils.isRegularFile(testFile1.get()));\n\n            Files.delete(testFile1.get());\n            assertFalse(PathUtils.isRegularFile(testFile1.get()));\n        }\n    }\n\n    @Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n        final Path file = writeToNewOutputStream(true);\n        assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n    }\n\n    public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n        final Path file = writeToNewOutputStream(append);\n        assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileInsideExistingSymlinkedDir() throws IOException {\n        final Path symlinkDir = createTempSymlinkedRelativeDir();\n        final Path file = symlinkDir.resolve(\"test.txt\");\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, null)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, true)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, false)) {\n            // empty\n        }\n    }\n\n    @Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(PathUtils.current(), PosixFileAttributes.class) != null);\n    }\n\n    @Test\n    public void testReadStringEmptyFile() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-empty.bin\");\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testReadStringSimpleUtf8() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-simple-utf8.bin\");\n        final String expected = \"ABC\\r\\n\";\n        assertEquals(expected, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(expected, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testSetReadOnlyFile() throws IOException {\n        final Path resolved = tempDirPath.resolve(\"testSetReadOnlyFile.txt\");\n        // Ask now, as we are allowed before editing parent permissions.\n        final boolean isPosix = PathUtils.isPosix(tempDirPath);\n\n        // TEMP HACK\n        assumeFalse(SystemUtils.IS_OS_LINUX);\n\n        PathUtils.writeString(resolved, \"test\", StandardCharsets.UTF_8);\n        final boolean readable = Files.isReadable(resolved);\n        final boolean writable = Files.isWritable(resolved);\n        final boolean regularFile = Files.isRegularFile(resolved);\n        final boolean executable = Files.isExecutable(resolved);\n        final boolean hidden = Files.isHidden(resolved);\n        final boolean directory = Files.isDirectory(resolved);\n        final boolean symbolicLink = Files.isSymbolicLink(resolved);\n        // Sanity checks\n        assertTrue(readable);\n        assertTrue(writable);\n        // Test A\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        // Again, shouldn't blow up.\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        //\n        assertEquals(regularFile, Files.isReadable(resolved));\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        // Test B\n        PathUtils.setReadOnly(resolved, true);\n        if (isPosix) {\n            // On POSIX, now that the parent is not WX, the file is not readable.\n            assertFalse(Files.isReadable(resolved), \"isReadable\");\n        } else {\n            assertTrue(Files.isReadable(resolved), \"isReadable\");\n        }\n        assertFalse(Files.isWritable(resolved), \"isWritable\");\n        final DosFileAttributeView dosFileAttributeView = PathUtils.getDosFileAttributeView(resolved);\n        if (dosFileAttributeView != null) {\n            assertTrue(dosFileAttributeView.readAttributes().isReadOnly());\n        }\n        if (isPosix) {\n            assertFalse(Files.isReadable(resolved));\n        } else {\n            assertEquals(regularFile, Files.isReadable(resolved));\n        }\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        //\n        PathUtils.setReadOnly(resolved, false);\n        PathUtils.deleteFile(resolved);\n    }\n\n    @Test\n    public void testTouch() throws IOException {\n        assertThrows(NullPointerException.class, () -> FileUtils.touch(null));\n\n        final Path file = managedTempDirPath.resolve(\"touch.txt\");\n        Files.deleteIfExists(file);\n        assertFalse(Files.exists(file), \"Bad test: test file still exists\");\n        PathUtils.touch(file);\n        assertTrue(Files.exists(file), \"touch() created file\");\n        try (OutputStream out = Files.newOutputStream(file)) {\n            assertEquals(0, Files.size(file), \"Created empty file.\");\n            out.write(0);\n        }\n        assertEquals(1, Files.size(file), \"Wrote one byte to file\");\n        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();\n        setLastModifiedMillis(file, y2k);  // 0L fails on Win98\n        assertEquals(y2k, getLastModifiedMillis(file), \"Bad test: set lastModified set incorrect value\");\n        final long nowMillis = System.currentTimeMillis();\n        PathUtils.touch(file);\n        assertEquals(1, Files.size(file), \"FileUtils.touch() didn't empty the file.\");\n        assertNotEquals(y2k, getLastModifiedMillis(file), \"FileUtils.touch() changed lastModified\");\n        final int delta = 3000;\n        assertTrue(getLastModifiedMillis(file) >= nowMillis - delta, \"FileUtils.touch() changed lastModified to more than now-3s\");\n        assertTrue(getLastModifiedMillis(file) <= nowMillis + delta, \"FileUtils.touch() changed lastModified to less than now+3s\");\n    }\n\n    @Test\n    public void testWriteStringToFile1() throws Exception {\n        final Path file = tempDirPath.resolve(\"write.txt\");\n        PathUtils.writeString(file, \"Hello /u1234\", StandardCharsets.UTF_8);\n        final byte[] text = \"Hello /u1234\".getBytes(StandardCharsets.UTF_8);\n        TestUtils.assertEqualContent(text, file);\n    }\n\n    /**\n     * Tests newOutputStream() here and don't use Files.write obviously.\n     */\n    private Path writeToNewOutputStream(final boolean append) throws IOException {\n        final Path file = tempDirPath.resolve(\"test1.txt\");\n        try (OutputStream os = PathUtils.newOutputStream(file, append)) {\n            os.write(BYTE_ARRAY_FIXTURE);\n        }\n        return file;\n    }\n\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertThrowsExactly;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileAlreadyExistsException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link PathUtils}.\n */\npublic class PathUtilsTest extends AbstractTempDirTest {\n\n    private static final String STRING_FIXTURE = \"Hello World\";\n\n    private static final byte[] BYTE_ARRAY_FIXTURE = STRING_FIXTURE.getBytes(StandardCharsets.UTF_8);\n\n    private static final String TEST_JAR_NAME = \"test.jar\";\n\n    private static final String TEST_JAR_PATH = \"src/test/resources/org/apache/commons/io/test.jar\";\n\n    private static final String PATH_FIXTURE = \"NOTICE.txt\";\n\n    /**\n     * Creates directory test fixtures.\n     * <ol>\n     * <li>tempDirPath/subdir</li>\n     * <li>tempDirPath/symlinked-dir -> tempDirPath/subdir</li>\n     * </ol>\n     *\n     * @return Path to tempDirPath/subdir\n     * @throws IOException if an I/O error occurs or the parent directory does not exist.\n     */\n    private Path createTempSymlinkedRelativeDir() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symlinkDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symlinkDir, targetDir);\n        return symlinkDir;\n    }\n\n    private Path current() {\n        return PathUtils.current();\n    }\n\n    private Long getLastModifiedMillis(final Path file) throws IOException {\n        return Files.getLastModifiedTime(file).toMillis();\n    }\n\n    private Path getNonExistantPath() {\n        return Paths.get(\"/does not exist/for/certain\");\n    }\n\n    private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n        if (createNew) {\n            final Map<String, String> env = new HashMap<>();\n            env.put(\"create\", \"true\");\n            final URI fileUri = p.toAbsolutePath().toUri();\n            final URI uri = URI.create(\"jar:\" + fileUri.toASCIIString());\n            return FileSystems.newFileSystem(uri, env, null);\n        }\n        return FileSystems.newFileSystem(p, (ClassLoader) null);\n    }\n\n    private void setLastModifiedMillis(final Path file, final long millis) throws IOException {\n        Files.setLastModifiedTime(file, FileTime.fromMillis(millis));\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false)) {\n            // relative jar -> absolute dir\n            Path sourceDir = archive.getPath(\"dir1\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"f1\")));\n\n            // absolute jar -> absolute dir\n            sourceDir = archive.getPath(\"/next\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"dir\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // absolute dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\").toAbsolutePath();\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // absolute dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false);\n            final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            final Path targetDir = targetArchive.getPath(\"targetDir\");\n            Files.createDirectory(targetDir);\n            // relative jar -> relative dir\n            Path sourceDir = archive.getPath(\"next\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dir\")));\n\n            // absolute jar -> relative dir\n            sourceDir = archive.getPath(\"/dir1\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"f1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // relative dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // relative dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyFile() throws IOException {\n        final Path sourceFile = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-1-file-size-1/file-size-1.bin\");\n        final Path targetFile = PathUtils.copyFileToDirectory(sourceFile, tempDirPath);\n        assertTrue(Files.exists(targetFile));\n        assertEquals(Files.size(sourceFile), Files.size(targetFile));\n    }\n\n    @Test\n    public void testCreateDirectoriesAlreadyExists() throws IOException {\n        assertEquals(tempDirPath.getParent(), PathUtils.createParentDirectories(tempDirPath));\n    }\n\n    @SuppressWarnings(\"resource\") // FileSystems.getDefault() is a singleton\n    @Test\n    public void testCreateDirectoriesForRoots() throws IOException {\n        for (final Path path : FileSystems.getDefault().getRootDirectories()) {\n            final Path parent = path.getParent();\n            assertNull(parent);\n            assertEquals(parent, PathUtils.createParentDirectories(path));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesForRootsLinkOptionNull() throws IOException {\n        for (final File f : File.listRoots()) {\n            final Path path = f.toPath();\n            assertEquals(path.getParent(), PathUtils.createParentDirectories(path, (LinkOption) null));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesNew() throws IOException {\n        assertEquals(tempDirPath, PathUtils.createParentDirectories(tempDirPath.resolve(\"child\")));\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlink() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        final String leafDirName = \"child\";\n        final Path newDirFollowed = PathUtils.createParentDirectories(symlinkedDir.resolve(leafDirName), PathUtils.NULL_LINK_OPTION);\n        assertEquals(Files.readSymbolicLink(symlinkedDir), newDirFollowed);\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlinkClashing() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        assertThrowsExactly(FileAlreadyExistsException.class, () -> PathUtils.createParentDirectories(symlinkedDir.resolve(\"child\")));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_File_Present() throws IOException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current().toFile()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_Path_Absent() throws IOException {\n        assertNull(PathUtils.getLastModifiedFileTime(getNonExistantPath()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_Path_FileTime_Absent() throws IOException {\n        final FileTime fromMillis = FileTime.fromMillis(0);\n        assertEquals(fromMillis, PathUtils.getLastModifiedFileTime(getNonExistantPath(), fromMillis));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_Path_Present() throws IOException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_URI_Present() throws IOException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current().toUri()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_URL_Present() throws IOException, URISyntaxException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current().toUri().toURL()));\n    }\n\n    @Test\n    public void testGetTempDirectory() {\n        final Path tempDirectory = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n        assertEquals(tempDirectory, PathUtils.getTempDirectory());\n    }\n\n    @Test\n    public void testIsDirectory() throws IOException {\n        assertFalse(PathUtils.isDirectory(null));\n\n        assertTrue(PathUtils.isDirectory(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertFalse(PathUtils.isDirectory(testFile1.get()));\n\n            Path ref = null;\n            try (TempDirectory tempDir = TempDirectory.create(getClass().getCanonicalName())) {\n                ref = tempDir.get();\n                assertTrue(PathUtils.isDirectory(tempDir.get()));\n            }\n            assertFalse(PathUtils.isDirectory(ref));\n        }\n    }\n\n    @Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(current()));\n    }\n\n    @Test\n    public void testIsRegularFile() throws IOException {\n        assertFalse(PathUtils.isRegularFile(null));\n\n        assertFalse(PathUtils.isRegularFile(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertTrue(PathUtils.isRegularFile(testFile1.get()));\n\n            Files.delete(testFile1.get());\n            assertFalse(PathUtils.isRegularFile(testFile1.get()));\n        }\n    }\n\n    @Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n        final Path file = writeToNewOutputStream(true);\n        assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n    }\n\n    public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n        final Path file = writeToNewOutputStream(append);\n        assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileInsideExistingSymlinkedDir() throws IOException {\n        final Path symlinkDir = createTempSymlinkedRelativeDir();\n        final Path file = symlinkDir.resolve(\"test.txt\");\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, null)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, true)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, false)) {\n            // empty\n        }\n    }\n\n    @Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(current(), PosixFileAttributes.class) != null);\n    }\n\n    @Test\n    public void testReadStringEmptyFile() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-empty.bin\");\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testReadStringSimpleUtf8() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-simple-utf8.bin\");\n        final String expected = \"ABC\\r\\n\";\n        assertEquals(expected, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(expected, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testSetReadOnlyFile() throws IOException {\n        final Path resolved = tempDirPath.resolve(\"testSetReadOnlyFile.txt\");\n        // Ask now, as we are allowed before editing parent permissions.\n        final boolean isPosix = PathUtils.isPosix(tempDirPath);\n\n        // TEMP HACK\n        assumeFalse(SystemUtils.IS_OS_LINUX);\n\n        PathUtils.writeString(resolved, \"test\", StandardCharsets.UTF_8);\n        final boolean readable = Files.isReadable(resolved);\n        final boolean writable = Files.isWritable(resolved);\n        final boolean regularFile = Files.isRegularFile(resolved);\n        final boolean executable = Files.isExecutable(resolved);\n        final boolean hidden = Files.isHidden(resolved);\n        final boolean directory = Files.isDirectory(resolved);\n        final boolean symbolicLink = Files.isSymbolicLink(resolved);\n        // Sanity checks\n        assertTrue(readable);\n        assertTrue(writable);\n        // Test A\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        // Again, shouldn't blow up.\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        //\n        assertEquals(regularFile, Files.isReadable(resolved));\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        // Test B\n        PathUtils.setReadOnly(resolved, true);\n        if (isPosix) {\n            // On POSIX, now that the parent is not WX, the file is not readable.\n            assertFalse(Files.isReadable(resolved), \"isReadable\");\n        } else {\n            assertTrue(Files.isReadable(resolved), \"isReadable\");\n        }\n        assertFalse(Files.isWritable(resolved), \"isWritable\");\n        final DosFileAttributeView dosFileAttributeView = PathUtils.getDosFileAttributeView(resolved);\n        if (dosFileAttributeView != null) {\n            assertTrue(dosFileAttributeView.readAttributes().isReadOnly());\n        }\n        if (isPosix) {\n            assertFalse(Files.isReadable(resolved));\n        } else {\n            assertEquals(regularFile, Files.isReadable(resolved));\n        }\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        //\n        PathUtils.setReadOnly(resolved, false);\n        PathUtils.deleteFile(resolved);\n    }\n\n    @Test\n    public void testTouch() throws IOException {\n        assertThrows(NullPointerException.class, () -> FileUtils.touch(null));\n\n        final Path file = managedTempDirPath.resolve(\"touch.txt\");\n        Files.deleteIfExists(file);\n        assertFalse(Files.exists(file), \"Bad test: test file still exists\");\n        PathUtils.touch(file);\n        assertTrue(Files.exists(file), \"touch() created file\");\n        try (OutputStream out = Files.newOutputStream(file)) {\n            assertEquals(0, Files.size(file), \"Created empty file.\");\n            out.write(0);\n        }\n        assertEquals(1, Files.size(file), \"Wrote one byte to file\");\n        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();\n        setLastModifiedMillis(file, y2k);  // 0L fails on Win98\n        assertEquals(y2k, getLastModifiedMillis(file), \"Bad test: set lastModified set incorrect value\");\n        final long nowMillis = System.currentTimeMillis();\n        PathUtils.touch(file);\n        assertEquals(1, Files.size(file), \"FileUtils.touch() didn't empty the file.\");\n        assertNotEquals(y2k, getLastModifiedMillis(file), \"FileUtils.touch() changed lastModified\");\n        final int delta = 3000;\n        assertTrue(getLastModifiedMillis(file) >= nowMillis - delta, \"FileUtils.touch() changed lastModified to more than now-3s\");\n        assertTrue(getLastModifiedMillis(file) <= nowMillis + delta, \"FileUtils.touch() changed lastModified to less than now+3s\");\n    }\n\n    @Test\n    public void testWriteStringToFile1() throws Exception {\n        final Path file = tempDirPath.resolve(\"write.txt\");\n        PathUtils.writeString(file, \"Hello /u1234\", StandardCharsets.UTF_8);\n        final byte[] text = \"Hello /u1234\".getBytes(StandardCharsets.UTF_8);\n        TestUtils.assertEqualContent(text, file);\n    }\n\n    /**\n     * Tests newOutputStream() here and don't use Files.write obviously.\n     */\n    private Path writeToNewOutputStream(final boolean append) throws IOException {\n        final Path file = tempDirPath.resolve(\"test1.txt\");\n        try (OutputStream os = PathUtils.newOutputStream(file, append)) {\n            os.write(BYTE_ARRAY_FIXTURE);\n        }\n        return file;\n    }\n\n}\n", "diffSourceCodeSet": ["private Path current() {\n        return PathUtils.current();\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.file.PathUtils#current\n methodBody: public static Path current() {\nreturn Paths.get(\".\");\n}", "methodSignature: org.apache.commons.io.file.PathUtils#newDirectoryStream\n methodBody: public static DirectoryStream<Path> newDirectoryStream(final Path dir, final PathFilter pathFilter) throws IOException {\nreturn Files.newDirectoryStream(dir,new DirectoryStreamFilter(pathFilter));\n}"], "sourceCodeAfterRefactoring": "@Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\nprivate Path current() {\n        return PathUtils.current();\n    }", "diffSourceCode": "-   94:     }\n-   95: \n-   96:     private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n-  278:     @Test\n-  279:     public void testNewDirectoryStream() throws Exception {\n-  280:         final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n-  281:         try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {\n-  282:             final Iterator<Path> iterator = stream.iterator();\n-  283:             final Path path = iterator.next();\n-  284:             assertEquals(PATH_FIXTURE, path.getFileName().toString());\n-  285:             assertFalse(iterator.hasNext());\n-  286:         }\n-  287:     }\n-  319:         final Path symlinkDir = createTempSymlinkedRelativeDir();\n-  320:         final Path file = symlinkDir.resolve(\"test.txt\");\n-  321:         try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {\n-  322:             // empty\n-  323:         }\n-  324:         try (OutputStream outputStream = PathUtils.newOutputStream(file, null)) {\n-  325:             // empty\n-  326:         }\n-  327:         try (OutputStream outputStream = PathUtils.newOutputStream(file, true)) {\n-  328:             // empty\n+   94:     private Path current() {\n+   95:         return PathUtils.current();\n+   96:     }\n+  278:     public void testIsDirectory() throws IOException {\n+  279:         assertFalse(PathUtils.isDirectory(null));\n+  280: \n+  281:         assertTrue(PathUtils.isDirectory(tempDirPath));\n+  282:         try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n+  283:             assertFalse(PathUtils.isDirectory(testFile1.get()));\n+  284: \n+  285:             Path ref = null;\n+  286:             try (TempDirectory tempDir = TempDirectory.create(getClass().getCanonicalName())) {\n+  287:                 ref = tempDir.get();\n+  319:     @Test\n+  320:     public void testNewDirectoryStream() throws Exception {\n+  321:         final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n+  322:         try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(current(), pathFilter)) {\n+  323:             final Iterator<Path> iterator = stream.iterator();\n+  324:             final Path path = iterator.next();\n+  325:             assertEquals(PATH_FIXTURE, path.getFileName().toString());\n+  326:             assertFalse(iterator.hasNext());\n+  327:         }\n+  328:     }\n", "uniqueId": "cb6f3aabcf872aeab3bb4c975d163f340b93f051_278_287_94_96_319_328", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testNewDirectoryStream` method, we can extract the logic that verifies the contents of the `DirectoryStream` into a separate method. This will make the test method cleaner and more focused on its purpose.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\n@Test\npublic void testNewDirectoryStream() throws Exception {\n    final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n    try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {\n        verifySingleFileInStream(stream, PATH_FIXTURE);\n    }\n}\n\nprivate void verifySingleFileInStream(DirectoryStream<Path> stream, String expectedFileName) {\n    final Iterator<Path> iterator = stream.iterator();\n    final Path path = iterator.next();\n    assertEquals(expectedFileName, path.getFileName().toString());\n    assertFalse(iterator.hasNext());\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic that checks the contents of the `DirectoryStream` has been moved to a new method called `verifySingleFileInStream`. This method takes the `DirectoryStream` and the expected file name as parameters.\n2. **Improved Readability**: The `testNewDirectoryStream` method is now more concise and clearly states its intent, which is to test the creation of a new directory stream.\n3. **Reusability**: The extracted method can be reused in other tests if similar functionality is needed in the future. \n\nThis refactoring enhances the modularity of the code and makes it easier to understand and maintain.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertThrowsExactly;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileAlreadyExistsException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link PathUtils}.\n */\npublic class PathUtilsTest extends AbstractTempDirTest {\n\n    private static final String STRING_FIXTURE = \"Hello World\";\n\n    private static final byte[] BYTE_ARRAY_FIXTURE = STRING_FIXTURE.getBytes(StandardCharsets.UTF_8);\n\n    private static final String TEST_JAR_NAME = \"test.jar\";\n\n    private static final String TEST_JAR_PATH = \"src/test/resources/org/apache/commons/io/test.jar\";\n\n    private static final String PATH_FIXTURE = \"NOTICE.txt\";\n\n    /**\n     * Creates directory test fixtures.\n     * <ol>\n     * <li>tempDirPath/subdir</li>\n     * <li>tempDirPath/symlinked-dir -> tempDirPath/subdir</li>\n     * </ol>\n     *\n     * @return Path to tempDirPath/subdir\n     * @throws IOException if an I/O error occurs or the parent directory does not exist.\n     */\n    private Path createTempSymlinkedRelativeDir() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symlinkDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symlinkDir, targetDir);\n        return symlinkDir;\n    }\n\n    private Long getLastModifiedMillis(final Path file) throws IOException {\n        return Files.getLastModifiedTime(file).toMillis();\n    }\n\n    private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n        if (createNew) {\n            final Map<String, String> env = new HashMap<>();\n            env.put(\"create\", \"true\");\n            final URI fileUri = p.toAbsolutePath().toUri();\n            final URI uri = URI.create(\"jar:\" + fileUri.toASCIIString());\n            return FileSystems.newFileSystem(uri, env, null);\n        }\n        return FileSystems.newFileSystem(p, (ClassLoader) null);\n    }\n\n    private void setLastModifiedMillis(final Path file, final long millis) throws IOException {\n        Files.setLastModifiedTime(file, FileTime.fromMillis(millis));\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false)) {\n            // relative jar -> absolute dir\n            Path sourceDir = archive.getPath(\"dir1\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"f1\")));\n\n            // absolute jar -> absolute dir\n            sourceDir = archive.getPath(\"/next\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"dir\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // absolute dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\").toAbsolutePath();\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // absolute dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false);\n            final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            final Path targetDir = targetArchive.getPath(\"targetDir\");\n            Files.createDirectory(targetDir);\n            // relative jar -> relative dir\n            Path sourceDir = archive.getPath(\"next\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dir\")));\n\n            // absolute jar -> relative dir\n            sourceDir = archive.getPath(\"/dir1\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"f1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // relative dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // relative dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyFile() throws IOException {\n        final Path sourceFile = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-1-file-size-1/file-size-1.bin\");\n        final Path targetFile = PathUtils.copyFileToDirectory(sourceFile, tempDirPath);\n        assertTrue(Files.exists(targetFile));\n        assertEquals(Files.size(sourceFile), Files.size(targetFile));\n    }\n\n    @Test\n    public void testCreateDirectoriesAlreadyExists() throws IOException {\n        assertEquals(tempDirPath.getParent(), PathUtils.createParentDirectories(tempDirPath));\n    }\n\n    @SuppressWarnings(\"resource\") // FileSystems.getDefault() is a singleton\n    @Test\n    public void testCreateDirectoriesForRoots() throws IOException {\n        for (final Path path : FileSystems.getDefault().getRootDirectories()) {\n            final Path parent = path.getParent();\n            assertNull(parent);\n            assertEquals(parent, PathUtils.createParentDirectories(path));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesForRootsLinkOptionNull() throws IOException {\n        for (final File f : File.listRoots()) {\n            final Path path = f.toPath();\n            assertEquals(path.getParent(), PathUtils.createParentDirectories(path, (LinkOption) null));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesNew() throws IOException {\n        assertEquals(tempDirPath, PathUtils.createParentDirectories(tempDirPath.resolve(\"child\")));\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlink() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        final String leafDirName = \"child\";\n        final Path newDirFollowed = PathUtils.createParentDirectories(symlinkedDir.resolve(leafDirName), PathUtils.NULL_LINK_OPTION);\n        assertEquals(Files.readSymbolicLink(symlinkedDir), newDirFollowed);\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlinkClashing() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        assertThrowsExactly(FileAlreadyExistsException.class, () -> PathUtils.createParentDirectories(symlinkedDir.resolve(\"child\")));\n    }\n\n    @Test\n    public void testGetTempDirectory() {\n        final Path tempDirectory = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n        assertEquals(tempDirectory, PathUtils.getTempDirectory());\n    }\n\n    @Test\n    public void testIsDirectory() throws IOException {\n        assertFalse(PathUtils.isDirectory(null));\n\n        assertTrue(PathUtils.isDirectory(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertFalse(PathUtils.isDirectory(testFile1.get()));\n\n            Path ref = null;\n            try (TempDirectory tempDir = TempDirectory.create(getClass().getCanonicalName())) {\n                ref = tempDir.get();\n                assertTrue(PathUtils.isDirectory(tempDir.get()));\n            }\n            assertFalse(PathUtils.isDirectory(ref));\n        }\n    }\n\n    @Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(PathUtils.current()));\n    }\n\n    @Test\n    public void testIsRegularFile() throws IOException {\n        assertFalse(PathUtils.isRegularFile(null));\n\n        assertFalse(PathUtils.isRegularFile(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertTrue(PathUtils.isRegularFile(testFile1.get()));\n\n            Files.delete(testFile1.get());\n            assertFalse(PathUtils.isRegularFile(testFile1.get()));\n        }\n    }\n\n    @Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n        final Path file = writeToNewOutputStream(true);\n        assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n    }\n\n    public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n        final Path file = writeToNewOutputStream(append);\n        assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileInsideExistingSymlinkedDir() throws IOException {\n        final Path symlinkDir = createTempSymlinkedRelativeDir();\n        final Path file = symlinkDir.resolve(\"test.txt\");\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, null)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, true)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, false)) {\n            // empty\n        }\n    }\n\n    @Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(PathUtils.current(), PosixFileAttributes.class) != null);\n    }\n\n    @Test\n    public void testReadStringEmptyFile() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-empty.bin\");\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testReadStringSimpleUtf8() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-simple-utf8.bin\");\n        final String expected = \"ABC\\r\\n\";\n        assertEquals(expected, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(expected, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testSetReadOnlyFile() throws IOException {\n        final Path resolved = tempDirPath.resolve(\"testSetReadOnlyFile.txt\");\n        // Ask now, as we are allowed before editing parent permissions.\n        final boolean isPosix = PathUtils.isPosix(tempDirPath);\n\n        // TEMP HACK\n        assumeFalse(SystemUtils.IS_OS_LINUX);\n\n        PathUtils.writeString(resolved, \"test\", StandardCharsets.UTF_8);\n        final boolean readable = Files.isReadable(resolved);\n        final boolean writable = Files.isWritable(resolved);\n        final boolean regularFile = Files.isRegularFile(resolved);\n        final boolean executable = Files.isExecutable(resolved);\n        final boolean hidden = Files.isHidden(resolved);\n        final boolean directory = Files.isDirectory(resolved);\n        final boolean symbolicLink = Files.isSymbolicLink(resolved);\n        // Sanity checks\n        assertTrue(readable);\n        assertTrue(writable);\n        // Test A\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        // Again, shouldn't blow up.\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        //\n        assertEquals(regularFile, Files.isReadable(resolved));\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        // Test B\n        PathUtils.setReadOnly(resolved, true);\n        if (isPosix) {\n            // On POSIX, now that the parent is not WX, the file is not readable.\n            assertFalse(Files.isReadable(resolved), \"isReadable\");\n        } else {\n            assertTrue(Files.isReadable(resolved), \"isReadable\");\n        }\n        assertFalse(Files.isWritable(resolved), \"isWritable\");\n        final DosFileAttributeView dosFileAttributeView = PathUtils.getDosFileAttributeView(resolved);\n        if (dosFileAttributeView != null) {\n            assertTrue(dosFileAttributeView.readAttributes().isReadOnly());\n        }\n        if (isPosix) {\n            assertFalse(Files.isReadable(resolved));\n        } else {\n            assertEquals(regularFile, Files.isReadable(resolved));\n        }\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        //\n        PathUtils.setReadOnly(resolved, false);\n        PathUtils.deleteFile(resolved);\n    }\n\n    @Test\n    public void testTouch() throws IOException {\n        assertThrows(NullPointerException.class, () -> FileUtils.touch(null));\n\n        final Path file = managedTempDirPath.resolve(\"touch.txt\");\n        Files.deleteIfExists(file);\n        assertFalse(Files.exists(file), \"Bad test: test file still exists\");\n        PathUtils.touch(file);\n        assertTrue(Files.exists(file), \"touch() created file\");\n        try (OutputStream out = Files.newOutputStream(file)) {\n            assertEquals(0, Files.size(file), \"Created empty file.\");\n            out.write(0);\n        }\n        assertEquals(1, Files.size(file), \"Wrote one byte to file\");\n        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();\n        setLastModifiedMillis(file, y2k);  // 0L fails on Win98\n        assertEquals(y2k, getLastModifiedMillis(file), \"Bad test: set lastModified set incorrect value\");\n        final long nowMillis = System.currentTimeMillis();\n        PathUtils.touch(file);\n        assertEquals(1, Files.size(file), \"FileUtils.touch() didn't empty the file.\");\n        assertNotEquals(y2k, getLastModifiedMillis(file), \"FileUtils.touch() changed lastModified\");\n        final int delta = 3000;\n        assertTrue(getLastModifiedMillis(file) >= nowMillis - delta, \"FileUtils.touch() changed lastModified to more than now-3s\");\n        assertTrue(getLastModifiedMillis(file) <= nowMillis + delta, \"FileUtils.touch() changed lastModified to less than now+3s\");\n    }\n\n    @Test\n    public void testWriteStringToFile1() throws Exception {\n        final Path file = tempDirPath.resolve(\"write.txt\");\n        PathUtils.writeString(file, \"Hello /u1234\", StandardCharsets.UTF_8);\n        final byte[] text = \"Hello /u1234\".getBytes(StandardCharsets.UTF_8);\n        TestUtils.assertEqualContent(text, file);\n    }\n\n    /**\n     * Tests newOutputStream() here and don't use Files.write obviously.\n     */\n    private Path writeToNewOutputStream(final boolean append) throws IOException {\n        final Path file = tempDirPath.resolve(\"test1.txt\");\n        try (OutputStream os = PathUtils.newOutputStream(file, append)) {\n            os.write(BYTE_ARRAY_FIXTURE);\n        }\n        return file;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tprivate current() : Path extracted from public testIsPosix() : void in class org.apache.commons.io.file.PathUtilsTest", "diffLocations": [{"filePath": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "startLine": 253, "endLine": 263, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "startLine": 294, "endLine": 304, "startColumn": 0, "endColumn": 0}, {"filePath": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "startLine": 94, "endLine": 96, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "@Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(PathUtils.current()));\n    }", "filePathBefore": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "isPureRefactoring": true, "commitId": "cb6f3aabcf872aeab3bb4c975d163f340b93f051", "packageNameBefore": "org.apache.commons.io.file", "classNameBefore": "org.apache.commons.io.file.PathUtilsTest", "methodNameBefore": "org.apache.commons.io.file.PathUtilsTest#testIsPosix", "invokedMethod": "methodSignature: org.apache.commons.io.file.PathUtils#current\n methodBody: public static Path current() {\nreturn Paths.get(\".\");\n}\nmethodSignature: org.apache.commons.io.file.PathUtils#isPosix\n methodBody: public static boolean isPosix(final Path test, final LinkOption... options) {\nreturn exists(test,options) && readPosixFileAttributes(test,options) != null;\n}", "classSignatureBefore": "public class PathUtilsTest extends AbstractTempDirTest ", "methodNameBeforeSet": ["org.apache.commons.io.file.PathUtilsTest#testIsPosix"], "classNameBeforeSet": ["org.apache.commons.io.file.PathUtilsTest"], "classSignatureBeforeSet": ["public class PathUtilsTest extends AbstractTempDirTest "], "purityCheckResultList": [{"isPure": true, "purityComment": "", "description": "Argument replaced with return expression - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertThrowsExactly;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileAlreadyExistsException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link PathUtils}.\n */\npublic class PathUtilsTest extends AbstractTempDirTest {\n\n    private static final String STRING_FIXTURE = \"Hello World\";\n\n    private static final byte[] BYTE_ARRAY_FIXTURE = STRING_FIXTURE.getBytes(StandardCharsets.UTF_8);\n\n    private static final String TEST_JAR_NAME = \"test.jar\";\n\n    private static final String TEST_JAR_PATH = \"src/test/resources/org/apache/commons/io/test.jar\";\n\n    private static final String PATH_FIXTURE = \"NOTICE.txt\";\n\n    /**\n     * Creates directory test fixtures.\n     * <ol>\n     * <li>tempDirPath/subdir</li>\n     * <li>tempDirPath/symlinked-dir -> tempDirPath/subdir</li>\n     * </ol>\n     *\n     * @return Path to tempDirPath/subdir\n     * @throws IOException if an I/O error occurs or the parent directory does not exist.\n     */\n    private Path createTempSymlinkedRelativeDir() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symlinkDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symlinkDir, targetDir);\n        return symlinkDir;\n    }\n\n    private Long getLastModifiedMillis(final Path file) throws IOException {\n        return Files.getLastModifiedTime(file).toMillis();\n    }\n\n    private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n        if (createNew) {\n            final Map<String, String> env = new HashMap<>();\n            env.put(\"create\", \"true\");\n            final URI fileUri = p.toAbsolutePath().toUri();\n            final URI uri = URI.create(\"jar:\" + fileUri.toASCIIString());\n            return FileSystems.newFileSystem(uri, env, null);\n        }\n        return FileSystems.newFileSystem(p, (ClassLoader) null);\n    }\n\n    private void setLastModifiedMillis(final Path file, final long millis) throws IOException {\n        Files.setLastModifiedTime(file, FileTime.fromMillis(millis));\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false)) {\n            // relative jar -> absolute dir\n            Path sourceDir = archive.getPath(\"dir1\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"f1\")));\n\n            // absolute jar -> absolute dir\n            sourceDir = archive.getPath(\"/next\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"dir\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // absolute dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\").toAbsolutePath();\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // absolute dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false);\n            final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            final Path targetDir = targetArchive.getPath(\"targetDir\");\n            Files.createDirectory(targetDir);\n            // relative jar -> relative dir\n            Path sourceDir = archive.getPath(\"next\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dir\")));\n\n            // absolute jar -> relative dir\n            sourceDir = archive.getPath(\"/dir1\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"f1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // relative dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // relative dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyFile() throws IOException {\n        final Path sourceFile = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-1-file-size-1/file-size-1.bin\");\n        final Path targetFile = PathUtils.copyFileToDirectory(sourceFile, tempDirPath);\n        assertTrue(Files.exists(targetFile));\n        assertEquals(Files.size(sourceFile), Files.size(targetFile));\n    }\n\n    @Test\n    public void testCreateDirectoriesAlreadyExists() throws IOException {\n        assertEquals(tempDirPath.getParent(), PathUtils.createParentDirectories(tempDirPath));\n    }\n\n    @SuppressWarnings(\"resource\") // FileSystems.getDefault() is a singleton\n    @Test\n    public void testCreateDirectoriesForRoots() throws IOException {\n        for (final Path path : FileSystems.getDefault().getRootDirectories()) {\n            final Path parent = path.getParent();\n            assertNull(parent);\n            assertEquals(parent, PathUtils.createParentDirectories(path));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesForRootsLinkOptionNull() throws IOException {\n        for (final File f : File.listRoots()) {\n            final Path path = f.toPath();\n            assertEquals(path.getParent(), PathUtils.createParentDirectories(path, (LinkOption) null));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesNew() throws IOException {\n        assertEquals(tempDirPath, PathUtils.createParentDirectories(tempDirPath.resolve(\"child\")));\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlink() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        final String leafDirName = \"child\";\n        final Path newDirFollowed = PathUtils.createParentDirectories(symlinkedDir.resolve(leafDirName), PathUtils.NULL_LINK_OPTION);\n        assertEquals(Files.readSymbolicLink(symlinkedDir), newDirFollowed);\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlinkClashing() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        assertThrowsExactly(FileAlreadyExistsException.class, () -> PathUtils.createParentDirectories(symlinkedDir.resolve(\"child\")));\n    }\n\n    @Test\n    public void testGetTempDirectory() {\n        final Path tempDirectory = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n        assertEquals(tempDirectory, PathUtils.getTempDirectory());\n    }\n\n    @Test\n    public void testIsDirectory() throws IOException {\n        assertFalse(PathUtils.isDirectory(null));\n\n        assertTrue(PathUtils.isDirectory(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertFalse(PathUtils.isDirectory(testFile1.get()));\n\n            Path ref = null;\n            try (TempDirectory tempDir = TempDirectory.create(getClass().getCanonicalName())) {\n                ref = tempDir.get();\n                assertTrue(PathUtils.isDirectory(tempDir.get()));\n            }\n            assertFalse(PathUtils.isDirectory(ref));\n        }\n    }\n\n    @Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(PathUtils.current()));\n    }\n\n    @Test\n    public void testIsRegularFile() throws IOException {\n        assertFalse(PathUtils.isRegularFile(null));\n\n        assertFalse(PathUtils.isRegularFile(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertTrue(PathUtils.isRegularFile(testFile1.get()));\n\n            Files.delete(testFile1.get());\n            assertFalse(PathUtils.isRegularFile(testFile1.get()));\n        }\n    }\n\n    @Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n        final Path file = writeToNewOutputStream(true);\n        assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n    }\n\n    public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n        final Path file = writeToNewOutputStream(append);\n        assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileInsideExistingSymlinkedDir() throws IOException {\n        final Path symlinkDir = createTempSymlinkedRelativeDir();\n        final Path file = symlinkDir.resolve(\"test.txt\");\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, null)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, true)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, false)) {\n            // empty\n        }\n    }\n\n    @Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(PathUtils.current(), PosixFileAttributes.class) != null);\n    }\n\n    @Test\n    public void testReadStringEmptyFile() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-empty.bin\");\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testReadStringSimpleUtf8() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-simple-utf8.bin\");\n        final String expected = \"ABC\\r\\n\";\n        assertEquals(expected, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(expected, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testSetReadOnlyFile() throws IOException {\n        final Path resolved = tempDirPath.resolve(\"testSetReadOnlyFile.txt\");\n        // Ask now, as we are allowed before editing parent permissions.\n        final boolean isPosix = PathUtils.isPosix(tempDirPath);\n\n        // TEMP HACK\n        assumeFalse(SystemUtils.IS_OS_LINUX);\n\n        PathUtils.writeString(resolved, \"test\", StandardCharsets.UTF_8);\n        final boolean readable = Files.isReadable(resolved);\n        final boolean writable = Files.isWritable(resolved);\n        final boolean regularFile = Files.isRegularFile(resolved);\n        final boolean executable = Files.isExecutable(resolved);\n        final boolean hidden = Files.isHidden(resolved);\n        final boolean directory = Files.isDirectory(resolved);\n        final boolean symbolicLink = Files.isSymbolicLink(resolved);\n        // Sanity checks\n        assertTrue(readable);\n        assertTrue(writable);\n        // Test A\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        // Again, shouldn't blow up.\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        //\n        assertEquals(regularFile, Files.isReadable(resolved));\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        // Test B\n        PathUtils.setReadOnly(resolved, true);\n        if (isPosix) {\n            // On POSIX, now that the parent is not WX, the file is not readable.\n            assertFalse(Files.isReadable(resolved), \"isReadable\");\n        } else {\n            assertTrue(Files.isReadable(resolved), \"isReadable\");\n        }\n        assertFalse(Files.isWritable(resolved), \"isWritable\");\n        final DosFileAttributeView dosFileAttributeView = PathUtils.getDosFileAttributeView(resolved);\n        if (dosFileAttributeView != null) {\n            assertTrue(dosFileAttributeView.readAttributes().isReadOnly());\n        }\n        if (isPosix) {\n            assertFalse(Files.isReadable(resolved));\n        } else {\n            assertEquals(regularFile, Files.isReadable(resolved));\n        }\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        //\n        PathUtils.setReadOnly(resolved, false);\n        PathUtils.deleteFile(resolved);\n    }\n\n    @Test\n    public void testTouch() throws IOException {\n        assertThrows(NullPointerException.class, () -> FileUtils.touch(null));\n\n        final Path file = managedTempDirPath.resolve(\"touch.txt\");\n        Files.deleteIfExists(file);\n        assertFalse(Files.exists(file), \"Bad test: test file still exists\");\n        PathUtils.touch(file);\n        assertTrue(Files.exists(file), \"touch() created file\");\n        try (OutputStream out = Files.newOutputStream(file)) {\n            assertEquals(0, Files.size(file), \"Created empty file.\");\n            out.write(0);\n        }\n        assertEquals(1, Files.size(file), \"Wrote one byte to file\");\n        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();\n        setLastModifiedMillis(file, y2k);  // 0L fails on Win98\n        assertEquals(y2k, getLastModifiedMillis(file), \"Bad test: set lastModified set incorrect value\");\n        final long nowMillis = System.currentTimeMillis();\n        PathUtils.touch(file);\n        assertEquals(1, Files.size(file), \"FileUtils.touch() didn't empty the file.\");\n        assertNotEquals(y2k, getLastModifiedMillis(file), \"FileUtils.touch() changed lastModified\");\n        final int delta = 3000;\n        assertTrue(getLastModifiedMillis(file) >= nowMillis - delta, \"FileUtils.touch() changed lastModified to more than now-3s\");\n        assertTrue(getLastModifiedMillis(file) <= nowMillis + delta, \"FileUtils.touch() changed lastModified to less than now+3s\");\n    }\n\n    @Test\n    public void testWriteStringToFile1() throws Exception {\n        final Path file = tempDirPath.resolve(\"write.txt\");\n        PathUtils.writeString(file, \"Hello /u1234\", StandardCharsets.UTF_8);\n        final byte[] text = \"Hello /u1234\".getBytes(StandardCharsets.UTF_8);\n        TestUtils.assertEqualContent(text, file);\n    }\n\n    /**\n     * Tests newOutputStream() here and don't use Files.write obviously.\n     */\n    private Path writeToNewOutputStream(final boolean append) throws IOException {\n        final Path file = tempDirPath.resolve(\"test1.txt\");\n        try (OutputStream os = PathUtils.newOutputStream(file, append)) {\n            os.write(BYTE_ARRAY_FIXTURE);\n        }\n        return file;\n    }\n\n}\n", "filePathAfter": "src/test/java/org/apache/commons/io/file/PathUtilsTest.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertThrowsExactly;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileAlreadyExistsException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link PathUtils}.\n */\npublic class PathUtilsTest extends AbstractTempDirTest {\n\n    private static final String STRING_FIXTURE = \"Hello World\";\n\n    private static final byte[] BYTE_ARRAY_FIXTURE = STRING_FIXTURE.getBytes(StandardCharsets.UTF_8);\n\n    private static final String TEST_JAR_NAME = \"test.jar\";\n\n    private static final String TEST_JAR_PATH = \"src/test/resources/org/apache/commons/io/test.jar\";\n\n    private static final String PATH_FIXTURE = \"NOTICE.txt\";\n\n    /**\n     * Creates directory test fixtures.\n     * <ol>\n     * <li>tempDirPath/subdir</li>\n     * <li>tempDirPath/symlinked-dir -> tempDirPath/subdir</li>\n     * </ol>\n     *\n     * @return Path to tempDirPath/subdir\n     * @throws IOException if an I/O error occurs or the parent directory does not exist.\n     */\n    private Path createTempSymlinkedRelativeDir() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symlinkDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symlinkDir, targetDir);\n        return symlinkDir;\n    }\n\n    private Path current() {\n        return PathUtils.current();\n    }\n\n    private Long getLastModifiedMillis(final Path file) throws IOException {\n        return Files.getLastModifiedTime(file).toMillis();\n    }\n\n    private Path getNonExistantPath() {\n        return Paths.get(\"/does not exist/for/certain\");\n    }\n\n    private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n        if (createNew) {\n            final Map<String, String> env = new HashMap<>();\n            env.put(\"create\", \"true\");\n            final URI fileUri = p.toAbsolutePath().toUri();\n            final URI uri = URI.create(\"jar:\" + fileUri.toASCIIString());\n            return FileSystems.newFileSystem(uri, env, null);\n        }\n        return FileSystems.newFileSystem(p, (ClassLoader) null);\n    }\n\n    private void setLastModifiedMillis(final Path file, final long millis) throws IOException {\n        Files.setLastModifiedTime(file, FileTime.fromMillis(millis));\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false)) {\n            // relative jar -> absolute dir\n            Path sourceDir = archive.getPath(\"dir1\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"f1\")));\n\n            // absolute jar -> absolute dir\n            sourceDir = archive.getPath(\"/next\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"dir\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // absolute dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\").toAbsolutePath();\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // absolute dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false);\n            final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            final Path targetDir = targetArchive.getPath(\"targetDir\");\n            Files.createDirectory(targetDir);\n            // relative jar -> relative dir\n            Path sourceDir = archive.getPath(\"next\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dir\")));\n\n            // absolute jar -> relative dir\n            sourceDir = archive.getPath(\"/dir1\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"f1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // relative dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // relative dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyFile() throws IOException {\n        final Path sourceFile = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-1-file-size-1/file-size-1.bin\");\n        final Path targetFile = PathUtils.copyFileToDirectory(sourceFile, tempDirPath);\n        assertTrue(Files.exists(targetFile));\n        assertEquals(Files.size(sourceFile), Files.size(targetFile));\n    }\n\n    @Test\n    public void testCreateDirectoriesAlreadyExists() throws IOException {\n        assertEquals(tempDirPath.getParent(), PathUtils.createParentDirectories(tempDirPath));\n    }\n\n    @SuppressWarnings(\"resource\") // FileSystems.getDefault() is a singleton\n    @Test\n    public void testCreateDirectoriesForRoots() throws IOException {\n        for (final Path path : FileSystems.getDefault().getRootDirectories()) {\n            final Path parent = path.getParent();\n            assertNull(parent);\n            assertEquals(parent, PathUtils.createParentDirectories(path));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesForRootsLinkOptionNull() throws IOException {\n        for (final File f : File.listRoots()) {\n            final Path path = f.toPath();\n            assertEquals(path.getParent(), PathUtils.createParentDirectories(path, (LinkOption) null));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesNew() throws IOException {\n        assertEquals(tempDirPath, PathUtils.createParentDirectories(tempDirPath.resolve(\"child\")));\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlink() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        final String leafDirName = \"child\";\n        final Path newDirFollowed = PathUtils.createParentDirectories(symlinkedDir.resolve(leafDirName), PathUtils.NULL_LINK_OPTION);\n        assertEquals(Files.readSymbolicLink(symlinkedDir), newDirFollowed);\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlinkClashing() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        assertThrowsExactly(FileAlreadyExistsException.class, () -> PathUtils.createParentDirectories(symlinkedDir.resolve(\"child\")));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_File_Present() throws IOException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current().toFile()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_Path_Absent() throws IOException {\n        assertNull(PathUtils.getLastModifiedFileTime(getNonExistantPath()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_Path_FileTime_Absent() throws IOException {\n        final FileTime fromMillis = FileTime.fromMillis(0);\n        assertEquals(fromMillis, PathUtils.getLastModifiedFileTime(getNonExistantPath(), fromMillis));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_Path_Present() throws IOException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_URI_Present() throws IOException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current().toUri()));\n    }\n\n    @Test\n    public void testGetLastModifiedFileTime_URL_Present() throws IOException, URISyntaxException {\n        assertNotNull(PathUtils.getLastModifiedFileTime(current().toUri().toURL()));\n    }\n\n    @Test\n    public void testGetTempDirectory() {\n        final Path tempDirectory = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n        assertEquals(tempDirectory, PathUtils.getTempDirectory());\n    }\n\n    @Test\n    public void testIsDirectory() throws IOException {\n        assertFalse(PathUtils.isDirectory(null));\n\n        assertTrue(PathUtils.isDirectory(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertFalse(PathUtils.isDirectory(testFile1.get()));\n\n            Path ref = null;\n            try (TempDirectory tempDir = TempDirectory.create(getClass().getCanonicalName())) {\n                ref = tempDir.get();\n                assertTrue(PathUtils.isDirectory(tempDir.get()));\n            }\n            assertFalse(PathUtils.isDirectory(ref));\n        }\n    }\n\n    @Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(current()));\n    }\n\n    @Test\n    public void testIsRegularFile() throws IOException {\n        assertFalse(PathUtils.isRegularFile(null));\n\n        assertFalse(PathUtils.isRegularFile(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertTrue(PathUtils.isRegularFile(testFile1.get()));\n\n            Files.delete(testFile1.get());\n            assertFalse(PathUtils.isRegularFile(testFile1.get()));\n        }\n    }\n\n    @Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n        final Path file = writeToNewOutputStream(true);\n        assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n    }\n\n    public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n        final Path file = writeToNewOutputStream(append);\n        assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileInsideExistingSymlinkedDir() throws IOException {\n        final Path symlinkDir = createTempSymlinkedRelativeDir();\n        final Path file = symlinkDir.resolve(\"test.txt\");\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, null)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, true)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, false)) {\n            // empty\n        }\n    }\n\n    @Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(current(), PosixFileAttributes.class) != null);\n    }\n\n    @Test\n    public void testReadStringEmptyFile() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-empty.bin\");\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testReadStringSimpleUtf8() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-simple-utf8.bin\");\n        final String expected = \"ABC\\r\\n\";\n        assertEquals(expected, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(expected, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testSetReadOnlyFile() throws IOException {\n        final Path resolved = tempDirPath.resolve(\"testSetReadOnlyFile.txt\");\n        // Ask now, as we are allowed before editing parent permissions.\n        final boolean isPosix = PathUtils.isPosix(tempDirPath);\n\n        // TEMP HACK\n        assumeFalse(SystemUtils.IS_OS_LINUX);\n\n        PathUtils.writeString(resolved, \"test\", StandardCharsets.UTF_8);\n        final boolean readable = Files.isReadable(resolved);\n        final boolean writable = Files.isWritable(resolved);\n        final boolean regularFile = Files.isRegularFile(resolved);\n        final boolean executable = Files.isExecutable(resolved);\n        final boolean hidden = Files.isHidden(resolved);\n        final boolean directory = Files.isDirectory(resolved);\n        final boolean symbolicLink = Files.isSymbolicLink(resolved);\n        // Sanity checks\n        assertTrue(readable);\n        assertTrue(writable);\n        // Test A\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        // Again, shouldn't blow up.\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        //\n        assertEquals(regularFile, Files.isReadable(resolved));\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        // Test B\n        PathUtils.setReadOnly(resolved, true);\n        if (isPosix) {\n            // On POSIX, now that the parent is not WX, the file is not readable.\n            assertFalse(Files.isReadable(resolved), \"isReadable\");\n        } else {\n            assertTrue(Files.isReadable(resolved), \"isReadable\");\n        }\n        assertFalse(Files.isWritable(resolved), \"isWritable\");\n        final DosFileAttributeView dosFileAttributeView = PathUtils.getDosFileAttributeView(resolved);\n        if (dosFileAttributeView != null) {\n            assertTrue(dosFileAttributeView.readAttributes().isReadOnly());\n        }\n        if (isPosix) {\n            assertFalse(Files.isReadable(resolved));\n        } else {\n            assertEquals(regularFile, Files.isReadable(resolved));\n        }\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        //\n        PathUtils.setReadOnly(resolved, false);\n        PathUtils.deleteFile(resolved);\n    }\n\n    @Test\n    public void testTouch() throws IOException {\n        assertThrows(NullPointerException.class, () -> FileUtils.touch(null));\n\n        final Path file = managedTempDirPath.resolve(\"touch.txt\");\n        Files.deleteIfExists(file);\n        assertFalse(Files.exists(file), \"Bad test: test file still exists\");\n        PathUtils.touch(file);\n        assertTrue(Files.exists(file), \"touch() created file\");\n        try (OutputStream out = Files.newOutputStream(file)) {\n            assertEquals(0, Files.size(file), \"Created empty file.\");\n            out.write(0);\n        }\n        assertEquals(1, Files.size(file), \"Wrote one byte to file\");\n        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();\n        setLastModifiedMillis(file, y2k);  // 0L fails on Win98\n        assertEquals(y2k, getLastModifiedMillis(file), \"Bad test: set lastModified set incorrect value\");\n        final long nowMillis = System.currentTimeMillis();\n        PathUtils.touch(file);\n        assertEquals(1, Files.size(file), \"FileUtils.touch() didn't empty the file.\");\n        assertNotEquals(y2k, getLastModifiedMillis(file), \"FileUtils.touch() changed lastModified\");\n        final int delta = 3000;\n        assertTrue(getLastModifiedMillis(file) >= nowMillis - delta, \"FileUtils.touch() changed lastModified to more than now-3s\");\n        assertTrue(getLastModifiedMillis(file) <= nowMillis + delta, \"FileUtils.touch() changed lastModified to less than now+3s\");\n    }\n\n    @Test\n    public void testWriteStringToFile1() throws Exception {\n        final Path file = tempDirPath.resolve(\"write.txt\");\n        PathUtils.writeString(file, \"Hello /u1234\", StandardCharsets.UTF_8);\n        final byte[] text = \"Hello /u1234\".getBytes(StandardCharsets.UTF_8);\n        TestUtils.assertEqualContent(text, file);\n    }\n\n    /**\n     * Tests newOutputStream() here and don't use Files.write obviously.\n     */\n    private Path writeToNewOutputStream(final boolean append) throws IOException {\n        final Path file = tempDirPath.resolve(\"test1.txt\");\n        try (OutputStream os = PathUtils.newOutputStream(file, append)) {\n            os.write(BYTE_ARRAY_FIXTURE);\n        }\n        return file;\n    }\n\n}\n", "diffSourceCodeSet": ["private Path current() {\n        return PathUtils.current();\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.file.PathUtils#current\n methodBody: public static Path current() {\nreturn Paths.get(\".\");\n}", "methodSignature: org.apache.commons.io.file.PathUtils#isPosix\n methodBody: public static boolean isPosix(final Path test, final LinkOption... options) {\nreturn exists(test,options) && readPosixFileAttributes(test,options) != null;\n}"], "sourceCodeAfterRefactoring": "@Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(current()));\n    }\nprivate Path current() {\n        return PathUtils.current();\n    }", "diffSourceCode": "-   94:     }\n-   95: \n-   96:     private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n-  253:     @Test\n-  254:     public void testIsPosix() throws IOException {\n-  255:         boolean isPosix;\n-  256:         try {\n-  257:             Files.getPosixFilePermissions(PathUtils.current());\n-  258:             isPosix = true;\n-  259:         } catch (final UnsupportedOperationException e) {\n-  260:             isPosix = false;\n-  261:         }\n-  262:         assertEquals(isPosix, PathUtils.isPosix(PathUtils.current()));\n-  263:     }\n-  294: \n-  295:     @Test\n-  296:     public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n-  297:         testNewOutputStreamNewFile(true);\n-  298:         final Path file = writeToNewOutputStream(true);\n-  299:         assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n-  300:     }\n-  301: \n-  302:     public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n-  303:         final Path file = writeToNewOutputStream(append);\n-  304:         assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n+   94:     private Path current() {\n+   95:         return PathUtils.current();\n+   96:     }\n+  253:         assertEquals(fromMillis, PathUtils.getLastModifiedFileTime(getNonExistantPath(), fromMillis));\n+  254:     }\n+  255: \n+  256:     @Test\n+  257:     public void testGetLastModifiedFileTime_Path_Present() throws IOException {\n+  258:         assertNotNull(PathUtils.getLastModifiedFileTime(current()));\n+  259:     }\n+  260: \n+  261:     @Test\n+  262:     public void testGetLastModifiedFileTime_URI_Present() throws IOException {\n+  263:         assertNotNull(PathUtils.getLastModifiedFileTime(current().toUri()));\n+  294:     @Test\n+  295:     public void testIsPosix() throws IOException {\n+  296:         boolean isPosix;\n+  297:         try {\n+  298:             Files.getPosixFilePermissions(current());\n+  299:             isPosix = true;\n+  300:         } catch (final UnsupportedOperationException e) {\n+  301:             isPosix = false;\n+  302:         }\n+  303:         assertEquals(isPosix, PathUtils.isPosix(current()));\n+  304:     }\n", "uniqueId": "cb6f3aabcf872aeab3bb4c975d163f340b93f051_253_263_94_96_294_304", "moveFileExist": true, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "testResult": true, "coverageInfo": {"testMethod": {"missed": 0, "covered": 1}}, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `testIsPosix` method, we can extract the logic that checks if the file system supports POSIX file permissions into a separate method. This will make the test method cleaner and more focused on its purpose, which is to assert the expected behavior.\n\nHere\u2019s the refactored code:\n\n```java\n@Test\npublic void testIsPosix() throws IOException {\n    boolean isPosix = isPosixFileSystem();\n    assertEquals(isPosix, PathUtils.isPosix(PathUtils.current()));\n}\n\nprivate boolean isPosixFileSystem() {\n    try {\n        Files.getPosixFilePermissions(PathUtils.current());\n        return true;\n    } catch (final UnsupportedOperationException e) {\n        return false;\n    }\n}\n```\n\nThe extracted method `isPosixFileSystem` encapsulates the logic for determining if the file system is POSIX-compliant, making the test method `testIsPosix` cleaner and easier to read.\n\nHere\u2019s the output in the requested format:\n\n##########################\n```java\nprivate boolean isPosixFileSystem() {\n    try {\n        Files.getPosixFilePermissions(PathUtils.current());\n        return true;\n    } catch (final UnsupportedOperationException e) {\n        return false;\n    }\n}\n```\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n@Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(PathUtils.current()));\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.commons.io.file;\n\nimport static org.junit.jupiter.api.Assertions.assertArrayEquals;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertNotEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\nimport static org.junit.jupiter.api.Assertions.assertThrowsExactly;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.junit.jupiter.api.Assumptions.assumeFalse;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.FileAlreadyExistsException;\nimport java.nio.file.FileSystem;\nimport java.nio.file.FileSystems;\nimport java.nio.file.Files;\nimport java.nio.file.LinkOption;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.attribute.DosFileAttributeView;\nimport java.nio.file.attribute.FileTime;\nimport java.nio.file.attribute.PosixFileAttributes;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.commons.io.filefilter.NameFileFilter;\nimport org.apache.commons.io.test.TestUtils;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.SystemUtils;\nimport org.junit.jupiter.api.Test;\n\n/**\n * Tests {@link PathUtils}.\n */\npublic class PathUtilsTest extends AbstractTempDirTest {\n\n    private static final String STRING_FIXTURE = \"Hello World\";\n\n    private static final byte[] BYTE_ARRAY_FIXTURE = STRING_FIXTURE.getBytes(StandardCharsets.UTF_8);\n\n    private static final String TEST_JAR_NAME = \"test.jar\";\n\n    private static final String TEST_JAR_PATH = \"src/test/resources/org/apache/commons/io/test.jar\";\n\n    private static final String PATH_FIXTURE = \"NOTICE.txt\";\n\n    /**\n     * Creates directory test fixtures.\n     * <ol>\n     * <li>tempDirPath/subdir</li>\n     * <li>tempDirPath/symlinked-dir -> tempDirPath/subdir</li>\n     * </ol>\n     *\n     * @return Path to tempDirPath/subdir\n     * @throws IOException if an I/O error occurs or the parent directory does not exist.\n     */\n    private Path createTempSymlinkedRelativeDir() throws IOException {\n        final Path targetDir = tempDirPath.resolve(\"subdir\");\n        final Path symlinkDir = tempDirPath.resolve(\"symlinked-dir\");\n        Files.createDirectory(targetDir);\n        Files.createSymbolicLink(symlinkDir, targetDir);\n        return symlinkDir;\n    }\n\n    private Long getLastModifiedMillis(final Path file) throws IOException {\n        return Files.getLastModifiedTime(file).toMillis();\n    }\n\n    private FileSystem openArchive(final Path p, final boolean createNew) throws IOException {\n        if (createNew) {\n            final Map<String, String> env = new HashMap<>();\n            env.put(\"create\", \"true\");\n            final URI fileUri = p.toAbsolutePath().toUri();\n            final URI uri = URI.create(\"jar:\" + fileUri.toASCIIString());\n            return FileSystems.newFileSystem(uri, env, null);\n        }\n        return FileSystems.newFileSystem(p, (ClassLoader) null);\n    }\n\n    private void setLastModifiedMillis(final Path file, final long millis) throws IOException {\n        Files.setLastModifiedTime(file, FileTime.fromMillis(millis));\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false)) {\n            // relative jar -> absolute dir\n            Path sourceDir = archive.getPath(\"dir1\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"f1\")));\n\n            // absolute jar -> absolute dir\n            sourceDir = archive.getPath(\"/next\");\n            PathUtils.copyDirectory(sourceDir, tempDirPath);\n            assertTrue(Files.exists(tempDirPath.resolve(\"dir\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithAbsolutePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // absolute dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\").toAbsolutePath();\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // absolute dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePath() throws IOException {\n        final Path archivePath = Paths.get(TEST_JAR_PATH);\n        try (FileSystem archive = openArchive(archivePath, false);\n            final FileSystem targetArchive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            final Path targetDir = targetArchive.getPath(\"targetDir\");\n            Files.createDirectory(targetDir);\n            // relative jar -> relative dir\n            Path sourceDir = archive.getPath(\"next\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dir\")));\n\n            // absolute jar -> relative dir\n            sourceDir = archive.getPath(\"/dir1\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"f1\")));\n        }\n    }\n\n    @Test\n    public void testCopyDirectoryForDifferentFilesystemsWithRelativePathReverse() throws IOException {\n        try (FileSystem archive = openArchive(tempDirPath.resolve(TEST_JAR_NAME), true)) {\n            // relative dir -> relative jar\n            Path targetDir = archive.getPath(\"target\");\n            Files.createDirectory(targetDir);\n            final Path sourceDir = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-2-file-size-2\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n\n            // relative dir -> absolute jar\n            targetDir = archive.getPath(\"/\");\n            PathUtils.copyDirectory(sourceDir, targetDir);\n            assertTrue(Files.exists(targetDir.resolve(\"dirs-a-file-size-1\")));\n        }\n    }\n\n    @Test\n    public void testCopyFile() throws IOException {\n        final Path sourceFile = Paths.get(\"src/test/resources/org/apache/commons/io/dirs-1-file-size-1/file-size-1.bin\");\n        final Path targetFile = PathUtils.copyFileToDirectory(sourceFile, tempDirPath);\n        assertTrue(Files.exists(targetFile));\n        assertEquals(Files.size(sourceFile), Files.size(targetFile));\n    }\n\n    @Test\n    public void testCreateDirectoriesAlreadyExists() throws IOException {\n        assertEquals(tempDirPath.getParent(), PathUtils.createParentDirectories(tempDirPath));\n    }\n\n    @SuppressWarnings(\"resource\") // FileSystems.getDefault() is a singleton\n    @Test\n    public void testCreateDirectoriesForRoots() throws IOException {\n        for (final Path path : FileSystems.getDefault().getRootDirectories()) {\n            final Path parent = path.getParent();\n            assertNull(parent);\n            assertEquals(parent, PathUtils.createParentDirectories(path));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesForRootsLinkOptionNull() throws IOException {\n        for (final File f : File.listRoots()) {\n            final Path path = f.toPath();\n            assertEquals(path.getParent(), PathUtils.createParentDirectories(path, (LinkOption) null));\n        }\n    }\n\n    @Test\n    public void testCreateDirectoriesNew() throws IOException {\n        assertEquals(tempDirPath, PathUtils.createParentDirectories(tempDirPath.resolve(\"child\")));\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlink() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        final String leafDirName = \"child\";\n        final Path newDirFollowed = PathUtils.createParentDirectories(symlinkedDir.resolve(leafDirName), PathUtils.NULL_LINK_OPTION);\n        assertEquals(Files.readSymbolicLink(symlinkedDir), newDirFollowed);\n    }\n\n    @Test\n    public void testCreateDirectoriesSymlinkClashing() throws IOException {\n        final Path symlinkedDir = createTempSymlinkedRelativeDir();\n        assertThrowsExactly(FileAlreadyExistsException.class, () -> PathUtils.createParentDirectories(symlinkedDir.resolve(\"child\")));\n    }\n\n    @Test\n    public void testGetTempDirectory() {\n        final Path tempDirectory = Paths.get(System.getProperty(\"java.io.tmpdir\"));\n        assertEquals(tempDirectory, PathUtils.getTempDirectory());\n    }\n\n    @Test\n    public void testIsDirectory() throws IOException {\n        assertFalse(PathUtils.isDirectory(null));\n\n        assertTrue(PathUtils.isDirectory(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertFalse(PathUtils.isDirectory(testFile1.get()));\n\n            Path ref = null;\n            try (TempDirectory tempDir = TempDirectory.create(getClass().getCanonicalName())) {\n                ref = tempDir.get();\n                assertTrue(PathUtils.isDirectory(tempDir.get()));\n            }\n            assertFalse(PathUtils.isDirectory(ref));\n        }\n    }\n\n    @Test\n    public void testIsPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.isPosix(PathUtils.current()));\n    }\n\n    @Test\n    public void testIsRegularFile() throws IOException {\n        assertFalse(PathUtils.isRegularFile(null));\n\n        assertFalse(PathUtils.isRegularFile(tempDirPath));\n        try (TempFile testFile1 = TempFile.create(tempDirPath, \"prefix\", null)) {\n            assertTrue(PathUtils.isRegularFile(testFile1.get()));\n\n            Files.delete(testFile1.get());\n            assertFalse(PathUtils.isRegularFile(testFile1.get()));\n        }\n    }\n\n    @Test\n    public void testNewDirectoryStream() throws Exception {\n        final PathFilter pathFilter = new NameFileFilter(PATH_FIXTURE);\n        try (DirectoryStream<Path> stream = PathUtils.newDirectoryStream(PathUtils.current(), pathFilter)) {\n            final Iterator<Path> iterator = stream.iterator();\n            final Path path = iterator.next();\n            assertEquals(PATH_FIXTURE, path.getFileName().toString());\n            assertFalse(iterator.hasNext());\n        }\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamExistingFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n        final Path file = writeToNewOutputStream(true);\n        assertArrayEquals(ArrayUtils.addAll(BYTE_ARRAY_FIXTURE, BYTE_ARRAY_FIXTURE), Files.readAllBytes(file));\n    }\n\n    public void testNewOutputStreamNewFile(final boolean append) throws IOException {\n        final Path file = writeToNewOutputStream(append);\n        assertArrayEquals(BYTE_ARRAY_FIXTURE, Files.readAllBytes(file));\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendFalse() throws IOException {\n        testNewOutputStreamNewFile(false);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileAppendTrue() throws IOException {\n        testNewOutputStreamNewFile(true);\n    }\n\n    @Test\n    public void testNewOutputStreamNewFileInsideExistingSymlinkedDir() throws IOException {\n        final Path symlinkDir = createTempSymlinkedRelativeDir();\n        final Path file = symlinkDir.resolve(\"test.txt\");\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, new LinkOption[] {})) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, null)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, true)) {\n            // empty\n        }\n        try (OutputStream outputStream = PathUtils.newOutputStream(file, false)) {\n            // empty\n        }\n    }\n\n    @Test\n    public void testReadAttributesPosix() throws IOException {\n        boolean isPosix;\n        try {\n            Files.getPosixFilePermissions(PathUtils.current());\n            isPosix = true;\n        } catch (final UnsupportedOperationException e) {\n            isPosix = false;\n        }\n        assertEquals(isPosix, PathUtils.readAttributes(PathUtils.current(), PosixFileAttributes.class) != null);\n    }\n\n    @Test\n    public void testReadStringEmptyFile() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-empty.bin\");\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(StringUtils.EMPTY, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testReadStringSimpleUtf8() throws IOException {\n        final Path path = Paths.get(\"src/test/resources/org/apache/commons/io/test-file-simple-utf8.bin\");\n        final String expected = \"ABC\\r\\n\";\n        assertEquals(expected, PathUtils.readString(path, StandardCharsets.UTF_8));\n        assertEquals(expected, PathUtils.readString(path, null));\n    }\n\n    @Test\n    public void testSetReadOnlyFile() throws IOException {\n        final Path resolved = tempDirPath.resolve(\"testSetReadOnlyFile.txt\");\n        // Ask now, as we are allowed before editing parent permissions.\n        final boolean isPosix = PathUtils.isPosix(tempDirPath);\n\n        // TEMP HACK\n        assumeFalse(SystemUtils.IS_OS_LINUX);\n\n        PathUtils.writeString(resolved, \"test\", StandardCharsets.UTF_8);\n        final boolean readable = Files.isReadable(resolved);\n        final boolean writable = Files.isWritable(resolved);\n        final boolean regularFile = Files.isRegularFile(resolved);\n        final boolean executable = Files.isExecutable(resolved);\n        final boolean hidden = Files.isHidden(resolved);\n        final boolean directory = Files.isDirectory(resolved);\n        final boolean symbolicLink = Files.isSymbolicLink(resolved);\n        // Sanity checks\n        assertTrue(readable);\n        assertTrue(writable);\n        // Test A\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        // Again, shouldn't blow up.\n        PathUtils.setReadOnly(resolved, false);\n        assertTrue(Files.isReadable(resolved), \"isReadable\");\n        assertTrue(Files.isWritable(resolved), \"isWritable\");\n        //\n        assertEquals(regularFile, Files.isReadable(resolved));\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        // Test B\n        PathUtils.setReadOnly(resolved, true);\n        if (isPosix) {\n            // On POSIX, now that the parent is not WX, the file is not readable.\n            assertFalse(Files.isReadable(resolved), \"isReadable\");\n        } else {\n            assertTrue(Files.isReadable(resolved), \"isReadable\");\n        }\n        assertFalse(Files.isWritable(resolved), \"isWritable\");\n        final DosFileAttributeView dosFileAttributeView = PathUtils.getDosFileAttributeView(resolved);\n        if (dosFileAttributeView != null) {\n            assertTrue(dosFileAttributeView.readAttributes().isReadOnly());\n        }\n        if (isPosix) {\n            assertFalse(Files.isReadable(resolved));\n        } else {\n            assertEquals(regularFile, Files.isReadable(resolved));\n        }\n        assertEquals(executable, Files.isExecutable(resolved));\n        assertEquals(hidden, Files.isHidden(resolved));\n        assertEquals(directory, Files.isDirectory(resolved));\n        assertEquals(symbolicLink, Files.isSymbolicLink(resolved));\n        //\n        PathUtils.setReadOnly(resolved, false);\n        PathUtils.deleteFile(resolved);\n    }\n\n    @Test\n    public void testTouch() throws IOException {\n        assertThrows(NullPointerException.class, () -> FileUtils.touch(null));\n\n        final Path file = managedTempDirPath.resolve(\"touch.txt\");\n        Files.deleteIfExists(file);\n        assertFalse(Files.exists(file), \"Bad test: test file still exists\");\n        PathUtils.touch(file);\n        assertTrue(Files.exists(file), \"touch() created file\");\n        try (OutputStream out = Files.newOutputStream(file)) {\n            assertEquals(0, Files.size(file), \"Created empty file.\");\n            out.write(0);\n        }\n        assertEquals(1, Files.size(file), \"Wrote one byte to file\");\n        final long y2k = new GregorianCalendar(2000, 0, 1).getTime().getTime();\n        setLastModifiedMillis(file, y2k);  // 0L fails on Win98\n        assertEquals(y2k, getLastModifiedMillis(file), \"Bad test: set lastModified set incorrect value\");\n        final long nowMillis = System.currentTimeMillis();\n        PathUtils.touch(file);\n        assertEquals(1, Files.size(file), \"FileUtils.touch() didn't empty the file.\");\n        assertNotEquals(y2k, getLastModifiedMillis(file), \"FileUtils.touch() changed lastModified\");\n        final int delta = 3000;\n        assertTrue(getLastModifiedMillis(file) >= nowMillis - delta, \"FileUtils.touch() changed lastModified to more than now-3s\");\n        assertTrue(getLastModifiedMillis(file) <= nowMillis + delta, \"FileUtils.touch() changed lastModified to less than now+3s\");\n    }\n\n    @Test\n    public void testWriteStringToFile1() throws Exception {\n        final Path file = tempDirPath.resolve(\"write.txt\");\n        PathUtils.writeString(file, \"Hello /u1234\", StandardCharsets.UTF_8);\n        final byte[] text = \"Hello /u1234\".getBytes(StandardCharsets.UTF_8);\n        TestUtils.assertEqualContent(text, file);\n    }\n\n    /**\n     * Tests newOutputStream() here and don't use Files.write obviously.\n     */\n    private Path writeToNewOutputStream(final boolean append) throws IOException {\n        final Path file = tempDirPath.resolve(\"test1.txt\");\n        try (OutputStream os = PathUtils.newOutputStream(file, append)) {\n            os.write(BYTE_ARRAY_FIXTURE);\n        }\n        return file;\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract And Move Method", "description": "Extract And Move Method\tpackage get(supplier IOSupplier<FileVisitResult>) : FileVisitResult extracted from public accept(file Path, attributes BasicFileAttributes) : FileVisitResult in class org.apache.commons.io.filefilter.SizeFileFilter & moved to class org.apache.commons.io.filefilter.AbstractFileFilter", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java", "startLine": 126, "endLine": 145, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java", "startLine": 126, "endLine": 141, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java", "startLine": 120, "endLine": 126, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Checks to see if the size of the file is favorable.\n     * <p>\n     * If size equals threshold and smaller files are required,\n     * file <b>IS NOT</b> selected.\n     * If size equals threshold and larger files are required,\n     * file <b>IS</b> selected.\n     * </p>\n     * @param file  the File to check\n     *\n     * @return true if the file name matches\n     */\n    @Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        try {\n            return toFileVisitResult(accept(Files.size(file)));\n        } catch (final IOException e) {\n            return handle(e);\n        }\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java", "isPureRefactoring": true, "commitId": "0d84f279d6dd6486b581acf2ea2ad212530e16fc", "packageNameBefore": "org.apache.commons.io.filefilter", "classNameBefore": "org.apache.commons.io.filefilter.SizeFileFilter", "methodNameBefore": "org.apache.commons.io.filefilter.SizeFileFilter#accept", "invokedMethod": "methodSignature: org.apache.commons.io.filefilter.EmptyFileFilter#accept\n methodBody: public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\ntryif(Files.isDirectory(file)){try(Stream<Path> stream=Files.list(file))return toFileVisitResult(!stream.findFirst().isPresent());\n}return toFileVisitResult(Files.size(file) == 0);\ncatch(final IOException e)return handle(e);\n}\nmethodSignature: org.apache.commons.io.filefilter.AgeFileFilter#accept\n methodBody: public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\ntryreturn toFileVisitResult(acceptOlder != PathUtils.isNewer(file,cutoffInstant));\ncatch(final IOException e)return handle(e);\n}\nmethodSignature: org.apache.commons.io.filefilter.SizeFileFilter#accept\n methodBody: public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\ntryreturn toFileVisitResult(accept(Files.size(file)));\ncatch(final IOException e)return handle(e);\n}\nmethodSignature: org.apache.commons.io.filefilter.AbstractFileFilter#handle\n methodBody: protected FileVisitResult handle(final Throwable t) {\nreturn FileVisitResult.TERMINATE;\n}\nmethodSignature: org.apache.commons.io.filefilter.HiddenFileFilter#accept\n methodBody: public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\ntryreturn toFileVisitResult(Files.isHidden(file));\ncatch(final IOException e)return handle(e);\n}\nmethodSignature: org.apache.commons.io.filefilter.AbstractFileFilter#toFileVisitResult\n methodBody: FileVisitResult toFileVisitResult(final boolean accept) {\nreturn accept ? onAccept : onReject;\n}\nmethodSignature: org.apache.commons.io.filefilter.AbstractFileFilter#accept\n methodBody: public boolean accept(final File dir, final String name) {\nObjects.requireNonNull(name,\"name\");\nreturn accept(new File(dir,name));\n}\nmethodSignature: org.apache.commons.io.filefilter.PathVisitorFileFilter#accept\n methodBody: public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {\ntryreturn Files.isDirectory(path) ? pathVisitor.postVisitDirectory(path,null) : visitFile(path,attributes);\ncatch(final IOException e)return handle(e);\n}", "classSignatureBefore": "public class SizeFileFilter extends AbstractFileFilter implements Serializable ", "methodNameBeforeSet": ["org.apache.commons.io.filefilter.SizeFileFilter#accept"], "classNameBeforeSet": ["org.apache.commons.io.filefilter.SizeFileFilter"], "classSignatureBeforeSet": ["public class SizeFileFilter extends AbstractFileFilter implements Serializable "], "purityCheckResultList": [{"isPure": true, "purityComment": " Severe changes", "description": "Return expression has been added within the Extract Method mechanics - with non-mapped leaves", "mappingState": 2}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.BasicFileAttributes;\n\n/**\n * Filters files based on size, can filter either smaller files or\n * files equal to or larger than a given threshold.\n * <p>\n * For example, to print all files and directories in the\n * current directory whose size is greater than 1 MB:\n * </p>\n * <h2>Using Classic IO</h2>\n * <pre>\n * File dir = FileUtils.current();\n * String[] files = dir.list(new SizeFileFilter(1024 * 1024));\n * for (String file : files) {\n *     System.out.println(file);\n * }\n * </pre>\n *\n * <h2>Using NIO</h2>\n * <pre>\n * final Path dir = PathUtils.current();\n * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new SizeFileFilter(1024 * 1024));\n * //\n * // Walk one dir\n * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);\n * System.out.println(visitor.getPathCounters());\n * System.out.println(visitor.getFileList());\n * //\n * visitor.getPathCounters().reset();\n * //\n * // Walk dir tree\n * Files.<b>walkFileTree</b>(dir, visitor);\n * System.out.println(visitor.getPathCounters());\n * System.out.println(visitor.getDirList());\n * System.out.println(visitor.getFileList());\n * </pre>\n *\n * @since 1.2\n * @see FileFilterUtils#sizeFileFilter(long)\n * @see FileFilterUtils#sizeFileFilter(long, boolean)\n * @see FileFilterUtils#sizeRangeFileFilter(long, long)\n */\npublic class SizeFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = 7388077430788600069L;\n\n    /** Whether the files accepted will be larger or smaller. */\n    private final boolean acceptLarger;\n\n    /** The size threshold. */\n    private final long size;\n\n    /**\n     * Constructs a new size file filter for files equal to or\n     * larger than a certain size.\n     *\n     * @param size  the threshold size of the files\n     * @throws IllegalArgumentException if the size is negative\n     */\n    public SizeFileFilter(final long size) {\n        this(size, true);\n    }\n\n    /**\n     * Constructs a new size file filter for files based on a certain size\n     * threshold.\n     *\n     * @param size  the threshold size of the files\n     * @param acceptLarger  if true, files equal to or larger are accepted,\n     * otherwise smaller ones (but not equal to)\n     * @throws IllegalArgumentException if the size is negative\n     */\n    public SizeFileFilter(final long size, final boolean acceptLarger) {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"The size must be non-negative\");\n        }\n        this.size = size;\n        this.acceptLarger = acceptLarger;\n    }\n\n    /**\n     * Checks to see if the size of the file is favorable.\n     * <p>\n     * If size equals threshold and smaller files are required,\n     * file <b>IS NOT</b> selected.\n     * If size equals threshold and larger files are required,\n     * file <b>IS</b> selected.\n     * </p>\n     *\n     * @param file  the File to check\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File file) {\n        return accept(file.length());\n    }\n\n    private boolean accept(final long length) {\n        return acceptLarger != length < size;\n    }\n\n    /**\n     * Checks to see if the size of the file is favorable.\n     * <p>\n     * If size equals threshold and smaller files are required,\n     * file <b>IS NOT</b> selected.\n     * If size equals threshold and larger files are required,\n     * file <b>IS</b> selected.\n     * </p>\n     * @param file  the File to check\n     *\n     * @return true if the file name matches\n     */\n    @Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        try {\n            return toFileVisitResult(accept(Files.size(file)));\n        } catch (final IOException e) {\n            return handle(e);\n        }\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final String condition = acceptLarger ? \">=\" : \"<\";\n        return super.toString() + \"(\" + condition + size + \")\";\n    }\n\n    @Override\n    public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {\n        return toFileVisitResult(accept(Files.size(file)));\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.BasicFileAttributes;\n\n/**\n * Filters files based on size, can filter either smaller files or\n * files equal to or larger than a given threshold.\n * <p>\n * For example, to print all files and directories in the\n * current directory whose size is greater than 1 MB:\n * </p>\n * <h2>Using Classic IO</h2>\n * <pre>\n * File dir = FileUtils.current();\n * String[] files = dir.list(new SizeFileFilter(1024 * 1024));\n * for (String file : files) {\n *     System.out.println(file);\n * }\n * </pre>\n *\n * <h2>Using NIO</h2>\n * <pre>\n * final Path dir = PathUtils.current();\n * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new SizeFileFilter(1024 * 1024));\n * //\n * // Walk one dir\n * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);\n * System.out.println(visitor.getPathCounters());\n * System.out.println(visitor.getFileList());\n * //\n * visitor.getPathCounters().reset();\n * //\n * // Walk dir tree\n * Files.<b>walkFileTree</b>(dir, visitor);\n * System.out.println(visitor.getPathCounters());\n * System.out.println(visitor.getDirList());\n * System.out.println(visitor.getFileList());\n * </pre>\n *\n * @since 1.2\n * @see FileFilterUtils#sizeFileFilter(long)\n * @see FileFilterUtils#sizeFileFilter(long, boolean)\n * @see FileFilterUtils#sizeRangeFileFilter(long, long)\n */\npublic class SizeFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = 7388077430788600069L;\n\n    /** Whether the files accepted will be larger or smaller. */\n    private final boolean acceptLarger;\n\n    /** The size threshold. */\n    private final long size;\n\n    /**\n     * Constructs a new size file filter for files equal to or\n     * larger than a certain size.\n     *\n     * @param size  the threshold size of the files\n     * @throws IllegalArgumentException if the size is negative\n     */\n    public SizeFileFilter(final long size) {\n        this(size, true);\n    }\n\n    /**\n     * Constructs a new size file filter for files based on a certain size\n     * threshold.\n     *\n     * @param size  the threshold size of the files\n     * @param acceptLarger  if true, files equal to or larger are accepted,\n     * otherwise smaller ones (but not equal to)\n     * @throws IllegalArgumentException if the size is negative\n     */\n    public SizeFileFilter(final long size, final boolean acceptLarger) {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"The size must be non-negative\");\n        }\n        this.size = size;\n        this.acceptLarger = acceptLarger;\n    }\n\n    /**\n     * Checks to see if the size of the file is favorable.\n     * <p>\n     * If size equals threshold and smaller files are required,\n     * file <b>IS NOT</b> selected.\n     * If size equals threshold and larger files are required,\n     * file <b>IS</b> selected.\n     * </p>\n     *\n     * @param file  the File to check\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File file) {\n        return accept(file.length());\n    }\n\n    private boolean accept(final long length) {\n        return acceptLarger != length < size;\n    }\n\n    /**\n     * Checks to see if the size of the file is favorable.\n     * <p>\n     * If size equals threshold and smaller files are required,\n     * file <b>IS NOT</b> selected.\n     * If size equals threshold and larger files are required,\n     * file <b>IS</b> selected.\n     * </p>\n     * @param file  the File to check\n     *\n     * @return true if the file name matches\n     */\n    @Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        return get(() -> toFileVisitResult(accept(Files.size(file))));\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final String condition = acceptLarger ? \">=\" : \"<\";\n        return super.toString() + \"(\" + condition + size + \")\";\n    }\n\n    @Override\n    public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {\n        return toFileVisitResult(accept(Files.size(file)));\n    }\n\n}\n", "diffSourceCodeSet": ["}\n\n    private boolean accept(final long length) {\n        return acceptLarger != length < size;\n    }\n\n    /**"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.filefilter.EmptyFileFilter#accept\n methodBody: public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\ntryif(Files.isDirectory(file)){try(Stream<Path> stream=Files.list(file))return toFileVisitResult(!stream.findFirst().isPresent());\n}return toFileVisitResult(Files.size(file) == 0);\ncatch(final IOException e)return handle(e);\n}", "methodSignature: org.apache.commons.io.filefilter.AgeFileFilter#accept\n methodBody: public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\ntryreturn toFileVisitResult(acceptOlder != PathUtils.isNewer(file,cutoffInstant));\ncatch(final IOException e)return handle(e);\n}", "methodSignature: org.apache.commons.io.filefilter.SizeFileFilter#accept\n methodBody: public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\ntryreturn toFileVisitResult(accept(Files.size(file)));\ncatch(final IOException e)return handle(e);\n}", "methodSignature: org.apache.commons.io.filefilter.AbstractFileFilter#handle\n methodBody: protected FileVisitResult handle(final Throwable t) {\nreturn FileVisitResult.TERMINATE;\n}", "methodSignature: org.apache.commons.io.filefilter.HiddenFileFilter#accept\n methodBody: public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\ntryreturn toFileVisitResult(Files.isHidden(file));\ncatch(final IOException e)return handle(e);\n}", "methodSignature: org.apache.commons.io.filefilter.AbstractFileFilter#toFileVisitResult\n methodBody: FileVisitResult toFileVisitResult(final boolean accept) {\nreturn accept ? onAccept : onReject;\n}", "methodSignature: org.apache.commons.io.filefilter.AbstractFileFilter#accept\n methodBody: public boolean accept(final File dir, final String name) {\nObjects.requireNonNull(name,\"name\");\nreturn accept(new File(dir,name));\n}", "methodSignature: org.apache.commons.io.filefilter.PathVisitorFileFilter#accept\n methodBody: public FileVisitResult accept(final Path path, final BasicFileAttributes attributes) {\ntryreturn Files.isDirectory(path) ? pathVisitor.postVisitDirectory(path,null) : visitFile(path,attributes);\ncatch(final IOException e)return handle(e);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Checks to see if the size of the file is favorable.\n     * <p>\n     * If size equals threshold and smaller files are required,\n     * file <b>IS NOT</b> selected.\n     * If size equals threshold and larger files are required,\n     * file <b>IS</b> selected.\n     * </p>\n     * @param file  the File to check\n     *\n     * @return true if the file name matches\n     */\n    @Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        return get(() -> toFileVisitResult(accept(Files.size(file))));\n    }\n}\n\n    private boolean accept(final long length) {\n        return acceptLarger != length < size;\n    }\n\n    /**", "diffSourceCode": "   120:     }\n   121: \n   122:     private boolean accept(final long length) {\n   123:         return acceptLarger != length < size;\n   124:     }\n   125: \n   126:     /**\n   127:      * Checks to see if the size of the file is favorable.\n   128:      * <p>\n   129:      * If size equals threshold and smaller files are required,\n   130:      * file <b>IS NOT</b> selected.\n   131:      * If size equals threshold and larger files are required,\n   132:      * file <b>IS</b> selected.\n   133:      * </p>\n   134:      * @param file  the File to check\n   135:      *\n   136:      * @return true if the file name matches\n   137:      */\n   138:     @Override\n   139:     public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n-  140:         try {\n-  141:             return toFileVisitResult(accept(Files.size(file)));\n-  142:         } catch (final IOException e) {\n-  143:             return handle(e);\n-  144:         }\n-  145:     }\n+  140:         return get(() -> toFileVisitResult(accept(Files.size(file))));\n+  141:     }\n+  142: \n+  143:     /**\n+  144:      * Provide a String representation of this file filter.\n+  145:      *\n", "uniqueId": "0d84f279d6dd6486b581acf2ea2ad212530e16fc_126_145_120_126_126_141", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 5, "covered": 7}, "LINE": {"missed": 2, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": false, "compileAndTestResult": false, "refactoredCode": "To refactor the provided code, we will extract the method that handles the file size checking logic and move it to a new utility class. This will improve modularity and maintainability. \n\n### Step 1: Analyze the Code\nThe method `accept(final Path file, final BasicFileAttributes attributes)` in the `SizeFileFilter` class is responsible for checking the file size and handling exceptions. The logic for checking the file size can be extracted into a utility method.\n\n### Step 2: Identify the Target Class\nWe will create a new utility class named `FileSizeUtils` to hold the extracted method. This class will be placed in the `src/main/java/org/apache/commons/io/filefilter/` directory, which is appropriate given the context of file filtering.\n\n### Step 3: Extract the Method\nThe extracted method will be a public static method that takes a `Path` and returns a `FileVisitResult`. \n\n### Step 4: Refactor the Original Method\nThe original method will be modified to call the new static method from the `FileSizeUtils` class.\n\n### Implementation\n\n#### Target File Path\n```plaintext\nsrc/main/java/org/apache/commons/io/filefilter/FileSizeUtils.java\n```\n\n#### Extracted Method Code\n```java\npublic static FileVisitResult checkFileSize(Path file, boolean acceptLarger) {\n    try {\n        long size = Files.size(file);\n        return toFileVisitResult(acceptLarger != size < size);\n    } catch (IOException e) {\n        return handle(e);\n    }\n}\n```\n\n#### Refactored Method Code\n```java\n@Override\npublic FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n    return FileSizeUtils.checkFileSize(file, acceptLarger);\n}\n```\n\n### Final Output\nHere is the complete output as per your request:\n\n##########################\nsrc/main/java/org/apache/commons/io/filefilter/FileSizeUtils.java\n##########################\npublic static FileVisitResult checkFileSize(Path file, boolean acceptLarger) {\n    try {\n        long size = Files.size(file);\n        return toFileVisitResult(acceptLarger != size < size);\n    } catch (IOException e) {\n        return handle(e);\n    }\n}\n##########################\n@Override\npublic FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n    return FileSizeUtils.checkFileSize(file, acceptLarger);\n}\n##########################", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Checks to see if the size of the file is favorable.\n     * <p>\n     * If size equals threshold and smaller files are required,\n     * file <b>IS NOT</b> selected.\n     * If size equals threshold and larger files are required,\n     * file <b>IS</b> selected.\n     * </p>\n     * @param file  the File to check\n     *\n     * @return true if the file name matches\n     */\n    @Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        try {\n            return toFileVisitResult(accept(Files.size(file)));\n        } catch (final IOException e) {\n            return handle(e);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io.filefilter;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.BasicFileAttributes;\n\n/**\n * Filters files based on size, can filter either smaller files or\n * files equal to or larger than a given threshold.\n * <p>\n * For example, to print all files and directories in the\n * current directory whose size is greater than 1 MB:\n * </p>\n * <h2>Using Classic IO</h2>\n * <pre>\n * File dir = FileUtils.current();\n * String[] files = dir.list(new SizeFileFilter(1024 * 1024));\n * for (String file : files) {\n *     System.out.println(file);\n * }\n * </pre>\n *\n * <h2>Using NIO</h2>\n * <pre>\n * final Path dir = PathUtils.current();\n * final AccumulatorPathVisitor visitor = AccumulatorPathVisitor.withLongCounters(new SizeFileFilter(1024 * 1024));\n * //\n * // Walk one dir\n * Files.<b>walkFileTree</b>(dir, Collections.emptySet(), 1, visitor);\n * System.out.println(visitor.getPathCounters());\n * System.out.println(visitor.getFileList());\n * //\n * visitor.getPathCounters().reset();\n * //\n * // Walk dir tree\n * Files.<b>walkFileTree</b>(dir, visitor);\n * System.out.println(visitor.getPathCounters());\n * System.out.println(visitor.getDirList());\n * System.out.println(visitor.getFileList());\n * </pre>\n *\n * @since 1.2\n * @see FileFilterUtils#sizeFileFilter(long)\n * @see FileFilterUtils#sizeFileFilter(long, boolean)\n * @see FileFilterUtils#sizeRangeFileFilter(long, long)\n */\npublic class SizeFileFilter extends AbstractFileFilter implements Serializable {\n\n    private static final long serialVersionUID = 7388077430788600069L;\n\n    /** Whether the files accepted will be larger or smaller. */\n    private final boolean acceptLarger;\n\n    /** The size threshold. */\n    private final long size;\n\n    /**\n     * Constructs a new size file filter for files equal to or\n     * larger than a certain size.\n     *\n     * @param size  the threshold size of the files\n     * @throws IllegalArgumentException if the size is negative\n     */\n    public SizeFileFilter(final long size) {\n        this(size, true);\n    }\n\n    /**\n     * Constructs a new size file filter for files based on a certain size\n     * threshold.\n     *\n     * @param size  the threshold size of the files\n     * @param acceptLarger  if true, files equal to or larger are accepted,\n     * otherwise smaller ones (but not equal to)\n     * @throws IllegalArgumentException if the size is negative\n     */\n    public SizeFileFilter(final long size, final boolean acceptLarger) {\n        if (size < 0) {\n            throw new IllegalArgumentException(\"The size must be non-negative\");\n        }\n        this.size = size;\n        this.acceptLarger = acceptLarger;\n    }\n\n    /**\n     * Checks to see if the size of the file is favorable.\n     * <p>\n     * If size equals threshold and smaller files are required,\n     * file <b>IS NOT</b> selected.\n     * If size equals threshold and larger files are required,\n     * file <b>IS</b> selected.\n     * </p>\n     *\n     * @param file  the File to check\n     * @return true if the file name matches\n     */\n    @Override\n    public boolean accept(final File file) {\n        return accept(file.length());\n    }\n\n    private boolean accept(final long length) {\n        return acceptLarger != length < size;\n    }\n\n    /**\n     * Checks to see if the size of the file is favorable.\n     * <p>\n     * If size equals threshold and smaller files are required,\n     * file <b>IS NOT</b> selected.\n     * If size equals threshold and larger files are required,\n     * file <b>IS</b> selected.\n     * </p>\n     * @param file  the File to check\n     *\n     * @return true if the file name matches\n     */\n    @Override\n    public FileVisitResult accept(final Path file, final BasicFileAttributes attributes) {\n        try {\n            return toFileVisitResult(accept(Files.size(file)));\n        } catch (final IOException e) {\n            return handle(e);\n        }\n    }\n\n    /**\n     * Provide a String representation of this file filter.\n     *\n     * @return a String representation\n     */\n    @Override\n    public String toString() {\n        final String condition = acceptLarger ? \">=\" : \"<\";\n        return super.toString() + \"(\" + condition + size + \")\";\n    }\n\n    @Override\n    public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {\n        return toFileVisitResult(accept(Files.size(file)));\n    }\n\n}\n\nRefactoring Operation:\nExtract And Move Method\n\nProject Structure:\n['src/main/java/org/apache/commons/io/ByteOrderMark.java', 'src/main/java/org/apache/commons/io/ByteOrderParser.java', 'src/main/java/org/apache/commons/io/Charsets.java', 'src/main/java/org/apache/commons/io/CloseableURLConnection.java', 'src/main/java/org/apache/commons/io/CopyUtils.java', 'src/main/java/org/apache/commons/io/DirectoryWalker.java', 'src/main/java/org/apache/commons/io/EndianUtils.java', 'src/main/java/org/apache/commons/io/FileCleaner.java', 'src/main/java/org/apache/commons/io/FileCleaningTracker.java', 'src/main/java/org/apache/commons/io/FileDeleteStrategy.java', 'src/main/java/org/apache/commons/io/FileExistsException.java', 'src/main/java/org/apache/commons/io/FileSystem.java', 'src/main/java/org/apache/commons/io/FileSystemUtils.java', 'src/main/java/org/apache/commons/io/FileUtils.java', 'src/main/java/org/apache/commons/io/FilenameUtils.java', 'src/main/java/org/apache/commons/io/HexDump.java', 'src/main/java/org/apache/commons/io/IOCase.java', 'src/main/java/org/apache/commons/io/IOExceptionList.java', 'src/main/java/org/apache/commons/io/IOExceptionWithCause.java', 'src/main/java/org/apache/commons/io/IOIndexedException.java', 'src/main/java/org/apache/commons/io/IOUtils.java', 'src/main/java/org/apache/commons/io/LineIterator.java', 'src/main/java/org/apache/commons/io/RandomAccessFileMode.java', 'src/main/java/org/apache/commons/io/StandardLineSeparator.java', 'src/main/java/org/apache/commons/io/StreamIterator.java', 'src/main/java/org/apache/commons/io/TaggedIOException.java', 'src/main/java/org/apache/commons/io/ThreadMonitor.java', 'src/main/java/org/apache/commons/io/UncheckedIO.java', 'src/main/java/org/apache/commons/io/UncheckedIOExceptions.java', 'src/main/java/org/apache/commons/io/charset/CharsetDecoders.java', 'src/main/java/org/apache/commons/io/charset/CharsetEncoders.java', 'src/main/java/org/apache/commons/io/charset/package-info.java', 'src/main/java/org/apache/commons/io/comparator/AbstractFileComparator.java', 'src/main/java/org/apache/commons/io/comparator/CompositeFileComparator.java', 'src/main/java/org/apache/commons/io/comparator/DefaultFileComparator.java', 'src/main/java/org/apache/commons/io/comparator/DirectoryFileComparator.java', 'src/main/java/org/apache/commons/io/comparator/ExtensionFileComparator.java', 'src/main/java/org/apache/commons/io/comparator/LastModifiedFileComparator.java', 'src/main/java/org/apache/commons/io/comparator/NameFileComparator.java', 'src/main/java/org/apache/commons/io/comparator/PathFileComparator.java', 'src/main/java/org/apache/commons/io/comparator/ReverseFileComparator.java', 'src/main/java/org/apache/commons/io/comparator/SizeFileComparator.java', 'src/main/java/org/apache/commons/io/file/AccumulatorPathVisitor.java', 'src/main/java/org/apache/commons/io/file/CleaningPathVisitor.java', 'src/main/java/org/apache/commons/io/file/CopyDirectoryVisitor.java', 'src/main/java/org/apache/commons/io/file/Counters.java', 'src/main/java/org/apache/commons/io/file/CountingPathVisitor.java', 'src/main/java/org/apache/commons/io/file/DeleteOption.java', 'src/main/java/org/apache/commons/io/file/DeletingPathVisitor.java', 'src/main/java/org/apache/commons/io/file/DirectoryStreamFilter.java', 'src/main/java/org/apache/commons/io/file/NoopPathVisitor.java', 'src/main/java/org/apache/commons/io/file/PathFilter.java', 'src/main/java/org/apache/commons/io/file/PathUtils.java', 'src/main/java/org/apache/commons/io/file/PathVisitor.java', 'src/main/java/org/apache/commons/io/file/SimplePathVisitor.java', 'src/main/java/org/apache/commons/io/file/StandardDeleteOption.java', 'src/main/java/org/apache/commons/io/file/attribute/FileTimes.java', 'src/main/java/org/apache/commons/io/file/attribute/package-info.java', 'src/main/java/org/apache/commons/io/file/package-info.java', 'src/main/java/org/apache/commons/io/file/spi/FileSystemProviders.java', 'src/main/java/org/apache/commons/io/file/spi/package-info.java', 'src/main/java/org/apache/commons/io/filefilter/AbstractFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/AgeFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/AndFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/CanExecuteFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/CanReadFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/CanWriteFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/ConditionalFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/DelegateFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/DirectoryFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/EmptyFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/FalseFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/FileEqualsFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/FileFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/FileFilterUtils.java', 'src/main/java/org/apache/commons/io/filefilter/HiddenFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/IOFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/MagicNumberFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/NameFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/NotFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/OrFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/PathEqualsFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/PathVisitorFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/PrefixFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/RegexFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/SuffixFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/SymbolicLinkFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/TrueFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/WildcardFileFilter.java', 'src/main/java/org/apache/commons/io/filefilter/WildcardFilter.java', 'src/main/java/org/apache/commons/io/function/IOBiConsumer.java', 'src/main/java/org/apache/commons/io/function/IOBiFunction.java', 'src/main/java/org/apache/commons/io/function/IOConsumer.java', 'src/main/java/org/apache/commons/io/function/IOFunction.java', 'src/main/java/org/apache/commons/io/function/IORunnable.java', 'src/main/java/org/apache/commons/io/function/IOStreams.java', 'src/main/java/org/apache/commons/io/function/IOSupplier.java', 'src/main/java/org/apache/commons/io/function/IOTriFunction.java', 'src/main/java/org/apache/commons/io/function/package-info.java', 'src/main/java/org/apache/commons/io/input/AbstractCharacterFilterReader.java', 'src/main/java/org/apache/commons/io/input/AutoCloseInputStream.java', 'src/main/java/org/apache/commons/io/input/BOMInputStream.java', 'src/main/java/org/apache/commons/io/input/BoundedInputStream.java', 'src/main/java/org/apache/commons/io/input/BoundedReader.java', 'src/main/java/org/apache/commons/io/input/BrokenInputStream.java', 'src/main/java/org/apache/commons/io/input/BrokenReader.java', 'src/main/java/org/apache/commons/io/input/BufferedFileChannelInputStream.java', 'src/main/java/org/apache/commons/io/input/ByteBufferCleaner.java', 'src/main/java/org/apache/commons/io/input/CharSequenceInputStream.java', 'src/main/java/org/apache/commons/io/input/CharSequenceReader.java', 'src/main/java/org/apache/commons/io/input/CharacterFilterReader.java', 'src/main/java/org/apache/commons/io/input/CharacterSetFilterReader.java', 'src/main/java/org/apache/commons/io/input/CircularInputStream.java', 'src/main/java/org/apache/commons/io/input/ClassLoaderObjectInputStream.java', 'src/main/java/org/apache/commons/io/input/CloseShieldInputStream.java', 'src/main/java/org/apache/commons/io/input/CloseShieldReader.java', 'src/main/java/org/apache/commons/io/input/ClosedInputStream.java', 'src/main/java/org/apache/commons/io/input/ClosedReader.java', 'src/main/java/org/apache/commons/io/input/CountingInputStream.java', 'src/main/java/org/apache/commons/io/input/DemuxInputStream.java', 'src/main/java/org/apache/commons/io/input/InfiniteCircularInputStream.java', 'src/main/java/org/apache/commons/io/input/MarkShieldInputStream.java', 'src/main/java/org/apache/commons/io/input/MemoryMappedFileInputStream.java', 'src/main/java/org/apache/commons/io/input/MessageDigestCalculatingInputStream.java', 'src/main/java/org/apache/commons/io/input/NullInputStream.java', 'src/main/java/org/apache/commons/io/input/NullReader.java', 'src/main/java/org/apache/commons/io/input/ObservableInputStream.java', 'src/main/java/org/apache/commons/io/input/ProxyInputStream.java', 'src/main/java/org/apache/commons/io/input/ProxyReader.java', 'src/main/java/org/apache/commons/io/input/QueueInputStream.java', 'src/main/java/org/apache/commons/io/input/RandomAccessFileInputStream.java', 'src/main/java/org/apache/commons/io/input/ReadAheadInputStream.java', 'src/main/java/org/apache/commons/io/input/ReaderInputStream.java', 'src/main/java/org/apache/commons/io/input/ReversedLinesFileReader.java', 'src/main/java/org/apache/commons/io/input/SequenceReader.java', 'src/main/java/org/apache/commons/io/input/SwappedDataInputStream.java', 'src/main/java/org/apache/commons/io/input/TaggedInputStream.java', 'src/main/java/org/apache/commons/io/input/TaggedReader.java', 'src/main/java/org/apache/commons/io/input/Tailer.java', 'src/main/java/org/apache/commons/io/input/TailerListener.java', 'src/main/java/org/apache/commons/io/input/TailerListenerAdapter.java', 'src/main/java/org/apache/commons/io/input/TeeInputStream.java', 'src/main/java/org/apache/commons/io/input/TeeReader.java', 'src/main/java/org/apache/commons/io/input/TimestampedObserver.java', 'src/main/java/org/apache/commons/io/input/UncheckedBufferedReader.java', 'src/main/java/org/apache/commons/io/input/UncheckedFilterInputStream.java', 'src/main/java/org/apache/commons/io/input/UncheckedFilterReader.java', 'src/main/java/org/apache/commons/io/input/UnixLineEndingInputStream.java', 'src/main/java/org/apache/commons/io/input/UnsupportedOperationExceptions.java', 'src/main/java/org/apache/commons/io/input/UnsynchronizedByteArrayInputStream.java', 'src/main/java/org/apache/commons/io/input/WindowsLineEndingInputStream.java', 'src/main/java/org/apache/commons/io/input/XmlStreamReader.java', 'src/main/java/org/apache/commons/io/input/XmlStreamReaderException.java', 'src/main/java/org/apache/commons/io/input/buffer/CircularBufferInputStream.java', 'src/main/java/org/apache/commons/io/input/buffer/CircularByteBuffer.java', 'src/main/java/org/apache/commons/io/input/buffer/PeekableInputStream.java', 'src/main/java/org/apache/commons/io/input/buffer/package-info.java', 'src/main/java/org/apache/commons/io/input/package-info.java', 'src/main/java/org/apache/commons/io/monitor/FileAlterationListener.java', 'src/main/java/org/apache/commons/io/monitor/FileAlterationListenerAdaptor.java', 'src/main/java/org/apache/commons/io/monitor/FileAlterationMonitor.java', 'src/main/java/org/apache/commons/io/monitor/FileAlterationObserver.java', 'src/main/java/org/apache/commons/io/monitor/FileEntry.java', 'src/main/java/org/apache/commons/io/monitor/package-info.java', 'src/main/java/org/apache/commons/io/output/AbstractByteArrayOutputStream.java', 'src/main/java/org/apache/commons/io/output/AppendableOutputStream.java', 'src/main/java/org/apache/commons/io/output/AppendableWriter.java', 'src/main/java/org/apache/commons/io/output/BrokenOutputStream.java', 'src/main/java/org/apache/commons/io/output/BrokenWriter.java', 'src/main/java/org/apache/commons/io/output/ByteArrayOutputStream.java', 'src/main/java/org/apache/commons/io/output/ChunkedOutputStream.java', 'src/main/java/org/apache/commons/io/output/ChunkedWriter.java', 'src/main/java/org/apache/commons/io/output/CloseShieldOutputStream.java', 'src/main/java/org/apache/commons/io/output/CloseShieldWriter.java', 'src/main/java/org/apache/commons/io/output/ClosedOutputStream.java', 'src/main/java/org/apache/commons/io/output/ClosedWriter.java', 'src/main/java/org/apache/commons/io/output/CountingOutputStream.java', 'src/main/java/org/apache/commons/io/output/DeferredFileOutputStream.java', 'src/main/java/org/apache/commons/io/output/DemuxOutputStream.java', 'src/main/java/org/apache/commons/io/output/FileWriterWithEncoding.java', 'src/main/java/org/apache/commons/io/output/FilterCollectionWriter.java', 'src/main/java/org/apache/commons/io/output/LockableFileWriter.java', 'src/main/java/org/apache/commons/io/output/NullAppendable.java', 'src/main/java/org/apache/commons/io/output/NullOutputStream.java', 'src/main/java/org/apache/commons/io/output/NullPrintStream.java', 'src/main/java/org/apache/commons/io/output/NullWriter.java', 'src/main/java/org/apache/commons/io/output/ProxyCollectionWriter.java', 'src/main/java/org/apache/commons/io/output/ProxyOutputStream.java', 'src/main/java/org/apache/commons/io/output/ProxyWriter.java', 'src/main/java/org/apache/commons/io/output/QueueOutputStream.java', 'src/main/java/org/apache/commons/io/output/StringBuilderWriter.java', 'src/main/java/org/apache/commons/io/output/TaggedOutputStream.java', 'src/main/java/org/apache/commons/io/output/TaggedWriter.java', 'src/main/java/org/apache/commons/io/output/TeeOutputStream.java', 'src/main/java/org/apache/commons/io/output/TeeWriter.java', 'src/main/java/org/apache/commons/io/output/ThresholdingOutputStream.java', 'src/main/java/org/apache/commons/io/output/UncheckedAppendable.java', 'src/main/java/org/apache/commons/io/output/UncheckedAppendableImpl.java', 'src/main/java/org/apache/commons/io/output/UncheckedFilterOutputStream.java', 'src/main/java/org/apache/commons/io/output/UncheckedFilterWriter.java', 'src/main/java/org/apache/commons/io/output/UnsynchronizedByteArrayOutputStream.java', 'src/main/java/org/apache/commons/io/output/WriterOutputStream.java', 'src/main/java/org/apache/commons/io/output/XmlStreamWriter.java', 'src/main/java/org/apache/commons/io/output/package-info.java', 'src/main/java/org/apache/commons/io/serialization/ClassNameMatcher.java', 'src/main/java/org/apache/commons/io/serialization/FullClassNameMatcher.java', 'src/main/java/org/apache/commons/io/serialization/RegexpClassNameMatcher.java', 'src/main/java/org/apache/commons/io/serialization/ValidatingObjectInputStream.java', 'src/main/java/org/apache/commons/io/serialization/WildcardClassNameMatcher.java', 'src/main/java/org/apache/commons/io/serialization/package-info.java']\n\nFile Path Before Refactoring:\nsrc/main/java/org/apache/commons/io/filefilter/SizeFileFilter.java\n\nInstructions:\n1. Analyze the provided code, class content, and project structure, apply relevant refactoring operation to the code to be refactored, and you need move the extracted method to another existing java file, output the target file path, extracted method code, refactored method code after refactoring.\nThe extracted method code should be the public static method.\nThe refactored method code should use the moved class to call the extracted method.\nThe target file path should be the path of the existing class where the method is moved to.\n\n2. If refactoring is performed, output the refactored class code in the following format:\n##########################\ntarget_file_path\n##########################\nextracted_method_code\n##########################\nrefactored_method_code\n##########################\n\n\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic toCharset(charsetName String, defaultCharset Charset) : Charset extracted from public toCharset(charsetName String) : Charset in class org.apache.commons.io.Charsets", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/Charsets.java", "startLine": 186, "endLine": 195, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/Charsets.java", "startLine": 198, "endLine": 207, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/Charsets.java", "startLine": 209, "endLine": 220, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charsetName The name of the requested charset, may be null.\n     * @return a Charset for the named charset.\n     * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n     */\n    public static Charset toCharset(final String charsetName) throws UnsupportedCharsetException {\n        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/Charsets.java", "isPureRefactoring": true, "commitId": "12b97b145355b381863b6fd7a7f0ab9614f74ab0", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.Charsets", "methodNameBefore": "org.apache.commons.io.Charsets#toCharset", "classSignatureBefore": "public class Charsets ", "methodNameBeforeSet": ["org.apache.commons.io.Charsets#toCharset"], "classNameBeforeSet": ["org.apache.commons.io.Charsets"], "classSignatureBeforeSet": ["public class Charsets "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All the mappings are matched! - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.Collections;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\n/**\n * Charsets required of every implementation of the Java platform.\n *\n * From the Java documentation <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">\n * Standard charsets</a>:\n * <p>\n * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult\n * the release documentation for your implementation to see if any other encodings are supported. Consult the release\n * documentation for your implementation to see if any other encodings are supported. </cite>\n * </p>\n *\n * <ul>\n * <li>{@code US-ASCII}<br>\n * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>\n * <li>{@code ISO-8859-1}<br>\n * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>\n * <li>{@code UTF-8}<br>\n * Eight-bit Unicode Transformation Format.</li>\n * <li>{@code UTF-16BE}<br>\n * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>\n * <li>{@code UTF-16LE}<br>\n * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>\n * <li>{@code UTF-16}<br>\n * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n * accepted on input, big-endian used on output.)</li>\n * </ul>\n *\n * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @since 2.3\n */\npublic class Charsets {\n\n    //\n    // This class should only contain Charset instances for required encodings. This guarantees that it will load\n    // correctly and without delay on all Java platforms.\n    //\n\n    private static final SortedMap<String, Charset> STANDARD_CHARSET_MAP;\n\n    static {\n        final SortedMap<String, Charset> standardCharsetMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        standardCharsetMap.put(StandardCharsets.ISO_8859_1.name(), StandardCharsets.ISO_8859_1);\n        standardCharsetMap.put(StandardCharsets.US_ASCII.name(), StandardCharsets.US_ASCII);\n        standardCharsetMap.put(StandardCharsets.UTF_16.name(), StandardCharsets.UTF_16);\n        standardCharsetMap.put(StandardCharsets.UTF_16BE.name(), StandardCharsets.UTF_16BE);\n        standardCharsetMap.put(StandardCharsets.UTF_16LE.name(), StandardCharsets.UTF_16LE);\n        standardCharsetMap.put(StandardCharsets.UTF_8.name(), StandardCharsets.UTF_8);\n        STANDARD_CHARSET_MAP = Collections.unmodifiableSortedMap(standardCharsetMap);\n    }\n\n    /**\n     * CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset ISO_8859_1 = StandardCharsets.ISO_8859_1;\n\n    /**\n     * <p>\n     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset US_ASCII = StandardCharsets.US_ASCII;\n\n    /**\n     * <p>\n     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n     * (either order accepted on input, big-endian used on output)\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_16 = StandardCharsets.UTF_16;\n\n    /**\n     * <p>\n     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_16BE = StandardCharsets.UTF_16BE;\n\n    /**\n     * <p>\n     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_16LE = StandardCharsets.UTF_16LE;\n\n    /**\n     * <p>\n     * Eight-bit Unicode Transformation Format.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_8 = StandardCharsets.UTF_8;\n\n    /**\n     * Constructs a sorted map from canonical charset names to charset objects required of every implementation of the\n     * Java platform.\n     * <p>\n     * From the Java documentation <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">\n     * Standard charsets</a>:\n     * </p>\n     *\n     * @return An immutable, case-insensitive map from canonical charset names to charset objects.\n     * @see Charset#availableCharsets()\n     * @since 2.5\n     */\n    public static SortedMap<String, Charset> requiredCharsets() {\n        return STANDARD_CHARSET_MAP;\n    }\n\n    /**\n     * Returns the given Charset or the default Charset if the given Charset is null.\n     *\n     * @param charset\n     *            A charset or null.\n     * @return the given Charset or the default Charset if the given Charset is null\n     */\n    public static Charset toCharset(final Charset charset) {\n        return charset == null ? Charset.defaultCharset() : charset;\n    }\n\n    /**\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charsetName The name of the requested charset, may be null.\n     * @return a Charset for the named charset.\n     * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n     */\n    public static Charset toCharset(final String charsetName) throws UnsupportedCharsetException {\n        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);\n    }\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/Charsets.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.Collections;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\n/**\n * Charsets required of every implementation of the Java platform.\n *\n * From the Java documentation <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">\n * Standard charsets</a>:\n * <p>\n * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult\n * the release documentation for your implementation to see if any other encodings are supported. Consult the release\n * documentation for your implementation to see if any other encodings are supported. </cite>\n * </p>\n *\n * <ul>\n * <li>{@code US-ASCII}<br>\n * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>\n * <li>{@code ISO-8859-1}<br>\n * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>\n * <li>{@code UTF-8}<br>\n * Eight-bit Unicode Transformation Format.</li>\n * <li>{@code UTF-16BE}<br>\n * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>\n * <li>{@code UTF-16LE}<br>\n * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>\n * <li>{@code UTF-16}<br>\n * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n * accepted on input, big-endian used on output.)</li>\n * </ul>\n *\n * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @since 2.3\n */\npublic class Charsets {\n\n    //\n    // This class should only contain Charset instances for required encodings. This guarantees that it will load\n    // correctly and without delay on all Java platforms.\n    //\n\n    private static final SortedMap<String, Charset> STANDARD_CHARSET_MAP;\n\n    static {\n        final SortedMap<String, Charset> standardCharsetMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        standardCharsetMap.put(StandardCharsets.ISO_8859_1.name(), StandardCharsets.ISO_8859_1);\n        standardCharsetMap.put(StandardCharsets.US_ASCII.name(), StandardCharsets.US_ASCII);\n        standardCharsetMap.put(StandardCharsets.UTF_16.name(), StandardCharsets.UTF_16);\n        standardCharsetMap.put(StandardCharsets.UTF_16BE.name(), StandardCharsets.UTF_16BE);\n        standardCharsetMap.put(StandardCharsets.UTF_16LE.name(), StandardCharsets.UTF_16LE);\n        standardCharsetMap.put(StandardCharsets.UTF_8.name(), StandardCharsets.UTF_8);\n        STANDARD_CHARSET_MAP = Collections.unmodifiableSortedMap(standardCharsetMap);\n    }\n\n    /**\n     * CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset ISO_8859_1 = StandardCharsets.ISO_8859_1;\n\n    /**\n     * <p>\n     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset US_ASCII = StandardCharsets.US_ASCII;\n\n    /**\n     * <p>\n     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n     * (either order accepted on input, big-endian used on output)\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_16 = StandardCharsets.UTF_16;\n\n    /**\n     * <p>\n     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_16BE = StandardCharsets.UTF_16BE;\n\n    /**\n     * <p>\n     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_16LE = StandardCharsets.UTF_16LE;\n\n    /**\n     * <p>\n     * Eight-bit Unicode Transformation Format.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_8 = StandardCharsets.UTF_8;\n\n    /**\n     * Constructs a sorted map from canonical charset names to charset objects required of every implementation of the\n     * Java platform.\n     * <p>\n     * From the Java documentation <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">\n     * Standard charsets</a>:\n     * </p>\n     *\n     * @return An immutable, case-insensitive map from canonical charset names to charset objects.\n     * @see Charset#availableCharsets()\n     * @since 2.5\n     */\n    public static SortedMap<String, Charset> requiredCharsets() {\n        return STANDARD_CHARSET_MAP;\n    }\n\n    /**\n     * Returns the given Charset or the default Charset if the given Charset is null.\n     *\n     * @param charset\n     *            A charset or null.\n     * @return the given Charset or the default Charset if the given Charset is null\n     */\n    public static Charset toCharset(final Charset charset) {\n        return charset == null ? Charset.defaultCharset() : charset;\n    }\n\n    /**\n     * Returns the given charset if non-null, otherwise return defaultCharset.\n     *\n     * @param charset The charset to test, may be null.\n     * @param defaultCharset The charset to return if charset is null, may be null.\n     * @return a Charset .\n     * @since 2.12.0\n     */\n    public static Charset toCharset(final Charset charset, final Charset defaultCharset) {\n        return charset == null ? defaultCharset : charset;\n    }\n\n    /**\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charsetName The name of the requested charset, may be null.\n     * @return a Charset for the named charset.\n     * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n     */\n    public static Charset toCharset(final String charsetName) throws UnsupportedCharsetException {\n        return toCharset(charsetName, Charset.defaultCharset());\n    }\n\n    /**\n     * Returns a Charset for the named charset. If the name is null, return the given default Charset.\n     *\n     * @param charsetName The name of the requested charset, may be null.\n     * @param defaultCharset The name charset to return if charsetName is null, may be null.\n     * @return a Charset for the named charset.\n     * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n     * @since 2.12.0\n     */\n    public static Charset toCharset(final String charsetName, final Charset defaultCharset) throws UnsupportedCharsetException {\n        return charsetName == null ? defaultCharset : Charset.forName(charsetName);\n    }\n}\n", "diffSourceCodeSet": ["/**\n     * Returns a Charset for the named charset. If the name is null, return the given default Charset.\n     *\n     * @param charsetName The name of the requested charset, may be null.\n     * @param defaultCharset The name charset to return if charsetName is null, may be null.\n     * @return a Charset for the named charset.\n     * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n     * @since 2.12.0\n     */\n    public static Charset toCharset(final String charsetName, final Charset defaultCharset) throws UnsupportedCharsetException {\n        return charsetName == null ? defaultCharset : Charset.forName(charsetName);\n    }"], "invokedMethodSet": [], "sourceCodeAfterRefactoring": "/**\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charsetName The name of the requested charset, may be null.\n     * @return a Charset for the named charset.\n     * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n     */\n    public static Charset toCharset(final String charsetName) throws UnsupportedCharsetException {\n        return toCharset(charsetName, Charset.defaultCharset());\n    }\n/**\n     * Returns a Charset for the named charset. If the name is null, return the given default Charset.\n     *\n     * @param charsetName The name of the requested charset, may be null.\n     * @param defaultCharset The name charset to return if charsetName is null, may be null.\n     * @return a Charset for the named charset.\n     * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n     * @since 2.12.0\n     */\n    public static Charset toCharset(final String charsetName, final Charset defaultCharset) throws UnsupportedCharsetException {\n        return charsetName == null ? defaultCharset : Charset.forName(charsetName);\n    }", "diffSourceCode": "   186:     /**\n-  187:      * Returns a Charset for the named charset. If the name is null, return the default Charset.\n+  187:      * Returns the given charset if non-null, otherwise return defaultCharset.\n   188:      *\n-  189:      * @param charsetName The name of the requested charset, may be null.\n-  190:      * @return a Charset for the named charset.\n-  191:      * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n-  192:      */\n-  193:     public static Charset toCharset(final String charsetName) throws UnsupportedCharsetException {\n-  194:         return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);\n-  195:     }\n+  189:      * @param charset The charset to test, may be null.\n+  190:      * @param defaultCharset The charset to return if charset is null, may be null.\n+  191:      * @return a Charset .\n+  192:      * @since 2.12.0\n+  193:      */\n+  194:     public static Charset toCharset(final Charset charset, final Charset defaultCharset) {\n+  195:         return charset == null ? defaultCharset : charset;\n+  198:     /**\n+  199:      * Returns a Charset for the named charset. If the name is null, return the default Charset.\n+  200:      *\n+  201:      * @param charsetName The name of the requested charset, may be null.\n+  202:      * @return a Charset for the named charset.\n+  203:      * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n+  204:      */\n+  205:     public static Charset toCharset(final String charsetName) throws UnsupportedCharsetException {\n+  206:         return toCharset(charsetName, Charset.defaultCharset());\n+  207:     }\n+  209:     /**\n+  210:      * Returns a Charset for the named charset. If the name is null, return the given default Charset.\n+  211:      *\n+  212:      * @param charsetName The name of the requested charset, may be null.\n+  213:      * @param defaultCharset The name charset to return if charsetName is null, may be null.\n+  214:      * @return a Charset for the named charset.\n+  215:      * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n+  216:      * @since 2.12.0\n+  217:      */\n+  218:     public static Charset toCharset(final String charsetName, final Charset defaultCharset) throws UnsupportedCharsetException {\n+  219:         return charsetName == null ? defaultCharset : Charset.forName(charsetName);\n+  220:     }\n", "uniqueId": "12b97b145355b381863b6fd7a7f0ab9614f74ab0_186_195_209_220_198_207", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 7}, "BRANCH": {"missed": 0, "covered": 2}, "LINE": {"missed": 0, "covered": 1}, "COMPLEXITY": {"missed": 0, "covered": 2}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To improve the readability and maintainability of the `toCharset` method that takes a `String` as an argument, we can extract the logic for handling the null check and charset retrieval into a separate private method. This will make the `toCharset` method cleaner and more focused on its primary responsibility.\n\nHere\u2019s the refactored code:\n\n```java\n##########################\nprivate static Charset getCharsetOrDefault(final String charsetName) {\n    return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);\n}\n\npublic static Charset toCharset(final String charsetName) throws UnsupportedCharsetException {\n    return getCharsetOrDefault(charsetName);\n}\n##########################\n```\n\nIn this refactoring:\n- A new private method `getCharsetOrDefault` is created to encapsulate the logic of returning the default charset if the provided charset name is null.\n- The `toCharset` method now simply calls this new method, improving its readability and separating concerns.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charsetName The name of the requested charset, may be null.\n     * @return a Charset for the named charset.\n     * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n     */\n    public static Charset toCharset(final String charsetName) throws UnsupportedCharsetException {\n        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.Collections;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\n/**\n * Charsets required of every implementation of the Java platform.\n *\n * From the Java documentation <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">\n * Standard charsets</a>:\n * <p>\n * <cite>Every implementation of the Java platform is required to support the following character encodings. Consult\n * the release documentation for your implementation to see if any other encodings are supported. Consult the release\n * documentation for your implementation to see if any other encodings are supported. </cite>\n * </p>\n *\n * <ul>\n * <li>{@code US-ASCII}<br>\n * Seven-bit ASCII, a.k.a. ISO646-US, a.k.a. the Basic Latin block of the Unicode character set.</li>\n * <li>{@code ISO-8859-1}<br>\n * ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.</li>\n * <li>{@code UTF-8}<br>\n * Eight-bit Unicode Transformation Format.</li>\n * <li>{@code UTF-16BE}<br>\n * Sixteen-bit Unicode Transformation Format, big-endian byte order.</li>\n * <li>{@code UTF-16LE}<br>\n * Sixteen-bit Unicode Transformation Format, little-endian byte order.</li>\n * <li>{@code UTF-16}<br>\n * Sixteen-bit Unicode Transformation Format, byte order specified by a mandatory initial byte-order mark (either order\n * accepted on input, big-endian used on output.)</li>\n * </ul>\n *\n * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n * @since 2.3\n */\npublic class Charsets {\n\n    //\n    // This class should only contain Charset instances for required encodings. This guarantees that it will load\n    // correctly and without delay on all Java platforms.\n    //\n\n    private static final SortedMap<String, Charset> STANDARD_CHARSET_MAP;\n\n    static {\n        final SortedMap<String, Charset> standardCharsetMap = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        standardCharsetMap.put(StandardCharsets.ISO_8859_1.name(), StandardCharsets.ISO_8859_1);\n        standardCharsetMap.put(StandardCharsets.US_ASCII.name(), StandardCharsets.US_ASCII);\n        standardCharsetMap.put(StandardCharsets.UTF_16.name(), StandardCharsets.UTF_16);\n        standardCharsetMap.put(StandardCharsets.UTF_16BE.name(), StandardCharsets.UTF_16BE);\n        standardCharsetMap.put(StandardCharsets.UTF_16LE.name(), StandardCharsets.UTF_16LE);\n        standardCharsetMap.put(StandardCharsets.UTF_8.name(), StandardCharsets.UTF_8);\n        STANDARD_CHARSET_MAP = Collections.unmodifiableSortedMap(standardCharsetMap);\n    }\n\n    /**\n     * CharEncodingISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1.\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset ISO_8859_1 = StandardCharsets.ISO_8859_1;\n\n    /**\n     * <p>\n     * Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset US_ASCII = StandardCharsets.US_ASCII;\n\n    /**\n     * <p>\n     * Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n     * (either order accepted on input, big-endian used on output)\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_16 = StandardCharsets.UTF_16;\n\n    /**\n     * <p>\n     * Sixteen-bit Unicode Transformation Format, big-endian byte order.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_16BE = StandardCharsets.UTF_16BE;\n\n    /**\n     * <p>\n     * Sixteen-bit Unicode Transformation Format, little-endian byte order.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_16LE = StandardCharsets.UTF_16LE;\n\n    /**\n     * <p>\n     * Eight-bit Unicode Transformation Format.\n     * </p>\n     * <p>\n     * Every implementation of the Java platform is required to support this character encoding.\n     * </p>\n     *\n     * @see <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n     * @deprecated Use Java 7's {@link java.nio.charset.StandardCharsets}\n     */\n    @Deprecated\n    public static final Charset UTF_8 = StandardCharsets.UTF_8;\n\n    /**\n     * Constructs a sorted map from canonical charset names to charset objects required of every implementation of the\n     * Java platform.\n     * <p>\n     * From the Java documentation <a href=\"https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html\">\n     * Standard charsets</a>:\n     * </p>\n     *\n     * @return An immutable, case-insensitive map from canonical charset names to charset objects.\n     * @see Charset#availableCharsets()\n     * @since 2.5\n     */\n    public static SortedMap<String, Charset> requiredCharsets() {\n        return STANDARD_CHARSET_MAP;\n    }\n\n    /**\n     * Returns the given Charset or the default Charset if the given Charset is null.\n     *\n     * @param charset\n     *            A charset or null.\n     * @return the given Charset or the default Charset if the given Charset is null\n     */\n    public static Charset toCharset(final Charset charset) {\n        return charset == null ? Charset.defaultCharset() : charset;\n    }\n\n    /**\n     * Returns a Charset for the named charset. If the name is null, return the default Charset.\n     *\n     * @param charsetName The name of the requested charset, may be null.\n     * @return a Charset for the named charset.\n     * @throws UnsupportedCharsetException If the named charset is unavailable (unchecked exception).\n     */\n    public static Charset toCharset(final String charsetName) throws UnsupportedCharsetException {\n        return charsetName == null ? Charset.defaultCharset() : Charset.forName(charsetName);\n    }\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}, {"type": "Extract Method", "description": "Extract Method\tpublic closeQuietly(closeables Iterable<Closeable>) : void extracted from public closeQuietly(closeables Closeable...) : void in class org.apache.commons.io.IOUtils", "diffLocations": [{"filePath": "src/main/java/org/apache/commons/io/IOUtils.java", "startLine": 475, "endLine": 525, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/IOUtils.java", "startLine": 483, "endLine": 533, "startColumn": 0, "endColumn": 0}, {"filePath": "src/main/java/org/apache/commons/io/IOUtils.java", "startLine": 587, "endLine": 601, "startColumn": 0, "endColumn": 0}], "sourceCodeBeforeRefactoring": "/**\n     * Closes a {@link Closeable} unconditionally.\n     * <p>\n     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.\n     * <p>\n     * This is typically used in finally blocks to ensure that the closeable is closed\n     * even if an Exception was thrown before the normal close statement was reached.\n     * <br>\n     * <b>It should not be used to replace the close statement(s)\n     * which should be present for the non-exceptional case.</b>\n     * <br>\n     * It is only intended to simplify tidying up where normal processing has already failed\n     * and reporting close failure as well is not necessary or useful.\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * Closeable closeable = null;\n     * try {\n     *     closeable = new FileReader(&quot;foo.txt&quot;);\n     *     // processing using the closeable; may throw an Exception\n     *     closeable.close(); // Normal close - exceptions not ignored\n     * } catch (Exception e) {\n     *     // error handling\n     * } finally {\n     *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>\n     * }\n     * </pre>\n     * <p>\n     * Closing all streams:\n     * <br>\n     * <pre>\n     * try {\n     *     return IOUtils.copy(inputStream, outputStream);\n     * } finally {\n     *     IOUtils.closeQuietly(inputStream, outputStream);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     * @param closeables the objects to close, may be null or already closed\n     * @see #closeQuietly(Closeable)\n     * @since 2.5\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Closeable... closeables) {\n        if (closeables != null) {\n            Arrays.stream(closeables).forEach(IOUtils::closeQuietly);\n        }\n    }", "filePathBefore": "src/main/java/org/apache/commons/io/IOUtils.java", "isPureRefactoring": true, "commitId": "57313b3ed3b356d9a81103f4dbcc1eb38b9f2c0b", "packageNameBefore": "org.apache.commons.io", "classNameBefore": "org.apache.commons.io.IOUtils", "methodNameBefore": "org.apache.commons.io.IOUtils#closeQuietly", "invokedMethod": "methodSignature: org.apache.commons.io.IOUtils#closeQuietly\n methodBody: public static void closeQuietly(final Writer writer) {\ncloseQuietly((Closeable)writer);\n}", "classSignatureBefore": "public class IOUtils ", "methodNameBeforeSet": ["org.apache.commons.io.IOUtils#closeQuietly"], "classNameBeforeSet": ["org.apache.commons.io.IOUtils"], "classSignatureBeforeSet": ["public class IOUtils "], "purityCheckResultList": [{"isPure": true, "purityComment": "Changes are within the Extract Method refactoring mechanics", "description": "All replacements have been justified - all mapped", "mappingState": 1}], "sourceCodeBeforeForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayInputStream;\nimport java.io.CharArrayWriter;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.net.HttpURLConnection;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.Selector;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Consumer;\n\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.input.QueueInputStream;\nimport org.apache.commons.io.output.AppendableWriter;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.apache.commons.io.output.NullOutputStream;\nimport org.apache.commons.io.output.StringBuilderWriter;\nimport org.apache.commons.io.output.ThresholdingOutputStream;\nimport org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n\n/**\n * General IO stream manipulation utilities.\n * <p>\n * This class provides static utility methods for input/output operations.\n * </p>\n * <ul>\n * <li>closeQuietly - these methods close a stream ignoring nulls and exceptions\n * <li>toXxx/read - these methods read data from a stream\n * <li>write - these methods write data to a stream\n * <li>copy - these methods copy all the data from one stream to another\n * <li>contentEquals - these methods compare the content of two streams\n * </ul>\n * <p>\n * The byte-to-char methods and char-to-byte methods involve a conversion step.\n * Two methods are provided in each case, one that uses the platform default\n * encoding and the other which allows you to specify an encoding. You are\n * encouraged to always specify an encoding because relying on the platform\n * default can lead to unexpected results, for example when moving from\n * development to production.\n * </p>\n * <p>\n * All the methods in this class that read a stream are buffered internally.\n * This means that there is no cause to use a {@link BufferedInputStream}\n * or {@link BufferedReader}. The default buffer size of 4K has been shown\n * to be efficient in tests.\n * </p>\n * <p>\n * The various copy methods all delegate the actual copying to one of the following methods:\n * </p>\n * <ul>\n * <li>{@link #copyLarge(InputStream, OutputStream, byte[])}</li>\n * <li>{@link #copyLarge(InputStream, OutputStream, long, long, byte[])}</li>\n * <li>{@link #copyLarge(Reader, Writer, char[])}</li>\n * <li>{@link #copyLarge(Reader, Writer, long, long, char[])}</li>\n * </ul>\n * For example, {@link #copy(InputStream, OutputStream)} calls {@link #copyLarge(InputStream, OutputStream)}\n * which calls {@link #copy(InputStream, OutputStream, int)} which creates the buffer and calls\n * {@link #copyLarge(InputStream, OutputStream, byte[])}.\n * <p>\n * Applications can re-use buffers by using the underlying methods directly.\n * This may improve performance for applications that need to do a lot of copying.\n * </p>\n * <p>\n * Wherever possible, the methods in this class do <em>not</em> flush or close\n * the stream. This is to avoid making non-portable assumptions about the\n * streams' origin and further use. Thus the caller is still responsible for\n * closing streams after use.\n * </p>\n * <p>\n * Origin of code: Excalibur.\n * </p>\n */\npublic class IOUtils {\n    // NOTE: This class is focused on InputStream, OutputStream, Reader and\n    // Writer. Each method should take at least one of these as a parameter,\n    // or return one of them.\n\n    /**\n     * CR char.\n     *\n     * @since 2.9.0\n     */\n    public static final int CR = '\\r';\n\n    /**\n     * The default buffer size ({@value}) to use in copy methods.\n     */\n    public static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     * The system directory separator character.\n     */\n    public static final char DIR_SEPARATOR = File.separatorChar;\n\n    /**\n     * The Unix directory separator character.\n     */\n    public static final char DIR_SEPARATOR_UNIX = '/';\n\n    /**\n     * The Windows directory separator character.\n     */\n    public static final char DIR_SEPARATOR_WINDOWS = '\\\\';\n\n    /**\n     * A singleton empty byte array.\n     *\n     *  @since 2.9.0\n     */\n    public static final byte[] EMPTY_BYTE_ARRAY = {};\n\n    /**\n     * Represents the end-of-file (or stream).\n     * @since 2.5 (made public)\n     */\n    public static final int EOF = -1;\n\n    /**\n     * LF char.\n     *\n     * @since 2.9.0\n     */\n    public static final int LF = '\\n';\n\n    /**\n     * The system line separator string.\n     *\n     * @deprecated Use {@link System#lineSeparator()}.\n     */\n    @Deprecated\n    public static final String LINE_SEPARATOR = System.lineSeparator();\n\n    /**\n     * The Unix line separator string.\n     *\n     * @see StandardLineSeparator#LF\n     */\n    public static final String LINE_SEPARATOR_UNIX = StandardLineSeparator.LF.getString();\n\n    /**\n     * The Windows line separator string.\n     *\n     * @see StandardLineSeparator#CRLF\n     */\n    public static final String LINE_SEPARATOR_WINDOWS = StandardLineSeparator.CRLF.getString();\n\n    /**\n     * Internal byte array buffer.\n     */\n    private static final ThreadLocal<byte[]> SKIP_BYTE_BUFFER = ThreadLocal.withInitial(IOUtils::byteArray);\n\n    /**\n     * Internal byte array buffer.\n     */\n    private static final ThreadLocal<char[]> SKIP_CHAR_BUFFER = ThreadLocal.withInitial(IOUtils::charArray);\n\n    /**\n     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a\n     * BufferedInputStream from the given InputStream.\n     *\n     * @param inputStream the InputStream to wrap or return (not null)\n     * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedInputStream buffer(final InputStream inputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream);\n    }\n\n    /**\n     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a\n     * BufferedInputStream from the given InputStream.\n     *\n     * @param inputStream the InputStream to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedInputStream is created.\n     * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedInputStream buffer(final InputStream inputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream, size);\n    }\n\n    /**\n     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a\n     * BufferedOutputStream from the given OutputStream.\n     *\n     * @param outputStream the OutputStream to wrap or return (not null)\n     * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedOutputStream buffer(final OutputStream outputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream);\n    }\n\n    /**\n     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a\n     * BufferedOutputStream from the given OutputStream.\n     *\n     * @param outputStream the OutputStream to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedOutputStream is created.\n     * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedOutputStream buffer(final OutputStream outputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream, size);\n    }\n\n    /**\n     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from\n     * the given reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedReader buffer(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }\n\n    /**\n     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from the\n     * given reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedReader is created.\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedReader buffer(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }\n\n    /**\n     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the\n     * given Writer.\n     *\n     * @param writer the Writer to wrap or return (not null)\n     * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedWriter buffer(final Writer writer) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer);\n    }\n\n    /**\n     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the\n     * given Writer.\n     *\n     * @param writer the Writer to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedWriter is created.\n     * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedWriter buffer(final Writer writer, final int size) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer, size);\n    }\n\n    /**\n     * Returns a new byte array of size {@link #DEFAULT_BUFFER_SIZE}.\n     *\n     * @return a new byte array of size {@link #DEFAULT_BUFFER_SIZE}.\n     * @since 2.9.0\n     */\n    public static byte[] byteArray() {\n        return byteArray(DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Returns a new byte array of the given size.\n     *\n     * TODO Consider guarding or warning against large allocations...\n     *\n     * @param size array size.\n     * @return a new byte array of the given size.\n     * @since 2.9.0\n     */\n    public static byte[] byteArray(final int size) {\n        return new byte[size];\n    }\n\n    /**\n     * Returns a new char array of size {@link #DEFAULT_BUFFER_SIZE}.\n     *\n     * @return a new char array of size {@link #DEFAULT_BUFFER_SIZE}.\n     * @since 2.9.0\n     */\n    private static char[] charArray() {\n        return charArray(DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Returns a new char array of the given size.\n     *\n     * TODO Consider guarding or warning against large allocations...\n     *\n     * @param size array size.\n     * @return a new char array of the given size.\n     * @since 2.9.0\n     */\n    private static char[] charArray(final int size) {\n        return new char[size];\n    }\n\n    /**\n     * Closes the given {@link Closeable} as a null-safe operation.\n     *\n     * @param closeable The resource to close, may be null.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.7\n     */\n    public static void close(final Closeable closeable) throws IOException {\n        if (closeable != null) {\n            closeable.close();\n        }\n    }\n\n    /**\n     * Closes the given {@link Closeable}s as null-safe operations.\n     *\n     * @param closeables The resource(s) to close, may be null.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static void close(final Closeable... closeables) throws IOException {\n        IOConsumer.forEach(closeables, IOUtils::close);\n    }\n\n    /**\n     * Closes the given {@link Closeable} as a null-safe operation.\n     *\n     * @param closeable The resource to close, may be null.\n     * @param consumer Consume the IOException thrown by {@link Closeable#close()}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.7\n     */\n    public static void close(final Closeable closeable, final IOConsumer<IOException> consumer) throws IOException {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer != null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Closes a URLConnection.\n     *\n     * @param conn the connection to close.\n     * @since 2.4\n     */\n    public static void close(final URLConnection conn) {\n        if (conn instanceof HttpURLConnection) {\n            ((HttpURLConnection) conn).disconnect();\n        }\n    }\n\n    /**\n     * Closes a {@link Closeable} unconditionally.\n     *\n     * <p>\n     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored. This is typically used in\n     * finally blocks.\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * Closeable closeable = null;\n     * try {\n     *     closeable = new FileReader(&quot;foo.txt&quot;);\n     *     // process closeable\n     *     closeable.close();\n     * } catch (Exception e) {\n     *     // error handling\n     * } finally {\n     *     IOUtils.closeQuietly(closeable);\n     * }\n     * </pre>\n     * <p>\n     * Closing all streams:\n     * </p>\n     * <pre>\n     * try {\n     *     return IOUtils.copy(inputStream, outputStream);\n     * } finally {\n     *     IOUtils.closeQuietly(inputStream);\n     *     IOUtils.closeQuietly(outputStream);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param closeable the objects to close, may be null or already closed\n     * @since 2.0\n     *\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Closeable closeable) {\n        closeQuietly(closeable, null);\n    }\n\n    /**\n     * Closes a {@link Closeable} unconditionally.\n     * <p>\n     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.\n     * <p>\n     * This is typically used in finally blocks to ensure that the closeable is closed\n     * even if an Exception was thrown before the normal close statement was reached.\n     * <br>\n     * <b>It should not be used to replace the close statement(s)\n     * which should be present for the non-exceptional case.</b>\n     * <br>\n     * It is only intended to simplify tidying up where normal processing has already failed\n     * and reporting close failure as well is not necessary or useful.\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * Closeable closeable = null;\n     * try {\n     *     closeable = new FileReader(&quot;foo.txt&quot;);\n     *     // processing using the closeable; may throw an Exception\n     *     closeable.close(); // Normal close - exceptions not ignored\n     * } catch (Exception e) {\n     *     // error handling\n     * } finally {\n     *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>\n     * }\n     * </pre>\n     * <p>\n     * Closing all streams:\n     * <br>\n     * <pre>\n     * try {\n     *     return IOUtils.copy(inputStream, outputStream);\n     * } finally {\n     *     IOUtils.closeQuietly(inputStream, outputStream);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     * @param closeables the objects to close, may be null or already closed\n     * @see #closeQuietly(Closeable)\n     * @since 2.5\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Closeable... closeables) {\n        if (closeables != null) {\n            Arrays.stream(closeables).forEach(IOUtils::closeQuietly);\n        }\n    }\n\n    /**\n     * Closes the given {@link Closeable} as a null-safe operation while consuming IOException by the given {@code consumer}.\n     *\n     * @param closeable The resource to close, may be null.\n     * @param consumer Consumes the IOException thrown by {@link Closeable#close()}.\n     * @since 2.7\n     */\n    public static void closeQuietly(final Closeable closeable, final Consumer<IOException> consumer) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer != null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Closes an {@link InputStream} unconditionally.\n     * <p>\n     * Equivalent to {@link InputStream#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   byte[] data = new byte[1024];\n     *   InputStream in = null;\n     *   try {\n     *       in = new FileInputStream(\"foo.txt\");\n     *       in.read(data);\n     *       in.close(); //close errors are handled\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(in);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param input the InputStream to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final InputStream input) {\n        closeQuietly((Closeable) input);\n    }\n\n    /**\n     * Closes an {@link OutputStream} unconditionally.\n     * <p>\n     * Equivalent to {@link OutputStream#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * byte[] data = \"Hello, World\".getBytes();\n     *\n     * OutputStream out = null;\n     * try {\n     *     out = new FileOutputStream(\"foo.txt\");\n     *     out.write(data);\n     *     out.close(); //close errors are handled\n     * } catch (IOException e) {\n     *     // error handling\n     * } finally {\n     *     IOUtils.closeQuietly(out);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param output the OutputStream to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final OutputStream output) {\n        closeQuietly((Closeable) output);\n    }\n\n    /**\n     * Closes an {@link Reader} unconditionally.\n     * <p>\n     * Equivalent to {@link Reader#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   char[] data = new char[1024];\n     *   Reader in = null;\n     *   try {\n     *       in = new FileReader(\"foo.txt\");\n     *       in.read(data);\n     *       in.close(); //close errors are handled\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(in);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param reader the Reader to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Reader reader) {\n        closeQuietly((Closeable) reader);\n    }\n\n    /**\n     * Closes a {@link Selector} unconditionally.\n     * <p>\n     * Equivalent to {@link Selector#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   Selector selector = null;\n     *   try {\n     *       selector = Selector.open();\n     *       // process socket\n     *\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(selector);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param selector the Selector to close, may be null or already closed\n     * @since 2.2\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Selector selector) {\n        closeQuietly((Closeable) selector);\n    }\n\n    /**\n     * Closes a {@link ServerSocket} unconditionally.\n     * <p>\n     * Equivalent to {@link ServerSocket#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   ServerSocket socket = null;\n     *   try {\n     *       socket = new ServerSocket();\n     *       // process socket\n     *       socket.close();\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(socket);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param serverSocket the ServerSocket to close, may be null or already closed\n     * @since 2.2\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final ServerSocket serverSocket) {\n        closeQuietly((Closeable) serverSocket);\n    }\n\n    /**\n     * Closes a {@link Socket} unconditionally.\n     * <p>\n     * Equivalent to {@link Socket#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   Socket socket = null;\n     *   try {\n     *       socket = new Socket(\"http://www.foo.com/\", 80);\n     *       // process socket\n     *       socket.close();\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(socket);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param socket the Socket to close, may be null or already closed\n     * @since 2.0\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Socket socket) {\n        closeQuietly((Closeable) socket);\n    }\n\n    /**\n     * Closes an {@link Writer} unconditionally.\n     * <p>\n     * Equivalent to {@link Writer#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   Writer out = null;\n     *   try {\n     *       out = new StringWriter();\n     *       out.write(\"Hello World\");\n     *       out.close(); //close errors are handled\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(out);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param writer the Writer to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Writer writer) {\n        closeQuietly((Closeable) writer);\n    }\n\n    /**\n     * Consumes bytes from a {@link InputStream} and ignores them.\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read.\n     * @return the number of bytes copied. or {@code 0} if {@code input is null}.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static long consume(final InputStream input)\n            throws IOException {\n        return copyLarge(input, NullOutputStream.INSTANCE, getByteArray());\n    }\n\n    /**\n     * Compares the contents of two Streams to determine if they are equal or\n     * not.\n     * <p>\n     * This method buffers the input internally using\n     * {@link BufferedInputStream} if they are not already buffered.\n     * </p>\n     *\n     * @param input1 the first stream\n     * @param input2 the second stream\n     * @return true if the content of the streams are equal or they both don't\n     * exist, false otherwise\n     * @throws NullPointerException if either input is null\n     * @throws IOException          if an I/O error occurs\n     */\n    public static boolean contentEquals(final InputStream input1, final InputStream input2) throws IOException {\n        // Before making any changes, please test with\n        // org.apache.commons.io.jmh.IOUtilsContentEqualsInputStreamsBenchmark\n        if (input1 == input2) {\n            return true;\n        }\n        if (input1 == null || input2 == null) {\n            return false;\n        }\n\n        // reuse one\n        final byte[] array1 = getByteArray();\n        // allocate another\n        final byte[] array2 = byteArray();\n        int pos1;\n        int pos2;\n        int count1;\n        int count2;\n        while (true) {\n            pos1 = 0;\n            pos2 = 0;\n            for (int index = 0; index < DEFAULT_BUFFER_SIZE; index++) {\n                if (pos1 == index) {\n                    do {\n                        count1 = input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n                    } while (count1 == 0);\n                    if (count1 == EOF) {\n                        return pos2 == index && input2.read() == EOF;\n                    }\n                    pos1 += count1;\n                }\n                if (pos2 == index) {\n                    do {\n                        count2 = input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n                    } while (count2 == 0);\n                    if (count2 == EOF) {\n                        return pos1 == index && input1.read() == EOF;\n                    }\n                    pos2 += count2;\n                }\n                if (array1[index] != array2[index]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    /**\n     * Compares the contents of two Readers to determine if they are equal or not.\n     * <p>\n     * This method buffers the input internally using {@link BufferedReader} if they are not already buffered.\n     * </p>\n     *\n     * @param input1 the first reader\n     * @param input2 the second reader\n     * @return true if the content of the readers are equal or they both don't exist, false otherwise\n     * @throws NullPointerException if either input is null\n     * @throws IOException if an I/O error occurs\n     * @since 1.1\n     */\n    public static boolean contentEquals(final Reader input1, final Reader input2) throws IOException {\n        if (input1 == input2) {\n            return true;\n        }\n        if (input1 == null || input2 == null) {\n            return false;\n        }\n\n        // reuse one\n        final char[] array1 = getCharArray();\n        // but allocate another\n        final char[] array2 = charArray();\n        int pos1;\n        int pos2;\n        int count1;\n        int count2;\n        while (true) {\n            pos1 = 0;\n            pos2 = 0;\n            for (int index = 0; index < DEFAULT_BUFFER_SIZE; index++) {\n                if (pos1 == index) {\n                    do {\n                        count1 = input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n                    } while (count1 == 0);\n                    if (count1 == EOF) {\n                        return pos2 == index && input2.read() == EOF;\n                    }\n                    pos1 += count1;\n                }\n                if (pos2 == index) {\n                    do {\n                        count2 = input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n                    } while (count2 == 0);\n                    if (count2 == EOF) {\n                        return pos1 == index && input1.read() == EOF;\n                    }\n                    pos2 += count2;\n                }\n                if (array1[index] != array2[index]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    /**\n     * Compares the contents of two Readers to determine if they are equal or\n     * not, ignoring EOL characters.\n     * <p>\n     * This method buffers the input internally using\n     * {@link BufferedReader} if they are not already buffered.\n     * </p>\n     *\n     * @param reader1 the first reader\n     * @param reader2 the second reader\n     * @return true if the content of the readers are equal (ignoring EOL differences),  false otherwise\n     * @throws NullPointerException if either input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    @SuppressWarnings(\"resource\")\n    public static boolean contentEqualsIgnoreEOL(final Reader reader1, final Reader reader2)\n            throws IOException {\n        if (reader1 == reader2) {\n            return true;\n        }\n        if (reader1 == null ^ reader2 == null) {\n            return false;\n        }\n        final BufferedReader br1 = toBufferedReader(reader1);\n        final BufferedReader br2 = toBufferedReader(reader2);\n\n        String line1 = br1.readLine();\n        String line2 = br2.readLine();\n        while (line1 != null && line1.equals(line2)) {\n            line1 = br1.readLine();\n            line2 = br2.readLine();\n        }\n        return Objects.equals(line1, line2);\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to an {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Large streams (over 2GB) will return a bytes copied value of {@code -1} after the copy has completed since\n     * the correct number of bytes cannot be returned as an int. For large streams use the\n     * {@link #copyLarge(InputStream, OutputStream)} method.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @return the number of bytes copied, or -1 if greater than {@link Integer#MAX_VALUE}.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 1.1\n     */\n    public static int copy(final InputStream inputStream, final OutputStream outputStream) throws IOException {\n        final long count = copyLarge(inputStream, outputStream);\n        return count > Integer.MAX_VALUE ? EOF : (int) count;\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to an {@link OutputStream} using an internal buffer of the\n     * given size.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write to\n     * @param bufferSize the bufferSize used to copy from the input to the output\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.5\n     */\n    public static long copy(final InputStream inputStream, final OutputStream outputStream, final int bufferSize)\n            throws IOException {\n        return copyLarge(inputStream, outputStream, IOUtils.byteArray(bufferSize));\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to chars on a\n     * {@link Writer} using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * This method uses {@link InputStreamReader}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #copy(InputStream, Writer, Charset)} instead\n     */\n    @Deprecated\n    public static void copy(final InputStream input, final Writer writer)\n            throws IOException {\n        copy(input, writer, Charset.defaultCharset());\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to chars on a\n     * {@link Writer} using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * This method uses {@link InputStreamReader}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputCharset the charset to use for the input stream, null means platform default\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void copy(final InputStream input, final Writer writer, final Charset inputCharset)\n            throws IOException {\n        final InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(inputCharset));\n        copy(reader, writer);\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to chars on a\n     * {@link Writer} using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link InputStreamReader}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputCharsetName the name of the requested charset for the InputStream, null means platform default\n     * @throws NullPointerException                         if the input or output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void copy(final InputStream input, final Writer writer, final String inputCharsetName)\n            throws IOException {\n        copy(input, writer, Charsets.toCharset(inputCharsetName));\n    }\n\n    /**\n     * Copies bytes from a {@link java.io.ByteArrayOutputStream} to a {@link QueueInputStream}.\n     * <p>\n     * Unlike using JDK {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream} for this, this\n     * solution works safely in a single thread environment.\n     * </p>\n     * <p>\n     * Example usage:\n     * </p>\n     *\n     * <pre>\n     * ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n     * outputStream.writeBytes(\"hello world\".getBytes(StandardCharsets.UTF_8));\n     *\n     * InputStream inputStream = IOUtils.copy(outputStream);\n     * </pre>\n     *\n     * @param outputStream the {@link java.io.ByteArrayOutputStream} to read.\n     * @return the {@link QueueInputStream} filled with the content of the outputStream.\n     * @throws NullPointerException if the {@link java.io.ByteArrayOutputStream} is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12\n     */\n    @SuppressWarnings(\"resource\") // streams are closed by the caller.\n    public static QueueInputStream copy(final java.io.ByteArrayOutputStream outputStream) throws IOException {\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        final QueueInputStream in = new QueueInputStream();\n        outputStream.writeTo(in.newQueueOutputStream());\n        return in;\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to a {@link Appendable}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Large streams (over 2GB) will return a chars copied value of\n     * {@code -1} after the copy has completed since the correct\n     * number of chars cannot be returned as an int. For large streams\n     * use the {@link #copyLarge(Reader, Writer)} method.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link Appendable} to write to\n     * @return the number of characters copied, or -1 if &gt; Integer.MAX_VALUE\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.7\n     */\n    public static long copy(final Reader reader, final Appendable output) throws IOException {\n        return copy(reader, output, CharBuffer.allocate(DEFAULT_BUFFER_SIZE));\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to an {@link Appendable}.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link Appendable} to write to\n     * @param buffer the buffer to be used for the copy\n     * @return the number of characters copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.7\n     */\n    public static long copy(final Reader reader, final Appendable output, final CharBuffer buffer) throws IOException {\n        long count = 0;\n        int n;\n        while (EOF != (n = reader.read(buffer))) {\n            buffer.flip();\n            output.append(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform, and calling flush.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Due to the implementation of OutputStreamWriter, this method performs a\n     * flush.\n     * </p>\n     * <p>\n     * This method uses {@link OutputStreamWriter}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #copy(Reader, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void copy(final Reader reader, final OutputStream output)\n            throws IOException {\n        copy(reader, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to bytes on an\n     * {@link OutputStream} using the specified character encoding, and\n     * calling flush.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Due to the implementation of OutputStreamWriter, this method performs a\n     * flush.\n     * </p>\n     * <p>\n     * This method uses {@link OutputStreamWriter}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param outputCharset the charset to use for the OutputStream, null means platform default\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void copy(final Reader reader, final OutputStream output, final Charset outputCharset)\n            throws IOException {\n        final OutputStreamWriter writer = new OutputStreamWriter(output, Charsets.toCharset(outputCharset));\n        copy(reader, writer);\n        // XXX Unless anyone is planning on rewriting OutputStreamWriter,\n        // we have to flush here.\n        writer.flush();\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to bytes on an\n     * {@link OutputStream} using the specified character encoding, and\n     * calling flush.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * Due to the implementation of OutputStreamWriter, this method performs a\n     * flush.\n     * </p>\n     * <p>\n     * This method uses {@link OutputStreamWriter}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param outputCharsetName the name of the requested charset for the OutputStream, null means platform default\n     * @throws NullPointerException                         if the input or output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void copy(final Reader reader, final OutputStream output, final String outputCharsetName)\n            throws IOException {\n        copy(reader, output, Charsets.toCharset(outputCharsetName));\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to a {@link Writer}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Large streams (over 2GB) will return a chars copied value of\n     * {@code -1} after the copy has completed since the correct\n     * number of chars cannot be returned as an int. For large streams\n     * use the {@link #copyLarge(Reader, Writer)} method.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read.\n     * @param writer the {@link Writer} to write.\n     * @return the number of characters copied, or -1 if &gt; Integer.MAX_VALUE\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static int copy(final Reader reader, final Writer writer) throws IOException {\n        final long count = copyLarge(reader, writer);\n        if (count > Integer.MAX_VALUE) {\n            return EOF;\n        }\n        return (int) count;\n    }\n\n    /**\n     * Copies bytes from a {@link URL} to an {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param url the {@link URL} to read.\n     * @param file the {@link OutputStream} to write.\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the URL is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static long copy(final URL url, final File file) throws IOException {\n        try (OutputStream outputStream = Files.newOutputStream(Objects.requireNonNull(file, \"file\").toPath())) {\n            return copy(url, outputStream);\n        }\n    }\n\n    /**\n     * Copies bytes from a {@link URL} to an {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param url the {@link URL} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the URL is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static long copy(final URL url, final OutputStream outputStream) throws IOException {\n        try (InputStream inputStream = Objects.requireNonNull(url, \"url\").openStream()) {\n            return copyLarge(inputStream, outputStream);\n        }\n    }\n\n    /**\n     * Copies bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 1.3\n     */\n    public static long copyLarge(final InputStream inputStream, final OutputStream outputStream)\n            throws IOException {\n        return copy(inputStream, outputStream, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Copies bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @param buffer the buffer to use for the copy\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.2\n     */\n    @SuppressWarnings(\"resource\") // streams are closed by the caller.\n    public static long copyLarge(final InputStream inputStream, final OutputStream outputStream, final byte[] buffer)\n        throws IOException {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        long count = 0;\n        int n;\n        while (EOF != (n = inputStream.read(buffer))) {\n            outputStream.write(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    /**\n     * Copies some or all bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input bytes.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(InputStream, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     *\n     * @param input the {@link InputStream} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param inputOffset : number of bytes to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of bytes to copy. -ve means all\n     * @return the number of bytes copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset,\n                                 final long length) throws IOException {\n        return copyLarge(input, output, inputOffset, length, getByteArray());\n    }\n\n    /**\n     * Copies some or all bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input bytes.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(InputStream, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param inputOffset : number of bytes to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of bytes to copy. -ve means all\n     * @param buffer the buffer to use for the copy\n     * @return the number of bytes copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final InputStream input, final OutputStream output,\n                                 final long inputOffset, final long length, final byte[] buffer) throws IOException {\n        if (inputOffset > 0) {\n            skipFully(input, inputOffset);\n        }\n        if (length == 0) {\n            return 0;\n        }\n        final int bufferLength = buffer.length;\n        int bytesToRead = bufferLength;\n        if (length > 0 && length < bufferLength) {\n            bytesToRead = (int) length;\n        }\n        int read;\n        long totalRead = 0;\n        while (bytesToRead > 0 && EOF != (read = input.read(buffer, 0, bytesToRead))) {\n            output.write(buffer, 0, read);\n            totalRead += read;\n            if (length > 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead = (int) Math.min(length - totalRead, bufferLength);\n            }\n        }\n        return totalRead;\n    }\n\n    /**\n     * Copies chars from a large (over 2GB) {@link Reader} to a {@link Writer}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to source.\n     * @param writer the {@link Writer} to target.\n     * @return the number of characters copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.3\n     */\n    public static long copyLarge(final Reader reader, final Writer writer) throws IOException {\n        return copyLarge(reader, writer, getCharArray());\n    }\n\n    /**\n     * Copies chars from a large (over 2GB) {@link Reader} to a {@link Writer}.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to source.\n     * @param writer the {@link Writer} to target.\n     * @param buffer the buffer to be used for the copy\n     * @return the number of characters copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final Reader reader, final Writer writer, final char[] buffer) throws IOException {\n        long count = 0;\n        int n;\n        while (EOF != (n = reader.read(buffer))) {\n            writer.write(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    /**\n     * Copies some or all chars from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input chars.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputOffset : number of chars to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of chars to copy. -ve means all\n     * @return the number of chars copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length)\n            throws IOException {\n        return copyLarge(reader, writer, inputOffset, length, getCharArray());\n    }\n\n    /**\n     * Copies some or all chars from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input chars.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputOffset : number of chars to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of chars to copy. -ve means all\n     * @param buffer the buffer to be used for the copy\n     * @return the number of chars copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length,\n                                 final char[] buffer)\n            throws IOException {\n        if (inputOffset > 0) {\n            skipFully(reader, inputOffset);\n        }\n        if (length == 0) {\n            return 0;\n        }\n        int bytesToRead = buffer.length;\n        if (length > 0 && length < buffer.length) {\n            bytesToRead = (int) length;\n        }\n        int read;\n        long totalRead = 0;\n        while (bytesToRead > 0 && EOF != (read = reader.read(buffer, 0, bytesToRead))) {\n            writer.write(buffer, 0, read);\n            totalRead += read;\n            if (length > 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead = (int) Math.min(length - totalRead, buffer.length);\n            }\n        }\n        return totalRead;\n    }\n\n    /**\n     * Gets the thread local byte array.\n     *\n     * @return the thread local byte array.\n     */\n    static byte[] getByteArray() {\n        return SKIP_BYTE_BUFFER.get();\n    }\n\n    /**\n     * Gets the thread local char array.\n     *\n     * @return the thread local char array.\n     */\n    static char[] getCharArray() {\n        return SKIP_CHAR_BUFFER.get();\n    }\n\n    /**\n     * Returns the length of the given array in a null-safe manner.\n     *\n     * @param array an array or null\n     * @return the array length -- or 0 if the given array is null.\n     * @since 2.7\n     */\n    public static int length(final byte[] array) {\n        return array == null ? 0 : array.length;\n    }\n\n    /**\n     * Returns the length of the given array in a null-safe manner.\n     *\n     * @param array an array or null\n     * @return the array length -- or 0 if the given array is null.\n     * @since 2.7\n     */\n    public static int length(final char[] array) {\n        return array == null ? 0 : array.length;\n    }\n\n    /**\n     * Returns the length of the given CharSequence in a null-safe manner.\n     *\n     * @param csq a CharSequence or null\n     * @return the CharSequence length -- or 0 if the given CharSequence is null.\n     * @since 2.7\n     */\n    public static int length(final CharSequence csq) {\n        return csq == null ? 0 : csq.length();\n    }\n\n    /**\n     * Returns the length of the given array in a null-safe manner.\n     *\n     * @param array an array or null\n     * @return the array length -- or 0 if the given array is null.\n     * @since 2.7\n     */\n    public static int length(final Object[] array) {\n        return array == null ? 0 : array.length;\n    }\n\n    /**\n     * Returns an Iterator for the lines in an {@link InputStream}, using\n     * the character encoding specified (or default encoding if null).\n     * <p>\n     * {@link LineIterator} holds a reference to the open\n     * {@link InputStream} specified here. When you have finished with\n     * the iterator you should close the stream to free internal resources.\n     * This can be done by using a try-with-resources block, closing the stream directly, or by calling\n     * {@link LineIterator#close()}.\n     * </p>\n     * <p>\n     * The recommended usage pattern is:\n     * </p>\n     * <pre>\n     * try {\n     *   LineIterator it = IOUtils.lineIterator(stream, charset);\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   IOUtils.closeQuietly(stream);\n     * }\n     * </pre>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charset the charset to use, null means platform default\n     * @return an Iterator of the lines in the reader, never null\n     * @throws IllegalArgumentException if the input is null\n     * @since 2.3\n     */\n    public static LineIterator lineIterator(final InputStream input, final Charset charset) {\n        return new LineIterator(new InputStreamReader(input, Charsets.toCharset(charset)));\n    }\n\n    /**\n     * Returns an Iterator for the lines in an {@link InputStream}, using\n     * the character encoding specified (or default encoding if null).\n     * <p>\n     * {@link LineIterator} holds a reference to the open\n     * {@link InputStream} specified here. When you have finished with\n     * the iterator you should close the stream to free internal resources.\n     * This can be done by using a try-with-resources block, closing the stream directly, or by calling\n     * {@link LineIterator#close()}.\n     * </p>\n     * <p>\n     * The recommended usage pattern is:\n     * </p>\n     * <pre>\n     * try {\n     *   LineIterator it = IOUtils.lineIterator(stream, \"UTF-8\");\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   IOUtils.closeQuietly(stream);\n     * }\n     * </pre>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charsetName the encoding to use, null means platform default\n     * @return an Iterator of the lines in the reader, never null\n     * @throws IllegalArgumentException                     if the input is null\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.2\n     */\n    public static LineIterator lineIterator(final InputStream input, final String charsetName) {\n        return lineIterator(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Returns an Iterator for the lines in a {@link Reader}.\n     * <p>\n     * {@link LineIterator} holds a reference to the open\n     * {@link Reader} specified here. When you have finished with the\n     * iterator you should close the reader to free internal resources.\n     * This can be done by using a try-with-resources block, closing the reader directly, or by calling\n     * {@link LineIterator#close()}.\n     * </p>\n     * <p>\n     * The recommended usage pattern is:\n     * </p>\n     * <pre>\n     * try {\n     *   LineIterator it = IOUtils.lineIterator(reader);\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   IOUtils.closeQuietly(reader);\n     * }\n     * </pre>\n     *\n     * @param reader the {@link Reader} to read from, not null\n     * @return an Iterator of the lines in the reader, never null\n     * @throws IllegalArgumentException if the reader is null\n     * @since 1.2\n     */\n    public static LineIterator lineIterator(final Reader reader) {\n        return new LineIterator(reader);\n    }\n\n    /**\n     * Reads bytes from an input stream.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link InputStream}.\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IOException if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final InputStream input, final byte[] buffer) throws IOException {\n        return read(input, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads bytes from an input stream.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link InputStream}.\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IllegalArgumentException if length is negative\n     * @throws IOException              if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length < 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining = length;\n        while (remaining > 0) {\n            final int location = length - remaining;\n            final int count = input.read(buffer, offset + location, remaining);\n            if (EOF == count) { // EOF\n                break;\n            }\n            remaining -= count;\n        }\n        return length - remaining;\n    }\n\n    /**\n     * Reads bytes from a ReadableByteChannel.\n     * <p>\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link ReadableByteChannel}.\n     * </p>\n     *\n     * @param input the byte channel to read\n     * @param buffer byte buffer destination\n     * @return the actual length read; may be less than requested if EOF was reached\n     * @throws IOException if a read error occurs\n     * @since 2.5\n     */\n    public static int read(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int length = buffer.remaining();\n        while (buffer.remaining() > 0) {\n            final int count = input.read(buffer);\n            if (EOF == count) { // EOF\n                break;\n            }\n        }\n        return length - buffer.remaining();\n    }\n\n    /**\n     * Reads characters from an input character stream.\n     * This implementation guarantees that it will read as many characters\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link Reader}.\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IOException if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final Reader reader, final char[] buffer) throws IOException {\n        return read(reader, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads characters from an input character stream.\n     * This implementation guarantees that it will read as many characters\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link Reader}.\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IllegalArgumentException if length is negative\n     * @throws IOException              if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final Reader reader, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length < 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining = length;\n        while (remaining > 0) {\n            final int location = length - remaining;\n            final int count = reader.read(buffer, offset + location, remaining);\n            if (EOF == count) { // EOF\n                break;\n            }\n            remaining -= count;\n        }\n        return length - remaining;\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     *\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of bytes read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final InputStream input, final byte[] buffer) throws IOException {\n        readFully(input, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     *\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of bytes read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual = read(input, buffer, offset, length);\n        if (actual != length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input where to read input from\n     * @param length length to read, must be &gt;= 0\n     * @return the bytes read from input\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of bytes read was incorrect\n     * @since 2.5\n     */\n    public static byte[] readFully(final InputStream input, final int length) throws IOException {\n        final byte[] buffer = IOUtils.byteArray(length);\n        readFully(input, buffer, 0, buffer.length);\n        return buffer;\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link ReadableByteChannel#read(ByteBuffer)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input the byte channel to read\n     * @param buffer byte buffer destination\n     * @throws IOException  if there is a problem reading the file\n     * @throws EOFException if the number of bytes read was incorrect\n     * @since 2.5\n     */\n    public static void readFully(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int expected = buffer.remaining();\n        final int actual = read(input, buffer);\n        if (actual != expected) {\n            throw new EOFException(\"Length to read: \" + expected + \" actual: \" + actual);\n        }\n    }\n\n    /**\n     * Reads the requested number of characters or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link Reader#read(char[], int, int)} may\n     * not read as many characters as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of characters read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final Reader reader, final char[] buffer) throws IOException {\n        readFully(reader, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads the requested number of characters or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link Reader#read(char[], int, int)} may\n     * not read as many characters as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of characters read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final Reader reader, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual = read(reader, buffer, offset, length);\n        if (actual != length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a list of Strings,\n     * one entry per line, using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @return the list of Strings, never null\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #readLines(InputStream, Charset)} instead\n     */\n    @Deprecated\n    public static List<String> readLines(final InputStream input) throws IOException {\n        return readLines(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a list of Strings,\n     * one entry per line, using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charset the charset to use, null means platform default\n     * @return the list of Strings, never null\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static List<String> readLines(final InputStream input, final Charset charset) throws IOException {\n        final InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(charset));\n        return readLines(reader);\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a list of Strings,\n     * one entry per line, using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the list of Strings, never null\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static List<String> readLines(final InputStream input, final String charsetName) throws IOException {\n        return readLines(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a list of Strings,\n     * one entry per line.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from, not null\n     * @return the list of Strings, never null\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\") // reader wraps input and is the responsibility of the caller.\n    public static List<String> readLines(final Reader reader) throws IOException {\n        final BufferedReader bufReader = toBufferedReader(reader);\n        final List<String> list = new ArrayList<>();\n        String line;\n        while ((line = bufReader.readLine()) != null) {\n            list.add(line);\n        }\n        return list;\n    }\n\n    /**\n     * Gets the contents of a resource as a byte array.\n     * <p>\n     * Delegates to {@link #resourceToByteArray(String, ClassLoader) resourceToByteArray(String, null)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @return the requested byte array\n     * @throws IOException if an I/O error occurs or the resource is not found.\n     * @see #resourceToByteArray(String, ClassLoader)\n     * @since 2.6\n     */\n    public static byte[] resourceToByteArray(final String name) throws IOException {\n        return resourceToByteArray(name, null);\n    }\n\n    /**\n     * Gets the contents of a resource as a byte array.\n     * <p>\n     * Delegates to {@link #resourceToURL(String, ClassLoader)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param classLoader the class loader that the resolution of the resource is delegated to\n     * @return the requested byte array\n     * @throws IOException if an I/O error occurs or the resource is not found.\n     * @see #resourceToURL(String, ClassLoader)\n     * @since 2.6\n     */\n    public static byte[] resourceToByteArray(final String name, final ClassLoader classLoader) throws IOException {\n        return toByteArray(resourceToURL(name, classLoader));\n    }\n\n    /**\n     * Gets the contents of a resource as a String using the specified character encoding.\n     * <p>\n     * Delegates to {@link #resourceToString(String, Charset, ClassLoader) resourceToString(String, Charset, null)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param charset the charset to use, null means platform default\n     * @return the requested String\n     * @throws IOException if an I/O error occurs or the resource is not found.\n     * @see #resourceToString(String, Charset, ClassLoader)\n     * @since 2.6\n     */\n    public static String resourceToString(final String name, final Charset charset) throws IOException {\n        return resourceToString(name, charset, null);\n    }\n\n    /**\n     * Gets the contents of a resource as a String using the specified character encoding.\n     * <p>\n     * Delegates to {@link #resourceToURL(String, ClassLoader)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param charset the Charset to use, null means platform default\n     * @param classLoader the class loader that the resolution of the resource is delegated to\n     * @return the requested String\n     * @throws IOException if an I/O error occurs.\n     * @see #resourceToURL(String, ClassLoader)\n     * @since 2.6\n     */\n    public static String resourceToString(final String name, final Charset charset, final ClassLoader classLoader) throws IOException {\n        return toString(resourceToURL(name, classLoader), charset);\n    }\n\n    /**\n     * Gets a URL pointing to the given resource.\n     * <p>\n     * Delegates to {@link #resourceToURL(String, ClassLoader) resourceToURL(String, null)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @return A URL object for reading the resource.\n     * @throws IOException if the resource is not found.\n     * @since 2.6\n     */\n    public static URL resourceToURL(final String name) throws IOException {\n        return resourceToURL(name, null);\n    }\n\n    /**\n     * Gets a URL pointing to the given resource.\n     * <p>\n     * If the {@code classLoader} is not null, call {@link ClassLoader#getResource(String)}, otherwise call\n     * {@link Class#getResource(String) IOUtils.class.getResource(name)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param classLoader Delegate to this class loader if not null\n     * @return A URL object for reading the resource.\n     * @throws IOException if the resource is not found.\n     * @since 2.6\n     */\n    public static URL resourceToURL(final String name, final ClassLoader classLoader) throws IOException {\n        // What about the thread context class loader?\n        // What about the system class loader?\n        final URL resource = classLoader == null ? IOUtils.class.getResource(name) : classLoader.getResource(name);\n        if (resource == null) {\n            throw new IOException(\"Resource not found: \" + name);\n        }\n        return resource;\n    }\n\n    /**\n     * Skips bytes from an input byte stream.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * skip() implementations in subclasses of {@link InputStream}.\n     * <p>\n     * Note that the implementation uses {@link InputStream#read(byte[], int, int)} rather\n     * than delegating to {@link InputStream#skip(long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of bytes are skipped.\n     * </p>\n     *\n     * @param input byte stream to skip\n     * @param toSkip number of bytes to skip.\n     * @return number of bytes actually skipped.\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @see InputStream#skip(long)\n     * @see <a href=\"https://issues.apache.org/jira/browse/IO-203\">IO-203 - Add skipFully() method for InputStreams</a>\n     * @since 2.0\n     */\n    public static long skip(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        /*\n         * N.B. no need to synchronize access to SKIP_BYTE_BUFFER: - we don't care if the buffer is created multiple\n         * times (the data is ignored) - we always use the same size buffer, so if it it is recreated it will still be\n         * OK (if the buffer size were variable, we would need to synch. to ensure some other thread did not create a\n         * smaller one)\n         */\n        long remain = toSkip;\n        while (remain > 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final byte[] byteArray = getByteArray();\n            final long n = input.read(byteArray, 0, (int) Math.min(remain, byteArray.length));\n            if (n < 0) { // EOF\n                break;\n            }\n            remain -= n;\n        }\n        return toSkip - remain;\n    }\n\n    /**\n     * Skips bytes from a ReadableByteChannel.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up.\n     *\n     * @param input ReadableByteChannel to skip\n     * @param toSkip number of bytes to skip.\n     * @return number of bytes actually skipped.\n     * @throws IOException              if there is a problem reading the ReadableByteChannel\n     * @throws IllegalArgumentException if toSkip is negative\n     * @since 2.5\n     */\n    public static long skip(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        final ByteBuffer skipByteBuffer = ByteBuffer.allocate((int) Math.min(toSkip, DEFAULT_BUFFER_SIZE));\n        long remain = toSkip;\n        while (remain > 0) {\n            skipByteBuffer.position(0);\n            skipByteBuffer.limit((int) Math.min(remain, DEFAULT_BUFFER_SIZE));\n            final int n = input.read(skipByteBuffer);\n            if (n == EOF) {\n                break;\n            }\n            remain -= n;\n        }\n        return toSkip - remain;\n    }\n\n    /**\n     * Skips characters from an input character stream.\n     * This implementation guarantees that it will read as many characters\n     * as possible before giving up; this may not always be the case for\n     * skip() implementations in subclasses of {@link Reader}.\n     * <p>\n     * Note that the implementation uses {@link Reader#read(char[], int, int)} rather\n     * than delegating to {@link Reader#skip(long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param reader character stream to skip\n     * @param toSkip number of characters to skip.\n     * @return number of characters actually skipped.\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @see Reader#skip(long)\n     * @see <a href=\"https://issues.apache.org/jira/browse/IO-203\">IO-203 - Add skipFully() method for InputStreams</a>\n     * @since 2.0\n     */\n    public static long skip(final Reader reader, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        long remain = toSkip;\n        while (remain > 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final char[] charArray = getCharArray();\n            final long n = reader.read(charArray, 0, (int) Math.min(remain, charArray.length));\n            if (n < 0) { // EOF\n                break;\n            }\n            remain -= n;\n        }\n        return toSkip - remain;\n    }\n\n    /**\n     * Skips the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#skip(long)} may\n     * not skip as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(InputStream, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param input stream to skip\n     * @param toSkip the number of bytes to skip\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @throws EOFException             if the number of bytes skipped was incorrect\n     * @see InputStream#skip(long)\n     * @since 2.0\n     */\n    public static void skipFully(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped = skip(input, toSkip);\n        if (skipped != toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }\n\n    /**\n     * Skips the requested number of bytes or fail if there are not enough left.\n     *\n     * @param input ReadableByteChannel to skip\n     * @param toSkip the number of bytes to skip\n     * @throws IOException              if there is a problem reading the ReadableByteChannel\n     * @throws IllegalArgumentException if toSkip is negative\n     * @throws EOFException             if the number of bytes skipped was incorrect\n     * @since 2.5\n     */\n    public static void skipFully(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped = skip(input, toSkip);\n        if (skipped != toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }\n\n    /**\n     * Skips the requested number of characters or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link Reader#skip(long)} may\n     * not skip as many characters as requested (most likely because of reaching EOF).\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(Reader, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param reader stream to skip\n     * @param toSkip the number of characters to skip\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @throws EOFException             if the number of characters skipped was incorrect\n     * @see Reader#skip(long)\n     * @since 2.0\n     */\n    public static void skipFully(final Reader reader, final long toSkip) throws IOException {\n        final long skipped = skip(reader, toSkip);\n        if (skipped != toSkip) {\n            throw new EOFException(\"Chars to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }\n\n    /**\n     * Fetches entire contents of an {@link InputStream} and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * </p>\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * <p>\n     * It can be used in favor of {@link #toByteArray(InputStream)}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input Stream to be fully buffered.\n     * @return A fully buffered stream.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream(final InputStream input) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input);\n    }\n\n    /**\n     * Fetches entire contents of an {@link InputStream} and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * </p>\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * <p>\n     * It can be used in favor of {@link #toByteArray(InputStream)}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     * @return A fully buffered stream.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream(final InputStream input, final int size) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input, size);\n    }\n\n    /**\n     * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a BufferedReader from the given\n     * reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @see #buffer(Reader)\n     * @since 2.2\n     */\n    public static BufferedReader toBufferedReader(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }\n\n    /**\n     * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a BufferedReader from the given\n     * reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedReader is created.\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @see #buffer(Reader)\n     * @since 2.5\n     */\n    public static BufferedReader toBufferedReader(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a {@code byte[]}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @return the requested byte array.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws IOException if an I/O error occurs or reading more than {@link Integer#MAX_VALUE} occurs.\n     */\n    public static byte[] toByteArray(final InputStream inputStream) throws IOException {\n        // We use a ThresholdingOutputStream to avoid reading AND writing more than Integer.MAX_VALUE.\n        try (UnsynchronizedByteArrayOutputStream ubaOutput = new UnsynchronizedByteArrayOutputStream();\n            ThresholdingOutputStream thresholdOuput = new ThresholdingOutputStream(Integer.MAX_VALUE, os -> {\n                throw new IllegalArgumentException(String.format(\"Cannot read more than %,d into a byte array\", Integer.MAX_VALUE));\n            }, os -> ubaOutput)) {\n            copy(inputStream, thresholdOuput);\n            return ubaOutput.toByteArray();\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a {@code byte[]}. Use this method instead of\n     * {@link #toByteArray(InputStream)} when {@link InputStream} size is known.\n     *\n     * @param input the {@link InputStream} to read.\n     * @param size the size of {@link InputStream} to read, where 0 &lt; {@code size} &lt;= length of input stream.\n     * @return byte [] of length {@code size}.\n     * @throws IOException if an I/O error occurs or {@link InputStream} length is smaller than parameter {@code size}.\n     * @throws IllegalArgumentException if {@code size} is less than zero.\n     * @since 2.1\n     */\n    public static byte[] toByteArray(final InputStream input, final int size) throws IOException {\n\n        if (size < 0) {\n            throw new IllegalArgumentException(\"Size must be equal or greater than zero: \" + size);\n        }\n\n        if (size == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n\n        final byte[] data = IOUtils.byteArray(size);\n        int offset = 0;\n        int read;\n\n        while (offset < size && (read = input.read(data, offset, size - offset)) != EOF) {\n            offset += read;\n        }\n\n        if (offset != size) {\n            throw new IOException(\"Unexpected read size, current: \" + offset + \", expected: \" + size);\n        }\n\n        return data;\n    }\n\n    /**\n     * Gets contents of an {@link InputStream} as a {@code byte[]}.\n     * Use this method instead of {@link #toByteArray(InputStream)}\n     * when {@link InputStream} size is known.\n     * <b>NOTE:</b> the method checks that the length can safely be cast to an int without truncation\n     * before using {@link IOUtils#toByteArray(java.io.InputStream, int)} to read into the byte array.\n     * (Arrays can have no more than Integer.MAX_VALUE entries anyway)\n     *\n     * @param input the {@link InputStream} to read from\n     * @param size the size of {@link InputStream} to read, where 0 &lt; {@code size} &lt;= min(Integer.MAX_VALUE, length of input stream).\n     * @return byte [] the requested byte array, of length {@code size}\n     * @throws IOException              if an I/O error occurs or {@link InputStream} length is less than {@code size}\n     * @throws IllegalArgumentException if size is less than zero or size is greater than Integer.MAX_VALUE\n     * @see IOUtils#toByteArray(java.io.InputStream, int)\n     * @since 2.1\n     */\n    public static byte[] toByteArray(final InputStream input, final long size) throws IOException {\n        if (size > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Size cannot be greater than Integer max value: \" + size);\n        }\n        return toByteArray(input, (int) size);\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a {@code byte[]}\n     * using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @deprecated 2.5 use {@link #toByteArray(Reader, Charset)} instead\n     */\n    @Deprecated\n    public static byte[] toByteArray(final Reader reader) throws IOException {\n        return toByteArray(reader, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a {@code byte[]}\n     * using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param charset the charset to use, null means platform default\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static byte[] toByteArray(final Reader reader, final Charset charset) throws IOException {\n        try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n            copy(reader, output, charset);\n            return output.toByteArray();\n        }\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a {@code byte[]}\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested byte array\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static byte[] toByteArray(final Reader reader, final String charsetName) throws IOException {\n        return toByteArray(reader, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link String} as a {@code byte[]}\n     * using the default character encoding of the platform.\n     * <p>\n     * This is the same as {@link String#getBytes()}.\n     * </p>\n     *\n     * @param input the {@link String} to convert\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @deprecated 2.5 Use {@link String#getBytes()} instead\n     */\n    @Deprecated\n    public static byte[] toByteArray(final String input) {\n        // make explicit the use of the default charset\n        return input.getBytes(Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of a {@link URI} as a {@code byte[]}.\n     *\n     * @param uri the {@link URI} to read\n     * @return the requested byte array\n     * @throws NullPointerException if the uri is null\n     * @throws IOException          if an I/O exception occurs\n     * @since 2.4\n     */\n    public static byte[] toByteArray(final URI uri) throws IOException {\n        return IOUtils.toByteArray(uri.toURL());\n    }\n\n    /**\n     * Gets the contents of a {@link URL} as a {@code byte[]}.\n     *\n     * @param url the {@link URL} to read\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O exception occurs\n     * @since 2.4\n     */\n    public static byte[] toByteArray(final URL url) throws IOException {\n        try (CloseableURLConnection urlConnection = CloseableURLConnection.open(url)) {\n            return IOUtils.toByteArray(urlConnection);\n        }\n    }\n\n    /**\n     * Gets the contents of a {@link URLConnection} as a {@code byte[]}.\n     *\n     * @param urlConnection the {@link URLConnection} to read.\n     * @return the requested byte array.\n     * @throws NullPointerException if the urlConn is null.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.4\n     */\n    public static byte[] toByteArray(final URLConnection urlConnection) throws IOException {\n        try (InputStream inputStream = urlConnection.getInputStream()) {\n            return IOUtils.toByteArray(inputStream);\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a character array\n     * using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read from\n     * @return the requested character array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #toCharArray(InputStream, Charset)} instead\n     */\n    @Deprecated\n    public static char[] toCharArray(final InputStream inputStream) throws IOException {\n        return toCharArray(inputStream, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a character array\n     * using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read from\n     * @param charset the charset to use, null means platform default\n     * @return the requested character array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static char[] toCharArray(final InputStream inputStream, final Charset charset)\n            throws IOException {\n        final CharArrayWriter writer = new CharArrayWriter();\n        copy(inputStream, writer, charset);\n        return writer.toCharArray();\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a character array\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested character array\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static char[] toCharArray(final InputStream inputStream, final String charsetName) throws IOException {\n        return toCharArray(inputStream, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a character array.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @return the requested character array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static char[] toCharArray(final Reader reader) throws IOException {\n        final CharArrayWriter sw = new CharArrayWriter();\n        copy(reader, sw);\n        return sw.toCharArray();\n    }\n\n    /**\n     * Converts the specified CharSequence to an input stream, encoded as bytes\n     * using the default character encoding of the platform.\n     *\n     * @param input the CharSequence to convert\n     * @return an input stream\n     * @since 2.0\n     * @deprecated 2.5 use {@link #toInputStream(CharSequence, Charset)} instead\n     */\n    @Deprecated\n    public static InputStream toInputStream(final CharSequence input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Converts the specified CharSequence to an input stream, encoded as bytes\n     * using the specified character encoding.\n     *\n     * @param input the CharSequence to convert\n     * @param charset the charset to use, null means platform default\n     * @return an input stream\n     * @since 2.3\n     */\n    public static InputStream toInputStream(final CharSequence input, final Charset charset) {\n        return toInputStream(input.toString(), charset);\n    }\n\n    /**\n     * Converts the specified CharSequence to an input stream, encoded as bytes\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param input the CharSequence to convert\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return an input stream\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 2.0\n     */\n    public static InputStream toInputStream(final CharSequence input, final String charsetName) {\n        return toInputStream(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Converts the specified string to an input stream, encoded as bytes\n     * using the default character encoding of the platform.\n     *\n     * @param input the string to convert\n     * @return an input stream\n     * @since 1.1\n     * @deprecated 2.5 use {@link #toInputStream(String, Charset)} instead\n     */\n    @Deprecated\n    public static InputStream toInputStream(final String input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Converts the specified string to an input stream, encoded as bytes\n     * using the specified character encoding.\n     *\n     * @param input the string to convert\n     * @param charset the charset to use, null means platform default\n     * @return an input stream\n     * @since 2.3\n     */\n    public static InputStream toInputStream(final String input, final Charset charset) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charset)));\n    }\n\n    /**\n     * Converts the specified string to an input stream, encoded as bytes\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param input the string to convert\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return an input stream\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static InputStream toInputStream(final String input, final String charsetName) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charsetName)));\n    }\n\n    /**\n     * Gets the contents of a {@code byte[]} as a String\n     * using the default character encoding of the platform.\n     *\n     * @param input the byte array to read from\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @deprecated 2.5 Use {@link String#String(byte[])} instead\n     */\n    @Deprecated\n    public static String toString(final byte[] input) {\n        // make explicit the use of the default charset\n        return new String(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of a {@code byte[]} as a String\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param input the byte array to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     */\n    public static String toString(final byte[] input, final String charsetName) {\n        return new String(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a String\n     * using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @deprecated 2.5 use {@link #toString(InputStream, Charset)} instead\n     */\n    @Deprecated\n    public static String toString(final InputStream input) throws IOException {\n        return toString(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a String\n     * using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param charset the charset to use, null means platform default\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static String toString(final InputStream input, final Charset charset) throws IOException {\n        try (StringBuilderWriter sw = new StringBuilderWriter()) {\n            copy(input, sw, charset);\n            return sw.toString();\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a String\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested String\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     */\n    public static String toString(final InputStream input, final String charsetName)\n            throws IOException {\n        return toString(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a String.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     */\n    public static String toString(final Reader reader) throws IOException {\n        try (StringBuilderWriter sw = new StringBuilderWriter()) {\n            copy(reader, sw);\n            return sw.toString();\n        }\n    }\n\n    /**\n     * Gets the contents at the given URI.\n     *\n     * @param uri The URI source.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.1\n     * @deprecated 2.5 use {@link #toString(URI, Charset)} instead\n     */\n    @Deprecated\n    public static String toString(final URI uri) throws IOException {\n        return toString(uri, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents at the given URI.\n     *\n     * @param uri The URI source.\n     * @param encoding The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.3.\n     */\n    public static String toString(final URI uri, final Charset encoding) throws IOException {\n        return toString(uri.toURL(), Charsets.toCharset(encoding));\n    }\n\n    /**\n     * Gets the contents at the given URI.\n     *\n     * @param uri The URI source.\n     * @param charsetName The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException                                  if an I/O exception occurs.\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 2.1\n     */\n    public static String toString(final URI uri, final String charsetName) throws IOException {\n        return toString(uri, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents at the given URL.\n     *\n     * @param url The URL source.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.1\n     * @deprecated 2.5 use {@link #toString(URL, Charset)} instead\n     */\n    @Deprecated\n    public static String toString(final URL url) throws IOException {\n        return toString(url, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents at the given URL.\n     *\n     * @param url The URL source.\n     * @param encoding The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.3\n     */\n    public static String toString(final URL url, final Charset encoding) throws IOException {\n        try (InputStream inputStream = url.openStream()) {\n            return toString(inputStream, encoding);\n        }\n    }\n\n    /**\n     * Gets the contents at the given URL.\n     *\n     * @param url The URL source.\n     * @param charsetName The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException                                  if an I/O exception occurs.\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 2.1\n     */\n    public static String toString(final URL url, final String charsetName) throws IOException {\n        return toString(url, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to an {@link OutputStream}.\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void write(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data != null) {\n            output.write(data);\n        }\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to chars on a {@link Writer}\n     * using the default character encoding of the platform.\n     * <p>\n     * This method uses {@link String#String(byte[])}.\n     * </p>\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #write(byte[], Writer, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final byte[] data, final Writer writer) throws IOException {\n        write(data, writer, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to chars on a {@link Writer}\n     * using the specified character encoding.\n     * <p>\n     * This method uses {@link String#String(byte[], String)}.\n     * </p>\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void write(final byte[] data, final Writer writer, final Charset charset) throws IOException {\n        if (data != null) {\n            writer.write(new String(data, Charsets.toCharset(charset)));\n        }\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to chars on a {@link Writer}\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#String(byte[], String)}.\n     * </p>\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException                         if output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void write(final byte[] data, final Writer writer, final String charsetName) throws IOException {\n        write(data, writer, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to bytes on an\n     * {@link OutputStream}.\n     * <p>\n     * This method uses {@link String#String(char[])} and\n     * {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #write(char[], OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final char[] data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * This method uses {@link String#String(char[])} and\n     * {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void write(final char[] data, final OutputStream output, final Charset charset) throws IOException {\n        if (data != null) {\n            write(new String(data), output, charset);\n        }\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#String(char[])} and\n     * {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException                         if output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 1.1\n     */\n    public static void write(final char[] data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to a {@link Writer}\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void write(final char[] data, final Writer writer) throws IOException {\n        if (data != null) {\n            writer.write(data);\n        }\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform.\n     * <p>\n     * This method uses {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.0\n     * @deprecated 2.5 use {@link #write(CharSequence, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final CharSequence data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void write(final CharSequence data, final OutputStream output, final Charset charset)\n            throws IOException {\n        if (data != null) {\n            write(data.toString(), output, charset);\n        }\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException        if output is null\n     * @throws IOException                 if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 2.0\n     */\n    public static void write(final CharSequence data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to a {@link Writer}.\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.0\n     */\n    public static void write(final CharSequence data, final Writer writer) throws IOException {\n        if (data != null) {\n            write(data.toString(), writer);\n        }\n    }\n\n\n    /**\n     * Writes chars from a {@link String} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform.\n     * <p>\n     * This method uses {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #write(String, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final String data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes chars from a {@link String} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    @SuppressWarnings(\"resource\")\n    public static void write(final String data, final OutputStream output, final Charset charset) throws IOException {\n        if (data != null) {\n            // Use Charset#encode(String), since calling String#getBytes(Charset) might result in\n            // NegativeArraySizeException or OutOfMemoryError.\n            // The underlying OutputStream should not be closed, so the channel is not closed.\n            Channels.newChannel(output).write(Charsets.toCharset(charset).encode(data));\n        }\n    }\n\n    /**\n     * Writes chars from a {@link String} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException        if output is null\n     * @throws IOException                 if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 1.1\n     */\n    public static void write(final String data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@link String} to a {@link Writer}.\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void write(final String data, final Writer writer) throws IOException {\n        if (data != null) {\n            writer.write(data);\n        }\n    }\n\n    /**\n     * Writes chars from a {@link StringBuffer} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform.\n     * <p>\n     * This method uses {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the {@link StringBuffer} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated Use {@link #write(CharSequence, OutputStream)}\n     */\n    @Deprecated\n    public static void write(final StringBuffer data, final OutputStream output) //NOSONAR\n            throws IOException {\n        write(data, output, (String) null);\n    }\n\n    /**\n     * Writes chars from a {@link StringBuffer} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link StringBuffer} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException        if output is null\n     * @throws IOException                 if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 1.1\n     * @deprecated Use {@link #write(CharSequence, OutputStream, String)}.\n     */\n    @Deprecated\n    public static void write(final StringBuffer data, final OutputStream output, final String charsetName) //NOSONAR\n        throws IOException {\n        if (data != null) {\n            write(data.toString(), output, Charsets.toCharset(charsetName));\n        }\n    }\n\n    /**\n     * Writes chars from a {@link StringBuffer} to a {@link Writer}.\n     *\n     * @param data the {@link StringBuffer} to write, null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated Use {@link #write(CharSequence, Writer)}\n     */\n    @Deprecated\n    public static void write(final StringBuffer data, final Writer writer) //NOSONAR\n            throws IOException {\n        if (data != null) {\n            writer.write(data.toString());\n        }\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to an {@link OutputStream} using chunked writes.\n     * This is intended for writing very large byte arrays which might otherwise cause excessive\n     * memory usage if the native code has to allocate a copy.\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.5\n     */\n    public static void writeChunked(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data != null) {\n            int bytes = data.length;\n            int offset = 0;\n            while (bytes > 0) {\n                final int chunk = Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                output.write(data, offset, chunk);\n                bytes -= chunk;\n                offset += chunk;\n            }\n        }\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to a {@link Writer} using chunked writes.\n     * This is intended for writing very large byte arrays which might otherwise cause excessive\n     * memory usage if the native code has to allocate a copy.\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.5\n     */\n    public static void writeChunked(final char[] data, final Writer writer) throws IOException {\n        if (data != null) {\n            int bytes = data.length;\n            int offset = 0;\n            while (bytes > 0) {\n                final int chunk = Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                writer.write(data, offset, chunk);\n                bytes -= chunk;\n                offset += chunk;\n            }\n        }\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * an {@link OutputStream} line by line, using the default character\n     * encoding of the platform and the specified line ending.\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param output the {@link OutputStream} to write to, not null, not closed\n     * @throws NullPointerException if the output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #writeLines(Collection, String, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void writeLines(final Collection<?> lines, final String lineEnding,\n                                  final OutputStream output) throws IOException {\n        writeLines(lines, lineEnding, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * an {@link OutputStream} line by line, using the specified character\n     * encoding and the specified line ending.\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param output the {@link OutputStream} to write to, not null, not closed\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if the output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void writeLines(final Collection<?> lines, String lineEnding, final OutputStream output,\n                                  final Charset charset) throws IOException {\n        if (lines == null) {\n            return;\n        }\n        if (lineEnding == null) {\n            lineEnding = System.lineSeparator();\n        }\n        final Charset cs = Charsets.toCharset(charset);\n        final byte[] eolBytes = lineEnding.getBytes(cs);\n        for (final Object line : lines) {\n            if (line != null) {\n                write(line.toString(), output, cs);\n            }\n            output.write(eolBytes);\n        }\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * an {@link OutputStream} line by line, using the specified character\n     * encoding and the specified line ending.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param output the {@link OutputStream} to write to, not null, not closed\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException                         if the output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void writeLines(final Collection<?> lines, final String lineEnding,\n                                  final OutputStream output, final String charsetName) throws IOException {\n        writeLines(lines, lineEnding, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * a {@link Writer} line by line, using the specified line ending.\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param writer the {@link Writer} to write to, not null, not closed\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void writeLines(final Collection<?> lines, String lineEnding,\n                                  final Writer writer) throws IOException {\n        if (lines == null) {\n            return;\n        }\n        if (lineEnding == null) {\n            lineEnding = System.lineSeparator();\n        }\n        for (final Object line : lines) {\n            if (line != null) {\n                writer.write(line.toString());\n            }\n            writer.write(lineEnding);\n        }\n    }\n\n    /**\n     * Returns the given Appendable if it is already a {@link Writer}, otherwise creates a Writer wrapper around the\n     * given Appendable.\n     *\n     * @param appendable the Appendable to wrap or return (not null)\n     * @return  the given Appendable or a Writer wrapper around the given Appendable\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.7\n     */\n    public static Writer writer(final Appendable appendable) {\n        Objects.requireNonNull(appendable, \"appendable\");\n        if (appendable instanceof Writer) {\n            return (Writer) appendable;\n        }\n        if (appendable instanceof StringBuilder) {\n            return new StringBuilderWriter((StringBuilder) appendable);\n        }\n        return new AppendableWriter<>(appendable);\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public IOUtils() { //NOSONAR\n    }\n\n}\n", "filePathAfter": "src/main/java/org/apache/commons/io/IOUtils.java", "sourceCodeAfterForWhole": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayInputStream;\nimport java.io.CharArrayWriter;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.net.HttpURLConnection;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.Selector;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.input.QueueInputStream;\nimport org.apache.commons.io.output.AppendableWriter;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.apache.commons.io.output.NullOutputStream;\nimport org.apache.commons.io.output.StringBuilderWriter;\nimport org.apache.commons.io.output.ThresholdingOutputStream;\nimport org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n\n/**\n * General IO stream manipulation utilities.\n * <p>\n * This class provides static utility methods for input/output operations.\n * </p>\n * <ul>\n * <li>closeQuietly - these methods close a stream ignoring nulls and exceptions\n * <li>toXxx/read - these methods read data from a stream\n * <li>write - these methods write data to a stream\n * <li>copy - these methods copy all the data from one stream to another\n * <li>contentEquals - these methods compare the content of two streams\n * </ul>\n * <p>\n * The byte-to-char methods and char-to-byte methods involve a conversion step.\n * Two methods are provided in each case, one that uses the platform default\n * encoding and the other which allows you to specify an encoding. You are\n * encouraged to always specify an encoding because relying on the platform\n * default can lead to unexpected results, for example when moving from\n * development to production.\n * </p>\n * <p>\n * All the methods in this class that read a stream are buffered internally.\n * This means that there is no cause to use a {@link BufferedInputStream}\n * or {@link BufferedReader}. The default buffer size of 4K has been shown\n * to be efficient in tests.\n * </p>\n * <p>\n * The various copy methods all delegate the actual copying to one of the following methods:\n * </p>\n * <ul>\n * <li>{@link #copyLarge(InputStream, OutputStream, byte[])}</li>\n * <li>{@link #copyLarge(InputStream, OutputStream, long, long, byte[])}</li>\n * <li>{@link #copyLarge(Reader, Writer, char[])}</li>\n * <li>{@link #copyLarge(Reader, Writer, long, long, char[])}</li>\n * </ul>\n * For example, {@link #copy(InputStream, OutputStream)} calls {@link #copyLarge(InputStream, OutputStream)}\n * which calls {@link #copy(InputStream, OutputStream, int)} which creates the buffer and calls\n * {@link #copyLarge(InputStream, OutputStream, byte[])}.\n * <p>\n * Applications can re-use buffers by using the underlying methods directly.\n * This may improve performance for applications that need to do a lot of copying.\n * </p>\n * <p>\n * Wherever possible, the methods in this class do <em>not</em> flush or close\n * the stream. This is to avoid making non-portable assumptions about the\n * streams' origin and further use. Thus the caller is still responsible for\n * closing streams after use.\n * </p>\n * <p>\n * Origin of code: Excalibur.\n * </p>\n */\npublic class IOUtils {\n    // NOTE: This class is focused on InputStream, OutputStream, Reader and\n    // Writer. Each method should take at least one of these as a parameter,\n    // or return one of them.\n\n    /**\n     * CR char.\n     *\n     * @since 2.9.0\n     */\n    public static final int CR = '\\r';\n\n    /**\n     * The default buffer size ({@value}) to use in copy methods.\n     */\n    public static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     * The system directory separator character.\n     */\n    public static final char DIR_SEPARATOR = File.separatorChar;\n\n    /**\n     * The Unix directory separator character.\n     */\n    public static final char DIR_SEPARATOR_UNIX = '/';\n\n    /**\n     * The Windows directory separator character.\n     */\n    public static final char DIR_SEPARATOR_WINDOWS = '\\\\';\n\n    /**\n     * A singleton empty byte array.\n     *\n     *  @since 2.9.0\n     */\n    public static final byte[] EMPTY_BYTE_ARRAY = {};\n\n    /**\n     * Represents the end-of-file (or stream).\n     * @since 2.5 (made public)\n     */\n    public static final int EOF = -1;\n\n    /**\n     * LF char.\n     *\n     * @since 2.9.0\n     */\n    public static final int LF = '\\n';\n\n    /**\n     * The system line separator string.\n     *\n     * @deprecated Use {@link System#lineSeparator()}.\n     */\n    @Deprecated\n    public static final String LINE_SEPARATOR = System.lineSeparator();\n\n    /**\n     * The Unix line separator string.\n     *\n     * @see StandardLineSeparator#LF\n     */\n    public static final String LINE_SEPARATOR_UNIX = StandardLineSeparator.LF.getString();\n\n    /**\n     * The Windows line separator string.\n     *\n     * @see StandardLineSeparator#CRLF\n     */\n    public static final String LINE_SEPARATOR_WINDOWS = StandardLineSeparator.CRLF.getString();\n\n    /**\n     * Internal byte array buffer.\n     */\n    private static final ThreadLocal<byte[]> SKIP_BYTE_BUFFER = ThreadLocal.withInitial(IOUtils::byteArray);\n\n    /**\n     * Internal byte array buffer.\n     */\n    private static final ThreadLocal<char[]> SKIP_CHAR_BUFFER = ThreadLocal.withInitial(IOUtils::charArray);\n\n    /**\n     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a\n     * BufferedInputStream from the given InputStream.\n     *\n     * @param inputStream the InputStream to wrap or return (not null)\n     * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedInputStream buffer(final InputStream inputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream);\n    }\n\n    /**\n     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a\n     * BufferedInputStream from the given InputStream.\n     *\n     * @param inputStream the InputStream to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedInputStream is created.\n     * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedInputStream buffer(final InputStream inputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream, size);\n    }\n\n    /**\n     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a\n     * BufferedOutputStream from the given OutputStream.\n     *\n     * @param outputStream the OutputStream to wrap or return (not null)\n     * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedOutputStream buffer(final OutputStream outputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream);\n    }\n\n    /**\n     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a\n     * BufferedOutputStream from the given OutputStream.\n     *\n     * @param outputStream the OutputStream to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedOutputStream is created.\n     * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedOutputStream buffer(final OutputStream outputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream, size);\n    }\n\n    /**\n     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from\n     * the given reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedReader buffer(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }\n\n    /**\n     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from the\n     * given reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedReader is created.\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedReader buffer(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }\n\n    /**\n     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the\n     * given Writer.\n     *\n     * @param writer the Writer to wrap or return (not null)\n     * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedWriter buffer(final Writer writer) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer);\n    }\n\n    /**\n     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the\n     * given Writer.\n     *\n     * @param writer the Writer to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedWriter is created.\n     * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedWriter buffer(final Writer writer, final int size) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer, size);\n    }\n\n    /**\n     * Returns a new byte array of size {@link #DEFAULT_BUFFER_SIZE}.\n     *\n     * @return a new byte array of size {@link #DEFAULT_BUFFER_SIZE}.\n     * @since 2.9.0\n     */\n    public static byte[] byteArray() {\n        return byteArray(DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Returns a new byte array of the given size.\n     *\n     * TODO Consider guarding or warning against large allocations...\n     *\n     * @param size array size.\n     * @return a new byte array of the given size.\n     * @since 2.9.0\n     */\n    public static byte[] byteArray(final int size) {\n        return new byte[size];\n    }\n\n    /**\n     * Returns a new char array of size {@link #DEFAULT_BUFFER_SIZE}.\n     *\n     * @return a new char array of size {@link #DEFAULT_BUFFER_SIZE}.\n     * @since 2.9.0\n     */\n    private static char[] charArray() {\n        return charArray(DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Returns a new char array of the given size.\n     *\n     * TODO Consider guarding or warning against large allocations...\n     *\n     * @param size array size.\n     * @return a new char array of the given size.\n     * @since 2.9.0\n     */\n    private static char[] charArray(final int size) {\n        return new char[size];\n    }\n\n    /**\n     * Closes the given {@link Closeable} as a null-safe operation.\n     *\n     * @param closeable The resource to close, may be null.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.7\n     */\n    public static void close(final Closeable closeable) throws IOException {\n        if (closeable != null) {\n            closeable.close();\n        }\n    }\n\n    /**\n     * Closes the given {@link Closeable}s as null-safe operations.\n     *\n     * @param closeables The resource(s) to close, may be null.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static void close(final Closeable... closeables) throws IOException {\n        IOConsumer.forEach(closeables, IOUtils::close);\n    }\n\n    /**\n     * Closes the given {@link Closeable} as a null-safe operation.\n     *\n     * @param closeable The resource to close, may be null.\n     * @param consumer Consume the IOException thrown by {@link Closeable#close()}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.7\n     */\n    public static void close(final Closeable closeable, final IOConsumer<IOException> consumer) throws IOException {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer != null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Closes a URLConnection.\n     *\n     * @param conn the connection to close.\n     * @since 2.4\n     */\n    public static void close(final URLConnection conn) {\n        if (conn instanceof HttpURLConnection) {\n            ((HttpURLConnection) conn).disconnect();\n        }\n    }\n\n    /**\n     * Closes a {@link Closeable} unconditionally.\n     *\n     * <p>\n     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored. This is typically used in\n     * finally blocks.\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * Closeable closeable = null;\n     * try {\n     *     closeable = new FileReader(&quot;foo.txt&quot;);\n     *     // process closeable\n     *     closeable.close();\n     * } catch (Exception e) {\n     *     // error handling\n     * } finally {\n     *     IOUtils.closeQuietly(closeable);\n     * }\n     * </pre>\n     * <p>\n     * Closing all streams:\n     * </p>\n     * <pre>\n     * try {\n     *     return IOUtils.copy(inputStream, outputStream);\n     * } finally {\n     *     IOUtils.closeQuietly(inputStream);\n     *     IOUtils.closeQuietly(outputStream);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param closeable the objects to close, may be null or already closed\n     * @since 2.0\n     *\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Closeable closeable) {\n        closeQuietly(closeable, null);\n    }\n\n    /**\n     * Avoids the need to type cast.\n     */\n    private static void closeQ(final Closeable closeable) {\n        closeQuietly(closeable, null);\n    }\n\n    /**\n     * Closes a {@link Closeable} unconditionally.\n     * <p>\n     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.\n     * <p>\n     * This is typically used in finally blocks to ensure that the closeable is closed\n     * even if an Exception was thrown before the normal close statement was reached.\n     * <br>\n     * <b>It should not be used to replace the close statement(s)\n     * which should be present for the non-exceptional case.</b>\n     * <br>\n     * It is only intended to simplify tidying up where normal processing has already failed\n     * and reporting close failure as well is not necessary or useful.\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * Closeable closeable = null;\n     * try {\n     *     closeable = new FileReader(&quot;foo.txt&quot;);\n     *     // processing using the closeable; may throw an Exception\n     *     closeable.close(); // Normal close - exceptions not ignored\n     * } catch (Exception e) {\n     *     // error handling\n     * } finally {\n     *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>\n     * }\n     * </pre>\n     * <p>\n     * Closing all streams:\n     * <br>\n     * <pre>\n     * try {\n     *     return IOUtils.copy(inputStream, outputStream);\n     * } finally {\n     *     IOUtils.closeQuietly(inputStream, outputStream);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     * @param closeables the objects to close, may be null or already closed\n     * @see #closeQuietly(Closeable)\n     * @since 2.5\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Closeable... closeables) {\n        if (closeables != null) {\n            closeQuietly(Arrays.stream(closeables));\n        }\n    }\n\n    /**\n     * Closes the given {@link Closeable} as a null-safe operation while consuming IOException by the given {@code consumer}.\n     *\n     * @param closeable The resource to close, may be null.\n     * @param consumer Consumes the IOException thrown by {@link Closeable#close()}.\n     * @since 2.7\n     */\n    public static void closeQuietly(final Closeable closeable, final Consumer<IOException> consumer) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer != null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Closes an {@link InputStream} unconditionally.\n     * <p>\n     * Equivalent to {@link InputStream#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   byte[] data = new byte[1024];\n     *   InputStream in = null;\n     *   try {\n     *       in = new FileInputStream(\"foo.txt\");\n     *       in.read(data);\n     *       in.close(); //close errors are handled\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(in);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param input the InputStream to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final InputStream input) {\n        closeQ(input);\n    }\n\n    /**\n     * Closes an iterable of {@link Closeable} unconditionally.\n     * <p>\n     * Equivalent calling {@link Closeable#close()} on each element, except any exceptions will be ignored.\n     * </p>\n     *\n     * @param closeables the objects to close, may be null or already closed\n     * @see #closeQuietly(Closeable)\n     * @since 2.12.0\n     */\n    public static void closeQuietly(final Iterable<Closeable> closeables) {\n        if (closeables != null) {\n            closeables.forEach(IOUtils::closeQuietly);\n        }\n    }\n\n    /**\n     * Closes a stream of {@link Closeable} unconditionally.\n     * <p>\n     * Equivalent calling {@link Closeable#close()} on each element, except any exceptions will be ignored.\n     * </p>\n     *\n     * @param closeables the objects to close, may be null or already closed\n     * @see #closeQuietly(Closeable)\n     * @since 2.12.0\n     */\n    public static void closeQuietly(final Stream<Closeable> closeables) {\n        if (closeables != null) {\n            closeables.forEach(IOUtils::closeQuietly);\n        }\n    }\n\n    /**\n     * Closes an {@link OutputStream} unconditionally.\n     * <p>\n     * Equivalent to {@link OutputStream#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * byte[] data = \"Hello, World\".getBytes();\n     *\n     * OutputStream out = null;\n     * try {\n     *     out = new FileOutputStream(\"foo.txt\");\n     *     out.write(data);\n     *     out.close(); //close errors are handled\n     * } catch (IOException e) {\n     *     // error handling\n     * } finally {\n     *     IOUtils.closeQuietly(out);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param output the OutputStream to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final OutputStream output) {\n        closeQ(output);\n    }\n\n    /**\n     * Closes an {@link Reader} unconditionally.\n     * <p>\n     * Equivalent to {@link Reader#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   char[] data = new char[1024];\n     *   Reader in = null;\n     *   try {\n     *       in = new FileReader(\"foo.txt\");\n     *       in.read(data);\n     *       in.close(); //close errors are handled\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(in);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param reader the Reader to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Reader reader) {\n        closeQ(reader);\n    }\n\n    /**\n     * Closes a {@link Selector} unconditionally.\n     * <p>\n     * Equivalent to {@link Selector#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   Selector selector = null;\n     *   try {\n     *       selector = Selector.open();\n     *       // process socket\n     *\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(selector);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param selector the Selector to close, may be null or already closed\n     * @since 2.2\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Selector selector) {\n        closeQ(selector);\n    }\n\n    /**\n     * Closes a {@link ServerSocket} unconditionally.\n     * <p>\n     * Equivalent to {@link ServerSocket#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   ServerSocket socket = null;\n     *   try {\n     *       socket = new ServerSocket();\n     *       // process socket\n     *       socket.close();\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(socket);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param serverSocket the ServerSocket to close, may be null or already closed\n     * @since 2.2\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final ServerSocket serverSocket) {\n        closeQ(serverSocket);\n    }\n\n    /**\n     * Closes a {@link Socket} unconditionally.\n     * <p>\n     * Equivalent to {@link Socket#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   Socket socket = null;\n     *   try {\n     *       socket = new Socket(\"http://www.foo.com/\", 80);\n     *       // process socket\n     *       socket.close();\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(socket);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param socket the Socket to close, may be null or already closed\n     * @since 2.0\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Socket socket) {\n        closeQ(socket);\n    }\n\n    /**\n     * Closes an {@link Writer} unconditionally.\n     * <p>\n     * Equivalent to {@link Writer#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   Writer out = null;\n     *   try {\n     *       out = new StringWriter();\n     *       out.write(\"Hello World\");\n     *       out.close(); //close errors are handled\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(out);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param writer the Writer to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Writer writer) {\n        closeQ(writer);\n    }\n\n    /**\n     * Consumes bytes from a {@link InputStream} and ignores them.\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read.\n     * @return the number of bytes copied. or {@code 0} if {@code input is null}.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static long consume(final InputStream input) throws IOException {\n        return copyLarge(input, NullOutputStream.INSTANCE, getByteArray());\n    }\n\n    /**\n     * Compares the contents of two Streams to determine if they are equal or\n     * not.\n     * <p>\n     * This method buffers the input internally using\n     * {@link BufferedInputStream} if they are not already buffered.\n     * </p>\n     *\n     * @param input1 the first stream\n     * @param input2 the second stream\n     * @return true if the content of the streams are equal or they both don't\n     * exist, false otherwise\n     * @throws NullPointerException if either input is null\n     * @throws IOException          if an I/O error occurs\n     */\n    public static boolean contentEquals(final InputStream input1, final InputStream input2) throws IOException {\n        // Before making any changes, please test with\n        // org.apache.commons.io.jmh.IOUtilsContentEqualsInputStreamsBenchmark\n        if (input1 == input2) {\n            return true;\n        }\n        if (input1 == null || input2 == null) {\n            return false;\n        }\n\n        // reuse one\n        final byte[] array1 = getByteArray();\n        // allocate another\n        final byte[] array2 = byteArray();\n        int pos1;\n        int pos2;\n        int count1;\n        int count2;\n        while (true) {\n            pos1 = 0;\n            pos2 = 0;\n            for (int index = 0; index < DEFAULT_BUFFER_SIZE; index++) {\n                if (pos1 == index) {\n                    do {\n                        count1 = input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n                    } while (count1 == 0);\n                    if (count1 == EOF) {\n                        return pos2 == index && input2.read() == EOF;\n                    }\n                    pos1 += count1;\n                }\n                if (pos2 == index) {\n                    do {\n                        count2 = input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n                    } while (count2 == 0);\n                    if (count2 == EOF) {\n                        return pos1 == index && input1.read() == EOF;\n                    }\n                    pos2 += count2;\n                }\n                if (array1[index] != array2[index]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    /**\n     * Compares the contents of two Readers to determine if they are equal or not.\n     * <p>\n     * This method buffers the input internally using {@link BufferedReader} if they are not already buffered.\n     * </p>\n     *\n     * @param input1 the first reader\n     * @param input2 the second reader\n     * @return true if the content of the readers are equal or they both don't exist, false otherwise\n     * @throws NullPointerException if either input is null\n     * @throws IOException if an I/O error occurs\n     * @since 1.1\n     */\n    public static boolean contentEquals(final Reader input1, final Reader input2) throws IOException {\n        if (input1 == input2) {\n            return true;\n        }\n        if (input1 == null || input2 == null) {\n            return false;\n        }\n\n        // reuse one\n        final char[] array1 = getCharArray();\n        // but allocate another\n        final char[] array2 = charArray();\n        int pos1;\n        int pos2;\n        int count1;\n        int count2;\n        while (true) {\n            pos1 = 0;\n            pos2 = 0;\n            for (int index = 0; index < DEFAULT_BUFFER_SIZE; index++) {\n                if (pos1 == index) {\n                    do {\n                        count1 = input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n                    } while (count1 == 0);\n                    if (count1 == EOF) {\n                        return pos2 == index && input2.read() == EOF;\n                    }\n                    pos1 += count1;\n                }\n                if (pos2 == index) {\n                    do {\n                        count2 = input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n                    } while (count2 == 0);\n                    if (count2 == EOF) {\n                        return pos1 == index && input1.read() == EOF;\n                    }\n                    pos2 += count2;\n                }\n                if (array1[index] != array2[index]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    /**\n     * Compares the contents of two Readers to determine if they are equal or\n     * not, ignoring EOL characters.\n     * <p>\n     * This method buffers the input internally using\n     * {@link BufferedReader} if they are not already buffered.\n     * </p>\n     *\n     * @param reader1 the first reader\n     * @param reader2 the second reader\n     * @return true if the content of the readers are equal (ignoring EOL differences),  false otherwise\n     * @throws NullPointerException if either input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    @SuppressWarnings(\"resource\")\n    public static boolean contentEqualsIgnoreEOL(final Reader reader1, final Reader reader2)\n            throws IOException {\n        if (reader1 == reader2) {\n            return true;\n        }\n        if (reader1 == null ^ reader2 == null) {\n            return false;\n        }\n        final BufferedReader br1 = toBufferedReader(reader1);\n        final BufferedReader br2 = toBufferedReader(reader2);\n\n        String line1 = br1.readLine();\n        String line2 = br2.readLine();\n        while (line1 != null && line1.equals(line2)) {\n            line1 = br1.readLine();\n            line2 = br2.readLine();\n        }\n        return Objects.equals(line1, line2);\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to an {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Large streams (over 2GB) will return a bytes copied value of {@code -1} after the copy has completed since\n     * the correct number of bytes cannot be returned as an int. For large streams use the\n     * {@link #copyLarge(InputStream, OutputStream)} method.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @return the number of bytes copied, or -1 if greater than {@link Integer#MAX_VALUE}.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 1.1\n     */\n    public static int copy(final InputStream inputStream, final OutputStream outputStream) throws IOException {\n        final long count = copyLarge(inputStream, outputStream);\n        return count > Integer.MAX_VALUE ? EOF : (int) count;\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to an {@link OutputStream} using an internal buffer of the\n     * given size.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write to\n     * @param bufferSize the bufferSize used to copy from the input to the output\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.5\n     */\n    public static long copy(final InputStream inputStream, final OutputStream outputStream, final int bufferSize)\n            throws IOException {\n        return copyLarge(inputStream, outputStream, IOUtils.byteArray(bufferSize));\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to chars on a\n     * {@link Writer} using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * This method uses {@link InputStreamReader}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #copy(InputStream, Writer, Charset)} instead\n     */\n    @Deprecated\n    public static void copy(final InputStream input, final Writer writer)\n            throws IOException {\n        copy(input, writer, Charset.defaultCharset());\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to chars on a\n     * {@link Writer} using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * This method uses {@link InputStreamReader}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputCharset the charset to use for the input stream, null means platform default\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void copy(final InputStream input, final Writer writer, final Charset inputCharset)\n            throws IOException {\n        final InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(inputCharset));\n        copy(reader, writer);\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to chars on a\n     * {@link Writer} using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link InputStreamReader}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputCharsetName the name of the requested charset for the InputStream, null means platform default\n     * @throws NullPointerException                         if the input or output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void copy(final InputStream input, final Writer writer, final String inputCharsetName)\n            throws IOException {\n        copy(input, writer, Charsets.toCharset(inputCharsetName));\n    }\n\n    /**\n     * Copies bytes from a {@link java.io.ByteArrayOutputStream} to a {@link QueueInputStream}.\n     * <p>\n     * Unlike using JDK {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream} for this, this\n     * solution works safely in a single thread environment.\n     * </p>\n     * <p>\n     * Example usage:\n     * </p>\n     *\n     * <pre>\n     * ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n     * outputStream.writeBytes(\"hello world\".getBytes(StandardCharsets.UTF_8));\n     *\n     * InputStream inputStream = IOUtils.copy(outputStream);\n     * </pre>\n     *\n     * @param outputStream the {@link java.io.ByteArrayOutputStream} to read.\n     * @return the {@link QueueInputStream} filled with the content of the outputStream.\n     * @throws NullPointerException if the {@link java.io.ByteArrayOutputStream} is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12\n     */\n    @SuppressWarnings(\"resource\") // streams are closed by the caller.\n    public static QueueInputStream copy(final java.io.ByteArrayOutputStream outputStream) throws IOException {\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        final QueueInputStream in = new QueueInputStream();\n        outputStream.writeTo(in.newQueueOutputStream());\n        return in;\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to a {@link Appendable}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Large streams (over 2GB) will return a chars copied value of\n     * {@code -1} after the copy has completed since the correct\n     * number of chars cannot be returned as an int. For large streams\n     * use the {@link #copyLarge(Reader, Writer)} method.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link Appendable} to write to\n     * @return the number of characters copied, or -1 if &gt; Integer.MAX_VALUE\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.7\n     */\n    public static long copy(final Reader reader, final Appendable output) throws IOException {\n        return copy(reader, output, CharBuffer.allocate(DEFAULT_BUFFER_SIZE));\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to an {@link Appendable}.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link Appendable} to write to\n     * @param buffer the buffer to be used for the copy\n     * @return the number of characters copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.7\n     */\n    public static long copy(final Reader reader, final Appendable output, final CharBuffer buffer) throws IOException {\n        long count = 0;\n        int n;\n        while (EOF != (n = reader.read(buffer))) {\n            buffer.flip();\n            output.append(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform, and calling flush.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Due to the implementation of OutputStreamWriter, this method performs a\n     * flush.\n     * </p>\n     * <p>\n     * This method uses {@link OutputStreamWriter}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #copy(Reader, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void copy(final Reader reader, final OutputStream output)\n            throws IOException {\n        copy(reader, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to bytes on an\n     * {@link OutputStream} using the specified character encoding, and\n     * calling flush.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Due to the implementation of OutputStreamWriter, this method performs a\n     * flush.\n     * </p>\n     * <p>\n     * This method uses {@link OutputStreamWriter}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param outputCharset the charset to use for the OutputStream, null means platform default\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void copy(final Reader reader, final OutputStream output, final Charset outputCharset)\n            throws IOException {\n        final OutputStreamWriter writer = new OutputStreamWriter(output, Charsets.toCharset(outputCharset));\n        copy(reader, writer);\n        // XXX Unless anyone is planning on rewriting OutputStreamWriter,\n        // we have to flush here.\n        writer.flush();\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to bytes on an\n     * {@link OutputStream} using the specified character encoding, and\n     * calling flush.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * Due to the implementation of OutputStreamWriter, this method performs a\n     * flush.\n     * </p>\n     * <p>\n     * This method uses {@link OutputStreamWriter}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param outputCharsetName the name of the requested charset for the OutputStream, null means platform default\n     * @throws NullPointerException                         if the input or output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void copy(final Reader reader, final OutputStream output, final String outputCharsetName)\n            throws IOException {\n        copy(reader, output, Charsets.toCharset(outputCharsetName));\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to a {@link Writer}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Large streams (over 2GB) will return a chars copied value of\n     * {@code -1} after the copy has completed since the correct\n     * number of chars cannot be returned as an int. For large streams\n     * use the {@link #copyLarge(Reader, Writer)} method.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read.\n     * @param writer the {@link Writer} to write.\n     * @return the number of characters copied, or -1 if &gt; Integer.MAX_VALUE\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static int copy(final Reader reader, final Writer writer) throws IOException {\n        final long count = copyLarge(reader, writer);\n        if (count > Integer.MAX_VALUE) {\n            return EOF;\n        }\n        return (int) count;\n    }\n\n    /**\n     * Copies bytes from a {@link URL} to an {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param url the {@link URL} to read.\n     * @param file the {@link OutputStream} to write.\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the URL is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static long copy(final URL url, final File file) throws IOException {\n        try (OutputStream outputStream = Files.newOutputStream(Objects.requireNonNull(file, \"file\").toPath())) {\n            return copy(url, outputStream);\n        }\n    }\n\n    /**\n     * Copies bytes from a {@link URL} to an {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param url the {@link URL} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the URL is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static long copy(final URL url, final OutputStream outputStream) throws IOException {\n        try (InputStream inputStream = Objects.requireNonNull(url, \"url\").openStream()) {\n            return copyLarge(inputStream, outputStream);\n        }\n    }\n\n    /**\n     * Copies bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 1.3\n     */\n    public static long copyLarge(final InputStream inputStream, final OutputStream outputStream)\n            throws IOException {\n        return copy(inputStream, outputStream, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Copies bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @param buffer the buffer to use for the copy\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.2\n     */\n    @SuppressWarnings(\"resource\") // streams are closed by the caller.\n    public static long copyLarge(final InputStream inputStream, final OutputStream outputStream, final byte[] buffer)\n        throws IOException {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        long count = 0;\n        int n;\n        while (EOF != (n = inputStream.read(buffer))) {\n            outputStream.write(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    /**\n     * Copies some or all bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input bytes.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(InputStream, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     *\n     * @param input the {@link InputStream} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param inputOffset : number of bytes to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of bytes to copy. -ve means all\n     * @return the number of bytes copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset,\n                                 final long length) throws IOException {\n        return copyLarge(input, output, inputOffset, length, getByteArray());\n    }\n\n    /**\n     * Copies some or all bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input bytes.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(InputStream, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param inputOffset : number of bytes to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of bytes to copy. -ve means all\n     * @param buffer the buffer to use for the copy\n     * @return the number of bytes copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final InputStream input, final OutputStream output,\n                                 final long inputOffset, final long length, final byte[] buffer) throws IOException {\n        if (inputOffset > 0) {\n            skipFully(input, inputOffset);\n        }\n        if (length == 0) {\n            return 0;\n        }\n        final int bufferLength = buffer.length;\n        int bytesToRead = bufferLength;\n        if (length > 0 && length < bufferLength) {\n            bytesToRead = (int) length;\n        }\n        int read;\n        long totalRead = 0;\n        while (bytesToRead > 0 && EOF != (read = input.read(buffer, 0, bytesToRead))) {\n            output.write(buffer, 0, read);\n            totalRead += read;\n            if (length > 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead = (int) Math.min(length - totalRead, bufferLength);\n            }\n        }\n        return totalRead;\n    }\n\n    /**\n     * Copies chars from a large (over 2GB) {@link Reader} to a {@link Writer}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to source.\n     * @param writer the {@link Writer} to target.\n     * @return the number of characters copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.3\n     */\n    public static long copyLarge(final Reader reader, final Writer writer) throws IOException {\n        return copyLarge(reader, writer, getCharArray());\n    }\n\n    /**\n     * Copies chars from a large (over 2GB) {@link Reader} to a {@link Writer}.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to source.\n     * @param writer the {@link Writer} to target.\n     * @param buffer the buffer to be used for the copy\n     * @return the number of characters copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final Reader reader, final Writer writer, final char[] buffer) throws IOException {\n        long count = 0;\n        int n;\n        while (EOF != (n = reader.read(buffer))) {\n            writer.write(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    /**\n     * Copies some or all chars from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input chars.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputOffset : number of chars to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of chars to copy. -ve means all\n     * @return the number of chars copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length)\n            throws IOException {\n        return copyLarge(reader, writer, inputOffset, length, getCharArray());\n    }\n\n    /**\n     * Copies some or all chars from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input chars.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputOffset : number of chars to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of chars to copy. -ve means all\n     * @param buffer the buffer to be used for the copy\n     * @return the number of chars copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length,\n                                 final char[] buffer)\n            throws IOException {\n        if (inputOffset > 0) {\n            skipFully(reader, inputOffset);\n        }\n        if (length == 0) {\n            return 0;\n        }\n        int bytesToRead = buffer.length;\n        if (length > 0 && length < buffer.length) {\n            bytesToRead = (int) length;\n        }\n        int read;\n        long totalRead = 0;\n        while (bytesToRead > 0 && EOF != (read = reader.read(buffer, 0, bytesToRead))) {\n            writer.write(buffer, 0, read);\n            totalRead += read;\n            if (length > 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead = (int) Math.min(length - totalRead, buffer.length);\n            }\n        }\n        return totalRead;\n    }\n\n    /**\n     * Gets the thread local byte array.\n     *\n     * @return the thread local byte array.\n     */\n    static byte[] getByteArray() {\n        return SKIP_BYTE_BUFFER.get();\n    }\n\n    /**\n     * Gets the thread local char array.\n     *\n     * @return the thread local char array.\n     */\n    static char[] getCharArray() {\n        return SKIP_CHAR_BUFFER.get();\n    }\n\n    /**\n     * Returns the length of the given array in a null-safe manner.\n     *\n     * @param array an array or null\n     * @return the array length -- or 0 if the given array is null.\n     * @since 2.7\n     */\n    public static int length(final byte[] array) {\n        return array == null ? 0 : array.length;\n    }\n\n    /**\n     * Returns the length of the given array in a null-safe manner.\n     *\n     * @param array an array or null\n     * @return the array length -- or 0 if the given array is null.\n     * @since 2.7\n     */\n    public static int length(final char[] array) {\n        return array == null ? 0 : array.length;\n    }\n\n    /**\n     * Returns the length of the given CharSequence in a null-safe manner.\n     *\n     * @param csq a CharSequence or null\n     * @return the CharSequence length -- or 0 if the given CharSequence is null.\n     * @since 2.7\n     */\n    public static int length(final CharSequence csq) {\n        return csq == null ? 0 : csq.length();\n    }\n\n    /**\n     * Returns the length of the given array in a null-safe manner.\n     *\n     * @param array an array or null\n     * @return the array length -- or 0 if the given array is null.\n     * @since 2.7\n     */\n    public static int length(final Object[] array) {\n        return array == null ? 0 : array.length;\n    }\n\n    /**\n     * Returns an Iterator for the lines in an {@link InputStream}, using\n     * the character encoding specified (or default encoding if null).\n     * <p>\n     * {@link LineIterator} holds a reference to the open\n     * {@link InputStream} specified here. When you have finished with\n     * the iterator you should close the stream to free internal resources.\n     * This can be done by using a try-with-resources block, closing the stream directly, or by calling\n     * {@link LineIterator#close()}.\n     * </p>\n     * <p>\n     * The recommended usage pattern is:\n     * </p>\n     * <pre>\n     * try {\n     *   LineIterator it = IOUtils.lineIterator(stream, charset);\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   IOUtils.closeQuietly(stream);\n     * }\n     * </pre>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charset the charset to use, null means platform default\n     * @return an Iterator of the lines in the reader, never null\n     * @throws IllegalArgumentException if the input is null\n     * @since 2.3\n     */\n    public static LineIterator lineIterator(final InputStream input, final Charset charset) {\n        return new LineIterator(new InputStreamReader(input, Charsets.toCharset(charset)));\n    }\n\n    /**\n     * Returns an Iterator for the lines in an {@link InputStream}, using\n     * the character encoding specified (or default encoding if null).\n     * <p>\n     * {@link LineIterator} holds a reference to the open\n     * {@link InputStream} specified here. When you have finished with\n     * the iterator you should close the stream to free internal resources.\n     * This can be done by using a try-with-resources block, closing the stream directly, or by calling\n     * {@link LineIterator#close()}.\n     * </p>\n     * <p>\n     * The recommended usage pattern is:\n     * </p>\n     * <pre>\n     * try {\n     *   LineIterator it = IOUtils.lineIterator(stream, \"UTF-8\");\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   IOUtils.closeQuietly(stream);\n     * }\n     * </pre>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charsetName the encoding to use, null means platform default\n     * @return an Iterator of the lines in the reader, never null\n     * @throws IllegalArgumentException                     if the input is null\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.2\n     */\n    public static LineIterator lineIterator(final InputStream input, final String charsetName) {\n        return lineIterator(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Returns an Iterator for the lines in a {@link Reader}.\n     * <p>\n     * {@link LineIterator} holds a reference to the open\n     * {@link Reader} specified here. When you have finished with the\n     * iterator you should close the reader to free internal resources.\n     * This can be done by using a try-with-resources block, closing the reader directly, or by calling\n     * {@link LineIterator#close()}.\n     * </p>\n     * <p>\n     * The recommended usage pattern is:\n     * </p>\n     * <pre>\n     * try {\n     *   LineIterator it = IOUtils.lineIterator(reader);\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   IOUtils.closeQuietly(reader);\n     * }\n     * </pre>\n     *\n     * @param reader the {@link Reader} to read from, not null\n     * @return an Iterator of the lines in the reader, never null\n     * @throws IllegalArgumentException if the reader is null\n     * @since 1.2\n     */\n    public static LineIterator lineIterator(final Reader reader) {\n        return new LineIterator(reader);\n    }\n\n    /**\n     * Reads bytes from an input stream.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link InputStream}.\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IOException if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final InputStream input, final byte[] buffer) throws IOException {\n        return read(input, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads bytes from an input stream.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link InputStream}.\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IllegalArgumentException if length is negative\n     * @throws IOException              if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length < 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining = length;\n        while (remaining > 0) {\n            final int location = length - remaining;\n            final int count = input.read(buffer, offset + location, remaining);\n            if (EOF == count) { // EOF\n                break;\n            }\n            remaining -= count;\n        }\n        return length - remaining;\n    }\n\n    /**\n     * Reads bytes from a ReadableByteChannel.\n     * <p>\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link ReadableByteChannel}.\n     * </p>\n     *\n     * @param input the byte channel to read\n     * @param buffer byte buffer destination\n     * @return the actual length read; may be less than requested if EOF was reached\n     * @throws IOException if a read error occurs\n     * @since 2.5\n     */\n    public static int read(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int length = buffer.remaining();\n        while (buffer.remaining() > 0) {\n            final int count = input.read(buffer);\n            if (EOF == count) { // EOF\n                break;\n            }\n        }\n        return length - buffer.remaining();\n    }\n\n    /**\n     * Reads characters from an input character stream.\n     * This implementation guarantees that it will read as many characters\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link Reader}.\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IOException if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final Reader reader, final char[] buffer) throws IOException {\n        return read(reader, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads characters from an input character stream.\n     * This implementation guarantees that it will read as many characters\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link Reader}.\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IllegalArgumentException if length is negative\n     * @throws IOException              if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final Reader reader, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length < 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining = length;\n        while (remaining > 0) {\n            final int location = length - remaining;\n            final int count = reader.read(buffer, offset + location, remaining);\n            if (EOF == count) { // EOF\n                break;\n            }\n            remaining -= count;\n        }\n        return length - remaining;\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     *\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of bytes read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final InputStream input, final byte[] buffer) throws IOException {\n        readFully(input, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     *\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of bytes read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual = read(input, buffer, offset, length);\n        if (actual != length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input where to read input from\n     * @param length length to read, must be &gt;= 0\n     * @return the bytes read from input\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of bytes read was incorrect\n     * @since 2.5\n     */\n    public static byte[] readFully(final InputStream input, final int length) throws IOException {\n        final byte[] buffer = IOUtils.byteArray(length);\n        readFully(input, buffer, 0, buffer.length);\n        return buffer;\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link ReadableByteChannel#read(ByteBuffer)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input the byte channel to read\n     * @param buffer byte buffer destination\n     * @throws IOException  if there is a problem reading the file\n     * @throws EOFException if the number of bytes read was incorrect\n     * @since 2.5\n     */\n    public static void readFully(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int expected = buffer.remaining();\n        final int actual = read(input, buffer);\n        if (actual != expected) {\n            throw new EOFException(\"Length to read: \" + expected + \" actual: \" + actual);\n        }\n    }\n\n    /**\n     * Reads the requested number of characters or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link Reader#read(char[], int, int)} may\n     * not read as many characters as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of characters read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final Reader reader, final char[] buffer) throws IOException {\n        readFully(reader, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads the requested number of characters or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link Reader#read(char[], int, int)} may\n     * not read as many characters as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of characters read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final Reader reader, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual = read(reader, buffer, offset, length);\n        if (actual != length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a list of Strings,\n     * one entry per line, using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @return the list of Strings, never null\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #readLines(InputStream, Charset)} instead\n     */\n    @Deprecated\n    public static List<String> readLines(final InputStream input) throws IOException {\n        return readLines(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a list of Strings,\n     * one entry per line, using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charset the charset to use, null means platform default\n     * @return the list of Strings, never null\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static List<String> readLines(final InputStream input, final Charset charset) throws IOException {\n        final InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(charset));\n        return readLines(reader);\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a list of Strings,\n     * one entry per line, using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the list of Strings, never null\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static List<String> readLines(final InputStream input, final String charsetName) throws IOException {\n        return readLines(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a list of Strings,\n     * one entry per line.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from, not null\n     * @return the list of Strings, never null\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\") // reader wraps input and is the responsibility of the caller.\n    public static List<String> readLines(final Reader reader) throws IOException {\n        final BufferedReader bufReader = toBufferedReader(reader);\n        final List<String> list = new ArrayList<>();\n        String line;\n        while ((line = bufReader.readLine()) != null) {\n            list.add(line);\n        }\n        return list;\n    }\n\n    /**\n     * Gets the contents of a resource as a byte array.\n     * <p>\n     * Delegates to {@link #resourceToByteArray(String, ClassLoader) resourceToByteArray(String, null)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @return the requested byte array\n     * @throws IOException if an I/O error occurs or the resource is not found.\n     * @see #resourceToByteArray(String, ClassLoader)\n     * @since 2.6\n     */\n    public static byte[] resourceToByteArray(final String name) throws IOException {\n        return resourceToByteArray(name, null);\n    }\n\n    /**\n     * Gets the contents of a resource as a byte array.\n     * <p>\n     * Delegates to {@link #resourceToURL(String, ClassLoader)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param classLoader the class loader that the resolution of the resource is delegated to\n     * @return the requested byte array\n     * @throws IOException if an I/O error occurs or the resource is not found.\n     * @see #resourceToURL(String, ClassLoader)\n     * @since 2.6\n     */\n    public static byte[] resourceToByteArray(final String name, final ClassLoader classLoader) throws IOException {\n        return toByteArray(resourceToURL(name, classLoader));\n    }\n\n    /**\n     * Gets the contents of a resource as a String using the specified character encoding.\n     * <p>\n     * Delegates to {@link #resourceToString(String, Charset, ClassLoader) resourceToString(String, Charset, null)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param charset the charset to use, null means platform default\n     * @return the requested String\n     * @throws IOException if an I/O error occurs or the resource is not found.\n     * @see #resourceToString(String, Charset, ClassLoader)\n     * @since 2.6\n     */\n    public static String resourceToString(final String name, final Charset charset) throws IOException {\n        return resourceToString(name, charset, null);\n    }\n\n    /**\n     * Gets the contents of a resource as a String using the specified character encoding.\n     * <p>\n     * Delegates to {@link #resourceToURL(String, ClassLoader)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param charset the Charset to use, null means platform default\n     * @param classLoader the class loader that the resolution of the resource is delegated to\n     * @return the requested String\n     * @throws IOException if an I/O error occurs.\n     * @see #resourceToURL(String, ClassLoader)\n     * @since 2.6\n     */\n    public static String resourceToString(final String name, final Charset charset, final ClassLoader classLoader) throws IOException {\n        return toString(resourceToURL(name, classLoader), charset);\n    }\n\n    /**\n     * Gets a URL pointing to the given resource.\n     * <p>\n     * Delegates to {@link #resourceToURL(String, ClassLoader) resourceToURL(String, null)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @return A URL object for reading the resource.\n     * @throws IOException if the resource is not found.\n     * @since 2.6\n     */\n    public static URL resourceToURL(final String name) throws IOException {\n        return resourceToURL(name, null);\n    }\n\n    /**\n     * Gets a URL pointing to the given resource.\n     * <p>\n     * If the {@code classLoader} is not null, call {@link ClassLoader#getResource(String)}, otherwise call\n     * {@link Class#getResource(String) IOUtils.class.getResource(name)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param classLoader Delegate to this class loader if not null\n     * @return A URL object for reading the resource.\n     * @throws IOException if the resource is not found.\n     * @since 2.6\n     */\n    public static URL resourceToURL(final String name, final ClassLoader classLoader) throws IOException {\n        // What about the thread context class loader?\n        // What about the system class loader?\n        final URL resource = classLoader == null ? IOUtils.class.getResource(name) : classLoader.getResource(name);\n        if (resource == null) {\n            throw new IOException(\"Resource not found: \" + name);\n        }\n        return resource;\n    }\n\n    /**\n     * Skips bytes from an input byte stream.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * skip() implementations in subclasses of {@link InputStream}.\n     * <p>\n     * Note that the implementation uses {@link InputStream#read(byte[], int, int)} rather\n     * than delegating to {@link InputStream#skip(long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of bytes are skipped.\n     * </p>\n     *\n     * @param input byte stream to skip\n     * @param toSkip number of bytes to skip.\n     * @return number of bytes actually skipped.\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @see InputStream#skip(long)\n     * @see <a href=\"https://issues.apache.org/jira/browse/IO-203\">IO-203 - Add skipFully() method for InputStreams</a>\n     * @since 2.0\n     */\n    public static long skip(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        /*\n         * N.B. no need to synchronize access to SKIP_BYTE_BUFFER: - we don't care if the buffer is created multiple\n         * times (the data is ignored) - we always use the same size buffer, so if it it is recreated it will still be\n         * OK (if the buffer size were variable, we would need to synch. to ensure some other thread did not create a\n         * smaller one)\n         */\n        long remain = toSkip;\n        while (remain > 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final byte[] byteArray = getByteArray();\n            final long n = input.read(byteArray, 0, (int) Math.min(remain, byteArray.length));\n            if (n < 0) { // EOF\n                break;\n            }\n            remain -= n;\n        }\n        return toSkip - remain;\n    }\n\n    /**\n     * Skips bytes from a ReadableByteChannel.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up.\n     *\n     * @param input ReadableByteChannel to skip\n     * @param toSkip number of bytes to skip.\n     * @return number of bytes actually skipped.\n     * @throws IOException              if there is a problem reading the ReadableByteChannel\n     * @throws IllegalArgumentException if toSkip is negative\n     * @since 2.5\n     */\n    public static long skip(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        final ByteBuffer skipByteBuffer = ByteBuffer.allocate((int) Math.min(toSkip, DEFAULT_BUFFER_SIZE));\n        long remain = toSkip;\n        while (remain > 0) {\n            skipByteBuffer.position(0);\n            skipByteBuffer.limit((int) Math.min(remain, DEFAULT_BUFFER_SIZE));\n            final int n = input.read(skipByteBuffer);\n            if (n == EOF) {\n                break;\n            }\n            remain -= n;\n        }\n        return toSkip - remain;\n    }\n\n    /**\n     * Skips characters from an input character stream.\n     * This implementation guarantees that it will read as many characters\n     * as possible before giving up; this may not always be the case for\n     * skip() implementations in subclasses of {@link Reader}.\n     * <p>\n     * Note that the implementation uses {@link Reader#read(char[], int, int)} rather\n     * than delegating to {@link Reader#skip(long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param reader character stream to skip\n     * @param toSkip number of characters to skip.\n     * @return number of characters actually skipped.\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @see Reader#skip(long)\n     * @see <a href=\"https://issues.apache.org/jira/browse/IO-203\">IO-203 - Add skipFully() method for InputStreams</a>\n     * @since 2.0\n     */\n    public static long skip(final Reader reader, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        long remain = toSkip;\n        while (remain > 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final char[] charArray = getCharArray();\n            final long n = reader.read(charArray, 0, (int) Math.min(remain, charArray.length));\n            if (n < 0) { // EOF\n                break;\n            }\n            remain -= n;\n        }\n        return toSkip - remain;\n    }\n\n    /**\n     * Skips the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#skip(long)} may\n     * not skip as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(InputStream, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param input stream to skip\n     * @param toSkip the number of bytes to skip\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @throws EOFException             if the number of bytes skipped was incorrect\n     * @see InputStream#skip(long)\n     * @since 2.0\n     */\n    public static void skipFully(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped = skip(input, toSkip);\n        if (skipped != toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }\n\n    /**\n     * Skips the requested number of bytes or fail if there are not enough left.\n     *\n     * @param input ReadableByteChannel to skip\n     * @param toSkip the number of bytes to skip\n     * @throws IOException              if there is a problem reading the ReadableByteChannel\n     * @throws IllegalArgumentException if toSkip is negative\n     * @throws EOFException             if the number of bytes skipped was incorrect\n     * @since 2.5\n     */\n    public static void skipFully(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped = skip(input, toSkip);\n        if (skipped != toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }\n\n    /**\n     * Skips the requested number of characters or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link Reader#skip(long)} may\n     * not skip as many characters as requested (most likely because of reaching EOF).\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(Reader, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param reader stream to skip\n     * @param toSkip the number of characters to skip\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @throws EOFException             if the number of characters skipped was incorrect\n     * @see Reader#skip(long)\n     * @since 2.0\n     */\n    public static void skipFully(final Reader reader, final long toSkip) throws IOException {\n        final long skipped = skip(reader, toSkip);\n        if (skipped != toSkip) {\n            throw new EOFException(\"Chars to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }\n\n    /**\n     * Fetches entire contents of an {@link InputStream} and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * </p>\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * <p>\n     * It can be used in favor of {@link #toByteArray(InputStream)}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input Stream to be fully buffered.\n     * @return A fully buffered stream.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream(final InputStream input) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input);\n    }\n\n    /**\n     * Fetches entire contents of an {@link InputStream} and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * </p>\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * <p>\n     * It can be used in favor of {@link #toByteArray(InputStream)}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     * @return A fully buffered stream.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream(final InputStream input, final int size) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input, size);\n    }\n\n    /**\n     * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a BufferedReader from the given\n     * reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @see #buffer(Reader)\n     * @since 2.2\n     */\n    public static BufferedReader toBufferedReader(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }\n\n    /**\n     * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a BufferedReader from the given\n     * reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedReader is created.\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @see #buffer(Reader)\n     * @since 2.5\n     */\n    public static BufferedReader toBufferedReader(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a {@code byte[]}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @return the requested byte array.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws IOException if an I/O error occurs or reading more than {@link Integer#MAX_VALUE} occurs.\n     */\n    public static byte[] toByteArray(final InputStream inputStream) throws IOException {\n        // We use a ThresholdingOutputStream to avoid reading AND writing more than Integer.MAX_VALUE.\n        try (UnsynchronizedByteArrayOutputStream ubaOutput = new UnsynchronizedByteArrayOutputStream();\n            ThresholdingOutputStream thresholdOuput = new ThresholdingOutputStream(Integer.MAX_VALUE, os -> {\n                throw new IllegalArgumentException(String.format(\"Cannot read more than %,d into a byte array\", Integer.MAX_VALUE));\n            }, os -> ubaOutput)) {\n            copy(inputStream, thresholdOuput);\n            return ubaOutput.toByteArray();\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a {@code byte[]}. Use this method instead of\n     * {@link #toByteArray(InputStream)} when {@link InputStream} size is known.\n     *\n     * @param input the {@link InputStream} to read.\n     * @param size the size of {@link InputStream} to read, where 0 &lt; {@code size} &lt;= length of input stream.\n     * @return byte [] of length {@code size}.\n     * @throws IOException if an I/O error occurs or {@link InputStream} length is smaller than parameter {@code size}.\n     * @throws IllegalArgumentException if {@code size} is less than zero.\n     * @since 2.1\n     */\n    public static byte[] toByteArray(final InputStream input, final int size) throws IOException {\n\n        if (size < 0) {\n            throw new IllegalArgumentException(\"Size must be equal or greater than zero: \" + size);\n        }\n\n        if (size == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n\n        final byte[] data = IOUtils.byteArray(size);\n        int offset = 0;\n        int read;\n\n        while (offset < size && (read = input.read(data, offset, size - offset)) != EOF) {\n            offset += read;\n        }\n\n        if (offset != size) {\n            throw new IOException(\"Unexpected read size, current: \" + offset + \", expected: \" + size);\n        }\n\n        return data;\n    }\n\n    /**\n     * Gets contents of an {@link InputStream} as a {@code byte[]}.\n     * Use this method instead of {@link #toByteArray(InputStream)}\n     * when {@link InputStream} size is known.\n     * <b>NOTE:</b> the method checks that the length can safely be cast to an int without truncation\n     * before using {@link IOUtils#toByteArray(java.io.InputStream, int)} to read into the byte array.\n     * (Arrays can have no more than Integer.MAX_VALUE entries anyway)\n     *\n     * @param input the {@link InputStream} to read from\n     * @param size the size of {@link InputStream} to read, where 0 &lt; {@code size} &lt;= min(Integer.MAX_VALUE, length of input stream).\n     * @return byte [] the requested byte array, of length {@code size}\n     * @throws IOException              if an I/O error occurs or {@link InputStream} length is less than {@code size}\n     * @throws IllegalArgumentException if size is less than zero or size is greater than Integer.MAX_VALUE\n     * @see IOUtils#toByteArray(java.io.InputStream, int)\n     * @since 2.1\n     */\n    public static byte[] toByteArray(final InputStream input, final long size) throws IOException {\n        if (size > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Size cannot be greater than Integer max value: \" + size);\n        }\n        return toByteArray(input, (int) size);\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a {@code byte[]}\n     * using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @deprecated 2.5 use {@link #toByteArray(Reader, Charset)} instead\n     */\n    @Deprecated\n    public static byte[] toByteArray(final Reader reader) throws IOException {\n        return toByteArray(reader, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a {@code byte[]}\n     * using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param charset the charset to use, null means platform default\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static byte[] toByteArray(final Reader reader, final Charset charset) throws IOException {\n        try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n            copy(reader, output, charset);\n            return output.toByteArray();\n        }\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a {@code byte[]}\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested byte array\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static byte[] toByteArray(final Reader reader, final String charsetName) throws IOException {\n        return toByteArray(reader, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link String} as a {@code byte[]}\n     * using the default character encoding of the platform.\n     * <p>\n     * This is the same as {@link String#getBytes()}.\n     * </p>\n     *\n     * @param input the {@link String} to convert\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @deprecated 2.5 Use {@link String#getBytes()} instead\n     */\n    @Deprecated\n    public static byte[] toByteArray(final String input) {\n        // make explicit the use of the default charset\n        return input.getBytes(Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of a {@link URI} as a {@code byte[]}.\n     *\n     * @param uri the {@link URI} to read\n     * @return the requested byte array\n     * @throws NullPointerException if the uri is null\n     * @throws IOException          if an I/O exception occurs\n     * @since 2.4\n     */\n    public static byte[] toByteArray(final URI uri) throws IOException {\n        return IOUtils.toByteArray(uri.toURL());\n    }\n\n    /**\n     * Gets the contents of a {@link URL} as a {@code byte[]}.\n     *\n     * @param url the {@link URL} to read\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O exception occurs\n     * @since 2.4\n     */\n    public static byte[] toByteArray(final URL url) throws IOException {\n        try (CloseableURLConnection urlConnection = CloseableURLConnection.open(url)) {\n            return IOUtils.toByteArray(urlConnection);\n        }\n    }\n\n    /**\n     * Gets the contents of a {@link URLConnection} as a {@code byte[]}.\n     *\n     * @param urlConnection the {@link URLConnection} to read.\n     * @return the requested byte array.\n     * @throws NullPointerException if the urlConn is null.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.4\n     */\n    public static byte[] toByteArray(final URLConnection urlConnection) throws IOException {\n        try (InputStream inputStream = urlConnection.getInputStream()) {\n            return IOUtils.toByteArray(inputStream);\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a character array\n     * using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read from\n     * @return the requested character array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #toCharArray(InputStream, Charset)} instead\n     */\n    @Deprecated\n    public static char[] toCharArray(final InputStream inputStream) throws IOException {\n        return toCharArray(inputStream, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a character array\n     * using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read from\n     * @param charset the charset to use, null means platform default\n     * @return the requested character array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static char[] toCharArray(final InputStream inputStream, final Charset charset)\n            throws IOException {\n        final CharArrayWriter writer = new CharArrayWriter();\n        copy(inputStream, writer, charset);\n        return writer.toCharArray();\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a character array\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested character array\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static char[] toCharArray(final InputStream inputStream, final String charsetName) throws IOException {\n        return toCharArray(inputStream, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a character array.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @return the requested character array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static char[] toCharArray(final Reader reader) throws IOException {\n        final CharArrayWriter sw = new CharArrayWriter();\n        copy(reader, sw);\n        return sw.toCharArray();\n    }\n\n    /**\n     * Converts the specified CharSequence to an input stream, encoded as bytes\n     * using the default character encoding of the platform.\n     *\n     * @param input the CharSequence to convert\n     * @return an input stream\n     * @since 2.0\n     * @deprecated 2.5 use {@link #toInputStream(CharSequence, Charset)} instead\n     */\n    @Deprecated\n    public static InputStream toInputStream(final CharSequence input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Converts the specified CharSequence to an input stream, encoded as bytes\n     * using the specified character encoding.\n     *\n     * @param input the CharSequence to convert\n     * @param charset the charset to use, null means platform default\n     * @return an input stream\n     * @since 2.3\n     */\n    public static InputStream toInputStream(final CharSequence input, final Charset charset) {\n        return toInputStream(input.toString(), charset);\n    }\n\n    /**\n     * Converts the specified CharSequence to an input stream, encoded as bytes\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param input the CharSequence to convert\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return an input stream\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 2.0\n     */\n    public static InputStream toInputStream(final CharSequence input, final String charsetName) {\n        return toInputStream(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Converts the specified string to an input stream, encoded as bytes\n     * using the default character encoding of the platform.\n     *\n     * @param input the string to convert\n     * @return an input stream\n     * @since 1.1\n     * @deprecated 2.5 use {@link #toInputStream(String, Charset)} instead\n     */\n    @Deprecated\n    public static InputStream toInputStream(final String input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Converts the specified string to an input stream, encoded as bytes\n     * using the specified character encoding.\n     *\n     * @param input the string to convert\n     * @param charset the charset to use, null means platform default\n     * @return an input stream\n     * @since 2.3\n     */\n    public static InputStream toInputStream(final String input, final Charset charset) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charset)));\n    }\n\n    /**\n     * Converts the specified string to an input stream, encoded as bytes\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param input the string to convert\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return an input stream\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static InputStream toInputStream(final String input, final String charsetName) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charsetName)));\n    }\n\n    /**\n     * Gets the contents of a {@code byte[]} as a String\n     * using the default character encoding of the platform.\n     *\n     * @param input the byte array to read from\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @deprecated 2.5 Use {@link String#String(byte[])} instead\n     */\n    @Deprecated\n    public static String toString(final byte[] input) {\n        // make explicit the use of the default charset\n        return new String(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of a {@code byte[]} as a String\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param input the byte array to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     */\n    public static String toString(final byte[] input, final String charsetName) {\n        return new String(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a String\n     * using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @deprecated 2.5 use {@link #toString(InputStream, Charset)} instead\n     */\n    @Deprecated\n    public static String toString(final InputStream input) throws IOException {\n        return toString(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a String\n     * using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param charset the charset to use, null means platform default\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static String toString(final InputStream input, final Charset charset) throws IOException {\n        try (StringBuilderWriter sw = new StringBuilderWriter()) {\n            copy(input, sw, charset);\n            return sw.toString();\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a String\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested String\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     */\n    public static String toString(final InputStream input, final String charsetName)\n            throws IOException {\n        return toString(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a String.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     */\n    public static String toString(final Reader reader) throws IOException {\n        try (StringBuilderWriter sw = new StringBuilderWriter()) {\n            copy(reader, sw);\n            return sw.toString();\n        }\n    }\n\n    /**\n     * Gets the contents at the given URI.\n     *\n     * @param uri The URI source.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.1\n     * @deprecated 2.5 use {@link #toString(URI, Charset)} instead\n     */\n    @Deprecated\n    public static String toString(final URI uri) throws IOException {\n        return toString(uri, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents at the given URI.\n     *\n     * @param uri The URI source.\n     * @param encoding The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.3.\n     */\n    public static String toString(final URI uri, final Charset encoding) throws IOException {\n        return toString(uri.toURL(), Charsets.toCharset(encoding));\n    }\n\n    /**\n     * Gets the contents at the given URI.\n     *\n     * @param uri The URI source.\n     * @param charsetName The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException                                  if an I/O exception occurs.\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 2.1\n     */\n    public static String toString(final URI uri, final String charsetName) throws IOException {\n        return toString(uri, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents at the given URL.\n     *\n     * @param url The URL source.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.1\n     * @deprecated 2.5 use {@link #toString(URL, Charset)} instead\n     */\n    @Deprecated\n    public static String toString(final URL url) throws IOException {\n        return toString(url, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents at the given URL.\n     *\n     * @param url The URL source.\n     * @param encoding The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.3\n     */\n    public static String toString(final URL url, final Charset encoding) throws IOException {\n        try (InputStream inputStream = url.openStream()) {\n            return toString(inputStream, encoding);\n        }\n    }\n\n    /**\n     * Gets the contents at the given URL.\n     *\n     * @param url The URL source.\n     * @param charsetName The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException                                  if an I/O exception occurs.\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 2.1\n     */\n    public static String toString(final URL url, final String charsetName) throws IOException {\n        return toString(url, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to an {@link OutputStream}.\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void write(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data != null) {\n            output.write(data);\n        }\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to chars on a {@link Writer}\n     * using the default character encoding of the platform.\n     * <p>\n     * This method uses {@link String#String(byte[])}.\n     * </p>\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #write(byte[], Writer, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final byte[] data, final Writer writer) throws IOException {\n        write(data, writer, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to chars on a {@link Writer}\n     * using the specified character encoding.\n     * <p>\n     * This method uses {@link String#String(byte[], String)}.\n     * </p>\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void write(final byte[] data, final Writer writer, final Charset charset) throws IOException {\n        if (data != null) {\n            writer.write(new String(data, Charsets.toCharset(charset)));\n        }\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to chars on a {@link Writer}\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#String(byte[], String)}.\n     * </p>\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException                         if output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void write(final byte[] data, final Writer writer, final String charsetName) throws IOException {\n        write(data, writer, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to bytes on an\n     * {@link OutputStream}.\n     * <p>\n     * This method uses {@link String#String(char[])} and\n     * {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #write(char[], OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final char[] data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * This method uses {@link String#String(char[])} and\n     * {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void write(final char[] data, final OutputStream output, final Charset charset) throws IOException {\n        if (data != null) {\n            write(new String(data), output, charset);\n        }\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#String(char[])} and\n     * {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException                         if output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 1.1\n     */\n    public static void write(final char[] data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to a {@link Writer}\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void write(final char[] data, final Writer writer) throws IOException {\n        if (data != null) {\n            writer.write(data);\n        }\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform.\n     * <p>\n     * This method uses {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.0\n     * @deprecated 2.5 use {@link #write(CharSequence, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final CharSequence data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void write(final CharSequence data, final OutputStream output, final Charset charset)\n            throws IOException {\n        if (data != null) {\n            write(data.toString(), output, charset);\n        }\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException        if output is null\n     * @throws IOException                 if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 2.0\n     */\n    public static void write(final CharSequence data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }\n\n\n    /**\n     * Writes chars from a {@link CharSequence} to a {@link Writer}.\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.0\n     */\n    public static void write(final CharSequence data, final Writer writer) throws IOException {\n        if (data != null) {\n            write(data.toString(), writer);\n        }\n    }\n\n    /**\n     * Writes chars from a {@link String} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform.\n     * <p>\n     * This method uses {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #write(String, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final String data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes chars from a {@link String} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    @SuppressWarnings(\"resource\")\n    public static void write(final String data, final OutputStream output, final Charset charset) throws IOException {\n        if (data != null) {\n            // Use Charset#encode(String), since calling String#getBytes(Charset) might result in\n            // NegativeArraySizeException or OutOfMemoryError.\n            // The underlying OutputStream should not be closed, so the channel is not closed.\n            Channels.newChannel(output).write(Charsets.toCharset(charset).encode(data));\n        }\n    }\n\n    /**\n     * Writes chars from a {@link String} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException        if output is null\n     * @throws IOException                 if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 1.1\n     */\n    public static void write(final String data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@link String} to a {@link Writer}.\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void write(final String data, final Writer writer) throws IOException {\n        if (data != null) {\n            writer.write(data);\n        }\n    }\n\n    /**\n     * Writes chars from a {@link StringBuffer} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform.\n     * <p>\n     * This method uses {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the {@link StringBuffer} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated Use {@link #write(CharSequence, OutputStream)}\n     */\n    @Deprecated\n    public static void write(final StringBuffer data, final OutputStream output) //NOSONAR\n            throws IOException {\n        write(data, output, (String) null);\n    }\n\n    /**\n     * Writes chars from a {@link StringBuffer} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link StringBuffer} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException        if output is null\n     * @throws IOException                 if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 1.1\n     * @deprecated Use {@link #write(CharSequence, OutputStream, String)}.\n     */\n    @Deprecated\n    public static void write(final StringBuffer data, final OutputStream output, final String charsetName) //NOSONAR\n        throws IOException {\n        if (data != null) {\n            write(data.toString(), output, Charsets.toCharset(charsetName));\n        }\n    }\n\n    /**\n     * Writes chars from a {@link StringBuffer} to a {@link Writer}.\n     *\n     * @param data the {@link StringBuffer} to write, null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated Use {@link #write(CharSequence, Writer)}\n     */\n    @Deprecated\n    public static void write(final StringBuffer data, final Writer writer) //NOSONAR\n            throws IOException {\n        if (data != null) {\n            writer.write(data.toString());\n        }\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to an {@link OutputStream} using chunked writes.\n     * This is intended for writing very large byte arrays which might otherwise cause excessive\n     * memory usage if the native code has to allocate a copy.\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.5\n     */\n    public static void writeChunked(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data != null) {\n            int bytes = data.length;\n            int offset = 0;\n            while (bytes > 0) {\n                final int chunk = Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                output.write(data, offset, chunk);\n                bytes -= chunk;\n                offset += chunk;\n            }\n        }\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to a {@link Writer} using chunked writes.\n     * This is intended for writing very large byte arrays which might otherwise cause excessive\n     * memory usage if the native code has to allocate a copy.\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.5\n     */\n    public static void writeChunked(final char[] data, final Writer writer) throws IOException {\n        if (data != null) {\n            int bytes = data.length;\n            int offset = 0;\n            while (bytes > 0) {\n                final int chunk = Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                writer.write(data, offset, chunk);\n                bytes -= chunk;\n                offset += chunk;\n            }\n        }\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * an {@link OutputStream} line by line, using the default character\n     * encoding of the platform and the specified line ending.\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param output the {@link OutputStream} to write to, not null, not closed\n     * @throws NullPointerException if the output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #writeLines(Collection, String, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void writeLines(final Collection<?> lines, final String lineEnding,\n                                  final OutputStream output) throws IOException {\n        writeLines(lines, lineEnding, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * an {@link OutputStream} line by line, using the specified character\n     * encoding and the specified line ending.\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param output the {@link OutputStream} to write to, not null, not closed\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if the output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void writeLines(final Collection<?> lines, String lineEnding, final OutputStream output,\n                                  final Charset charset) throws IOException {\n        if (lines == null) {\n            return;\n        }\n        if (lineEnding == null) {\n            lineEnding = System.lineSeparator();\n        }\n        final Charset cs = Charsets.toCharset(charset);\n        final byte[] eolBytes = lineEnding.getBytes(cs);\n        for (final Object line : lines) {\n            if (line != null) {\n                write(line.toString(), output, cs);\n            }\n            output.write(eolBytes);\n        }\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * an {@link OutputStream} line by line, using the specified character\n     * encoding and the specified line ending.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param output the {@link OutputStream} to write to, not null, not closed\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException                         if the output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void writeLines(final Collection<?> lines, final String lineEnding,\n                                  final OutputStream output, final String charsetName) throws IOException {\n        writeLines(lines, lineEnding, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * a {@link Writer} line by line, using the specified line ending.\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param writer the {@link Writer} to write to, not null, not closed\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void writeLines(final Collection<?> lines, String lineEnding,\n                                  final Writer writer) throws IOException {\n        if (lines == null) {\n            return;\n        }\n        if (lineEnding == null) {\n            lineEnding = System.lineSeparator();\n        }\n        for (final Object line : lines) {\n            if (line != null) {\n                writer.write(line.toString());\n            }\n            writer.write(lineEnding);\n        }\n    }\n\n    /**\n     * Returns the given Appendable if it is already a {@link Writer}, otherwise creates a Writer wrapper around the\n     * given Appendable.\n     *\n     * @param appendable the Appendable to wrap or return (not null)\n     * @return  the given Appendable or a Writer wrapper around the given Appendable\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.7\n     */\n    public static Writer writer(final Appendable appendable) {\n        Objects.requireNonNull(appendable, \"appendable\");\n        if (appendable instanceof Writer) {\n            return (Writer) appendable;\n        }\n        if (appendable instanceof StringBuilder) {\n            return new StringBuilderWriter((StringBuilder) appendable);\n        }\n        return new AppendableWriter<>(appendable);\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public IOUtils() { //NOSONAR\n    }\n\n}\n", "diffSourceCodeSet": ["/**\n     * Closes an iterable of {@link Closeable} unconditionally.\n     * <p>\n     * Equivalent calling {@link Closeable#close()} on each element, except any exceptions will be ignored.\n     * </p>\n     *\n     * @param closeables the objects to close, may be null or already closed\n     * @see #closeQuietly(Closeable)\n     * @since 2.12.0\n     */\n    public static void closeQuietly(final Iterable<Closeable> closeables) {\n        if (closeables != null) {\n            closeables.forEach(IOUtils::closeQuietly);\n        }\n    }"], "invokedMethodSet": ["methodSignature: org.apache.commons.io.IOUtils#closeQuietly\n methodBody: public static void closeQuietly(final Writer writer) {\ncloseQuietly((Closeable)writer);\n}"], "sourceCodeAfterRefactoring": "/**\n     * Closes a {@link Closeable} unconditionally.\n     * <p>\n     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.\n     * <p>\n     * This is typically used in finally blocks to ensure that the closeable is closed\n     * even if an Exception was thrown before the normal close statement was reached.\n     * <br>\n     * <b>It should not be used to replace the close statement(s)\n     * which should be present for the non-exceptional case.</b>\n     * <br>\n     * It is only intended to simplify tidying up where normal processing has already failed\n     * and reporting close failure as well is not necessary or useful.\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * Closeable closeable = null;\n     * try {\n     *     closeable = new FileReader(&quot;foo.txt&quot;);\n     *     // processing using the closeable; may throw an Exception\n     *     closeable.close(); // Normal close - exceptions not ignored\n     * } catch (Exception e) {\n     *     // error handling\n     * } finally {\n     *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>\n     * }\n     * </pre>\n     * <p>\n     * Closing all streams:\n     * <br>\n     * <pre>\n     * try {\n     *     return IOUtils.copy(inputStream, outputStream);\n     * } finally {\n     *     IOUtils.closeQuietly(inputStream, outputStream);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     * @param closeables the objects to close, may be null or already closed\n     * @see #closeQuietly(Closeable)\n     * @since 2.5\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Closeable... closeables) {\n        if (closeables != null) {\n            closeQuietly(Arrays.stream(closeables));\n        }\n    }\n/**\n     * Closes an iterable of {@link Closeable} unconditionally.\n     * <p>\n     * Equivalent calling {@link Closeable#close()} on each element, except any exceptions will be ignored.\n     * </p>\n     *\n     * @param closeables the objects to close, may be null or already closed\n     * @see #closeQuietly(Closeable)\n     * @since 2.12.0\n     */\n    public static void closeQuietly(final Iterable<Closeable> closeables) {\n        if (closeables != null) {\n            closeables.forEach(IOUtils::closeQuietly);\n        }\n    }", "diffSourceCode": "-  475:     /**\n-  476:      * Closes a {@link Closeable} unconditionally.\n-  477:      * <p>\n-  478:      * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.\n-  479:      * <p>\n-  480:      * This is typically used in finally blocks to ensure that the closeable is closed\n-  481:      * even if an Exception was thrown before the normal close statement was reached.\n-  482:      * <br>\n-  483:      * <b>It should not be used to replace the close statement(s)\n-  484:      * which should be present for the non-exceptional case.</b>\n-  485:      * <br>\n-  486:      * It is only intended to simplify tidying up where normal processing has already failed\n-  487:      * and reporting close failure as well is not necessary or useful.\n-  488:      * <p>\n-  489:      * Example code:\n-  490:      * </p>\n-  491:      * <pre>\n-  492:      * Closeable closeable = null;\n-  493:      * try {\n-  494:      *     closeable = new FileReader(&quot;foo.txt&quot;);\n-  495:      *     // processing using the closeable; may throw an Exception\n-  496:      *     closeable.close(); // Normal close - exceptions not ignored\n-  497:      * } catch (Exception e) {\n-  498:      *     // error handling\n-  499:      * } finally {\n-  500:      *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>\n-  501:      * }\n-  502:      * </pre>\n-  503:      * <p>\n-  504:      * Closing all streams:\n-  505:      * <br>\n-  506:      * <pre>\n-  507:      * try {\n-  508:      *     return IOUtils.copy(inputStream, outputStream);\n-  509:      * } finally {\n-  510:      *     IOUtils.closeQuietly(inputStream, outputStream);\n-  511:      * }\n-  512:      * </pre>\n-  513:      * <p>\n-  514:      * Also consider using a try-with-resources statement where appropriate.\n-  515:      * </p>\n-  516:      * @param closeables the objects to close, may be null or already closed\n-  517:      * @see #closeQuietly(Closeable)\n-  518:      * @since 2.5\n-  519:      * @see Throwable#addSuppressed(java.lang.Throwable)\n-  520:      */\n-  521:     public static void closeQuietly(final Closeable... closeables) {\n-  522:         if (closeables != null) {\n-  523:             Arrays.stream(closeables).forEach(IOUtils::closeQuietly);\n-  524:         }\n-  525:     }\n-  526: \n-  527:     /**\n-  528:      * Closes the given {@link Closeable} as a null-safe operation while consuming IOException by the given {@code consumer}.\n-  529:      *\n-  530:      * @param closeable The resource to close, may be null.\n-  531:      * @param consumer Consumes the IOException thrown by {@link Closeable#close()}.\n-  532:      * @since 2.7\n-  533:      */\n-  587:      * </p>\n-  588:      * <pre>\n-  589:      * byte[] data = \"Hello, World\".getBytes();\n-  590:      *\n-  591:      * OutputStream out = null;\n-  592:      * try {\n-  593:      *     out = new FileOutputStream(\"foo.txt\");\n-  594:      *     out.write(data);\n-  595:      *     out.close(); //close errors are handled\n-  596:      * } catch (IOException e) {\n-  597:      *     // error handling\n-  598:      * } finally {\n-  599:      *     IOUtils.closeQuietly(out);\n-  600:      * }\n-  601:      * </pre>\n+  475: \n+  476:     /**\n+  477:      * Avoids the need to type cast.\n+  478:      */\n+  479:     private static void closeQ(final Closeable closeable) {\n+  480:         closeQuietly(closeable, null);\n+  481:     }\n+  482: \n+  483:     /**\n+  484:      * Closes a {@link Closeable} unconditionally.\n+  485:      * <p>\n+  486:      * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.\n+  487:      * <p>\n+  488:      * This is typically used in finally blocks to ensure that the closeable is closed\n+  489:      * even if an Exception was thrown before the normal close statement was reached.\n+  490:      * <br>\n+  491:      * <b>It should not be used to replace the close statement(s)\n+  492:      * which should be present for the non-exceptional case.</b>\n+  493:      * <br>\n+  494:      * It is only intended to simplify tidying up where normal processing has already failed\n+  495:      * and reporting close failure as well is not necessary or useful.\n+  496:      * <p>\n+  497:      * Example code:\n+  498:      * </p>\n+  499:      * <pre>\n+  500:      * Closeable closeable = null;\n+  501:      * try {\n+  502:      *     closeable = new FileReader(&quot;foo.txt&quot;);\n+  503:      *     // processing using the closeable; may throw an Exception\n+  504:      *     closeable.close(); // Normal close - exceptions not ignored\n+  505:      * } catch (Exception e) {\n+  506:      *     // error handling\n+  507:      * } finally {\n+  508:      *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>\n+  509:      * }\n+  510:      * </pre>\n+  511:      * <p>\n+  512:      * Closing all streams:\n+  513:      * <br>\n+  514:      * <pre>\n+  515:      * try {\n+  516:      *     return IOUtils.copy(inputStream, outputStream);\n+  517:      * } finally {\n+  518:      *     IOUtils.closeQuietly(inputStream, outputStream);\n+  519:      * }\n+  520:      * </pre>\n+  521:      * <p>\n+  522:      * Also consider using a try-with-resources statement where appropriate.\n+  523:      * </p>\n+  524:      * @param closeables the objects to close, may be null or already closed\n+  525:      * @see #closeQuietly(Closeable)\n+  526:      * @since 2.5\n+  527:      * @see Throwable#addSuppressed(java.lang.Throwable)\n+  528:      */\n+  529:     public static void closeQuietly(final Closeable... closeables) {\n+  530:         if (closeables != null) {\n+  531:             closeQuietly(Arrays.stream(closeables));\n+  532:         }\n+  533:     }\n+  587:     /**\n+  588:      * Closes an iterable of {@link Closeable} unconditionally.\n+  589:      * <p>\n+  590:      * Equivalent calling {@link Closeable#close()} on each element, except any exceptions will be ignored.\n+  591:      * </p>\n+  592:      *\n+  593:      * @param closeables the objects to close, may be null or already closed\n+  594:      * @see #closeQuietly(Closeable)\n+  595:      * @since 2.12.0\n+  596:      */\n+  597:     public static void closeQuietly(final Iterable<Closeable> closeables) {\n+  598:         if (closeables != null) {\n+  599:             closeables.forEach(IOUtils::closeQuietly);\n+  600:         }\n+  601:     }\n", "uniqueId": "57313b3ed3b356d9a81103f4dbcc1eb38b9f2c0b_475_525_587_601_483_533", "moveFileExist": true, "testResult": true, "coverageInfo": {"INSTRUCTION": {"missed": 0, "covered": 3}, "LINE": {"missed": 0, "covered": 2}, "COMPLEXITY": {"missed": 0, "covered": 1}, "METHOD": {"missed": 0, "covered": 1}}, "compileResultBefore": true, "compileResultCurrent": true, "compileJDK": 17, "refactoringMinerResult": true, "compileAndTestResult": false, "refactoredCode": "To refactor the `closeQuietly` method in the provided code, we can extract the logic that handles the closing of multiple `Closeable` resources into a separate method. This will improve readability and maintainability by making the code more modular.\n\nHere's the refactored method code:\n\n```java\n##########################\n/**\n * Closes multiple {@link Closeable} resources unconditionally.\n * <p>\n * This method iterates over the provided closeables and calls {@link #closeQuietly(Closeable)} on each.\n * </p>\n *\n * @param closeables the objects to close, may be null or already closed\n * @since 2.5\n */\nprivate static void closeQuietlyMultiple(final Closeable... closeables) {\n    if (closeables != null) {\n        Arrays.stream(closeables).forEach(IOUtils::closeQuietly);\n    }\n}\n\n/**\n * Closes a {@link Closeable} unconditionally.\n * <p>\n * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.\n * </p>\n * @param closeables the objects to close, may be null or already closed\n * @see #closeQuietly(Closeable)\n * @since 2.5\n */\npublic static void closeQuietly(final Closeable... closeables) {\n    closeQuietlyMultiple(closeables);\n}\n##########################\n```\n\n### Explanation of Changes:\n1. **Extracted Method**: The logic for closing multiple `Closeable` resources has been extracted into a new private method called `closeQuietlyMultiple`. This method handles the iteration and calls the existing `closeQuietly` method for each resource.\n2. **Updated Original Method**: The original `closeQuietly` method now simply calls the new `closeQuietlyMultiple` method, which keeps the original method's purpose intact while delegating the actual closing logic to the new method.\n3. **Documentation**: Added JavaDoc comments to the new method to explain its purpose and usage.\n\nThis refactoring enhances the modularity of the code, making it easier to read and maintain.", "prompt": "Task: You are an expert software engineer. You are given a code to be refactored. The objective is to refactor this code by performing given refactoring operation. This refactoring will improve code readability, maintainability, and modularity.\n\nCode to be Refactored:\n/**\n     * Closes a {@link Closeable} unconditionally.\n     * <p>\n     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.\n     * <p>\n     * This is typically used in finally blocks to ensure that the closeable is closed\n     * even if an Exception was thrown before the normal close statement was reached.\n     * <br>\n     * <b>It should not be used to replace the close statement(s)\n     * which should be present for the non-exceptional case.</b>\n     * <br>\n     * It is only intended to simplify tidying up where normal processing has already failed\n     * and reporting close failure as well is not necessary or useful.\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * Closeable closeable = null;\n     * try {\n     *     closeable = new FileReader(&quot;foo.txt&quot;);\n     *     // processing using the closeable; may throw an Exception\n     *     closeable.close(); // Normal close - exceptions not ignored\n     * } catch (Exception e) {\n     *     // error handling\n     * } finally {\n     *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>\n     * }\n     * </pre>\n     * <p>\n     * Closing all streams:\n     * <br>\n     * <pre>\n     * try {\n     *     return IOUtils.copy(inputStream, outputStream);\n     * } finally {\n     *     IOUtils.closeQuietly(inputStream, outputStream);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     * @param closeables the objects to close, may be null or already closed\n     * @see #closeQuietly(Closeable)\n     * @since 2.5\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Closeable... closeables) {\n        if (closeables != null) {\n            Arrays.stream(closeables).forEach(IOUtils::closeQuietly);\n        }\n    }\n\nClass content:\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.io;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayInputStream;\nimport java.io.CharArrayWriter;\nimport java.io.Closeable;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.net.HttpURLConnection;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.Selector;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.function.Consumer;\n\nimport org.apache.commons.io.function.IOConsumer;\nimport org.apache.commons.io.input.QueueInputStream;\nimport org.apache.commons.io.output.AppendableWriter;\nimport org.apache.commons.io.output.ByteArrayOutputStream;\nimport org.apache.commons.io.output.NullOutputStream;\nimport org.apache.commons.io.output.StringBuilderWriter;\nimport org.apache.commons.io.output.ThresholdingOutputStream;\nimport org.apache.commons.io.output.UnsynchronizedByteArrayOutputStream;\n\n/**\n * General IO stream manipulation utilities.\n * <p>\n * This class provides static utility methods for input/output operations.\n * </p>\n * <ul>\n * <li>closeQuietly - these methods close a stream ignoring nulls and exceptions\n * <li>toXxx/read - these methods read data from a stream\n * <li>write - these methods write data to a stream\n * <li>copy - these methods copy all the data from one stream to another\n * <li>contentEquals - these methods compare the content of two streams\n * </ul>\n * <p>\n * The byte-to-char methods and char-to-byte methods involve a conversion step.\n * Two methods are provided in each case, one that uses the platform default\n * encoding and the other which allows you to specify an encoding. You are\n * encouraged to always specify an encoding because relying on the platform\n * default can lead to unexpected results, for example when moving from\n * development to production.\n * </p>\n * <p>\n * All the methods in this class that read a stream are buffered internally.\n * This means that there is no cause to use a {@link BufferedInputStream}\n * or {@link BufferedReader}. The default buffer size of 4K has been shown\n * to be efficient in tests.\n * </p>\n * <p>\n * The various copy methods all delegate the actual copying to one of the following methods:\n * </p>\n * <ul>\n * <li>{@link #copyLarge(InputStream, OutputStream, byte[])}</li>\n * <li>{@link #copyLarge(InputStream, OutputStream, long, long, byte[])}</li>\n * <li>{@link #copyLarge(Reader, Writer, char[])}</li>\n * <li>{@link #copyLarge(Reader, Writer, long, long, char[])}</li>\n * </ul>\n * For example, {@link #copy(InputStream, OutputStream)} calls {@link #copyLarge(InputStream, OutputStream)}\n * which calls {@link #copy(InputStream, OutputStream, int)} which creates the buffer and calls\n * {@link #copyLarge(InputStream, OutputStream, byte[])}.\n * <p>\n * Applications can re-use buffers by using the underlying methods directly.\n * This may improve performance for applications that need to do a lot of copying.\n * </p>\n * <p>\n * Wherever possible, the methods in this class do <em>not</em> flush or close\n * the stream. This is to avoid making non-portable assumptions about the\n * streams' origin and further use. Thus the caller is still responsible for\n * closing streams after use.\n * </p>\n * <p>\n * Origin of code: Excalibur.\n * </p>\n */\npublic class IOUtils {\n    // NOTE: This class is focused on InputStream, OutputStream, Reader and\n    // Writer. Each method should take at least one of these as a parameter,\n    // or return one of them.\n\n    /**\n     * CR char.\n     *\n     * @since 2.9.0\n     */\n    public static final int CR = '\\r';\n\n    /**\n     * The default buffer size ({@value}) to use in copy methods.\n     */\n    public static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    /**\n     * The system directory separator character.\n     */\n    public static final char DIR_SEPARATOR = File.separatorChar;\n\n    /**\n     * The Unix directory separator character.\n     */\n    public static final char DIR_SEPARATOR_UNIX = '/';\n\n    /**\n     * The Windows directory separator character.\n     */\n    public static final char DIR_SEPARATOR_WINDOWS = '\\\\';\n\n    /**\n     * A singleton empty byte array.\n     *\n     *  @since 2.9.0\n     */\n    public static final byte[] EMPTY_BYTE_ARRAY = {};\n\n    /**\n     * Represents the end-of-file (or stream).\n     * @since 2.5 (made public)\n     */\n    public static final int EOF = -1;\n\n    /**\n     * LF char.\n     *\n     * @since 2.9.0\n     */\n    public static final int LF = '\\n';\n\n    /**\n     * The system line separator string.\n     *\n     * @deprecated Use {@link System#lineSeparator()}.\n     */\n    @Deprecated\n    public static final String LINE_SEPARATOR = System.lineSeparator();\n\n    /**\n     * The Unix line separator string.\n     *\n     * @see StandardLineSeparator#LF\n     */\n    public static final String LINE_SEPARATOR_UNIX = StandardLineSeparator.LF.getString();\n\n    /**\n     * The Windows line separator string.\n     *\n     * @see StandardLineSeparator#CRLF\n     */\n    public static final String LINE_SEPARATOR_WINDOWS = StandardLineSeparator.CRLF.getString();\n\n    /**\n     * Internal byte array buffer.\n     */\n    private static final ThreadLocal<byte[]> SKIP_BYTE_BUFFER = ThreadLocal.withInitial(IOUtils::byteArray);\n\n    /**\n     * Internal byte array buffer.\n     */\n    private static final ThreadLocal<char[]> SKIP_CHAR_BUFFER = ThreadLocal.withInitial(IOUtils::charArray);\n\n    /**\n     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a\n     * BufferedInputStream from the given InputStream.\n     *\n     * @param inputStream the InputStream to wrap or return (not null)\n     * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedInputStream buffer(final InputStream inputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream);\n    }\n\n    /**\n     * Returns the given InputStream if it is already a {@link BufferedInputStream}, otherwise creates a\n     * BufferedInputStream from the given InputStream.\n     *\n     * @param inputStream the InputStream to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedInputStream is created.\n     * @return the given InputStream or a new {@link BufferedInputStream} for the given InputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedInputStream buffer(final InputStream inputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        return inputStream instanceof BufferedInputStream ?\n                (BufferedInputStream) inputStream : new BufferedInputStream(inputStream, size);\n    }\n\n    /**\n     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a\n     * BufferedOutputStream from the given OutputStream.\n     *\n     * @param outputStream the OutputStream to wrap or return (not null)\n     * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedOutputStream buffer(final OutputStream outputStream) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream);\n    }\n\n    /**\n     * Returns the given OutputStream if it is already a {@link BufferedOutputStream}, otherwise creates a\n     * BufferedOutputStream from the given OutputStream.\n     *\n     * @param outputStream the OutputStream to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedOutputStream is created.\n     * @return the given OutputStream or a new {@link BufferedOutputStream} for the given OutputStream\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    @SuppressWarnings(\"resource\") // parameter null check\n    public static BufferedOutputStream buffer(final OutputStream outputStream, final int size) {\n        // reject null early on rather than waiting for IO operation to fail\n        // not checked by BufferedInputStream\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        return outputStream instanceof BufferedOutputStream ?\n                (BufferedOutputStream) outputStream : new BufferedOutputStream(outputStream, size);\n    }\n\n    /**\n     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from\n     * the given reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedReader buffer(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }\n\n    /**\n     * Returns the given reader if it is already a {@link BufferedReader}, otherwise creates a BufferedReader from the\n     * given reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedReader is created.\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedReader buffer(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }\n\n    /**\n     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the\n     * given Writer.\n     *\n     * @param writer the Writer to wrap or return (not null)\n     * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedWriter buffer(final Writer writer) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer);\n    }\n\n    /**\n     * Returns the given Writer if it is already a {@link BufferedWriter}, otherwise creates a BufferedWriter from the\n     * given Writer.\n     *\n     * @param writer the Writer to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedWriter is created.\n     * @return the given Writer or a new {@link BufferedWriter} for the given Writer\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.5\n     */\n    public static BufferedWriter buffer(final Writer writer, final int size) {\n        return writer instanceof BufferedWriter ? (BufferedWriter) writer : new BufferedWriter(writer, size);\n    }\n\n    /**\n     * Returns a new byte array of size {@link #DEFAULT_BUFFER_SIZE}.\n     *\n     * @return a new byte array of size {@link #DEFAULT_BUFFER_SIZE}.\n     * @since 2.9.0\n     */\n    public static byte[] byteArray() {\n        return byteArray(DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Returns a new byte array of the given size.\n     *\n     * TODO Consider guarding or warning against large allocations...\n     *\n     * @param size array size.\n     * @return a new byte array of the given size.\n     * @since 2.9.0\n     */\n    public static byte[] byteArray(final int size) {\n        return new byte[size];\n    }\n\n    /**\n     * Returns a new char array of size {@link #DEFAULT_BUFFER_SIZE}.\n     *\n     * @return a new char array of size {@link #DEFAULT_BUFFER_SIZE}.\n     * @since 2.9.0\n     */\n    private static char[] charArray() {\n        return charArray(DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Returns a new char array of the given size.\n     *\n     * TODO Consider guarding or warning against large allocations...\n     *\n     * @param size array size.\n     * @return a new char array of the given size.\n     * @since 2.9.0\n     */\n    private static char[] charArray(final int size) {\n        return new char[size];\n    }\n\n    /**\n     * Closes the given {@link Closeable} as a null-safe operation.\n     *\n     * @param closeable The resource to close, may be null.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.7\n     */\n    public static void close(final Closeable closeable) throws IOException {\n        if (closeable != null) {\n            closeable.close();\n        }\n    }\n\n    /**\n     * Closes the given {@link Closeable}s as null-safe operations.\n     *\n     * @param closeables The resource(s) to close, may be null.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static void close(final Closeable... closeables) throws IOException {\n        IOConsumer.forEach(closeables, IOUtils::close);\n    }\n\n    /**\n     * Closes the given {@link Closeable} as a null-safe operation.\n     *\n     * @param closeable The resource to close, may be null.\n     * @param consumer Consume the IOException thrown by {@link Closeable#close()}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.7\n     */\n    public static void close(final Closeable closeable, final IOConsumer<IOException> consumer) throws IOException {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer != null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Closes a URLConnection.\n     *\n     * @param conn the connection to close.\n     * @since 2.4\n     */\n    public static void close(final URLConnection conn) {\n        if (conn instanceof HttpURLConnection) {\n            ((HttpURLConnection) conn).disconnect();\n        }\n    }\n\n    /**\n     * Closes a {@link Closeable} unconditionally.\n     *\n     * <p>\n     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored. This is typically used in\n     * finally blocks.\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * Closeable closeable = null;\n     * try {\n     *     closeable = new FileReader(&quot;foo.txt&quot;);\n     *     // process closeable\n     *     closeable.close();\n     * } catch (Exception e) {\n     *     // error handling\n     * } finally {\n     *     IOUtils.closeQuietly(closeable);\n     * }\n     * </pre>\n     * <p>\n     * Closing all streams:\n     * </p>\n     * <pre>\n     * try {\n     *     return IOUtils.copy(inputStream, outputStream);\n     * } finally {\n     *     IOUtils.closeQuietly(inputStream);\n     *     IOUtils.closeQuietly(outputStream);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param closeable the objects to close, may be null or already closed\n     * @since 2.0\n     *\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Closeable closeable) {\n        closeQuietly(closeable, null);\n    }\n\n    /**\n     * Closes a {@link Closeable} unconditionally.\n     * <p>\n     * Equivalent to {@link Closeable#close()}, except any exceptions will be ignored.\n     * <p>\n     * This is typically used in finally blocks to ensure that the closeable is closed\n     * even if an Exception was thrown before the normal close statement was reached.\n     * <br>\n     * <b>It should not be used to replace the close statement(s)\n     * which should be present for the non-exceptional case.</b>\n     * <br>\n     * It is only intended to simplify tidying up where normal processing has already failed\n     * and reporting close failure as well is not necessary or useful.\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * Closeable closeable = null;\n     * try {\n     *     closeable = new FileReader(&quot;foo.txt&quot;);\n     *     // processing using the closeable; may throw an Exception\n     *     closeable.close(); // Normal close - exceptions not ignored\n     * } catch (Exception e) {\n     *     // error handling\n     * } finally {\n     *     <b>IOUtils.closeQuietly(closeable); // In case normal close was skipped due to Exception</b>\n     * }\n     * </pre>\n     * <p>\n     * Closing all streams:\n     * <br>\n     * <pre>\n     * try {\n     *     return IOUtils.copy(inputStream, outputStream);\n     * } finally {\n     *     IOUtils.closeQuietly(inputStream, outputStream);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     * @param closeables the objects to close, may be null or already closed\n     * @see #closeQuietly(Closeable)\n     * @since 2.5\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Closeable... closeables) {\n        if (closeables != null) {\n            Arrays.stream(closeables).forEach(IOUtils::closeQuietly);\n        }\n    }\n\n    /**\n     * Closes the given {@link Closeable} as a null-safe operation while consuming IOException by the given {@code consumer}.\n     *\n     * @param closeable The resource to close, may be null.\n     * @param consumer Consumes the IOException thrown by {@link Closeable#close()}.\n     * @since 2.7\n     */\n    public static void closeQuietly(final Closeable closeable, final Consumer<IOException> consumer) {\n        if (closeable != null) {\n            try {\n                closeable.close();\n            } catch (final IOException e) {\n                if (consumer != null) {\n                    consumer.accept(e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Closes an {@link InputStream} unconditionally.\n     * <p>\n     * Equivalent to {@link InputStream#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   byte[] data = new byte[1024];\n     *   InputStream in = null;\n     *   try {\n     *       in = new FileInputStream(\"foo.txt\");\n     *       in.read(data);\n     *       in.close(); //close errors are handled\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(in);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param input the InputStream to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final InputStream input) {\n        closeQuietly((Closeable) input);\n    }\n\n    /**\n     * Closes an {@link OutputStream} unconditionally.\n     * <p>\n     * Equivalent to {@link OutputStream#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     * byte[] data = \"Hello, World\".getBytes();\n     *\n     * OutputStream out = null;\n     * try {\n     *     out = new FileOutputStream(\"foo.txt\");\n     *     out.write(data);\n     *     out.close(); //close errors are handled\n     * } catch (IOException e) {\n     *     // error handling\n     * } finally {\n     *     IOUtils.closeQuietly(out);\n     * }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param output the OutputStream to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final OutputStream output) {\n        closeQuietly((Closeable) output);\n    }\n\n    /**\n     * Closes an {@link Reader} unconditionally.\n     * <p>\n     * Equivalent to {@link Reader#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   char[] data = new char[1024];\n     *   Reader in = null;\n     *   try {\n     *       in = new FileReader(\"foo.txt\");\n     *       in.read(data);\n     *       in.close(); //close errors are handled\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(in);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param reader the Reader to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Reader reader) {\n        closeQuietly((Closeable) reader);\n    }\n\n    /**\n     * Closes a {@link Selector} unconditionally.\n     * <p>\n     * Equivalent to {@link Selector#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   Selector selector = null;\n     *   try {\n     *       selector = Selector.open();\n     *       // process socket\n     *\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(selector);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param selector the Selector to close, may be null or already closed\n     * @since 2.2\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Selector selector) {\n        closeQuietly((Closeable) selector);\n    }\n\n    /**\n     * Closes a {@link ServerSocket} unconditionally.\n     * <p>\n     * Equivalent to {@link ServerSocket#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   ServerSocket socket = null;\n     *   try {\n     *       socket = new ServerSocket();\n     *       // process socket\n     *       socket.close();\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(socket);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param serverSocket the ServerSocket to close, may be null or already closed\n     * @since 2.2\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final ServerSocket serverSocket) {\n        closeQuietly((Closeable) serverSocket);\n    }\n\n    /**\n     * Closes a {@link Socket} unconditionally.\n     * <p>\n     * Equivalent to {@link Socket#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   Socket socket = null;\n     *   try {\n     *       socket = new Socket(\"http://www.foo.com/\", 80);\n     *       // process socket\n     *       socket.close();\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(socket);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param socket the Socket to close, may be null or already closed\n     * @since 2.0\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Socket socket) {\n        closeQuietly((Closeable) socket);\n    }\n\n    /**\n     * Closes an {@link Writer} unconditionally.\n     * <p>\n     * Equivalent to {@link Writer#close()}, except any exceptions will be ignored.\n     * This is typically used in finally blocks.\n     * </p>\n     * <p>\n     * Example code:\n     * </p>\n     * <pre>\n     *   Writer out = null;\n     *   try {\n     *       out = new StringWriter();\n     *       out.write(\"Hello World\");\n     *       out.close(); //close errors are handled\n     *   } catch (Exception e) {\n     *       // error handling\n     *   } finally {\n     *       IOUtils.closeQuietly(out);\n     *   }\n     * </pre>\n     * <p>\n     * Also consider using a try-with-resources statement where appropriate.\n     * </p>\n     *\n     * @param writer the Writer to close, may be null or already closed\n     * @see Throwable#addSuppressed(java.lang.Throwable)\n     */\n    public static void closeQuietly(final Writer writer) {\n        closeQuietly((Closeable) writer);\n    }\n\n    /**\n     * Consumes bytes from a {@link InputStream} and ignores them.\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read.\n     * @return the number of bytes copied. or {@code 0} if {@code input is null}.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.8.0\n     */\n    public static long consume(final InputStream input)\n            throws IOException {\n        return copyLarge(input, NullOutputStream.INSTANCE, getByteArray());\n    }\n\n    /**\n     * Compares the contents of two Streams to determine if they are equal or\n     * not.\n     * <p>\n     * This method buffers the input internally using\n     * {@link BufferedInputStream} if they are not already buffered.\n     * </p>\n     *\n     * @param input1 the first stream\n     * @param input2 the second stream\n     * @return true if the content of the streams are equal or they both don't\n     * exist, false otherwise\n     * @throws NullPointerException if either input is null\n     * @throws IOException          if an I/O error occurs\n     */\n    public static boolean contentEquals(final InputStream input1, final InputStream input2) throws IOException {\n        // Before making any changes, please test with\n        // org.apache.commons.io.jmh.IOUtilsContentEqualsInputStreamsBenchmark\n        if (input1 == input2) {\n            return true;\n        }\n        if (input1 == null || input2 == null) {\n            return false;\n        }\n\n        // reuse one\n        final byte[] array1 = getByteArray();\n        // allocate another\n        final byte[] array2 = byteArray();\n        int pos1;\n        int pos2;\n        int count1;\n        int count2;\n        while (true) {\n            pos1 = 0;\n            pos2 = 0;\n            for (int index = 0; index < DEFAULT_BUFFER_SIZE; index++) {\n                if (pos1 == index) {\n                    do {\n                        count1 = input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n                    } while (count1 == 0);\n                    if (count1 == EOF) {\n                        return pos2 == index && input2.read() == EOF;\n                    }\n                    pos1 += count1;\n                }\n                if (pos2 == index) {\n                    do {\n                        count2 = input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n                    } while (count2 == 0);\n                    if (count2 == EOF) {\n                        return pos1 == index && input1.read() == EOF;\n                    }\n                    pos2 += count2;\n                }\n                if (array1[index] != array2[index]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    /**\n     * Compares the contents of two Readers to determine if they are equal or not.\n     * <p>\n     * This method buffers the input internally using {@link BufferedReader} if they are not already buffered.\n     * </p>\n     *\n     * @param input1 the first reader\n     * @param input2 the second reader\n     * @return true if the content of the readers are equal or they both don't exist, false otherwise\n     * @throws NullPointerException if either input is null\n     * @throws IOException if an I/O error occurs\n     * @since 1.1\n     */\n    public static boolean contentEquals(final Reader input1, final Reader input2) throws IOException {\n        if (input1 == input2) {\n            return true;\n        }\n        if (input1 == null || input2 == null) {\n            return false;\n        }\n\n        // reuse one\n        final char[] array1 = getCharArray();\n        // but allocate another\n        final char[] array2 = charArray();\n        int pos1;\n        int pos2;\n        int count1;\n        int count2;\n        while (true) {\n            pos1 = 0;\n            pos2 = 0;\n            for (int index = 0; index < DEFAULT_BUFFER_SIZE; index++) {\n                if (pos1 == index) {\n                    do {\n                        count1 = input1.read(array1, pos1, DEFAULT_BUFFER_SIZE - pos1);\n                    } while (count1 == 0);\n                    if (count1 == EOF) {\n                        return pos2 == index && input2.read() == EOF;\n                    }\n                    pos1 += count1;\n                }\n                if (pos2 == index) {\n                    do {\n                        count2 = input2.read(array2, pos2, DEFAULT_BUFFER_SIZE - pos2);\n                    } while (count2 == 0);\n                    if (count2 == EOF) {\n                        return pos1 == index && input1.read() == EOF;\n                    }\n                    pos2 += count2;\n                }\n                if (array1[index] != array2[index]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    /**\n     * Compares the contents of two Readers to determine if they are equal or\n     * not, ignoring EOL characters.\n     * <p>\n     * This method buffers the input internally using\n     * {@link BufferedReader} if they are not already buffered.\n     * </p>\n     *\n     * @param reader1 the first reader\n     * @param reader2 the second reader\n     * @return true if the content of the readers are equal (ignoring EOL differences),  false otherwise\n     * @throws NullPointerException if either input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    @SuppressWarnings(\"resource\")\n    public static boolean contentEqualsIgnoreEOL(final Reader reader1, final Reader reader2)\n            throws IOException {\n        if (reader1 == reader2) {\n            return true;\n        }\n        if (reader1 == null ^ reader2 == null) {\n            return false;\n        }\n        final BufferedReader br1 = toBufferedReader(reader1);\n        final BufferedReader br2 = toBufferedReader(reader2);\n\n        String line1 = br1.readLine();\n        String line2 = br2.readLine();\n        while (line1 != null && line1.equals(line2)) {\n            line1 = br1.readLine();\n            line2 = br2.readLine();\n        }\n        return Objects.equals(line1, line2);\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to an {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Large streams (over 2GB) will return a bytes copied value of {@code -1} after the copy has completed since\n     * the correct number of bytes cannot be returned as an int. For large streams use the\n     * {@link #copyLarge(InputStream, OutputStream)} method.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @return the number of bytes copied, or -1 if greater than {@link Integer#MAX_VALUE}.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 1.1\n     */\n    public static int copy(final InputStream inputStream, final OutputStream outputStream) throws IOException {\n        final long count = copyLarge(inputStream, outputStream);\n        return count > Integer.MAX_VALUE ? EOF : (int) count;\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to an {@link OutputStream} using an internal buffer of the\n     * given size.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write to\n     * @param bufferSize the bufferSize used to copy from the input to the output\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.5\n     */\n    public static long copy(final InputStream inputStream, final OutputStream outputStream, final int bufferSize)\n            throws IOException {\n        return copyLarge(inputStream, outputStream, IOUtils.byteArray(bufferSize));\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to chars on a\n     * {@link Writer} using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * This method uses {@link InputStreamReader}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #copy(InputStream, Writer, Charset)} instead\n     */\n    @Deprecated\n    public static void copy(final InputStream input, final Writer writer)\n            throws IOException {\n        copy(input, writer, Charset.defaultCharset());\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to chars on a\n     * {@link Writer} using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * This method uses {@link InputStreamReader}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputCharset the charset to use for the input stream, null means platform default\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void copy(final InputStream input, final Writer writer, final Charset inputCharset)\n            throws IOException {\n        final InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(inputCharset));\n        copy(reader, writer);\n    }\n\n    /**\n     * Copies bytes from an {@link InputStream} to chars on a\n     * {@link Writer} using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link InputStreamReader}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputCharsetName the name of the requested charset for the InputStream, null means platform default\n     * @throws NullPointerException                         if the input or output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void copy(final InputStream input, final Writer writer, final String inputCharsetName)\n            throws IOException {\n        copy(input, writer, Charsets.toCharset(inputCharsetName));\n    }\n\n    /**\n     * Copies bytes from a {@link java.io.ByteArrayOutputStream} to a {@link QueueInputStream}.\n     * <p>\n     * Unlike using JDK {@link java.io.PipedInputStream} and {@link java.io.PipedOutputStream} for this, this\n     * solution works safely in a single thread environment.\n     * </p>\n     * <p>\n     * Example usage:\n     * </p>\n     *\n     * <pre>\n     * ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n     * outputStream.writeBytes(\"hello world\".getBytes(StandardCharsets.UTF_8));\n     *\n     * InputStream inputStream = IOUtils.copy(outputStream);\n     * </pre>\n     *\n     * @param outputStream the {@link java.io.ByteArrayOutputStream} to read.\n     * @return the {@link QueueInputStream} filled with the content of the outputStream.\n     * @throws NullPointerException if the {@link java.io.ByteArrayOutputStream} is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.12\n     */\n    @SuppressWarnings(\"resource\") // streams are closed by the caller.\n    public static QueueInputStream copy(final java.io.ByteArrayOutputStream outputStream) throws IOException {\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        final QueueInputStream in = new QueueInputStream();\n        outputStream.writeTo(in.newQueueOutputStream());\n        return in;\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to a {@link Appendable}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Large streams (over 2GB) will return a chars copied value of\n     * {@code -1} after the copy has completed since the correct\n     * number of chars cannot be returned as an int. For large streams\n     * use the {@link #copyLarge(Reader, Writer)} method.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link Appendable} to write to\n     * @return the number of characters copied, or -1 if &gt; Integer.MAX_VALUE\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.7\n     */\n    public static long copy(final Reader reader, final Appendable output) throws IOException {\n        return copy(reader, output, CharBuffer.allocate(DEFAULT_BUFFER_SIZE));\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to an {@link Appendable}.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link Appendable} to write to\n     * @param buffer the buffer to be used for the copy\n     * @return the number of characters copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.7\n     */\n    public static long copy(final Reader reader, final Appendable output, final CharBuffer buffer) throws IOException {\n        long count = 0;\n        int n;\n        while (EOF != (n = reader.read(buffer))) {\n            buffer.flip();\n            output.append(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform, and calling flush.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Due to the implementation of OutputStreamWriter, this method performs a\n     * flush.\n     * </p>\n     * <p>\n     * This method uses {@link OutputStreamWriter}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #copy(Reader, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void copy(final Reader reader, final OutputStream output)\n            throws IOException {\n        copy(reader, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to bytes on an\n     * {@link OutputStream} using the specified character encoding, and\n     * calling flush.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Due to the implementation of OutputStreamWriter, this method performs a\n     * flush.\n     * </p>\n     * <p>\n     * This method uses {@link OutputStreamWriter}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param outputCharset the charset to use for the OutputStream, null means platform default\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void copy(final Reader reader, final OutputStream output, final Charset outputCharset)\n            throws IOException {\n        final OutputStreamWriter writer = new OutputStreamWriter(output, Charsets.toCharset(outputCharset));\n        copy(reader, writer);\n        // XXX Unless anyone is planning on rewriting OutputStreamWriter,\n        // we have to flush here.\n        writer.flush();\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to bytes on an\n     * {@link OutputStream} using the specified character encoding, and\n     * calling flush.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * Due to the implementation of OutputStreamWriter, this method performs a\n     * flush.\n     * </p>\n     * <p>\n     * This method uses {@link OutputStreamWriter}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param outputCharsetName the name of the requested charset for the OutputStream, null means platform default\n     * @throws NullPointerException                         if the input or output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void copy(final Reader reader, final OutputStream output, final String outputCharsetName)\n            throws IOException {\n        copy(reader, output, Charsets.toCharset(outputCharsetName));\n    }\n\n    /**\n     * Copies chars from a {@link Reader} to a {@link Writer}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * Large streams (over 2GB) will return a chars copied value of\n     * {@code -1} after the copy has completed since the correct\n     * number of chars cannot be returned as an int. For large streams\n     * use the {@link #copyLarge(Reader, Writer)} method.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read.\n     * @param writer the {@link Writer} to write.\n     * @return the number of characters copied, or -1 if &gt; Integer.MAX_VALUE\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static int copy(final Reader reader, final Writer writer) throws IOException {\n        final long count = copyLarge(reader, writer);\n        if (count > Integer.MAX_VALUE) {\n            return EOF;\n        }\n        return (int) count;\n    }\n\n    /**\n     * Copies bytes from a {@link URL} to an {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param url the {@link URL} to read.\n     * @param file the {@link OutputStream} to write.\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the URL is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static long copy(final URL url, final File file) throws IOException {\n        try (OutputStream outputStream = Files.newOutputStream(Objects.requireNonNull(file, \"file\").toPath())) {\n            return copy(url, outputStream);\n        }\n    }\n\n    /**\n     * Copies bytes from a {@link URL} to an {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param url the {@link URL} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the URL is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.9.0\n     */\n    public static long copy(final URL url, final OutputStream outputStream) throws IOException {\n        try (InputStream inputStream = Objects.requireNonNull(url, \"url\").openStream()) {\n            return copyLarge(inputStream, outputStream);\n        }\n    }\n\n    /**\n     * Copies bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 1.3\n     */\n    public static long copyLarge(final InputStream inputStream, final OutputStream outputStream)\n            throws IOException {\n        return copy(inputStream, outputStream, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Copies bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @param outputStream the {@link OutputStream} to write.\n     * @param buffer the buffer to use for the copy\n     * @return the number of bytes copied.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws NullPointerException if the OutputStream is {@code null}.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.2\n     */\n    @SuppressWarnings(\"resource\") // streams are closed by the caller.\n    public static long copyLarge(final InputStream inputStream, final OutputStream outputStream, final byte[] buffer)\n        throws IOException {\n        Objects.requireNonNull(inputStream, \"inputStream\");\n        Objects.requireNonNull(outputStream, \"outputStream\");\n        long count = 0;\n        int n;\n        while (EOF != (n = inputStream.read(buffer))) {\n            outputStream.write(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    /**\n     * Copies some or all bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input bytes.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(InputStream, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     *\n     * @param input the {@link InputStream} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param inputOffset : number of bytes to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of bytes to copy. -ve means all\n     * @return the number of bytes copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final InputStream input, final OutputStream output, final long inputOffset,\n                                 final long length) throws IOException {\n        return copyLarge(input, output, inputOffset, length, getByteArray());\n    }\n\n    /**\n     * Copies some or all bytes from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input bytes.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(InputStream, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param output the {@link OutputStream} to write to\n     * @param inputOffset : number of bytes to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of bytes to copy. -ve means all\n     * @param buffer the buffer to use for the copy\n     * @return the number of bytes copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final InputStream input, final OutputStream output,\n                                 final long inputOffset, final long length, final byte[] buffer) throws IOException {\n        if (inputOffset > 0) {\n            skipFully(input, inputOffset);\n        }\n        if (length == 0) {\n            return 0;\n        }\n        final int bufferLength = buffer.length;\n        int bytesToRead = bufferLength;\n        if (length > 0 && length < bufferLength) {\n            bytesToRead = (int) length;\n        }\n        int read;\n        long totalRead = 0;\n        while (bytesToRead > 0 && EOF != (read = input.read(buffer, 0, bytesToRead))) {\n            output.write(buffer, 0, read);\n            totalRead += read;\n            if (length > 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead = (int) Math.min(length - totalRead, bufferLength);\n            }\n        }\n        return totalRead;\n    }\n\n    /**\n     * Copies chars from a large (over 2GB) {@link Reader} to a {@link Writer}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to source.\n     * @param writer the {@link Writer} to target.\n     * @return the number of characters copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.3\n     */\n    public static long copyLarge(final Reader reader, final Writer writer) throws IOException {\n        return copyLarge(reader, writer, getCharArray());\n    }\n\n    /**\n     * Copies chars from a large (over 2GB) {@link Reader} to a {@link Writer}.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to source.\n     * @param writer the {@link Writer} to target.\n     * @param buffer the buffer to be used for the copy\n     * @return the number of characters copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final Reader reader, final Writer writer, final char[] buffer) throws IOException {\n        long count = 0;\n        int n;\n        while (EOF != (n = reader.read(buffer))) {\n            writer.write(buffer, 0, n);\n            count += n;\n        }\n        return count;\n    }\n\n    /**\n     * Copies some or all chars from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input chars.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     * <p>\n     * The buffer size is given by {@link #DEFAULT_BUFFER_SIZE}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputOffset : number of chars to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of chars to copy. -ve means all\n     * @return the number of chars copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length)\n            throws IOException {\n        return copyLarge(reader, writer, inputOffset, length, getCharArray());\n    }\n\n    /**\n     * Copies some or all chars from a large (over 2GB) {@link InputStream} to an\n     * {@link OutputStream}, optionally skipping input chars.\n     * <p>\n     * This method uses the provided buffer, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param writer the {@link Writer} to write to\n     * @param inputOffset : number of chars to skip from input before copying\n     * -ve values are ignored\n     * @param length : number of chars to copy. -ve means all\n     * @param buffer the buffer to be used for the copy\n     * @return the number of chars copied\n     * @throws NullPointerException if the input or output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.2\n     */\n    public static long copyLarge(final Reader reader, final Writer writer, final long inputOffset, final long length,\n                                 final char[] buffer)\n            throws IOException {\n        if (inputOffset > 0) {\n            skipFully(reader, inputOffset);\n        }\n        if (length == 0) {\n            return 0;\n        }\n        int bytesToRead = buffer.length;\n        if (length > 0 && length < buffer.length) {\n            bytesToRead = (int) length;\n        }\n        int read;\n        long totalRead = 0;\n        while (bytesToRead > 0 && EOF != (read = reader.read(buffer, 0, bytesToRead))) {\n            writer.write(buffer, 0, read);\n            totalRead += read;\n            if (length > 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead = (int) Math.min(length - totalRead, buffer.length);\n            }\n        }\n        return totalRead;\n    }\n\n    /**\n     * Gets the thread local byte array.\n     *\n     * @return the thread local byte array.\n     */\n    static byte[] getByteArray() {\n        return SKIP_BYTE_BUFFER.get();\n    }\n\n    /**\n     * Gets the thread local char array.\n     *\n     * @return the thread local char array.\n     */\n    static char[] getCharArray() {\n        return SKIP_CHAR_BUFFER.get();\n    }\n\n    /**\n     * Returns the length of the given array in a null-safe manner.\n     *\n     * @param array an array or null\n     * @return the array length -- or 0 if the given array is null.\n     * @since 2.7\n     */\n    public static int length(final byte[] array) {\n        return array == null ? 0 : array.length;\n    }\n\n    /**\n     * Returns the length of the given array in a null-safe manner.\n     *\n     * @param array an array or null\n     * @return the array length -- or 0 if the given array is null.\n     * @since 2.7\n     */\n    public static int length(final char[] array) {\n        return array == null ? 0 : array.length;\n    }\n\n    /**\n     * Returns the length of the given CharSequence in a null-safe manner.\n     *\n     * @param csq a CharSequence or null\n     * @return the CharSequence length -- or 0 if the given CharSequence is null.\n     * @since 2.7\n     */\n    public static int length(final CharSequence csq) {\n        return csq == null ? 0 : csq.length();\n    }\n\n    /**\n     * Returns the length of the given array in a null-safe manner.\n     *\n     * @param array an array or null\n     * @return the array length -- or 0 if the given array is null.\n     * @since 2.7\n     */\n    public static int length(final Object[] array) {\n        return array == null ? 0 : array.length;\n    }\n\n    /**\n     * Returns an Iterator for the lines in an {@link InputStream}, using\n     * the character encoding specified (or default encoding if null).\n     * <p>\n     * {@link LineIterator} holds a reference to the open\n     * {@link InputStream} specified here. When you have finished with\n     * the iterator you should close the stream to free internal resources.\n     * This can be done by using a try-with-resources block, closing the stream directly, or by calling\n     * {@link LineIterator#close()}.\n     * </p>\n     * <p>\n     * The recommended usage pattern is:\n     * </p>\n     * <pre>\n     * try {\n     *   LineIterator it = IOUtils.lineIterator(stream, charset);\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   IOUtils.closeQuietly(stream);\n     * }\n     * </pre>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charset the charset to use, null means platform default\n     * @return an Iterator of the lines in the reader, never null\n     * @throws IllegalArgumentException if the input is null\n     * @since 2.3\n     */\n    public static LineIterator lineIterator(final InputStream input, final Charset charset) {\n        return new LineIterator(new InputStreamReader(input, Charsets.toCharset(charset)));\n    }\n\n    /**\n     * Returns an Iterator for the lines in an {@link InputStream}, using\n     * the character encoding specified (or default encoding if null).\n     * <p>\n     * {@link LineIterator} holds a reference to the open\n     * {@link InputStream} specified here. When you have finished with\n     * the iterator you should close the stream to free internal resources.\n     * This can be done by using a try-with-resources block, closing the stream directly, or by calling\n     * {@link LineIterator#close()}.\n     * </p>\n     * <p>\n     * The recommended usage pattern is:\n     * </p>\n     * <pre>\n     * try {\n     *   LineIterator it = IOUtils.lineIterator(stream, \"UTF-8\");\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   IOUtils.closeQuietly(stream);\n     * }\n     * </pre>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charsetName the encoding to use, null means platform default\n     * @return an Iterator of the lines in the reader, never null\n     * @throws IllegalArgumentException                     if the input is null\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.2\n     */\n    public static LineIterator lineIterator(final InputStream input, final String charsetName) {\n        return lineIterator(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Returns an Iterator for the lines in a {@link Reader}.\n     * <p>\n     * {@link LineIterator} holds a reference to the open\n     * {@link Reader} specified here. When you have finished with the\n     * iterator you should close the reader to free internal resources.\n     * This can be done by using a try-with-resources block, closing the reader directly, or by calling\n     * {@link LineIterator#close()}.\n     * </p>\n     * <p>\n     * The recommended usage pattern is:\n     * </p>\n     * <pre>\n     * try {\n     *   LineIterator it = IOUtils.lineIterator(reader);\n     *   while (it.hasNext()) {\n     *     String line = it.nextLine();\n     *     /// do something with line\n     *   }\n     * } finally {\n     *   IOUtils.closeQuietly(reader);\n     * }\n     * </pre>\n     *\n     * @param reader the {@link Reader} to read from, not null\n     * @return an Iterator of the lines in the reader, never null\n     * @throws IllegalArgumentException if the reader is null\n     * @since 1.2\n     */\n    public static LineIterator lineIterator(final Reader reader) {\n        return new LineIterator(reader);\n    }\n\n    /**\n     * Reads bytes from an input stream.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link InputStream}.\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IOException if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final InputStream input, final byte[] buffer) throws IOException {\n        return read(input, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads bytes from an input stream.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link InputStream}.\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IllegalArgumentException if length is negative\n     * @throws IOException              if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length < 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining = length;\n        while (remaining > 0) {\n            final int location = length - remaining;\n            final int count = input.read(buffer, offset + location, remaining);\n            if (EOF == count) { // EOF\n                break;\n            }\n            remaining -= count;\n        }\n        return length - remaining;\n    }\n\n    /**\n     * Reads bytes from a ReadableByteChannel.\n     * <p>\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link ReadableByteChannel}.\n     * </p>\n     *\n     * @param input the byte channel to read\n     * @param buffer byte buffer destination\n     * @return the actual length read; may be less than requested if EOF was reached\n     * @throws IOException if a read error occurs\n     * @since 2.5\n     */\n    public static int read(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int length = buffer.remaining();\n        while (buffer.remaining() > 0) {\n            final int count = input.read(buffer);\n            if (EOF == count) { // EOF\n                break;\n            }\n        }\n        return length - buffer.remaining();\n    }\n\n    /**\n     * Reads characters from an input character stream.\n     * This implementation guarantees that it will read as many characters\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link Reader}.\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IOException if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final Reader reader, final char[] buffer) throws IOException {\n        return read(reader, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads characters from an input character stream.\n     * This implementation guarantees that it will read as many characters\n     * as possible before giving up; this may not always be the case for\n     * subclasses of {@link Reader}.\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     * @return actual length read; may be less than requested if EOF was reached\n     * @throws IllegalArgumentException if length is negative\n     * @throws IOException              if a read error occurs\n     * @since 2.2\n     */\n    public static int read(final Reader reader, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        if (length < 0) {\n            throw new IllegalArgumentException(\"Length must not be negative: \" + length);\n        }\n        int remaining = length;\n        while (remaining > 0) {\n            final int location = length - remaining;\n            final int count = reader.read(buffer, offset + location, remaining);\n            if (EOF == count) { // EOF\n                break;\n            }\n            remaining -= count;\n        }\n        return length - remaining;\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     *\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of bytes read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final InputStream input, final byte[] buffer) throws IOException {\n        readFully(input, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     *\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of bytes read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final InputStream input, final byte[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual = read(input, buffer, offset, length);\n        if (actual != length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#read(byte[], int, int)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input where to read input from\n     * @param length length to read, must be &gt;= 0\n     * @return the bytes read from input\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of bytes read was incorrect\n     * @since 2.5\n     */\n    public static byte[] readFully(final InputStream input, final int length) throws IOException {\n        final byte[] buffer = IOUtils.byteArray(length);\n        readFully(input, buffer, 0, buffer.length);\n        return buffer;\n    }\n\n    /**\n     * Reads the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link ReadableByteChannel#read(ByteBuffer)} may\n     * not read as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param input the byte channel to read\n     * @param buffer byte buffer destination\n     * @throws IOException  if there is a problem reading the file\n     * @throws EOFException if the number of bytes read was incorrect\n     * @since 2.5\n     */\n    public static void readFully(final ReadableByteChannel input, final ByteBuffer buffer) throws IOException {\n        final int expected = buffer.remaining();\n        final int actual = read(input, buffer);\n        if (actual != expected) {\n            throw new EOFException(\"Length to read: \" + expected + \" actual: \" + actual);\n        }\n    }\n\n    /**\n     * Reads the requested number of characters or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link Reader#read(char[], int, int)} may\n     * not read as many characters as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of characters read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final Reader reader, final char[] buffer) throws IOException {\n        readFully(reader, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Reads the requested number of characters or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link Reader#read(char[], int, int)} may\n     * not read as many characters as requested (most likely because of reaching EOF).\n     * </p>\n     *\n     * @param reader where to read input from\n     * @param buffer destination\n     * @param offset initial offset into buffer\n     * @param length length to read, must be &gt;= 0\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if length is negative\n     * @throws EOFException             if the number of characters read was incorrect\n     * @since 2.2\n     */\n    public static void readFully(final Reader reader, final char[] buffer, final int offset, final int length)\n            throws IOException {\n        final int actual = read(reader, buffer, offset, length);\n        if (actual != length) {\n            throw new EOFException(\"Length to read: \" + length + \" actual: \" + actual);\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a list of Strings,\n     * one entry per line, using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @return the list of Strings, never null\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #readLines(InputStream, Charset)} instead\n     */\n    @Deprecated\n    public static List<String> readLines(final InputStream input) throws IOException {\n        return readLines(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a list of Strings,\n     * one entry per line, using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charset the charset to use, null means platform default\n     * @return the list of Strings, never null\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static List<String> readLines(final InputStream input, final Charset charset) throws IOException {\n        final InputStreamReader reader = new InputStreamReader(input, Charsets.toCharset(charset));\n        return readLines(reader);\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a list of Strings,\n     * one entry per line, using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from, not null\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the list of Strings, never null\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static List<String> readLines(final InputStream input, final String charsetName) throws IOException {\n        return readLines(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a list of Strings,\n     * one entry per line.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from, not null\n     * @return the list of Strings, never null\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    @SuppressWarnings(\"resource\") // reader wraps input and is the responsibility of the caller.\n    public static List<String> readLines(final Reader reader) throws IOException {\n        final BufferedReader bufReader = toBufferedReader(reader);\n        final List<String> list = new ArrayList<>();\n        String line;\n        while ((line = bufReader.readLine()) != null) {\n            list.add(line);\n        }\n        return list;\n    }\n\n    /**\n     * Gets the contents of a resource as a byte array.\n     * <p>\n     * Delegates to {@link #resourceToByteArray(String, ClassLoader) resourceToByteArray(String, null)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @return the requested byte array\n     * @throws IOException if an I/O error occurs or the resource is not found.\n     * @see #resourceToByteArray(String, ClassLoader)\n     * @since 2.6\n     */\n    public static byte[] resourceToByteArray(final String name) throws IOException {\n        return resourceToByteArray(name, null);\n    }\n\n    /**\n     * Gets the contents of a resource as a byte array.\n     * <p>\n     * Delegates to {@link #resourceToURL(String, ClassLoader)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param classLoader the class loader that the resolution of the resource is delegated to\n     * @return the requested byte array\n     * @throws IOException if an I/O error occurs or the resource is not found.\n     * @see #resourceToURL(String, ClassLoader)\n     * @since 2.6\n     */\n    public static byte[] resourceToByteArray(final String name, final ClassLoader classLoader) throws IOException {\n        return toByteArray(resourceToURL(name, classLoader));\n    }\n\n    /**\n     * Gets the contents of a resource as a String using the specified character encoding.\n     * <p>\n     * Delegates to {@link #resourceToString(String, Charset, ClassLoader) resourceToString(String, Charset, null)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param charset the charset to use, null means platform default\n     * @return the requested String\n     * @throws IOException if an I/O error occurs or the resource is not found.\n     * @see #resourceToString(String, Charset, ClassLoader)\n     * @since 2.6\n     */\n    public static String resourceToString(final String name, final Charset charset) throws IOException {\n        return resourceToString(name, charset, null);\n    }\n\n    /**\n     * Gets the contents of a resource as a String using the specified character encoding.\n     * <p>\n     * Delegates to {@link #resourceToURL(String, ClassLoader)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param charset the Charset to use, null means platform default\n     * @param classLoader the class loader that the resolution of the resource is delegated to\n     * @return the requested String\n     * @throws IOException if an I/O error occurs.\n     * @see #resourceToURL(String, ClassLoader)\n     * @since 2.6\n     */\n    public static String resourceToString(final String name, final Charset charset, final ClassLoader classLoader) throws IOException {\n        return toString(resourceToURL(name, classLoader), charset);\n    }\n\n    /**\n     * Gets a URL pointing to the given resource.\n     * <p>\n     * Delegates to {@link #resourceToURL(String, ClassLoader) resourceToURL(String, null)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @return A URL object for reading the resource.\n     * @throws IOException if the resource is not found.\n     * @since 2.6\n     */\n    public static URL resourceToURL(final String name) throws IOException {\n        return resourceToURL(name, null);\n    }\n\n    /**\n     * Gets a URL pointing to the given resource.\n     * <p>\n     * If the {@code classLoader} is not null, call {@link ClassLoader#getResource(String)}, otherwise call\n     * {@link Class#getResource(String) IOUtils.class.getResource(name)}.\n     * </p>\n     *\n     * @param name The resource name.\n     * @param classLoader Delegate to this class loader if not null\n     * @return A URL object for reading the resource.\n     * @throws IOException if the resource is not found.\n     * @since 2.6\n     */\n    public static URL resourceToURL(final String name, final ClassLoader classLoader) throws IOException {\n        // What about the thread context class loader?\n        // What about the system class loader?\n        final URL resource = classLoader == null ? IOUtils.class.getResource(name) : classLoader.getResource(name);\n        if (resource == null) {\n            throw new IOException(\"Resource not found: \" + name);\n        }\n        return resource;\n    }\n\n    /**\n     * Skips bytes from an input byte stream.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up; this may not always be the case for\n     * skip() implementations in subclasses of {@link InputStream}.\n     * <p>\n     * Note that the implementation uses {@link InputStream#read(byte[], int, int)} rather\n     * than delegating to {@link InputStream#skip(long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of bytes are skipped.\n     * </p>\n     *\n     * @param input byte stream to skip\n     * @param toSkip number of bytes to skip.\n     * @return number of bytes actually skipped.\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @see InputStream#skip(long)\n     * @see <a href=\"https://issues.apache.org/jira/browse/IO-203\">IO-203 - Add skipFully() method for InputStreams</a>\n     * @since 2.0\n     */\n    public static long skip(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        /*\n         * N.B. no need to synchronize access to SKIP_BYTE_BUFFER: - we don't care if the buffer is created multiple\n         * times (the data is ignored) - we always use the same size buffer, so if it it is recreated it will still be\n         * OK (if the buffer size were variable, we would need to synch. to ensure some other thread did not create a\n         * smaller one)\n         */\n        long remain = toSkip;\n        while (remain > 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final byte[] byteArray = getByteArray();\n            final long n = input.read(byteArray, 0, (int) Math.min(remain, byteArray.length));\n            if (n < 0) { // EOF\n                break;\n            }\n            remain -= n;\n        }\n        return toSkip - remain;\n    }\n\n    /**\n     * Skips bytes from a ReadableByteChannel.\n     * This implementation guarantees that it will read as many bytes\n     * as possible before giving up.\n     *\n     * @param input ReadableByteChannel to skip\n     * @param toSkip number of bytes to skip.\n     * @return number of bytes actually skipped.\n     * @throws IOException              if there is a problem reading the ReadableByteChannel\n     * @throws IllegalArgumentException if toSkip is negative\n     * @since 2.5\n     */\n    public static long skip(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        final ByteBuffer skipByteBuffer = ByteBuffer.allocate((int) Math.min(toSkip, DEFAULT_BUFFER_SIZE));\n        long remain = toSkip;\n        while (remain > 0) {\n            skipByteBuffer.position(0);\n            skipByteBuffer.limit((int) Math.min(remain, DEFAULT_BUFFER_SIZE));\n            final int n = input.read(skipByteBuffer);\n            if (n == EOF) {\n                break;\n            }\n            remain -= n;\n        }\n        return toSkip - remain;\n    }\n\n    /**\n     * Skips characters from an input character stream.\n     * This implementation guarantees that it will read as many characters\n     * as possible before giving up; this may not always be the case for\n     * skip() implementations in subclasses of {@link Reader}.\n     * <p>\n     * Note that the implementation uses {@link Reader#read(char[], int, int)} rather\n     * than delegating to {@link Reader#skip(long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param reader character stream to skip\n     * @param toSkip number of characters to skip.\n     * @return number of characters actually skipped.\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @see Reader#skip(long)\n     * @see <a href=\"https://issues.apache.org/jira/browse/IO-203\">IO-203 - Add skipFully() method for InputStreams</a>\n     * @since 2.0\n     */\n    public static long skip(final Reader reader, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        long remain = toSkip;\n        while (remain > 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final char[] charArray = getCharArray();\n            final long n = reader.read(charArray, 0, (int) Math.min(remain, charArray.length));\n            if (n < 0) { // EOF\n                break;\n            }\n            remain -= n;\n        }\n        return toSkip - remain;\n    }\n\n    /**\n     * Skips the requested number of bytes or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link InputStream#skip(long)} may\n     * not skip as many bytes as requested (most likely because of reaching EOF).\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(InputStream, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param input stream to skip\n     * @param toSkip the number of bytes to skip\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @throws EOFException             if the number of bytes skipped was incorrect\n     * @see InputStream#skip(long)\n     * @since 2.0\n     */\n    public static void skipFully(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped = skip(input, toSkip);\n        if (skipped != toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }\n\n    /**\n     * Skips the requested number of bytes or fail if there are not enough left.\n     *\n     * @param input ReadableByteChannel to skip\n     * @param toSkip the number of bytes to skip\n     * @throws IOException              if there is a problem reading the ReadableByteChannel\n     * @throws IllegalArgumentException if toSkip is negative\n     * @throws EOFException             if the number of bytes skipped was incorrect\n     * @since 2.5\n     */\n    public static void skipFully(final ReadableByteChannel input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped = skip(input, toSkip);\n        if (skipped != toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }\n\n    /**\n     * Skips the requested number of characters or fail if there are not enough left.\n     * <p>\n     * This allows for the possibility that {@link Reader#skip(long)} may\n     * not skip as many characters as requested (most likely because of reaching EOF).\n     * </p>\n     * <p>\n     * Note that the implementation uses {@link #skip(Reader, long)}.\n     * This means that the method may be considerably less efficient than using the actual skip implementation,\n     * this is done to guarantee that the correct number of characters are skipped.\n     * </p>\n     *\n     * @param reader stream to skip\n     * @param toSkip the number of characters to skip\n     * @throws IOException              if there is a problem reading the file\n     * @throws IllegalArgumentException if toSkip is negative\n     * @throws EOFException             if the number of characters skipped was incorrect\n     * @see Reader#skip(long)\n     * @since 2.0\n     */\n    public static void skipFully(final Reader reader, final long toSkip) throws IOException {\n        final long skipped = skip(reader, toSkip);\n        if (skipped != toSkip) {\n            throw new EOFException(\"Chars to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }\n\n    /**\n     * Fetches entire contents of an {@link InputStream} and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * </p>\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * <p>\n     * It can be used in favor of {@link #toByteArray(InputStream)}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input Stream to be fully buffered.\n     * @return A fully buffered stream.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream(final InputStream input) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input);\n    }\n\n    /**\n     * Fetches entire contents of an {@link InputStream} and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * </p>\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * <p>\n     * It can be used in favor of {@link #toByteArray(InputStream)}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     * @return A fully buffered stream.\n     * @throws IOException if an I/O error occurs.\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream(final InputStream input, final int size) throws IOException {\n        return ByteArrayOutputStream.toBufferedInputStream(input, size);\n    }\n\n    /**\n     * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a BufferedReader from the given\n     * reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @see #buffer(Reader)\n     * @since 2.2\n     */\n    public static BufferedReader toBufferedReader(final Reader reader) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader);\n    }\n\n    /**\n     * Returns the given reader if it is a {@link BufferedReader}, otherwise creates a BufferedReader from the given\n     * reader.\n     *\n     * @param reader the reader to wrap or return (not null)\n     * @param size the buffer size, if a new BufferedReader is created.\n     * @return the given reader or a new {@link BufferedReader} for the given reader\n     * @throws NullPointerException if the input parameter is null\n     * @see #buffer(Reader)\n     * @since 2.5\n     */\n    public static BufferedReader toBufferedReader(final Reader reader, final int size) {\n        return reader instanceof BufferedReader ? (BufferedReader) reader : new BufferedReader(reader, size);\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a {@code byte[]}.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read.\n     * @return the requested byte array.\n     * @throws NullPointerException if the InputStream is {@code null}.\n     * @throws IOException if an I/O error occurs or reading more than {@link Integer#MAX_VALUE} occurs.\n     */\n    public static byte[] toByteArray(final InputStream inputStream) throws IOException {\n        // We use a ThresholdingOutputStream to avoid reading AND writing more than Integer.MAX_VALUE.\n        try (UnsynchronizedByteArrayOutputStream ubaOutput = new UnsynchronizedByteArrayOutputStream();\n            ThresholdingOutputStream thresholdOuput = new ThresholdingOutputStream(Integer.MAX_VALUE, os -> {\n                throw new IllegalArgumentException(String.format(\"Cannot read more than %,d into a byte array\", Integer.MAX_VALUE));\n            }, os -> ubaOutput)) {\n            copy(inputStream, thresholdOuput);\n            return ubaOutput.toByteArray();\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a {@code byte[]}. Use this method instead of\n     * {@link #toByteArray(InputStream)} when {@link InputStream} size is known.\n     *\n     * @param input the {@link InputStream} to read.\n     * @param size the size of {@link InputStream} to read, where 0 &lt; {@code size} &lt;= length of input stream.\n     * @return byte [] of length {@code size}.\n     * @throws IOException if an I/O error occurs or {@link InputStream} length is smaller than parameter {@code size}.\n     * @throws IllegalArgumentException if {@code size} is less than zero.\n     * @since 2.1\n     */\n    public static byte[] toByteArray(final InputStream input, final int size) throws IOException {\n\n        if (size < 0) {\n            throw new IllegalArgumentException(\"Size must be equal or greater than zero: \" + size);\n        }\n\n        if (size == 0) {\n            return EMPTY_BYTE_ARRAY;\n        }\n\n        final byte[] data = IOUtils.byteArray(size);\n        int offset = 0;\n        int read;\n\n        while (offset < size && (read = input.read(data, offset, size - offset)) != EOF) {\n            offset += read;\n        }\n\n        if (offset != size) {\n            throw new IOException(\"Unexpected read size, current: \" + offset + \", expected: \" + size);\n        }\n\n        return data;\n    }\n\n    /**\n     * Gets contents of an {@link InputStream} as a {@code byte[]}.\n     * Use this method instead of {@link #toByteArray(InputStream)}\n     * when {@link InputStream} size is known.\n     * <b>NOTE:</b> the method checks that the length can safely be cast to an int without truncation\n     * before using {@link IOUtils#toByteArray(java.io.InputStream, int)} to read into the byte array.\n     * (Arrays can have no more than Integer.MAX_VALUE entries anyway)\n     *\n     * @param input the {@link InputStream} to read from\n     * @param size the size of {@link InputStream} to read, where 0 &lt; {@code size} &lt;= min(Integer.MAX_VALUE, length of input stream).\n     * @return byte [] the requested byte array, of length {@code size}\n     * @throws IOException              if an I/O error occurs or {@link InputStream} length is less than {@code size}\n     * @throws IllegalArgumentException if size is less than zero or size is greater than Integer.MAX_VALUE\n     * @see IOUtils#toByteArray(java.io.InputStream, int)\n     * @since 2.1\n     */\n    public static byte[] toByteArray(final InputStream input, final long size) throws IOException {\n        if (size > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException(\"Size cannot be greater than Integer max value: \" + size);\n        }\n        return toByteArray(input, (int) size);\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a {@code byte[]}\n     * using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @deprecated 2.5 use {@link #toByteArray(Reader, Charset)} instead\n     */\n    @Deprecated\n    public static byte[] toByteArray(final Reader reader) throws IOException {\n        return toByteArray(reader, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a {@code byte[]}\n     * using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param charset the charset to use, null means platform default\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static byte[] toByteArray(final Reader reader, final Charset charset) throws IOException {\n        try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n            copy(reader, output, charset);\n            return output.toByteArray();\n        }\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a {@code byte[]}\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested byte array\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static byte[] toByteArray(final Reader reader, final String charsetName) throws IOException {\n        return toByteArray(reader, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link String} as a {@code byte[]}\n     * using the default character encoding of the platform.\n     * <p>\n     * This is the same as {@link String#getBytes()}.\n     * </p>\n     *\n     * @param input the {@link String} to convert\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @deprecated 2.5 Use {@link String#getBytes()} instead\n     */\n    @Deprecated\n    public static byte[] toByteArray(final String input) {\n        // make explicit the use of the default charset\n        return input.getBytes(Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of a {@link URI} as a {@code byte[]}.\n     *\n     * @param uri the {@link URI} to read\n     * @return the requested byte array\n     * @throws NullPointerException if the uri is null\n     * @throws IOException          if an I/O exception occurs\n     * @since 2.4\n     */\n    public static byte[] toByteArray(final URI uri) throws IOException {\n        return IOUtils.toByteArray(uri.toURL());\n    }\n\n    /**\n     * Gets the contents of a {@link URL} as a {@code byte[]}.\n     *\n     * @param url the {@link URL} to read\n     * @return the requested byte array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O exception occurs\n     * @since 2.4\n     */\n    public static byte[] toByteArray(final URL url) throws IOException {\n        try (CloseableURLConnection urlConnection = CloseableURLConnection.open(url)) {\n            return IOUtils.toByteArray(urlConnection);\n        }\n    }\n\n    /**\n     * Gets the contents of a {@link URLConnection} as a {@code byte[]}.\n     *\n     * @param urlConnection the {@link URLConnection} to read.\n     * @return the requested byte array.\n     * @throws NullPointerException if the urlConn is null.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.4\n     */\n    public static byte[] toByteArray(final URLConnection urlConnection) throws IOException {\n        try (InputStream inputStream = urlConnection.getInputStream()) {\n            return IOUtils.toByteArray(inputStream);\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a character array\n     * using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read from\n     * @return the requested character array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #toCharArray(InputStream, Charset)} instead\n     */\n    @Deprecated\n    public static char[] toCharArray(final InputStream inputStream) throws IOException {\n        return toCharArray(inputStream, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a character array\n     * using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read from\n     * @param charset the charset to use, null means platform default\n     * @return the requested character array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static char[] toCharArray(final InputStream inputStream, final Charset charset)\n            throws IOException {\n        final CharArrayWriter writer = new CharArrayWriter();\n        copy(inputStream, writer, charset);\n        return writer.toCharArray();\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a character array\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param inputStream the {@link InputStream} to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested character array\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static char[] toCharArray(final InputStream inputStream, final String charsetName) throws IOException {\n        return toCharArray(inputStream, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a character array.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @return the requested character array\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static char[] toCharArray(final Reader reader) throws IOException {\n        final CharArrayWriter sw = new CharArrayWriter();\n        copy(reader, sw);\n        return sw.toCharArray();\n    }\n\n    /**\n     * Converts the specified CharSequence to an input stream, encoded as bytes\n     * using the default character encoding of the platform.\n     *\n     * @param input the CharSequence to convert\n     * @return an input stream\n     * @since 2.0\n     * @deprecated 2.5 use {@link #toInputStream(CharSequence, Charset)} instead\n     */\n    @Deprecated\n    public static InputStream toInputStream(final CharSequence input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Converts the specified CharSequence to an input stream, encoded as bytes\n     * using the specified character encoding.\n     *\n     * @param input the CharSequence to convert\n     * @param charset the charset to use, null means platform default\n     * @return an input stream\n     * @since 2.3\n     */\n    public static InputStream toInputStream(final CharSequence input, final Charset charset) {\n        return toInputStream(input.toString(), charset);\n    }\n\n    /**\n     * Converts the specified CharSequence to an input stream, encoded as bytes\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param input the CharSequence to convert\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return an input stream\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 2.0\n     */\n    public static InputStream toInputStream(final CharSequence input, final String charsetName) {\n        return toInputStream(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Converts the specified string to an input stream, encoded as bytes\n     * using the default character encoding of the platform.\n     *\n     * @param input the string to convert\n     * @return an input stream\n     * @since 1.1\n     * @deprecated 2.5 use {@link #toInputStream(String, Charset)} instead\n     */\n    @Deprecated\n    public static InputStream toInputStream(final String input) {\n        return toInputStream(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Converts the specified string to an input stream, encoded as bytes\n     * using the specified character encoding.\n     *\n     * @param input the string to convert\n     * @param charset the charset to use, null means platform default\n     * @return an input stream\n     * @since 2.3\n     */\n    public static InputStream toInputStream(final String input, final Charset charset) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charset)));\n    }\n\n    /**\n     * Converts the specified string to an input stream, encoded as bytes\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param input the string to convert\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return an input stream\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static InputStream toInputStream(final String input, final String charsetName) {\n        return new ByteArrayInputStream(input.getBytes(Charsets.toCharset(charsetName)));\n    }\n\n    /**\n     * Gets the contents of a {@code byte[]} as a String\n     * using the default character encoding of the platform.\n     *\n     * @param input the byte array to read from\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @deprecated 2.5 Use {@link String#String(byte[])} instead\n     */\n    @Deprecated\n    public static String toString(final byte[] input) {\n        // make explicit the use of the default charset\n        return new String(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of a {@code byte[]} as a String\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param input the byte array to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     */\n    public static String toString(final byte[] input, final String charsetName) {\n        return new String(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a String\n     * using the default character encoding of the platform.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @deprecated 2.5 use {@link #toString(InputStream, Charset)} instead\n     */\n    @Deprecated\n    public static String toString(final InputStream input) throws IOException {\n        return toString(input, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a String\n     * using the specified character encoding.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param charset the charset to use, null means platform default\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static String toString(final InputStream input, final Charset charset) throws IOException {\n        try (StringBuilderWriter sw = new StringBuilderWriter()) {\n            copy(input, sw, charset);\n            return sw.toString();\n        }\n    }\n\n    /**\n     * Gets the contents of an {@link InputStream} as a String\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedInputStream}.\n     * </p>\n     *\n     * @param input the {@link InputStream} to read from\n     * @param charsetName the name of the requested charset, null means platform default\n     * @return the requested String\n     * @throws NullPointerException                         if the input is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     */\n    public static String toString(final InputStream input, final String charsetName)\n            throws IOException {\n        return toString(input, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents of a {@link Reader} as a String.\n     * <p>\n     * This method buffers the input internally, so there is no need to use a\n     * {@link BufferedReader}.\n     * </p>\n     *\n     * @param reader the {@link Reader} to read from\n     * @return the requested String\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     */\n    public static String toString(final Reader reader) throws IOException {\n        try (StringBuilderWriter sw = new StringBuilderWriter()) {\n            copy(reader, sw);\n            return sw.toString();\n        }\n    }\n\n    /**\n     * Gets the contents at the given URI.\n     *\n     * @param uri The URI source.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.1\n     * @deprecated 2.5 use {@link #toString(URI, Charset)} instead\n     */\n    @Deprecated\n    public static String toString(final URI uri) throws IOException {\n        return toString(uri, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents at the given URI.\n     *\n     * @param uri The URI source.\n     * @param encoding The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.3.\n     */\n    public static String toString(final URI uri, final Charset encoding) throws IOException {\n        return toString(uri.toURL(), Charsets.toCharset(encoding));\n    }\n\n    /**\n     * Gets the contents at the given URI.\n     *\n     * @param uri The URI source.\n     * @param charsetName The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException                                  if an I/O exception occurs.\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 2.1\n     */\n    public static String toString(final URI uri, final String charsetName) throws IOException {\n        return toString(uri, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Gets the contents at the given URL.\n     *\n     * @param url The URL source.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.1\n     * @deprecated 2.5 use {@link #toString(URL, Charset)} instead\n     */\n    @Deprecated\n    public static String toString(final URL url) throws IOException {\n        return toString(url, Charset.defaultCharset());\n    }\n\n    /**\n     * Gets the contents at the given URL.\n     *\n     * @param url The URL source.\n     * @param encoding The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException if an I/O exception occurs.\n     * @since 2.3\n     */\n    public static String toString(final URL url, final Charset encoding) throws IOException {\n        try (InputStream inputStream = url.openStream()) {\n            return toString(inputStream, encoding);\n        }\n    }\n\n    /**\n     * Gets the contents at the given URL.\n     *\n     * @param url The URL source.\n     * @param charsetName The encoding name for the URL contents.\n     * @return The contents of the URL as a String.\n     * @throws IOException                                  if an I/O exception occurs.\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 2.1\n     */\n    public static String toString(final URL url, final String charsetName) throws IOException {\n        return toString(url, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to an {@link OutputStream}.\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void write(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data != null) {\n            output.write(data);\n        }\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to chars on a {@link Writer}\n     * using the default character encoding of the platform.\n     * <p>\n     * This method uses {@link String#String(byte[])}.\n     * </p>\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #write(byte[], Writer, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final byte[] data, final Writer writer) throws IOException {\n        write(data, writer, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to chars on a {@link Writer}\n     * using the specified character encoding.\n     * <p>\n     * This method uses {@link String#String(byte[], String)}.\n     * </p>\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void write(final byte[] data, final Writer writer, final Charset charset) throws IOException {\n        if (data != null) {\n            writer.write(new String(data, Charsets.toCharset(charset)));\n        }\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to chars on a {@link Writer}\n     * using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#String(byte[], String)}.\n     * </p>\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException                         if output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void write(final byte[] data, final Writer writer, final String charsetName) throws IOException {\n        write(data, writer, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to bytes on an\n     * {@link OutputStream}.\n     * <p>\n     * This method uses {@link String#String(char[])} and\n     * {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #write(char[], OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final char[] data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * This method uses {@link String#String(char[])} and\n     * {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void write(final char[] data, final OutputStream output, final Charset charset) throws IOException {\n        if (data != null) {\n            write(new String(data), output, charset);\n        }\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#String(char[])} and\n     * {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException                         if output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 1.1\n     */\n    public static void write(final char[] data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to a {@link Writer}\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void write(final char[] data, final Writer writer) throws IOException {\n        if (data != null) {\n            writer.write(data);\n        }\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform.\n     * <p>\n     * This method uses {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.0\n     * @deprecated 2.5 use {@link #write(CharSequence, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final CharSequence data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void write(final CharSequence data, final OutputStream output, final Charset charset)\n            throws IOException {\n        if (data != null) {\n            write(data.toString(), output, charset);\n        }\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException        if output is null\n     * @throws IOException                 if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 2.0\n     */\n    public static void write(final CharSequence data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@link CharSequence} to a {@link Writer}.\n     *\n     * @param data the {@link CharSequence} to write, null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.0\n     */\n    public static void write(final CharSequence data, final Writer writer) throws IOException {\n        if (data != null) {\n            write(data.toString(), writer);\n        }\n    }\n\n\n    /**\n     * Writes chars from a {@link String} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform.\n     * <p>\n     * This method uses {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #write(String, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void write(final String data, final OutputStream output)\n            throws IOException {\n        write(data, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes chars from a {@link String} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    @SuppressWarnings(\"resource\")\n    public static void write(final String data, final OutputStream output, final Charset charset) throws IOException {\n        if (data != null) {\n            // Use Charset#encode(String), since calling String#getBytes(Charset) might result in\n            // NegativeArraySizeException or OutOfMemoryError.\n            // The underlying OutputStream should not be closed, so the channel is not closed.\n            Channels.newChannel(output).write(Charsets.toCharset(charset).encode(data));\n        }\n    }\n\n    /**\n     * Writes chars from a {@link String} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException        if output is null\n     * @throws IOException                 if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 1.1\n     */\n    public static void write(final String data, final OutputStream output, final String charsetName)\n            throws IOException {\n        write(data, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes chars from a {@link String} to a {@link Writer}.\n     *\n     * @param data the {@link String} to write, null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void write(final String data, final Writer writer) throws IOException {\n        if (data != null) {\n            writer.write(data);\n        }\n    }\n\n    /**\n     * Writes chars from a {@link StringBuffer} to bytes on an\n     * {@link OutputStream} using the default character encoding of the\n     * platform.\n     * <p>\n     * This method uses {@link String#getBytes()}.\n     * </p>\n     *\n     * @param data the {@link StringBuffer} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated Use {@link #write(CharSequence, OutputStream)}\n     */\n    @Deprecated\n    public static void write(final StringBuffer data, final OutputStream output) //NOSONAR\n            throws IOException {\n        write(data, output, (String) null);\n    }\n\n    /**\n     * Writes chars from a {@link StringBuffer} to bytes on an\n     * {@link OutputStream} using the specified character encoding.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     * <p>\n     * This method uses {@link String#getBytes(String)}.\n     * </p>\n     *\n     * @param data the {@link StringBuffer} to write, null ignored\n     * @param output the {@link OutputStream} to write to\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException        if output is null\n     * @throws IOException                 if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     * .UnsupportedEncodingException} in version 2.2 if the encoding is not supported.\n     * @since 1.1\n     * @deprecated Use {@link #write(CharSequence, OutputStream, String)}.\n     */\n    @Deprecated\n    public static void write(final StringBuffer data, final OutputStream output, final String charsetName) //NOSONAR\n        throws IOException {\n        if (data != null) {\n            write(data.toString(), output, Charsets.toCharset(charsetName));\n        }\n    }\n\n    /**\n     * Writes chars from a {@link StringBuffer} to a {@link Writer}.\n     *\n     * @param data the {@link StringBuffer} to write, null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated Use {@link #write(CharSequence, Writer)}\n     */\n    @Deprecated\n    public static void write(final StringBuffer data, final Writer writer) //NOSONAR\n            throws IOException {\n        if (data != null) {\n            writer.write(data.toString());\n        }\n    }\n\n    /**\n     * Writes bytes from a {@code byte[]} to an {@link OutputStream} using chunked writes.\n     * This is intended for writing very large byte arrays which might otherwise cause excessive\n     * memory usage if the native code has to allocate a copy.\n     *\n     * @param data the byte array to write, do not modify during output,\n     * null ignored\n     * @param output the {@link OutputStream} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.5\n     */\n    public static void writeChunked(final byte[] data, final OutputStream output)\n            throws IOException {\n        if (data != null) {\n            int bytes = data.length;\n            int offset = 0;\n            while (bytes > 0) {\n                final int chunk = Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                output.write(data, offset, chunk);\n                bytes -= chunk;\n                offset += chunk;\n            }\n        }\n    }\n\n    /**\n     * Writes chars from a {@code char[]} to a {@link Writer} using chunked writes.\n     * This is intended for writing very large byte arrays which might otherwise cause excessive\n     * memory usage if the native code has to allocate a copy.\n     *\n     * @param data the char array to write, do not modify during output,\n     * null ignored\n     * @param writer the {@link Writer} to write to\n     * @throws NullPointerException if output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.5\n     */\n    public static void writeChunked(final char[] data, final Writer writer) throws IOException {\n        if (data != null) {\n            int bytes = data.length;\n            int offset = 0;\n            while (bytes > 0) {\n                final int chunk = Math.min(bytes, DEFAULT_BUFFER_SIZE);\n                writer.write(data, offset, chunk);\n                bytes -= chunk;\n                offset += chunk;\n            }\n        }\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * an {@link OutputStream} line by line, using the default character\n     * encoding of the platform and the specified line ending.\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param output the {@link OutputStream} to write to, not null, not closed\n     * @throws NullPointerException if the output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     * @deprecated 2.5 use {@link #writeLines(Collection, String, OutputStream, Charset)} instead\n     */\n    @Deprecated\n    public static void writeLines(final Collection<?> lines, final String lineEnding,\n                                  final OutputStream output) throws IOException {\n        writeLines(lines, lineEnding, output, Charset.defaultCharset());\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * an {@link OutputStream} line by line, using the specified character\n     * encoding and the specified line ending.\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param output the {@link OutputStream} to write to, not null, not closed\n     * @param charset the charset to use, null means platform default\n     * @throws NullPointerException if the output is null\n     * @throws IOException          if an I/O error occurs\n     * @since 2.3\n     */\n    public static void writeLines(final Collection<?> lines, String lineEnding, final OutputStream output,\n                                  final Charset charset) throws IOException {\n        if (lines == null) {\n            return;\n        }\n        if (lineEnding == null) {\n            lineEnding = System.lineSeparator();\n        }\n        final Charset cs = Charsets.toCharset(charset);\n        final byte[] eolBytes = lineEnding.getBytes(cs);\n        for (final Object line : lines) {\n            if (line != null) {\n                write(line.toString(), output, cs);\n            }\n            output.write(eolBytes);\n        }\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * an {@link OutputStream} line by line, using the specified character\n     * encoding and the specified line ending.\n     * <p>\n     * Character encoding names can be found at\n     * <a href=\"http://www.iana.org/assignments/character-sets\">IANA</a>.\n     * </p>\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param output the {@link OutputStream} to write to, not null, not closed\n     * @param charsetName the name of the requested charset, null means platform default\n     * @throws NullPointerException                         if the output is null\n     * @throws IOException                                  if an I/O error occurs\n     * @throws java.nio.charset.UnsupportedCharsetException thrown instead of {@link java.io\n     *                                                      .UnsupportedEncodingException} in version 2.2 if the\n     *                                                      encoding is not supported.\n     * @since 1.1\n     */\n    public static void writeLines(final Collection<?> lines, final String lineEnding,\n                                  final OutputStream output, final String charsetName) throws IOException {\n        writeLines(lines, lineEnding, output, Charsets.toCharset(charsetName));\n    }\n\n    /**\n     * Writes the {@link #toString()} value of each item in a collection to\n     * a {@link Writer} line by line, using the specified line ending.\n     *\n     * @param lines the lines to write, null entries produce blank lines\n     * @param lineEnding the line separator to use, null is system default\n     * @param writer the {@link Writer} to write to, not null, not closed\n     * @throws NullPointerException if the input is null\n     * @throws IOException          if an I/O error occurs\n     * @since 1.1\n     */\n    public static void writeLines(final Collection<?> lines, String lineEnding,\n                                  final Writer writer) throws IOException {\n        if (lines == null) {\n            return;\n        }\n        if (lineEnding == null) {\n            lineEnding = System.lineSeparator();\n        }\n        for (final Object line : lines) {\n            if (line != null) {\n                writer.write(line.toString());\n            }\n            writer.write(lineEnding);\n        }\n    }\n\n    /**\n     * Returns the given Appendable if it is already a {@link Writer}, otherwise creates a Writer wrapper around the\n     * given Appendable.\n     *\n     * @param appendable the Appendable to wrap or return (not null)\n     * @return  the given Appendable or a Writer wrapper around the given Appendable\n     * @throws NullPointerException if the input parameter is null\n     * @since 2.7\n     */\n    public static Writer writer(final Appendable appendable) {\n        Objects.requireNonNull(appendable, \"appendable\");\n        if (appendable instanceof Writer) {\n            return (Writer) appendable;\n        }\n        if (appendable instanceof StringBuilder) {\n            return new StringBuilderWriter((StringBuilder) appendable);\n        }\n        return new AppendableWriter<>(appendable);\n    }\n\n    /**\n     * Instances should NOT be constructed in standard programming.\n     */\n    public IOUtils() { //NOSONAR\n    }\n\n}\n\nRefactoring Operation:\nExtract Method\n\nInstructions:\n1. Analyze the provided code and class content, apply relevant refactoring operation to the code to be refactored.\n2. If refactoring is performed, output the refactored_method_code in the following format:\n##########################\nrefactored_method_code\n##########################\n\n\n\n"}]